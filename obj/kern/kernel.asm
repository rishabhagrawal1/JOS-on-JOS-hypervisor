
obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
// VMCALL to the VMM to get a multiboot map.
    movl $VMX_VMCALL_MBMAP, %eax
    vmcall
#endif

    movl $multiboot_info, %eax
  100000:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  100005:	89 18                	mov    %ebx,(%rax)

#ifndef VMM_GUEST
    movw $0x1234,0x472			# warm boot
  100007:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472(%rip)        # 100482 <verify_cpu_no_longmode+0x36f>
  10000e:	34 12 
#endif

# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  100010:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100015:	e8 cc 00 00 00       	callq  1000e6 <verify_cpu>
#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
  10001a:	b8 20 00 00 00       	mov    $0x20,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
#endif
    movl %eax,%cr4
  10001f:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100022:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100027:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100029:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002e:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  100030:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100035:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  10003a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  100040:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100042:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100047:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10004a:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004d:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  100050:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100055:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  10005a:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005d:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100060:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100062:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100067:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006c:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006f:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100072:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100074:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100079:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007e:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100083:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100089:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008e:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  100090:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100092:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100095:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100098:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009d:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  1000a0:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a3:	75 e9                	jne    10008e <_head64+0x8e>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a5:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000aa:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ad:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b2:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b4:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b8:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000ba:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bd:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000c0:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c5:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000ca:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000cf:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d2:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d5:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000da:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dd:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000df:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e4:	50                   	push   %rax

00000000001000e5 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e5:	cb                   	lret   

00000000001000e6 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e6:	9c                   	pushfq 
    popl %eax
  1000e7:	58                   	pop    %rax
    movl %eax,%ecx
  1000e8:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000ea:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ef:	50                   	push   %rax
    popfl
  1000f0:	9d                   	popfq  
    pushfl
  1000f1:	9c                   	pushfq 
    popl %eax
  1000f2:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f3:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f5:	74 1c                	je     100113 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f7:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fc:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fe:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100101:	72 10                	jb     100113 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100103:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100108:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  10010a:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  100110:	74 01                	je     100113 <verify_cpu_no_longmode>

    ret
  100112:	c3                   	retq   

0000000000100113 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100113:	eb fe                	jmp    100113 <verify_cpu_no_longmode>
  100115:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011c:	00 00 00 
  10011f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100126:	00 00 00 
  100129:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100130:	00 00 00 
  100133:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10013a:	00 00 00 
  10013d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100144:	00 00 00 
  100147:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014e:	00 00 00 
  100151:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100158:	00 00 00 
  10015b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100162:	00 00 00 
  100165:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016c:	00 00 00 
  10016f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100176:	00 00 00 
  100179:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100180:	00 00 00 
  100183:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10018a:	00 00 00 
  10018d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100194:	00 00 00 
  100197:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019e:	00 00 00 
  1001a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a8:	00 00 00 
  1001ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b2:	00 00 00 
  1001b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bc:	00 00 00 
  1001bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c6:	00 00 00 
  1001c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d0:	00 00 00 
  1001d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001da:	00 00 00 
  1001dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e4:	00 00 00 
  1001e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ee:	00 00 00 
  1001f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f8:	00 00 00 
  1001fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100202:	00 00 00 
  100205:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020c:	00 00 00 
  10020f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100216:	00 00 00 
  100219:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100220:	00 00 00 
  100223:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10022a:	00 00 00 
  10022d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100234:	00 00 00 
  100237:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023e:	00 00 00 
  100241:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100248:	00 00 00 
  10024b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100252:	00 00 00 
  100255:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025c:	00 00 00 
  10025f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100266:	00 00 00 
  100269:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100270:	00 00 00 
  100273:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10027a:	00 00 00 
  10027d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100284:	00 00 00 
  100287:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028e:	00 00 00 
  100291:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100298:	00 00 00 
  10029b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a2:	00 00 00 
  1002a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ac:	00 00 00 
  1002af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b6:	00 00 00 
  1002b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c0:	00 00 00 
  1002c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ca:	00 00 00 
  1002cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d4:	00 00 00 
  1002d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002de:	00 00 00 
  1002e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e8:	00 00 00 
  1002eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f2:	00 00 00 
  1002f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fc:	00 00 00 
  1002ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100306:	00 00 00 
  100309:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100310:	00 00 00 
  100313:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10031a:	00 00 00 
  10031d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100324:	00 00 00 
  100327:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032e:	00 00 00 
  100331:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100338:	00 00 00 
  10033b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100342:	00 00 00 
  100345:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034c:	00 00 00 
  10034f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100356:	00 00 00 
  100359:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100360:	00 00 00 
  100363:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10036a:	00 00 00 
  10036d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100374:	00 00 00 
  100377:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037e:	00 00 00 
  100381:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100388:	00 00 00 
  10038b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100392:	00 00 00 
  100395:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039c:	00 00 00 
  10039f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a6:	00 00 00 
  1003a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b0:	00 00 00 
  1003b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ba:	00 00 00 
  1003bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c4:	00 00 00 
  1003c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ce:	00 00 00 
  1003d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d8:	00 00 00 
  1003db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e2:	00 00 00 
  1003e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ec:	00 00 00 
  1003ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f6:	00 00 00 
  1003f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100400:	00 00 00 
  100403:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10040a:	00 00 00 
  10040d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100414:	00 00 00 
  100417:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041e:	00 00 00 
  100421:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100428:	00 00 00 
  10042b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100432:	00 00 00 
  100435:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043c:	00 00 00 
  10043f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100446:	00 00 00 
  100449:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100450:	00 00 00 
  100453:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10045a:	00 00 00 
  10045d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100464:	00 00 00 
  100467:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046e:	00 00 00 
  100471:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100478:	00 00 00 
  10047b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100482:	00 00 00 
  100485:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048c:	00 00 00 
  10048f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100496:	00 00 00 
  100499:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a0:	00 00 00 
  1004a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004aa:	00 00 00 
  1004ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b4:	00 00 00 
  1004b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004be:	00 00 00 
  1004c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c8:	00 00 00 
  1004cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d2:	00 00 00 
  1004d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004dc:	00 00 00 
  1004df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e6:	00 00 00 
  1004e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f0:	00 00 00 
  1004f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004fa:	00 00 00 
  1004fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100504:	00 00 00 
  100507:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050e:	00 00 00 
  100511:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100518:	00 00 00 
  10051b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100522:	00 00 00 
  100525:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052c:	00 00 00 
  10052f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100536:	00 00 00 
  100539:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100540:	00 00 00 
  100543:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10054a:	00 00 00 
  10054d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100554:	00 00 00 
  100557:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055e:	00 00 00 
  100561:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100568:	00 00 00 
  10056b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100572:	00 00 00 
  100575:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057c:	00 00 00 
  10057f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100586:	00 00 00 
  100589:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100590:	00 00 00 
  100593:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10059a:	00 00 00 
  10059d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a4:	00 00 00 
  1005a7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ae:	00 00 00 
  1005b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b8:	00 00 00 
  1005bb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c2:	00 00 00 
  1005c5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cc:	00 00 00 
  1005cf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d6:	00 00 00 
  1005d9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e0:	00 00 00 
  1005e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ea:	00 00 00 
  1005ed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f4:	00 00 00 
  1005f7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fe:	00 00 00 
  100601:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100608:	00 00 00 
  10060b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100612:	00 00 00 
  100615:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061c:	00 00 00 
  10061f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100626:	00 00 00 
  100629:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100630:	00 00 00 
  100633:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10063a:	00 00 00 
  10063d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100644:	00 00 00 
  100647:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064e:	00 00 00 
  100651:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100658:	00 00 00 
  10065b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100662:	00 00 00 
  100665:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066c:	00 00 00 
  10066f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100676:	00 00 00 
  100679:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100680:	00 00 00 
  100683:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10068a:	00 00 00 
  10068d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100694:	00 00 00 
  100697:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069e:	00 00 00 
  1006a1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a8:	00 00 00 
  1006ab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b2:	00 00 00 
  1006b5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bc:	00 00 00 
  1006bf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c6:	00 00 00 
  1006c9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d0:	00 00 00 
  1006d3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006da:	00 00 00 
  1006dd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e4:	00 00 00 
  1006e7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ee:	00 00 00 
  1006f1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f8:	00 00 00 
  1006fb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100702:	00 00 00 
  100705:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070c:	00 00 00 
  10070f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100716:	00 00 00 
  100719:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100720:	00 00 00 
  100723:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10072a:	00 00 00 
  10072d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100734:	00 00 00 
  100737:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073e:	00 00 00 
  100741:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100748:	00 00 00 
  10074b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100752:	00 00 00 
  100755:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075c:	00 00 00 
  10075f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100766:	00 00 00 
  100769:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100770:	00 00 00 
  100773:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10077a:	00 00 00 
  10077d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100784:	00 00 00 
  100787:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078e:	00 00 00 
  100791:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100798:	00 00 00 
  10079b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a2:	00 00 00 
  1007a5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ac:	00 00 00 
  1007af:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b6:	00 00 00 
  1007b9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c0:	00 00 00 
  1007c3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ca:	00 00 00 
  1007cd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d4:	00 00 00 
  1007d7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007de:	00 00 00 
  1007e1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e8:	00 00 00 
  1007eb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f2:	00 00 00 
  1007f5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fc:	00 00 00 
  1007ff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100806:	00 00 00 
  100809:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100810:	00 00 00 
  100813:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10081a:	00 00 00 
  10081d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100824:	00 00 00 
  100827:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082e:	00 00 00 
  100831:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100838:	00 00 00 
  10083b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100842:	00 00 00 
  100845:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084c:	00 00 00 
  10084f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100856:	00 00 00 
  100859:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100860:	00 00 00 
  100863:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10086a:	00 00 00 
  10086d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100874:	00 00 00 
  100877:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087e:	00 00 00 
  100881:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100888:	00 00 00 
  10088b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100892:	00 00 00 
  100895:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089c:	00 00 00 
  10089f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a6:	00 00 00 
  1008a9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b0:	00 00 00 
  1008b3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ba:	00 00 00 
  1008bd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c4:	00 00 00 
  1008c7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ce:	00 00 00 
  1008d1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d8:	00 00 00 
  1008db:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e2:	00 00 00 
  1008e5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ec:	00 00 00 
  1008ef:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f6:	00 00 00 
  1008f9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100900:	00 00 00 
  100903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10090a:	00 00 00 
  10090d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100914:	00 00 00 
  100917:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091e:	00 00 00 
  100921:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100928:	00 00 00 
  10092b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100932:	00 00 00 
  100935:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093c:	00 00 00 
  10093f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100946:	00 00 00 
  100949:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100950:	00 00 00 
  100953:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10095a:	00 00 00 
  10095d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100964:	00 00 00 
  100967:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096e:	00 00 00 
  100971:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100978:	00 00 00 
  10097b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100982:	00 00 00 
  100985:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098c:	00 00 00 
  10098f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100996:	00 00 00 
  100999:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a0:	00 00 00 
  1009a3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009aa:	00 00 00 
  1009ad:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b4:	00 00 00 
  1009b7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009be:	00 00 00 
  1009c1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c8:	00 00 00 
  1009cb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d2:	00 00 00 
  1009d5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009dc:	00 00 00 
  1009df:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e6:	00 00 00 
  1009e9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f0:	00 00 00 
  1009f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009fa:	00 00 00 
  1009fd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a04:	00 00 00 
  100a07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0e:	00 00 00 
  100a11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a18:	00 00 00 
  100a1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a22:	00 00 00 
  100a25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2c:	00 00 00 
  100a2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a36:	00 00 00 
  100a39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a40:	00 00 00 
  100a43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a4a:	00 00 00 
  100a4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a54:	00 00 00 
  100a57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5e:	00 00 00 
  100a61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a68:	00 00 00 
  100a6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a72:	00 00 00 
  100a75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7c:	00 00 00 
  100a7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a86:	00 00 00 
  100a89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a90:	00 00 00 
  100a93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a9a:	00 00 00 
  100a9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa4:	00 00 00 
  100aa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aae:	00 00 00 
  100ab1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab8:	00 00 00 
  100abb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac2:	00 00 00 
  100ac5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acc:	00 00 00 
  100acf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad6:	00 00 00 
  100ad9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae0:	00 00 00 
  100ae3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aea:	00 00 00 
  100aed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af4:	00 00 00 
  100af7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afe:	00 00 00 
  100b01:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b08:	00 00 00 
  100b0b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b12:	00 00 00 
  100b15:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1c:	00 00 00 
  100b1f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b26:	00 00 00 
  100b29:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b30:	00 00 00 
  100b33:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b3a:	00 00 00 
  100b3d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b44:	00 00 00 
  100b47:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4e:	00 00 00 
  100b51:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b58:	00 00 00 
  100b5b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b62:	00 00 00 
  100b65:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6c:	00 00 00 
  100b6f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b76:	00 00 00 
  100b79:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b80:	00 00 00 
  100b83:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b8a:	00 00 00 
  100b8d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b94:	00 00 00 
  100b97:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9e:	00 00 00 
  100ba1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba8:	00 00 00 
  100bab:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb2:	00 00 00 
  100bb5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbc:	00 00 00 
  100bbf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc6:	00 00 00 
  100bc9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd0:	00 00 00 
  100bd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bda:	00 00 00 
  100bdd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be4:	00 00 00 
  100be7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bee:	00 00 00 
  100bf1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf8:	00 00 00 
  100bfb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c02:	00 00 00 
  100c05:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0c:	00 00 00 
  100c0f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c16:	00 00 00 
  100c19:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c20:	00 00 00 
  100c23:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c2a:	00 00 00 
  100c2d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c34:	00 00 00 
  100c37:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3e:	00 00 00 
  100c41:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c48:	00 00 00 
  100c4b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c52:	00 00 00 
  100c55:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5c:	00 00 00 
  100c5f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c66:	00 00 00 
  100c69:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c70:	00 00 00 
  100c73:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c7a:	00 00 00 
  100c7d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c84:	00 00 00 
  100c87:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8e:	00 00 00 
  100c91:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c98:	00 00 00 
  100c9b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca2:	00 00 00 
  100ca5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cac:	00 00 00 
  100caf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb6:	00 00 00 
  100cb9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc0:	00 00 00 
  100cc3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cca:	00 00 00 
  100ccd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd4:	00 00 00 
  100cd7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cde:	00 00 00 
  100ce1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce8:	00 00 00 
  100ceb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf2:	00 00 00 
  100cf5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfc:	00 00 00 
  100cff:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d06:	00 00 00 
  100d09:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d10:	00 00 00 
  100d13:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d1a:	00 00 00 
  100d1d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d24:	00 00 00 
  100d27:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2e:	00 00 00 
  100d31:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d38:	00 00 00 
  100d3b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d42:	00 00 00 
  100d45:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4c:	00 00 00 
  100d4f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d56:	00 00 00 
  100d59:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d60:	00 00 00 
  100d63:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d6a:	00 00 00 
  100d6d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d74:	00 00 00 
  100d77:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7e:	00 00 00 
  100d81:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d88:	00 00 00 
  100d8b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d92:	00 00 00 
  100d95:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9c:	00 00 00 
  100d9f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da6:	00 00 00 
  100da9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db0:	00 00 00 
  100db3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dba:	00 00 00 
  100dbd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc4:	00 00 00 
  100dc7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dce:	00 00 00 
  100dd1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd8:	00 00 00 
  100ddb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de2:	00 00 00 
  100de5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dec:	00 00 00 
  100def:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df6:	00 00 00 
  100df9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e00:	00 00 00 
  100e03:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e0a:	00 00 00 
  100e0d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e14:	00 00 00 
  100e17:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1e:	00 00 00 
  100e21:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e28:	00 00 00 
  100e2b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e32:	00 00 00 
  100e35:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3c:	00 00 00 
  100e3f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e46:	00 00 00 
  100e49:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e50:	00 00 00 
  100e53:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e5a:	00 00 00 
  100e5d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e64:	00 00 00 
  100e67:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6e:	00 00 00 
  100e71:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e78:	00 00 00 
  100e7b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e82:	00 00 00 
  100e85:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8c:	00 00 00 
  100e8f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e96:	00 00 00 
  100e99:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea0:	00 00 00 
  100ea3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eaa:	00 00 00 
  100ead:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb4:	00 00 00 
  100eb7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebe:	00 00 00 
  100ec1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec8:	00 00 00 
  100ecb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed2:	00 00 00 
  100ed5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edc:	00 00 00 
  100edf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee6:	00 00 00 
  100ee9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef0:	00 00 00 
  100ef3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100efa:	00 00 00 
  100efd:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f04:	00 00 00 
  100f07:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0e:	00 00 00 
  100f11:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f18:	00 00 00 
  100f1b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f22:	00 00 00 
  100f25:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2c:	00 00 00 
  100f2f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f36:	00 00 00 
  100f39:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f40:	00 00 00 
  100f43:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f4a:	00 00 00 
  100f4d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f54:	00 00 00 
  100f57:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5e:	00 00 00 
  100f61:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f68:	00 00 00 
  100f6b:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f72:	00 00 00 
  100f75:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7c:	00 00 00 
  100f7f:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f86:	00 00 00 
  100f89:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f90:	00 00 00 
  100f93:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f9a:	00 00 00 
  100f9d:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa4:	00 00 00 
  100fa7:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fae:	00 00 00 
  100fb1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb8:	00 00 00 
  100fbb:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc2:	00 00 00 
  100fc5:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcc:	00 00 00 
  100fcf:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd6:	00 00 00 
  100fd9:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe0:	00 00 00 
  100fe3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fea:	00 00 00 
  100fed:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff4:	00 00 00 
  100ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  100ffe:	00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 30 23 04 80 	movabs $0x8004233038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 30 23 04 80 	movabs $0x8004233000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 1d 01 20 04 80 	movabs $0x800420011d,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004200060:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004200064:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004200067:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420006b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420006e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004200072:	f0 87 02             	lock xchg %eax,(%rdx)
  8004200075:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004200078:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420007b:	c9                   	leaveq 
  800420007c:	c3                   	retq   

000000800420007d <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420007d:	55                   	push   %rbp
  800420007e:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004200081:	48 bf 40 37 23 04 80 	movabs $0x8004233740,%rdi
  8004200088:	00 00 00 
  800420008b:	48 b8 25 7f 21 04 80 	movabs $0x8004217f25,%rax
  8004200092:	00 00 00 
  8004200095:	ff d0                	callq  *%rax
}
  8004200097:	5d                   	pop    %rbp
  8004200098:	c3                   	retq   

0000008004200099 <test_backtrace>:


// Test the stack backtrace function (lab 1 only)
void
test_backtrace(int x)
{
  8004200099:	55                   	push   %rbp
  800420009a:	48 89 e5             	mov    %rsp,%rbp
  800420009d:	48 83 ec 10          	sub    $0x10,%rsp
  80042000a1:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cprintf("entering test_backtrace %d\n", x);
  80042000a4:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000a7:	89 c6                	mov    %eax,%esi
  80042000a9:	48 bf 00 d2 21 04 80 	movabs $0x800421d200,%rdi
  80042000b0:	00 00 00 
  80042000b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042000b8:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042000bf:	00 00 00 
  80042000c2:	ff d2                	callq  *%rdx
	if (x > 0)
  80042000c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042000c8:	7e 16                	jle    80042000e0 <test_backtrace+0x47>
		test_backtrace(x-1);
  80042000ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000cd:	83 e8 01             	sub    $0x1,%eax
  80042000d0:	89 c7                	mov    %eax,%edi
  80042000d2:	48 b8 99 00 20 04 80 	movabs $0x8004200099,%rax
  80042000d9:	00 00 00 
  80042000dc:	ff d0                	callq  *%rax
  80042000de:	eb 1b                	jmp    80042000fb <test_backtrace+0x62>
	else
		mon_backtrace(0, 0, 0);
  80042000e0:	ba 00 00 00 00       	mov    $0x0,%edx
  80042000e5:	be 00 00 00 00       	mov    $0x0,%esi
  80042000ea:	bf 00 00 00 00       	mov    $0x0,%edi
  80042000ef:	48 b8 6e 16 20 04 80 	movabs $0x800420166e,%rax
  80042000f6:	00 00 00 
  80042000f9:	ff d0                	callq  *%rax
	cprintf("leaving test_backtrace %d\n", x);
  80042000fb:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042000fe:	89 c6                	mov    %eax,%esi
  8004200100:	48 bf 1c d2 21 04 80 	movabs $0x800421d21c,%rdi
  8004200107:	00 00 00 
  800420010a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420010f:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004200116:	00 00 00 
  8004200119:	ff d2                	callq  *%rdx
}
  800420011b:	c9                   	leaveq 
  800420011c:	c3                   	retq   

000000800420011d <i386_init>:


void
i386_init(void)
{
  800420011d:	55                   	push   %rbp
  800420011e:	48 89 e5             	mov    %rsp,%rbp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  8004200121:	48 ba 10 10 3f 04 80 	movabs $0x80043f1010,%rdx
  8004200128:	00 00 00 
  800420012b:	48 b8 2c cf 3a 04 80 	movabs $0x80043acf2c,%rax
  8004200132:	00 00 00 
  8004200135:	48 29 c2             	sub    %rax,%rdx
  8004200138:	48 89 d0             	mov    %rdx,%rax
  800420013b:	48 89 c2             	mov    %rax,%rdx
  800420013e:	be 00 00 00 00       	mov    $0x0,%esi
  8004200143:	48 bf 2c cf 3a 04 80 	movabs $0x80043acf2c,%rdi
  800420014a:	00 00 00 
  800420014d:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004200154:	00 00 00 
  8004200157:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  8004200159:	48 b8 12 12 20 04 80 	movabs $0x8004201212,%rax
  8004200160:	00 00 00 
  8004200163:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  8004200165:	be ac 1a 00 00       	mov    $0x1aac,%esi
  800420016a:	48 bf 37 d2 21 04 80 	movabs $0x800421d237,%rdi
  8004200171:	00 00 00 
  8004200174:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200179:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004200180:	00 00 00 
  8004200183:	ff d2                	callq  *%rdx
	}
#endif

#ifndef VMM_GUEST
	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end); 
  8004200185:	48 b8 10 10 3f 04 80 	movabs $0x80043f1010,%rax
  800420018c:	00 00 00 
  800420018f:	48 89 c6             	mov    %rax,%rsi
  8004200192:	48 bf 00 00 01 04 80 	movabs $0x8004010000,%rdi
  8004200199:	00 00 00 
  800420019c:	48 b8 bb 65 21 04 80 	movabs $0x80042165bb,%rax
  80042001a3:	00 00 00 
  80042001a6:	ff d0                	callq  *%rax
  80042001a8:	48 ba 70 e7 3a 04 80 	movabs $0x80043ae770,%rdx
  80042001af:	00 00 00 
  80042001b2:	48 89 02             	mov    %rax,(%rdx)
#endif

	// Lab 2 memory management initialization functions
	x64_vm_init();
  80042001b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042001ba:	48 ba 29 27 20 04 80 	movabs $0x8004202729,%rdx
  80042001c1:	00 00 00 
  80042001c4:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  80042001c6:	48 b8 dd 79 20 04 80 	movabs $0x80042079dd,%rax
  80042001cd:	00 00 00 
  80042001d0:	ff d0                	callq  *%rax
	trap_init();
  80042001d2:	48 b8 92 97 20 04 80 	movabs $0x8004209792,%rax
  80042001d9:	00 00 00 
  80042001dc:	ff d0                	callq  *%rax

#ifndef VMM_GUEST
	// Lab 4 multiprocessor initialization functions
	mp_init();
  80042001de:	48 b8 45 75 21 04 80 	movabs $0x8004217545,%rax
  80042001e5:	00 00 00 
  80042001e8:	ff d0                	callq  *%rax
	lapic_init();
  80042001ea:	48 b8 a3 79 21 04 80 	movabs $0x80042179a3,%rax
  80042001f1:	00 00 00 
  80042001f4:	ff d0                	callq  *%rax
#endif

	// Lab 4 multitasking initialization functions
	pic_init();
  80042001f6:	48 b8 1a 93 20 04 80 	movabs $0x800420931a,%rax
  80042001fd:	00 00 00 
  8004200200:	ff d0                	callq  *%rax

	// Lab 6 hardware initialization functions
	time_init();
  8004200202:	48 b8 40 8d 21 04 80 	movabs $0x8004218d40,%rax
  8004200209:	00 00 00 
  800420020c:	ff d0                	callq  *%rax
	pci_init();
  800420020e:	48 b8 04 8d 21 04 80 	movabs $0x8004218d04,%rax
  8004200215:	00 00 00 
  8004200218:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:
	lock_kernel();
  800420021a:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200221:	00 00 00 
  8004200224:	ff d0                	callq  *%rax
#ifndef VMM_GUEST
	// Starting non-boot CPUs
	boot_aps();
  8004200226:	48 b8 74 02 20 04 80 	movabs $0x8004200274,%rax
  800420022d:	00 00 00 
  8004200230:	ff d0                	callq  *%rax



#ifndef VMM_GUEST
	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
  8004200232:	be 01 00 00 00       	mov    $0x1,%esi
  8004200237:	48 bf ef 8e 2a 04 80 	movabs $0x80042a8eef,%rdi
  800420023e:	00 00 00 
  8004200241:	48 b8 56 88 20 04 80 	movabs $0x8004208856,%rax
  8004200248:	00 00 00 
  800420024b:	ff d0                	callq  *%rax
	ENV_CREATE(user_hello, ENV_TYPE_USER);
#endif

#if defined(TEST)
	// Don't touch -- used by grading script!
	ENV_CREATE(TEST, ENV_TYPE_USER);
  800420024d:	be 00 00 00 00       	mov    $0x0,%esi
  8004200252:	48 bf 36 d8 37 04 80 	movabs $0x800437d836,%rdi
  8004200259:	00 00 00 
  800420025c:	48 b8 56 88 20 04 80 	movabs $0x8004208856,%rax
  8004200263:	00 00 00 
  8004200266:	ff d0                	callq  *%rax
	//ENV_CREATE(user_testkbd, ENV_TYPE_USER);


#endif // TEST*
	// Schedule and run the first user environment!
	sched_yield();
  8004200268:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  800420026f:	00 00 00 
  8004200272:	ff d0                	callq  *%rax

0000008004200274 <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  8004200274:	55                   	push   %rbp
  8004200275:	48 89 e5             	mov    %rsp,%rbp
  8004200278:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  800420027c:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  8004200283:	00 
  8004200284:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004200288:	48 c1 e8 0c          	shr    $0xc,%rax
  800420028c:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420028f:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200292:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004200299:	00 00 00 
  800420029c:	48 8b 00             	mov    (%rax),%rax
  800420029f:	48 39 c2             	cmp    %rax,%rdx
  80042002a2:	72 32                	jb     80042002d6 <boot_aps+0x62>
  80042002a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042002a8:	48 89 c1             	mov    %rax,%rcx
  80042002ab:	48 ba 58 d2 21 04 80 	movabs $0x800421d258,%rdx
  80042002b2:	00 00 00 
  80042002b5:	be b4 00 00 00       	mov    $0xb4,%esi
  80042002ba:	48 bf 7b d2 21 04 80 	movabs $0x800421d27b,%rdi
  80042002c1:	00 00 00 
  80042002c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042002c9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042002d0:	00 00 00 
  80042002d3:	41 ff d0             	callq  *%r8
  80042002d6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042002dd:	00 00 00 
  80042002e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042002e4:	48 01 d0             	add    %rdx,%rax
  80042002e7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  80042002eb:	48 ba 6e 70 21 04 80 	movabs $0x800421706e,%rdx
  80042002f2:	00 00 00 
  80042002f5:	48 b8 88 6f 21 04 80 	movabs $0x8004216f88,%rax
  80042002fc:	00 00 00 
  80042002ff:	48 29 c2             	sub    %rax,%rdx
  8004200302:	48 89 d0             	mov    %rdx,%rax
  8004200305:	48 89 c2             	mov    %rax,%rdx
  8004200308:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420030c:	48 be 88 6f 21 04 80 	movabs $0x8004216f88,%rsi
  8004200313:	00 00 00 
  8004200316:	48 89 c7             	mov    %rax,%rdi
  8004200319:	48 b8 17 0c 21 04 80 	movabs $0x8004210c17,%rax
  8004200320:	00 00 00 
  8004200323:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200325:	48 b8 20 00 3b 04 80 	movabs $0x80043b0020,%rax
  800420032c:	00 00 00 
  800420032f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004200333:	e9 0e 01 00 00       	jmpq   8004200446 <boot_aps+0x1d2>
		if (c == cpus + cpunum())  // We've started already.
  8004200338:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420033f:	00 00 00 
  8004200342:	ff d0                	callq  *%rax
  8004200344:	48 98                	cltq   
  8004200346:	48 c1 e0 03          	shl    $0x3,%rax
  800420034a:	48 89 c2             	mov    %rax,%rdx
  800420034d:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200351:	48 01 c2             	add    %rax,%rdx
  8004200354:	48 b8 20 00 3b 04 80 	movabs $0x80043b0020,%rax
  800420035b:	00 00 00 
  800420035e:	48 01 d0             	add    %rdx,%rax
  8004200361:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200365:	75 05                	jne    800420036c <boot_aps+0xf8>
			continue;
  8004200367:	e9 d2 00 00 00       	jmpq   800420043e <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  800420036c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200370:	48 b8 20 00 3b 04 80 	movabs $0x80043b0020,%rax
  8004200377:	00 00 00 
  800420037a:	48 29 c2             	sub    %rax,%rdx
  800420037d:	48 89 d0             	mov    %rdx,%rax
  8004200380:	48 c1 f8 03          	sar    $0x3,%rax
  8004200384:	48 89 c2             	mov    %rax,%rdx
  8004200387:	48 b8 f1 f0 f0 f0 f0 	movabs $0xf0f0f0f0f0f0f0f1,%rax
  800420038e:	f0 f0 f0 
  8004200391:	48 0f af c2          	imul   %rdx,%rax
  8004200395:	48 83 c0 01          	add    $0x1,%rax
  8004200399:	48 c1 e0 10          	shl    $0x10,%rax
  800420039d:	48 89 c2             	mov    %rax,%rdx
  80042003a0:	48 b8 00 10 3b 04 80 	movabs $0x80043b1000,%rax
  80042003a7:	00 00 00 
  80042003aa:	48 01 c2             	add    %rax,%rdx
  80042003ad:	48 b8 80 e7 3a 04 80 	movabs $0x80043ae780,%rax
  80042003b4:	00 00 00 
  80042003b7:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  80042003ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042003be:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042003c2:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042003c9:	00 00 00 
  80042003cc:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042003d0:	77 32                	ja     8004200404 <boot_aps+0x190>
  80042003d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042003d6:	48 89 c1             	mov    %rax,%rcx
  80042003d9:	48 ba 88 d2 21 04 80 	movabs $0x800421d288,%rdx
  80042003e0:	00 00 00 
  80042003e3:	be be 00 00 00       	mov    $0xbe,%esi
  80042003e8:	48 bf 7b d2 21 04 80 	movabs $0x800421d27b,%rdi
  80042003ef:	00 00 00 
  80042003f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042003f7:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042003fe:	00 00 00 
  8004200401:	41 ff d0             	callq  *%r8
  8004200404:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420040b:	ff ff ff 
  800420040e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200412:	48 01 d0             	add    %rdx,%rax
  8004200415:	89 c2                	mov    %eax,%edx
  8004200417:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420041b:	0f b6 00             	movzbl (%rax),%eax
  800420041e:	0f b6 c0             	movzbl %al,%eax
  8004200421:	89 d6                	mov    %edx,%esi
  8004200423:	89 c7                	mov    %eax,%edi
  8004200425:	48 b8 0a 7c 21 04 80 	movabs $0x8004217c0a,%rax
  800420042c:	00 00 00 
  800420042f:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  8004200431:	90                   	nop
  8004200432:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200436:	8b 40 04             	mov    0x4(%rax),%eax
  8004200439:	83 f8 01             	cmp    $0x1,%eax
  800420043c:	75 f4                	jne    8004200432 <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  800420043e:	48 81 45 f8 88 00 00 	addq   $0x88,-0x8(%rbp)
  8004200445:	00 
  8004200446:	48 b8 48 02 3b 04 80 	movabs $0x80043b0248,%rax
  800420044d:	00 00 00 
  8004200450:	8b 00                	mov    (%rax),%eax
  8004200452:	48 98                	cltq   
  8004200454:	48 c1 e0 03          	shl    $0x3,%rax
  8004200458:	48 89 c2             	mov    %rax,%rdx
  800420045b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420045f:	48 01 c2             	add    %rax,%rdx
  8004200462:	48 b8 20 00 3b 04 80 	movabs $0x80043b0020,%rax
  8004200469:	00 00 00 
  800420046c:	48 01 d0             	add    %rdx,%rax
  800420046f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004200473:	0f 87 bf fe ff ff    	ja     8004200338 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  8004200479:	c9                   	leaveq 
  800420047a:	c3                   	retq   

000000800420047b <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  800420047b:	55                   	push   %rbp
  800420047c:	48 89 e5             	mov    %rsp,%rbp
  800420047f:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  8004200483:	48 b8 88 e7 3a 04 80 	movabs $0x80043ae788,%rax
  800420048a:	00 00 00 
  800420048d:	48 8b 00             	mov    (%rax),%rax
  8004200490:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004200494:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200498:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  800420049b:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  80042004a2:	00 00 00 
  80042004a5:	ff d0                	callq  *%rax
  80042004a7:	89 c6                	mov    %eax,%esi
  80042004a9:	48 bf ac d2 21 04 80 	movabs $0x800421d2ac,%rdi
  80042004b0:	00 00 00 
  80042004b3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042004b8:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042004bf:	00 00 00 
  80042004c2:	ff d2                	callq  *%rdx

	lapic_init();
  80042004c4:	48 b8 a3 79 21 04 80 	movabs $0x80042179a3,%rax
  80042004cb:	00 00 00 
  80042004ce:	ff d0                	callq  *%rax
	env_init_percpu();
  80042004d0:	48 b8 b4 7a 20 04 80 	movabs $0x8004207ab4,%rax
  80042004d7:	00 00 00 
  80042004da:	ff d0                	callq  *%rax
	trap_init_percpu();
  80042004dc:	48 b8 42 bf 20 04 80 	movabs $0x800420bf42,%rax
  80042004e3:	00 00 00 
  80042004e6:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  80042004e8:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  80042004ef:	00 00 00 
  80042004f2:	ff d0                	callq  *%rax
  80042004f4:	48 98                	cltq   
  80042004f6:	48 c1 e0 03          	shl    $0x3,%rax
  80042004fa:	48 89 c2             	mov    %rax,%rdx
  80042004fd:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200501:	48 01 d0             	add    %rdx,%rax
  8004200504:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420050b:	00 00 00 
  800420050e:	48 01 d0             	add    %rdx,%rax
  8004200511:	48 83 c0 04          	add    $0x4,%rax
  8004200515:	be 01 00 00 00       	mov    $0x1,%esi
  800420051a:	48 89 c7             	mov    %rax,%rdi
  800420051d:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  8004200524:	00 00 00 
  8004200527:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	lock_kernel();
  8004200529:	48 b8 7d 00 20 04 80 	movabs $0x800420007d,%rax
  8004200530:	00 00 00 
  8004200533:	ff d0                	callq  *%rax
	sched_yield();
  8004200535:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  800420053c:	00 00 00 
  800420053f:	ff d0                	callq  *%rax

0000008004200541 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  8004200541:	55                   	push   %rbp
  8004200542:	48 89 e5             	mov    %rsp,%rbp
  8004200545:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420054c:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  8004200553:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200559:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200560:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004200567:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420056e:	84 c0                	test   %al,%al
  8004200570:	74 20                	je     8004200592 <_panic+0x51>
  8004200572:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004200576:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420057a:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420057e:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004200582:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004200586:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420058a:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420058e:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004200592:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  8004200599:	48 b8 78 e7 3a 04 80 	movabs $0x80043ae778,%rax
  80042005a0:	00 00 00 
  80042005a3:	48 8b 00             	mov    (%rax),%rax
  80042005a6:	48 85 c0             	test   %rax,%rax
  80042005a9:	74 05                	je     80042005b0 <_panic+0x6f>
		goto dead;
  80042005ab:	e9 b5 00 00 00       	jmpq   8004200665 <_panic+0x124>
	panicstr = fmt;
  80042005b0:	48 b8 78 e7 3a 04 80 	movabs $0x80043ae778,%rax
  80042005b7:	00 00 00 
  80042005ba:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  80042005c1:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  80042005c4:	fa                   	cli    
  80042005c5:	fc                   	cld    

	va_start(ap, fmt);
  80042005c6:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042005cd:	00 00 00 
  80042005d0:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042005d7:	00 00 00 
  80042005da:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042005de:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042005e5:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042005ec:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  80042005f3:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  80042005fa:	00 00 00 
  80042005fd:	ff d0                	callq  *%rax
  80042005ff:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  8004200605:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800420060c:	89 c6                	mov    %eax,%esi
  800420060e:	48 bf c8 d2 21 04 80 	movabs $0x800421d2c8,%rdi
  8004200615:	00 00 00 
  8004200618:	b8 00 00 00 00       	mov    $0x0,%eax
  800420061d:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  8004200624:	00 00 00 
  8004200627:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  800420062a:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200631:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200638:	48 89 d6             	mov    %rdx,%rsi
  800420063b:	48 89 c7             	mov    %rax,%rdi
  800420063e:	48 b8 bb 95 20 04 80 	movabs $0x80042095bb,%rax
  8004200645:	00 00 00 
  8004200648:	ff d0                	callq  *%rax
	cprintf("\n");
  800420064a:	48 bf ea d2 21 04 80 	movabs $0x800421d2ea,%rdi
  8004200651:	00 00 00 
  8004200654:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200659:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004200660:	00 00 00 
  8004200663:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  8004200665:	bf 00 00 00 00       	mov    $0x0,%edi
  800420066a:	48 b8 4c 1b 20 04 80 	movabs $0x8004201b4c,%rax
  8004200671:	00 00 00 
  8004200674:	ff d0                	callq  *%rax
  8004200676:	eb ed                	jmp    8004200665 <_panic+0x124>

0000008004200678 <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  8004200678:	55                   	push   %rbp
  8004200679:	48 89 e5             	mov    %rsp,%rbp
  800420067c:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200683:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420068a:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200690:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200697:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420069e:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042006a5:	84 c0                	test   %al,%al
  80042006a7:	74 20                	je     80042006c9 <_warn+0x51>
  80042006a9:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042006ad:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042006b1:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042006b5:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042006b9:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042006bd:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042006c1:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042006c5:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042006c9:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  80042006d0:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042006d7:	00 00 00 
  80042006da:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042006e1:	00 00 00 
  80042006e4:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042006e8:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042006ef:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042006f6:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  80042006fd:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004200703:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420070a:	48 89 c6             	mov    %rax,%rsi
  800420070d:	48 bf ec d2 21 04 80 	movabs $0x800421d2ec,%rdi
  8004200714:	00 00 00 
  8004200717:	b8 00 00 00 00       	mov    $0x0,%eax
  800420071c:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  8004200723:	00 00 00 
  8004200726:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  8004200728:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  800420072f:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200736:	48 89 d6             	mov    %rdx,%rsi
  8004200739:	48 89 c7             	mov    %rax,%rdi
  800420073c:	48 b8 bb 95 20 04 80 	movabs $0x80042095bb,%rax
  8004200743:	00 00 00 
  8004200746:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200748:	48 bf ea d2 21 04 80 	movabs $0x800421d2ea,%rdi
  800420074f:	00 00 00 
  8004200752:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200757:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420075e:	00 00 00 
  8004200761:	ff d2                	callq  *%rdx
	va_end(ap);
}
  8004200763:	c9                   	leaveq 
  8004200764:	c3                   	retq   

0000008004200765 <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  8004200765:	55                   	push   %rbp
  8004200766:	48 89 e5             	mov    %rsp,%rbp
  8004200769:	48 83 ec 20          	sub    $0x20,%rsp
  800420076d:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200774:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200777:	89 c2                	mov    %eax,%edx
  8004200779:	ec                   	in     (%dx),%al
  800420077a:	88 45 fb             	mov    %al,-0x5(%rbp)
  800420077d:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  8004200784:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200787:	89 c2                	mov    %eax,%edx
  8004200789:	ec                   	in     (%dx),%al
  800420078a:	88 45 f3             	mov    %al,-0xd(%rbp)
  800420078d:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  8004200794:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200797:	89 c2                	mov    %eax,%edx
  8004200799:	ec                   	in     (%dx),%al
  800420079a:	88 45 eb             	mov    %al,-0x15(%rbp)
  800420079d:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  80042007a4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042007a7:	89 c2                	mov    %eax,%edx
  80042007a9:	ec                   	in     (%dx),%al
  80042007aa:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  80042007ad:	c9                   	leaveq 
  80042007ae:	c3                   	retq   

00000080042007af <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  80042007af:	55                   	push   %rbp
  80042007b0:	48 89 e5             	mov    %rsp,%rbp
  80042007b3:	48 83 ec 10          	sub    $0x10,%rsp
  80042007b7:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  80042007be:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042007c1:	89 c2                	mov    %eax,%edx
  80042007c3:	ec                   	in     (%dx),%al
  80042007c4:	88 45 fb             	mov    %al,-0x5(%rbp)
    return data;
  80042007c7:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  80042007cb:	0f b6 c0             	movzbl %al,%eax
  80042007ce:	83 e0 01             	and    $0x1,%eax
  80042007d1:	85 c0                	test   %eax,%eax
  80042007d3:	75 07                	jne    80042007dc <serial_proc_data+0x2d>
		return -1;
  80042007d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042007da:	eb 17                	jmp    80042007f3 <serial_proc_data+0x44>
  80042007dc:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042007e3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042007e6:	89 c2                	mov    %eax,%edx
  80042007e8:	ec                   	in     (%dx),%al
  80042007e9:	88 45 f3             	mov    %al,-0xd(%rbp)
    return data;
  80042007ec:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  80042007f0:	0f b6 c0             	movzbl %al,%eax
}
  80042007f3:	c9                   	leaveq 
  80042007f4:	c3                   	retq   

00000080042007f5 <serial_intr>:

void
serial_intr(void)
{
  80042007f5:	55                   	push   %rbp
  80042007f6:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  80042007f9:	48 b8 00 d0 3a 04 80 	movabs $0x80043ad000,%rax
  8004200800:	00 00 00 
  8004200803:	0f b6 00             	movzbl (%rax),%eax
  8004200806:	84 c0                	test   %al,%al
  8004200808:	74 16                	je     8004200820 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  800420080a:	48 bf af 07 20 04 80 	movabs $0x80042007af,%rdi
  8004200811:	00 00 00 
  8004200814:	48 b8 95 10 20 04 80 	movabs $0x8004201095,%rax
  800420081b:	00 00 00 
  800420081e:	ff d0                	callq  *%rax
}
  8004200820:	5d                   	pop    %rbp
  8004200821:	c3                   	retq   

0000008004200822 <serial_putc>:

static void
serial_putc(int c)
{
  8004200822:	55                   	push   %rbp
  8004200823:	48 89 e5             	mov    %rsp,%rbp
  8004200826:	48 83 ec 28          	sub    $0x28,%rsp
  800420082a:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  800420082d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200834:	eb 10                	jmp    8004200846 <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  8004200836:	48 b8 65 07 20 04 80 	movabs $0x8004200765,%rax
  800420083d:	00 00 00 
  8004200840:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  8004200842:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200846:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420084d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200850:	89 c2                	mov    %eax,%edx
  8004200852:	ec                   	in     (%dx),%al
  8004200853:	88 45 f7             	mov    %al,-0x9(%rbp)
    return data;
  8004200856:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420085a:	0f b6 c0             	movzbl %al,%eax
  800420085d:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  8004200860:	85 c0                	test   %eax,%eax
  8004200862:	75 09                	jne    800420086d <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200864:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  800420086b:	7e c9                	jle    8004200836 <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  800420086d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200870:	0f b6 c0             	movzbl %al,%eax
  8004200873:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  800420087a:	88 45 ef             	mov    %al,-0x11(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420087d:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200881:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200884:	ee                   	out    %al,(%dx)
}
  8004200885:	c9                   	leaveq 
  8004200886:	c3                   	retq   

0000008004200887 <serial_init>:

static void
serial_init(void)
{
  8004200887:	55                   	push   %rbp
  8004200888:	48 89 e5             	mov    %rsp,%rbp
  800420088b:	48 83 ec 50          	sub    $0x50,%rsp
  800420088f:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  8004200896:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  800420089a:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420089e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042008a1:	ee                   	out    %al,(%dx)
  80042008a2:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  80042008a9:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  80042008ad:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042008b1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042008b4:	ee                   	out    %al,(%dx)
  80042008b5:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  80042008bc:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  80042008c0:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042008c4:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042008c7:	ee                   	out    %al,(%dx)
  80042008c8:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  80042008cf:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  80042008d3:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042008d7:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042008da:	ee                   	out    %al,(%dx)
  80042008db:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  80042008e2:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  80042008e6:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  80042008ea:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042008ed:	ee                   	out    %al,(%dx)
  80042008ee:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  80042008f5:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  80042008f9:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  80042008fd:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200900:	ee                   	out    %al,(%dx)
  8004200901:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  8004200908:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  800420090c:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004200910:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200913:	ee                   	out    %al,(%dx)
  8004200914:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420091b:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420091e:	89 c2                	mov    %eax,%edx
  8004200920:	ec                   	in     (%dx),%al
  8004200921:	88 45 c3             	mov    %al,-0x3d(%rbp)
    return data;
  8004200924:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  8004200928:	3c ff                	cmp    $0xff,%al
  800420092a:	0f 95 c2             	setne  %dl
  800420092d:	48 b8 00 d0 3a 04 80 	movabs $0x80043ad000,%rax
  8004200934:	00 00 00 
  8004200937:	88 10                	mov    %dl,(%rax)
  8004200939:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200940:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004200943:	89 c2                	mov    %eax,%edx
  8004200945:	ec                   	in     (%dx),%al
  8004200946:	88 45 bb             	mov    %al,-0x45(%rbp)
  8004200949:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  8004200950:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004200953:	89 c2                	mov    %eax,%edx
  8004200955:	ec                   	in     (%dx),%al
  8004200956:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  8004200959:	48 b8 00 d0 3a 04 80 	movabs $0x80043ad000,%rax
  8004200960:	00 00 00 
  8004200963:	0f b6 00             	movzbl (%rax),%eax
  8004200966:	84 c0                	test   %al,%al
  8004200968:	74 23                	je     800420098d <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  800420096a:	48 b8 52 36 23 04 80 	movabs $0x8004233652,%rax
  8004200971:	00 00 00 
  8004200974:	0f b7 00             	movzwl (%rax),%eax
  8004200977:	0f b7 c0             	movzwl %ax,%eax
  800420097a:	25 ef ff 00 00       	and    $0xffef,%eax
  800420097f:	89 c7                	mov    %eax,%edi
  8004200981:	48 b8 6c 94 20 04 80 	movabs $0x800420946c,%rax
  8004200988:	00 00 00 
  800420098b:	ff d0                	callq  *%rax
}
  800420098d:	c9                   	leaveq 
  800420098e:	c3                   	retq   

000000800420098f <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  800420098f:	55                   	push   %rbp
  8004200990:	48 89 e5             	mov    %rsp,%rbp
  8004200993:	48 83 ec 38          	sub    $0x38,%rsp
  8004200997:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  800420099a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042009a1:	eb 10                	jmp    80042009b3 <lpt_putc+0x24>
		delay();
  80042009a3:	48 b8 65 07 20 04 80 	movabs $0x8004200765,%rax
  80042009aa:	00 00 00 
  80042009ad:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  80042009af:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042009b3:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  80042009ba:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042009bd:	89 c2                	mov    %eax,%edx
  80042009bf:	ec                   	in     (%dx),%al
  80042009c0:	88 45 f7             	mov    %al,-0x9(%rbp)
    return data;
  80042009c3:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042009c7:	84 c0                	test   %al,%al
  80042009c9:	78 09                	js     80042009d4 <lpt_putc+0x45>
  80042009cb:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  80042009d2:	7e cf                	jle    80042009a3 <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  80042009d4:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042009d7:	0f b6 c0             	movzbl %al,%eax
  80042009da:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  80042009e1:	88 45 ef             	mov    %al,-0x11(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042009e4:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042009e8:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042009eb:	ee                   	out    %al,(%dx)
  80042009ec:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  80042009f3:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  80042009f7:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042009fb:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042009fe:	ee                   	out    %al,(%dx)
  80042009ff:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200a06:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  8004200a0a:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200a0e:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200a11:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  8004200a12:	c9                   	leaveq 
  8004200a13:	c3                   	retq   

0000008004200a14 <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200a14:	55                   	push   %rbp
  8004200a15:	48 89 e5             	mov    %rsp,%rbp
  8004200a18:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200a1c:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200a23:	00 00 00 
  8004200a26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200a2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a2e:	0f b7 00             	movzwl (%rax),%eax
  8004200a31:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200a35:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a39:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200a3e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a42:	0f b7 00             	movzwl (%rax),%eax
  8004200a45:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200a49:	74 20                	je     8004200a6b <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200a4b:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200a52:	00 00 00 
  8004200a55:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200a59:	48 b8 04 d0 3a 04 80 	movabs $0x80043ad004,%rax
  8004200a60:	00 00 00 
  8004200a63:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200a69:	eb 1b                	jmp    8004200a86 <cga_init+0x72>
	} else {
		*cp = was;
  8004200a6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200a6f:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200a73:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200a76:	48 b8 04 d0 3a 04 80 	movabs $0x80043ad004,%rax
  8004200a7d:	00 00 00 
  8004200a80:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200a86:	48 b8 04 d0 3a 04 80 	movabs $0x80043ad004,%rax
  8004200a8d:	00 00 00 
  8004200a90:	8b 00                	mov    (%rax),%eax
  8004200a92:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200a95:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200a99:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200a9d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200aa0:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200aa1:	48 b8 04 d0 3a 04 80 	movabs $0x80043ad004,%rax
  8004200aa8:	00 00 00 
  8004200aab:	8b 00                	mov    (%rax),%eax
  8004200aad:	83 c0 01             	add    $0x1,%eax
  8004200ab0:	89 45 e4             	mov    %eax,-0x1c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200ab3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200ab6:	89 c2                	mov    %eax,%edx
  8004200ab8:	ec                   	in     (%dx),%al
  8004200ab9:	88 45 e3             	mov    %al,-0x1d(%rbp)
    return data;
  8004200abc:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200ac0:	0f b6 c0             	movzbl %al,%eax
  8004200ac3:	c1 e0 08             	shl    $0x8,%eax
  8004200ac6:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200ac9:	48 b8 04 d0 3a 04 80 	movabs $0x80043ad004,%rax
  8004200ad0:	00 00 00 
  8004200ad3:	8b 00                	mov    (%rax),%eax
  8004200ad5:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200ad8:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200adc:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200ae0:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200ae3:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200ae4:	48 b8 04 d0 3a 04 80 	movabs $0x80043ad004,%rax
  8004200aeb:	00 00 00 
  8004200aee:	8b 00                	mov    (%rax),%eax
  8004200af0:	83 c0 01             	add    $0x1,%eax
  8004200af3:	89 45 d4             	mov    %eax,-0x2c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200af6:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200af9:	89 c2                	mov    %eax,%edx
  8004200afb:	ec                   	in     (%dx),%al
  8004200afc:	88 45 d3             	mov    %al,-0x2d(%rbp)
    return data;
  8004200aff:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200b03:	0f b6 c0             	movzbl %al,%eax
  8004200b06:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200b09:	48 b8 08 d0 3a 04 80 	movabs $0x80043ad008,%rax
  8004200b10:	00 00 00 
  8004200b13:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200b17:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200b1a:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200b1d:	89 c2                	mov    %eax,%edx
  8004200b1f:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200b26:	00 00 00 
  8004200b29:	66 89 10             	mov    %dx,(%rax)
}
  8004200b2c:	c9                   	leaveq 
  8004200b2d:	c3                   	retq   

0000008004200b2e <cga_putc>:



static void
cga_putc(int c)
{
  8004200b2e:	55                   	push   %rbp
  8004200b2f:	48 89 e5             	mov    %rsp,%rbp
  8004200b32:	48 83 ec 40          	sub    $0x40,%rsp
  8004200b36:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200b39:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b3c:	b0 00                	mov    $0x0,%al
  8004200b3e:	85 c0                	test   %eax,%eax
  8004200b40:	75 07                	jne    8004200b49 <cga_putc+0x1b>
		c |= 0x0700;
  8004200b42:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200b49:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200b4c:	0f b6 c0             	movzbl %al,%eax
  8004200b4f:	83 f8 09             	cmp    $0x9,%eax
  8004200b52:	0f 84 f6 00 00 00    	je     8004200c4e <cga_putc+0x120>
  8004200b58:	83 f8 09             	cmp    $0x9,%eax
  8004200b5b:	7f 0a                	jg     8004200b67 <cga_putc+0x39>
  8004200b5d:	83 f8 08             	cmp    $0x8,%eax
  8004200b60:	74 18                	je     8004200b7a <cga_putc+0x4c>
  8004200b62:	e9 3e 01 00 00       	jmpq   8004200ca5 <cga_putc+0x177>
  8004200b67:	83 f8 0a             	cmp    $0xa,%eax
  8004200b6a:	74 75                	je     8004200be1 <cga_putc+0xb3>
  8004200b6c:	83 f8 0d             	cmp    $0xd,%eax
  8004200b6f:	0f 84 89 00 00 00    	je     8004200bfe <cga_putc+0xd0>
  8004200b75:	e9 2b 01 00 00       	jmpq   8004200ca5 <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200b7a:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200b81:	00 00 00 
  8004200b84:	0f b7 00             	movzwl (%rax),%eax
  8004200b87:	66 85 c0             	test   %ax,%ax
  8004200b8a:	74 50                	je     8004200bdc <cga_putc+0xae>
			crt_pos--;
  8004200b8c:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200b93:	00 00 00 
  8004200b96:	0f b7 00             	movzwl (%rax),%eax
  8004200b99:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200b9c:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200ba3:	00 00 00 
  8004200ba6:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200ba9:	48 b8 08 d0 3a 04 80 	movabs $0x80043ad008,%rax
  8004200bb0:	00 00 00 
  8004200bb3:	48 8b 10             	mov    (%rax),%rdx
  8004200bb6:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200bbd:	00 00 00 
  8004200bc0:	0f b7 00             	movzwl (%rax),%eax
  8004200bc3:	0f b7 c0             	movzwl %ax,%eax
  8004200bc6:	48 01 c0             	add    %rax,%rax
  8004200bc9:	48 01 c2             	add    %rax,%rdx
  8004200bcc:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200bcf:	b0 00                	mov    $0x0,%al
  8004200bd1:	83 c8 20             	or     $0x20,%eax
  8004200bd4:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200bd7:	e9 04 01 00 00       	jmpq   8004200ce0 <cga_putc+0x1b2>
  8004200bdc:	e9 ff 00 00 00       	jmpq   8004200ce0 <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200be1:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200be8:	00 00 00 
  8004200beb:	0f b7 00             	movzwl (%rax),%eax
  8004200bee:	8d 50 50             	lea    0x50(%rax),%edx
  8004200bf1:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200bf8:	00 00 00 
  8004200bfb:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200bfe:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200c05:	00 00 00 
  8004200c08:	0f b7 30             	movzwl (%rax),%esi
  8004200c0b:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200c12:	00 00 00 
  8004200c15:	0f b7 08             	movzwl (%rax),%ecx
  8004200c18:	0f b7 c1             	movzwl %cx,%eax
  8004200c1b:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200c21:	c1 e8 10             	shr    $0x10,%eax
  8004200c24:	89 c2                	mov    %eax,%edx
  8004200c26:	66 c1 ea 06          	shr    $0x6,%dx
  8004200c2a:	89 d0                	mov    %edx,%eax
  8004200c2c:	c1 e0 02             	shl    $0x2,%eax
  8004200c2f:	01 d0                	add    %edx,%eax
  8004200c31:	c1 e0 04             	shl    $0x4,%eax
  8004200c34:	29 c1                	sub    %eax,%ecx
  8004200c36:	89 ca                	mov    %ecx,%edx
  8004200c38:	29 d6                	sub    %edx,%esi
  8004200c3a:	89 f2                	mov    %esi,%edx
  8004200c3c:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200c43:	00 00 00 
  8004200c46:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200c49:	e9 92 00 00 00       	jmpq   8004200ce0 <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200c4e:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c53:	48 b8 d2 11 20 04 80 	movabs $0x80042011d2,%rax
  8004200c5a:	00 00 00 
  8004200c5d:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c5f:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c64:	48 b8 d2 11 20 04 80 	movabs $0x80042011d2,%rax
  8004200c6b:	00 00 00 
  8004200c6e:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c70:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c75:	48 b8 d2 11 20 04 80 	movabs $0x80042011d2,%rax
  8004200c7c:	00 00 00 
  8004200c7f:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c81:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c86:	48 b8 d2 11 20 04 80 	movabs $0x80042011d2,%rax
  8004200c8d:	00 00 00 
  8004200c90:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200c92:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200c97:	48 b8 d2 11 20 04 80 	movabs $0x80042011d2,%rax
  8004200c9e:	00 00 00 
  8004200ca1:	ff d0                	callq  *%rax
		break;
  8004200ca3:	eb 3b                	jmp    8004200ce0 <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200ca5:	48 b8 08 d0 3a 04 80 	movabs $0x80043ad008,%rax
  8004200cac:	00 00 00 
  8004200caf:	48 8b 30             	mov    (%rax),%rsi
  8004200cb2:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200cb9:	00 00 00 
  8004200cbc:	0f b7 00             	movzwl (%rax),%eax
  8004200cbf:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200cc2:	48 ba 10 d0 3a 04 80 	movabs $0x80043ad010,%rdx
  8004200cc9:	00 00 00 
  8004200ccc:	66 89 0a             	mov    %cx,(%rdx)
  8004200ccf:	0f b7 c0             	movzwl %ax,%eax
  8004200cd2:	48 01 c0             	add    %rax,%rax
  8004200cd5:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200cd9:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200cdc:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200cdf:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200ce0:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200ce7:	00 00 00 
  8004200cea:	0f b7 00             	movzwl (%rax),%eax
  8004200ced:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200cf1:	0f 86 89 00 00 00    	jbe    8004200d80 <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200cf7:	48 b8 08 d0 3a 04 80 	movabs $0x80043ad008,%rax
  8004200cfe:	00 00 00 
  8004200d01:	48 8b 00             	mov    (%rax),%rax
  8004200d04:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200d0b:	48 b8 08 d0 3a 04 80 	movabs $0x80043ad008,%rax
  8004200d12:	00 00 00 
  8004200d15:	48 8b 00             	mov    (%rax),%rax
  8004200d18:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200d1d:	48 89 ce             	mov    %rcx,%rsi
  8004200d20:	48 89 c7             	mov    %rax,%rdi
  8004200d23:	48 b8 17 0c 21 04 80 	movabs $0x8004210c17,%rax
  8004200d2a:	00 00 00 
  8004200d2d:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d2f:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200d36:	eb 22                	jmp    8004200d5a <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200d38:	48 b8 08 d0 3a 04 80 	movabs $0x80043ad008,%rax
  8004200d3f:	00 00 00 
  8004200d42:	48 8b 00             	mov    (%rax),%rax
  8004200d45:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200d48:	48 63 d2             	movslq %edx,%rdx
  8004200d4b:	48 01 d2             	add    %rdx,%rdx
  8004200d4e:	48 01 d0             	add    %rdx,%rax
  8004200d51:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200d56:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200d5a:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200d61:	7e d5                	jle    8004200d38 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200d63:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200d6a:	00 00 00 
  8004200d6d:	0f b7 00             	movzwl (%rax),%eax
  8004200d70:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200d73:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200d7a:	00 00 00 
  8004200d7d:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200d80:	48 b8 04 d0 3a 04 80 	movabs $0x80043ad004,%rax
  8004200d87:	00 00 00 
  8004200d8a:	8b 00                	mov    (%rax),%eax
  8004200d8c:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200d8f:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200d93:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200d97:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200d9a:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200d9b:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200da2:	00 00 00 
  8004200da5:	0f b7 00             	movzwl (%rax),%eax
  8004200da8:	66 c1 e8 08          	shr    $0x8,%ax
  8004200dac:	0f b6 c0             	movzbl %al,%eax
  8004200daf:	48 ba 04 d0 3a 04 80 	movabs $0x80043ad004,%rdx
  8004200db6:	00 00 00 
  8004200db9:	8b 12                	mov    (%rdx),%edx
  8004200dbb:	83 c2 01             	add    $0x1,%edx
  8004200dbe:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200dc1:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200dc4:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200dc8:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200dcb:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200dcc:	48 b8 04 d0 3a 04 80 	movabs $0x80043ad004,%rax
  8004200dd3:	00 00 00 
  8004200dd6:	8b 00                	mov    (%rax),%eax
  8004200dd8:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200ddb:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200ddf:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200de3:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200de6:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200de7:	48 b8 10 d0 3a 04 80 	movabs $0x80043ad010,%rax
  8004200dee:	00 00 00 
  8004200df1:	0f b7 00             	movzwl (%rax),%eax
  8004200df4:	0f b6 c0             	movzbl %al,%eax
  8004200df7:	48 ba 04 d0 3a 04 80 	movabs $0x80043ad004,%rdx
  8004200dfe:	00 00 00 
  8004200e01:	8b 12                	mov    (%rdx),%edx
  8004200e03:	83 c2 01             	add    $0x1,%edx
  8004200e06:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200e09:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200e0c:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200e10:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200e13:	ee                   	out    %al,(%dx)
}
  8004200e14:	c9                   	leaveq 
  8004200e15:	c3                   	retq   

0000008004200e16 <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200e16:	55                   	push   %rbp
  8004200e17:	48 89 e5             	mov    %rsp,%rbp
  8004200e1a:	48 83 ec 20          	sub    $0x20,%rsp
  8004200e1e:	c7 45 f4 64 00 00 00 	movl   $0x64,-0xc(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e25:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004200e28:	89 c2                	mov    %eax,%edx
  8004200e2a:	ec                   	in     (%dx),%al
  8004200e2b:	88 45 f3             	mov    %al,-0xd(%rbp)
    return data;
  8004200e2e:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200e32:	0f b6 c0             	movzbl %al,%eax
  8004200e35:	83 e0 01             	and    $0x1,%eax
  8004200e38:	85 c0                	test   %eax,%eax
  8004200e3a:	75 0a                	jne    8004200e46 <kbd_proc_data+0x30>
		return -1;
  8004200e3c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200e41:	e9 fc 01 00 00       	jmpq   8004201042 <kbd_proc_data+0x22c>
  8004200e46:	c7 45 ec 60 00 00 00 	movl   $0x60,-0x14(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200e4d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004200e50:	89 c2                	mov    %eax,%edx
  8004200e52:	ec                   	in     (%dx),%al
  8004200e53:	88 45 eb             	mov    %al,-0x15(%rbp)
    return data;
  8004200e56:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax

	data = inb(KBDATAP);
  8004200e5a:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200e5d:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200e61:	75 27                	jne    8004200e8a <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200e63:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200e6a:	00 00 00 
  8004200e6d:	8b 00                	mov    (%rax),%eax
  8004200e6f:	83 c8 40             	or     $0x40,%eax
  8004200e72:	89 c2                	mov    %eax,%edx
  8004200e74:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200e7b:	00 00 00 
  8004200e7e:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200e80:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200e85:	e9 b8 01 00 00       	jmpq   8004201042 <kbd_proc_data+0x22c>
	} else if (data & 0x80) {
  8004200e8a:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200e8e:	84 c0                	test   %al,%al
  8004200e90:	79 65                	jns    8004200ef7 <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200e92:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200e99:	00 00 00 
  8004200e9c:	8b 00                	mov    (%rax),%eax
  8004200e9e:	83 e0 40             	and    $0x40,%eax
  8004200ea1:	85 c0                	test   %eax,%eax
  8004200ea3:	75 09                	jne    8004200eae <kbd_proc_data+0x98>
  8004200ea5:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200ea9:	83 e0 7f             	and    $0x7f,%eax
  8004200eac:	eb 04                	jmp    8004200eb2 <kbd_proc_data+0x9c>
  8004200eae:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200eb2:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200eb5:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200eb9:	48 ba 60 30 23 04 80 	movabs $0x8004233060,%rdx
  8004200ec0:	00 00 00 
  8004200ec3:	48 98                	cltq   
  8004200ec5:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200ec9:	83 c8 40             	or     $0x40,%eax
  8004200ecc:	0f b6 c0             	movzbl %al,%eax
  8004200ecf:	f7 d0                	not    %eax
  8004200ed1:	89 c2                	mov    %eax,%edx
  8004200ed3:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200eda:	00 00 00 
  8004200edd:	8b 00                	mov    (%rax),%eax
  8004200edf:	21 c2                	and    %eax,%edx
  8004200ee1:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200ee8:	00 00 00 
  8004200eeb:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200eed:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200ef2:	e9 4b 01 00 00       	jmpq   8004201042 <kbd_proc_data+0x22c>
	} else if (shift & E0ESC) {
  8004200ef7:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200efe:	00 00 00 
  8004200f01:	8b 00                	mov    (%rax),%eax
  8004200f03:	83 e0 40             	and    $0x40,%eax
  8004200f06:	85 c0                	test   %eax,%eax
  8004200f08:	74 21                	je     8004200f2b <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004200f0a:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004200f0e:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200f15:	00 00 00 
  8004200f18:	8b 00                	mov    (%rax),%eax
  8004200f1a:	83 e0 bf             	and    $0xffffffbf,%eax
  8004200f1d:	89 c2                	mov    %eax,%edx
  8004200f1f:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200f26:	00 00 00 
  8004200f29:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004200f2b:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f2f:	48 ba 60 30 23 04 80 	movabs $0x8004233060,%rdx
  8004200f36:	00 00 00 
  8004200f39:	48 98                	cltq   
  8004200f3b:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f3f:	0f b6 d0             	movzbl %al,%edx
  8004200f42:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200f49:	00 00 00 
  8004200f4c:	8b 00                	mov    (%rax),%eax
  8004200f4e:	09 c2                	or     %eax,%edx
  8004200f50:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200f57:	00 00 00 
  8004200f5a:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004200f5c:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200f60:	48 ba 60 31 23 04 80 	movabs $0x8004233160,%rdx
  8004200f67:	00 00 00 
  8004200f6a:	48 98                	cltq   
  8004200f6c:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200f70:	0f b6 d0             	movzbl %al,%edx
  8004200f73:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200f7a:	00 00 00 
  8004200f7d:	8b 00                	mov    (%rax),%eax
  8004200f7f:	31 c2                	xor    %eax,%edx
  8004200f81:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200f88:	00 00 00 
  8004200f8b:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  8004200f8d:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200f94:	00 00 00 
  8004200f97:	8b 00                	mov    (%rax),%eax
  8004200f99:	83 e0 03             	and    $0x3,%eax
  8004200f9c:	89 c2                	mov    %eax,%edx
  8004200f9e:	48 b8 60 35 23 04 80 	movabs $0x8004233560,%rax
  8004200fa5:	00 00 00 
  8004200fa8:	89 d2                	mov    %edx,%edx
  8004200faa:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  8004200fae:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200fb2:	48 01 d0             	add    %rdx,%rax
  8004200fb5:	0f b6 00             	movzbl (%rax),%eax
  8004200fb8:	0f b6 c0             	movzbl %al,%eax
  8004200fbb:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  8004200fbe:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200fc5:	00 00 00 
  8004200fc8:	8b 00                	mov    (%rax),%eax
  8004200fca:	83 e0 08             	and    $0x8,%eax
  8004200fcd:	85 c0                	test   %eax,%eax
  8004200fcf:	74 22                	je     8004200ff3 <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  8004200fd1:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  8004200fd5:	7e 0c                	jle    8004200fe3 <kbd_proc_data+0x1cd>
  8004200fd7:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  8004200fdb:	7f 06                	jg     8004200fe3 <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  8004200fdd:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  8004200fe1:	eb 10                	jmp    8004200ff3 <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  8004200fe3:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  8004200fe7:	7e 0a                	jle    8004200ff3 <kbd_proc_data+0x1dd>
  8004200fe9:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004200fed:	7f 04                	jg     8004200ff3 <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004200fef:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  8004200ff3:	48 b8 28 d2 3a 04 80 	movabs $0x80043ad228,%rax
  8004200ffa:	00 00 00 
  8004200ffd:	8b 00                	mov    (%rax),%eax
  8004200fff:	f7 d0                	not    %eax
  8004201001:	83 e0 06             	and    $0x6,%eax
  8004201004:	85 c0                	test   %eax,%eax
  8004201006:	75 37                	jne    800420103f <kbd_proc_data+0x229>
  8004201008:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  800420100f:	75 2e                	jne    800420103f <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004201011:	48 bf 06 d3 21 04 80 	movabs $0x800421d306,%rdi
  8004201018:	00 00 00 
  800420101b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201020:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201027:	00 00 00 
  800420102a:	ff d2                	callq  *%rdx
  800420102c:	c7 45 e4 92 00 00 00 	movl   $0x92,-0x1c(%rbp)
  8004201033:	c6 45 e3 03          	movb   $0x3,-0x1d(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004201037:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  800420103b:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420103e:	ee                   	out    %al,(%dx)
	if (c == 0x1b) {
		cprintf("ESC pressed\n");
		asm("vmcall":"=a"(r): "0"(VMX_VMCALL_BACKTOHOST));
	}
#endif
	return c;
  800420103f:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004201042:	c9                   	leaveq 
  8004201043:	c3                   	retq   

0000008004201044 <kbd_intr>:

void
kbd_intr(void)
{
  8004201044:	55                   	push   %rbp
  8004201045:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  8004201048:	48 bf 16 0e 20 04 80 	movabs $0x8004200e16,%rdi
  800420104f:	00 00 00 
  8004201052:	48 b8 95 10 20 04 80 	movabs $0x8004201095,%rax
  8004201059:	00 00 00 
  800420105c:	ff d0                	callq  *%rax
}
  800420105e:	5d                   	pop    %rbp
  800420105f:	c3                   	retq   

0000008004201060 <kbd_init>:

static void
kbd_init(void)
{
  8004201060:	55                   	push   %rbp
  8004201061:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  8004201064:	48 b8 44 10 20 04 80 	movabs $0x8004201044,%rax
  800420106b:	00 00 00 
  800420106e:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  8004201070:	48 b8 52 36 23 04 80 	movabs $0x8004233652,%rax
  8004201077:	00 00 00 
  800420107a:	0f b7 00             	movzwl (%rax),%eax
  800420107d:	0f b7 c0             	movzwl %ax,%eax
  8004201080:	25 fd ff 00 00       	and    $0xfffd,%eax
  8004201085:	89 c7                	mov    %eax,%edi
  8004201087:	48 b8 6c 94 20 04 80 	movabs $0x800420946c,%rax
  800420108e:	00 00 00 
  8004201091:	ff d0                	callq  *%rax
}
  8004201093:	5d                   	pop    %rbp
  8004201094:	c3                   	retq   

0000008004201095 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  8004201095:	55                   	push   %rbp
  8004201096:	48 89 e5             	mov    %rsp,%rbp
  8004201099:	48 83 ec 20          	sub    $0x20,%rsp
  800420109d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  80042010a1:	eb 6a                	jmp    800420110d <cons_intr+0x78>
		if (c == 0)
  80042010a3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042010a7:	75 02                	jne    80042010ab <cons_intr+0x16>
			continue;
  80042010a9:	eb 62                	jmp    800420110d <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  80042010ab:	48 b8 20 d0 3a 04 80 	movabs $0x80043ad020,%rax
  80042010b2:	00 00 00 
  80042010b5:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010bb:	8d 48 01             	lea    0x1(%rax),%ecx
  80042010be:	48 ba 20 d0 3a 04 80 	movabs $0x80043ad020,%rdx
  80042010c5:	00 00 00 
  80042010c8:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  80042010ce:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042010d1:	89 d1                	mov    %edx,%ecx
  80042010d3:	48 ba 20 d0 3a 04 80 	movabs $0x80043ad020,%rdx
  80042010da:	00 00 00 
  80042010dd:	89 c0                	mov    %eax,%eax
  80042010df:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  80042010e2:	48 b8 20 d0 3a 04 80 	movabs $0x80043ad020,%rax
  80042010e9:	00 00 00 
  80042010ec:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042010f2:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042010f7:	75 14                	jne    800420110d <cons_intr+0x78>
			cons.wpos = 0;
  80042010f9:	48 b8 20 d0 3a 04 80 	movabs $0x80043ad020,%rax
  8004201100:	00 00 00 
  8004201103:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  800420110a:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  800420110d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201111:	ff d0                	callq  *%rax
  8004201113:	89 45 fc             	mov    %eax,-0x4(%rbp)
  8004201116:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420111a:	75 87                	jne    80042010a3 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  800420111c:	c9                   	leaveq 
  800420111d:	c3                   	retq   

000000800420111e <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  800420111e:	55                   	push   %rbp
  800420111f:	48 89 e5             	mov    %rsp,%rbp
  8004201122:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  8004201126:	48 b8 f5 07 20 04 80 	movabs $0x80042007f5,%rax
  800420112d:	00 00 00 
  8004201130:	ff d0                	callq  *%rax
	kbd_intr();
  8004201132:	48 b8 44 10 20 04 80 	movabs $0x8004201044,%rax
  8004201139:	00 00 00 
  800420113c:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  800420113e:	48 b8 20 d0 3a 04 80 	movabs $0x80043ad020,%rax
  8004201145:	00 00 00 
  8004201148:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  800420114e:	48 b8 20 d0 3a 04 80 	movabs $0x80043ad020,%rax
  8004201155:	00 00 00 
  8004201158:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  800420115e:	39 c2                	cmp    %eax,%edx
  8004201160:	74 69                	je     80042011cb <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  8004201162:	48 b8 20 d0 3a 04 80 	movabs $0x80043ad020,%rax
  8004201169:	00 00 00 
  800420116c:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  8004201172:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201175:	48 ba 20 d0 3a 04 80 	movabs $0x80043ad020,%rdx
  800420117c:	00 00 00 
  800420117f:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  8004201185:	48 ba 20 d0 3a 04 80 	movabs $0x80043ad020,%rdx
  800420118c:	00 00 00 
  800420118f:	89 c0                	mov    %eax,%eax
  8004201191:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201195:	0f b6 c0             	movzbl %al,%eax
  8004201198:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  800420119b:	48 b8 20 d0 3a 04 80 	movabs $0x80043ad020,%rax
  80042011a2:	00 00 00 
  80042011a5:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042011ab:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042011b0:	75 14                	jne    80042011c6 <cons_getc+0xa8>
			cons.rpos = 0;
  80042011b2:	48 b8 20 d0 3a 04 80 	movabs $0x80043ad020,%rax
  80042011b9:	00 00 00 
  80042011bc:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  80042011c3:	00 00 00 
		return c;
  80042011c6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011c9:	eb 05                	jmp    80042011d0 <cons_getc+0xb2>
	}
	return 0;
  80042011cb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042011d0:	c9                   	leaveq 
  80042011d1:	c3                   	retq   

00000080042011d2 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  80042011d2:	55                   	push   %rbp
  80042011d3:	48 89 e5             	mov    %rsp,%rbp
  80042011d6:	48 83 ec 10          	sub    $0x10,%rsp
  80042011da:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  80042011dd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011e0:	89 c7                	mov    %eax,%edi
  80042011e2:	48 b8 22 08 20 04 80 	movabs $0x8004200822,%rax
  80042011e9:	00 00 00 
  80042011ec:	ff d0                	callq  *%rax
	lpt_putc(c);
  80042011ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042011f1:	89 c7                	mov    %eax,%edi
  80042011f3:	48 b8 8f 09 20 04 80 	movabs $0x800420098f,%rax
  80042011fa:	00 00 00 
  80042011fd:	ff d0                	callq  *%rax
	cga_putc(c);
  80042011ff:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201202:	89 c7                	mov    %eax,%edi
  8004201204:	48 b8 2e 0b 20 04 80 	movabs $0x8004200b2e,%rax
  800420120b:	00 00 00 
  800420120e:	ff d0                	callq  *%rax
}
  8004201210:	c9                   	leaveq 
  8004201211:	c3                   	retq   

0000008004201212 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  8004201212:	55                   	push   %rbp
  8004201213:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  8004201216:	48 b8 14 0a 20 04 80 	movabs $0x8004200a14,%rax
  800420121d:	00 00 00 
  8004201220:	ff d0                	callq  *%rax
	kbd_init();
  8004201222:	48 b8 60 10 20 04 80 	movabs $0x8004201060,%rax
  8004201229:	00 00 00 
  800420122c:	ff d0                	callq  *%rax
	serial_init();
  800420122e:	48 b8 87 08 20 04 80 	movabs $0x8004200887,%rax
  8004201235:	00 00 00 
  8004201238:	ff d0                	callq  *%rax

	if (!serial_exists)
  800420123a:	48 b8 00 d0 3a 04 80 	movabs $0x80043ad000,%rax
  8004201241:	00 00 00 
  8004201244:	0f b6 00             	movzbl (%rax),%eax
  8004201247:	83 f0 01             	xor    $0x1,%eax
  800420124a:	84 c0                	test   %al,%al
  800420124c:	74 1b                	je     8004201269 <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  800420124e:	48 bf 12 d3 21 04 80 	movabs $0x800421d312,%rdi
  8004201255:	00 00 00 
  8004201258:	b8 00 00 00 00       	mov    $0x0,%eax
  800420125d:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201264:	00 00 00 
  8004201267:	ff d2                	callq  *%rdx
}
  8004201269:	5d                   	pop    %rbp
  800420126a:	c3                   	retq   

000000800420126b <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  800420126b:	55                   	push   %rbp
  800420126c:	48 89 e5             	mov    %rsp,%rbp
  800420126f:	48 83 ec 10          	sub    $0x10,%rsp
  8004201273:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  8004201276:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201279:	89 c7                	mov    %eax,%edi
  800420127b:	48 b8 d2 11 20 04 80 	movabs $0x80042011d2,%rax
  8004201282:	00 00 00 
  8004201285:	ff d0                	callq  *%rax
}
  8004201287:	c9                   	leaveq 
  8004201288:	c3                   	retq   

0000008004201289 <getchar>:

int
getchar(void)
{
  8004201289:	55                   	push   %rbp
  800420128a:	48 89 e5             	mov    %rsp,%rbp
  800420128d:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  8004201291:	48 b8 1e 11 20 04 80 	movabs $0x800420111e,%rax
  8004201298:	00 00 00 
  800420129b:	ff d0                	callq  *%rax
  800420129d:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042012a0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042012a4:	74 eb                	je     8004201291 <getchar+0x8>
		/* do nothing */;
	return c;
  80042012a6:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042012a9:	c9                   	leaveq 
  80042012aa:	c3                   	retq   

00000080042012ab <iscons>:

int
iscons(int fdnum)
{
  80042012ab:	55                   	push   %rbp
  80042012ac:	48 89 e5             	mov    %rsp,%rbp
  80042012af:	48 83 ec 04          	sub    $0x4,%rsp
  80042012b3:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  80042012b6:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042012bb:	c9                   	leaveq 
  80042012bc:	c3                   	retq   

00000080042012bd <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  80042012bd:	55                   	push   %rbp
  80042012be:	48 89 e5             	mov    %rsp,%rbp
  80042012c1:	48 83 ec 30          	sub    $0x30,%rsp
  80042012c5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042012c8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042012cc:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  80042012d0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042012d7:	eb 6c                	jmp    8004201345 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  80042012d9:	48 b9 80 35 23 04 80 	movabs $0x8004233580,%rcx
  80042012e0:	00 00 00 
  80042012e3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042012e6:	48 63 d0             	movslq %eax,%rdx
  80042012e9:	48 89 d0             	mov    %rdx,%rax
  80042012ec:	48 01 c0             	add    %rax,%rax
  80042012ef:	48 01 d0             	add    %rdx,%rax
  80042012f2:	48 c1 e0 03          	shl    $0x3,%rax
  80042012f6:	48 01 c8             	add    %rcx,%rax
  80042012f9:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042012fd:	48 be 80 35 23 04 80 	movabs $0x8004233580,%rsi
  8004201304:	00 00 00 
  8004201307:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420130a:	48 63 d0             	movslq %eax,%rdx
  800420130d:	48 89 d0             	mov    %rdx,%rax
  8004201310:	48 01 c0             	add    %rax,%rax
  8004201313:	48 01 d0             	add    %rdx,%rax
  8004201316:	48 c1 e0 03          	shl    $0x3,%rax
  800420131a:	48 01 f0             	add    %rsi,%rax
  800420131d:	48 8b 00             	mov    (%rax),%rax
  8004201320:	48 89 ca             	mov    %rcx,%rdx
  8004201323:	48 89 c6             	mov    %rax,%rsi
  8004201326:	48 bf aa d3 21 04 80 	movabs $0x800421d3aa,%rdi
  800420132d:	00 00 00 
  8004201330:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201335:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420133c:	00 00 00 
  800420133f:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201341:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201345:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201348:	83 f8 02             	cmp    $0x2,%eax
  800420134b:	76 8c                	jbe    80042012d9 <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	cprintf("%d",sizeof(int));	
  800420134d:	be 04 00 00 00       	mov    $0x4,%esi
  8004201352:	48 bf b3 d3 21 04 80 	movabs $0x800421d3b3,%rdi
  8004201359:	00 00 00 
  800420135c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201361:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201368:	00 00 00 
  800420136b:	ff d2                	callq  *%rdx
	return 0;
  800420136d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201372:	c9                   	leaveq 
  8004201373:	c3                   	retq   

0000008004201374 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  8004201374:	55                   	push   %rbp
  8004201375:	48 89 e5             	mov    %rsp,%rbp
  8004201378:	48 83 ec 30          	sub    $0x30,%rsp
  800420137c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420137f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201383:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  8004201387:	48 bf b6 d3 21 04 80 	movabs $0x800421d3b6,%rdi
  800420138e:	00 00 00 
  8004201391:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201396:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420139d:	00 00 00 
  80042013a0:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  80042013a2:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  80042013a9:	00 00 00 
  80042013ac:	48 bf d0 d3 21 04 80 	movabs $0x800421d3d0,%rdi
  80042013b3:	00 00 00 
  80042013b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013bb:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042013c2:	00 00 00 
  80042013c5:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  80042013c7:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  80042013ce:	00 00 00 
  80042013d1:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  80042013d8:	00 00 00 
  80042013db:	48 bf f8 d3 21 04 80 	movabs $0x800421d3f8,%rdi
  80042013e2:	00 00 00 
  80042013e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013ea:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  80042013f1:	00 00 00 
  80042013f4:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  80042013f6:	48 ba e6 d1 21 00 00 	movabs $0x21d1e6,%rdx
  80042013fd:	00 00 00 
  8004201400:	48 be e6 d1 21 04 80 	movabs $0x800421d1e6,%rsi
  8004201407:	00 00 00 
  800420140a:	48 bf 20 d4 21 04 80 	movabs $0x800421d420,%rdi
  8004201411:	00 00 00 
  8004201414:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201419:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  8004201420:	00 00 00 
  8004201423:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201425:	48 ba 2c cf 3a 00 00 	movabs $0x3acf2c,%rdx
  800420142c:	00 00 00 
  800420142f:	48 be 2c cf 3a 04 80 	movabs $0x80043acf2c,%rsi
  8004201436:	00 00 00 
  8004201439:	48 bf 48 d4 21 04 80 	movabs $0x800421d448,%rdi
  8004201440:	00 00 00 
  8004201443:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201448:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420144f:	00 00 00 
  8004201452:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201454:	48 ba 10 10 3f 00 00 	movabs $0x3f1010,%rdx
  800420145b:	00 00 00 
  800420145e:	48 be 10 10 3f 04 80 	movabs $0x80043f1010,%rsi
  8004201465:	00 00 00 
  8004201468:	48 bf 70 d4 21 04 80 	movabs $0x800421d470,%rdi
  800420146f:	00 00 00 
  8004201472:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201477:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420147e:	00 00 00 
  8004201481:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  8004201483:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800420148a:	00 
  800420148b:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  8004201492:	00 00 00 
  8004201495:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201499:	48 29 c2             	sub    %rax,%rdx
  800420149c:	48 b8 10 10 3f 04 80 	movabs $0x80043f1010,%rax
  80042014a3:	00 00 00 
  80042014a6:	48 83 e8 01          	sub    $0x1,%rax
  80042014aa:	48 01 d0             	add    %rdx,%rax
  80042014ad:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042014b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042014b5:	ba 00 00 00 00       	mov    $0x0,%edx
  80042014ba:	48 f7 75 f8          	divq   -0x8(%rbp)
  80042014be:	48 89 d0             	mov    %rdx,%rax
  80042014c1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042014c5:	48 29 c2             	sub    %rax,%rdx
  80042014c8:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  80042014cb:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  80042014d2:	48 85 c0             	test   %rax,%rax
  80042014d5:	48 0f 48 c2          	cmovs  %rdx,%rax
  80042014d9:	48 c1 f8 0a          	sar    $0xa,%rax
  80042014dd:	48 89 c6             	mov    %rax,%rsi
  80042014e0:	48 bf 98 d4 21 04 80 	movabs $0x800421d498,%rdi
  80042014e7:	00 00 00 
  80042014ea:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014ef:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042014f6:	00 00 00 
  80042014f9:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  80042014fb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201500:	c9                   	leaveq 
  8004201501:	c3                   	retq   

0000008004201502 <printArgList>:

void printArgList(uint64_t* prbp, struct Ripdebuginfo *info)
{
  8004201502:	55                   	push   %rbp
  8004201503:	48 89 e5             	mov    %rsp,%rbp
  8004201506:	48 83 ec 30          	sub    $0x30,%rsp
  800420150a:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420150e:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t* tprbp = (uint64_t*)(prbp - 4);
  8004201512:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201516:	48 83 e8 20          	sub    $0x20,%rax
  800420151a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	int numberArg = info->rip_fn_narg;
  800420151e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201522:	8b 40 28             	mov    0x28(%rax),%eax
  8004201525:	89 45 f4             	mov    %eax,-0xc(%rbp)
	int i = 0;
  8004201528:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	uint64_t size = 0;
  800420152f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004201536:	00 
	if(numberArg <= 0)
  8004201537:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420153b:	7f 20                	jg     800420155d <printArgList+0x5b>
	{
		cprintf("\n");
  800420153d:	48 bf c2 d4 21 04 80 	movabs $0x800421d4c2,%rdi
  8004201544:	00 00 00 
  8004201547:	b8 00 00 00 00       	mov    $0x0,%eax
  800420154c:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201553:	00 00 00 
  8004201556:	ff d2                	callq  *%rdx
		return;
  8004201558:	e9 0f 01 00 00       	jmpq   800420166c <printArgList+0x16a>
	}
	
	while(numberArg > 0)
  800420155d:	e9 e5 00 00 00       	jmpq   8004201647 <printArgList+0x145>
	{
		//cprintf("size of argument %d is %d %x",i, info->size_fn_arg[i],*prbp);
		size = info->size_fn_arg[i];
  8004201562:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201566:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004201569:	48 63 d2             	movslq %edx,%rdx
  800420156c:	48 83 c2 08          	add    $0x8,%rdx
  8004201570:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  8004201574:	48 98                	cltq   
  8004201576:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		cprintf(" ");
  800420157a:	48 bf c4 d4 21 04 80 	movabs $0x800421d4c4,%rdi
  8004201581:	00 00 00 
  8004201584:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201589:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201590:	00 00 00 
  8004201593:	ff d2                	callq  *%rdx
		switch(size)
  8004201595:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201599:	48 83 f8 04          	cmp    $0x4,%rax
  800420159d:	74 43                	je     80042015e2 <printArgList+0xe0>
  800420159f:	48 83 f8 08          	cmp    $0x8,%rax
  80042015a3:	74 6b                	je     8004201610 <printArgList+0x10e>
  80042015a5:	48 83 f8 01          	cmp    $0x1,%rax
  80042015a9:	74 05                	je     80042015b0 <printArgList+0xae>
			case 8:
				cprintf("%016x",*(tprbp -1));
				tprbp = tprbp - 1;
				break;
			default:
				break;
  80042015ab:	e9 8f 00 00 00       	jmpq   800420163f <printArgList+0x13d>
		size = info->size_fn_arg[i];
		cprintf(" ");
		switch(size)
		{
			case 1:
				cprintf("%016x",*((char*)tprbp -1));
  80042015b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042015b4:	48 83 e8 01          	sub    $0x1,%rax
  80042015b8:	0f b6 00             	movzbl (%rax),%eax
  80042015bb:	0f be c0             	movsbl %al,%eax
  80042015be:	89 c6                	mov    %eax,%esi
  80042015c0:	48 bf c6 d4 21 04 80 	movabs $0x800421d4c6,%rdi
  80042015c7:	00 00 00 
  80042015ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015cf:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042015d6:	00 00 00 
  80042015d9:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((char*)tprbp - 1);
  80042015db:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
				break;
  80042015e0:	eb 5d                	jmp    800420163f <printArgList+0x13d>
			case 4:
				cprintf("%016x",*((int*)tprbp -1));
  80042015e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042015e6:	48 83 e8 04          	sub    $0x4,%rax
  80042015ea:	8b 00                	mov    (%rax),%eax
  80042015ec:	89 c6                	mov    %eax,%esi
  80042015ee:	48 bf c6 d4 21 04 80 	movabs $0x800421d4c6,%rdi
  80042015f5:	00 00 00 
  80042015f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015fd:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201604:	00 00 00 
  8004201607:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((int*)tprbp - 1);
  8004201609:	48 83 6d f8 04       	subq   $0x4,-0x8(%rbp)
				break;
  800420160e:	eb 2f                	jmp    800420163f <printArgList+0x13d>
			case 8:
				cprintf("%016x",*(tprbp -1));
  8004201610:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201614:	48 83 e8 08          	sub    $0x8,%rax
  8004201618:	48 8b 00             	mov    (%rax),%rax
  800420161b:	48 89 c6             	mov    %rax,%rsi
  800420161e:	48 bf c6 d4 21 04 80 	movabs $0x800421d4c6,%rdi
  8004201625:	00 00 00 
  8004201628:	b8 00 00 00 00       	mov    $0x0,%eax
  800420162d:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201634:	00 00 00 
  8004201637:	ff d2                	callq  *%rdx
				tprbp = tprbp - 1;
  8004201639:	48 83 6d f8 08       	subq   $0x8,-0x8(%rbp)
				break;
  800420163e:	90                   	nop
			default:
				break;
		}
		i++;
  800420163f:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
		numberArg--;
  8004201643:	83 6d f4 01          	subl   $0x1,-0xc(%rbp)
	{
		cprintf("\n");
		return;
	}
	
	while(numberArg > 0)
  8004201647:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420164b:	0f 8f 11 ff ff ff    	jg     8004201562 <printArgList+0x60>
				break;
		}
		i++;
		numberArg--;
	}
	cprintf("\n");
  8004201651:	48 bf c2 d4 21 04 80 	movabs $0x800421d4c2,%rdi
  8004201658:	00 00 00 
  800420165b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201660:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201667:	00 00 00 
  800420166a:	ff d2                	callq  *%rdx
}
  800420166c:	c9                   	leaveq 
  800420166d:	c3                   	retq   

000000800420166e <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  800420166e:	55                   	push   %rbp
  800420166f:	48 89 e5             	mov    %rsp,%rbp
  8004201672:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004201679:	89 bd fc fa ff ff    	mov    %edi,-0x504(%rbp)
  800420167f:	48 89 b5 f0 fa ff ff 	mov    %rsi,-0x510(%rbp)
  8004201686:	48 89 95 e8 fa ff ff 	mov    %rdx,-0x518(%rbp)
	// Your code here.
	uint64_t rbp = 0x0;
  800420168d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004201694:	00 
	uint64_t rip = 0x0;
  8004201695:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420169c:	00 
	uint64_t* prbp = NULL;
  800420169d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042016a4:	00 

	struct Ripdebuginfo info;

	cprintf("Stack backtrace:\n");
  80042016a5:	48 bf cc d4 21 04 80 	movabs $0x800421d4cc,%rdi
  80042016ac:	00 00 00 
  80042016af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016b4:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042016bb:	00 00 00 
  80042016be:	ff d2                	callq  *%rdx

    static __inline uint64_t
read_rbp(void)
{
    uint64_t rbp;
    __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  80042016c0:	48 89 e8             	mov    %rbp,%rax
  80042016c3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    return rbp;
  80042016c7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	rbp = read_rbp();
  80042016cb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	read_rip(rip);
  80042016cf:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 80042016d6 <mon_backtrace+0x68>
  80042016d6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(rbp == 0x0 || rip == 0x0)
  80042016da:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042016df:	74 07                	je     80042016e8 <mon_backtrace+0x7a>
  80042016e1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042016e6:	75 25                	jne    800420170d <mon_backtrace+0x9f>
	{
		cprintf("Not able to show backtrace");
  80042016e8:	48 bf de d4 21 04 80 	movabs $0x800421d4de,%rdi
  80042016ef:	00 00 00 
  80042016f2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016f7:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042016fe:	00 00 00 
  8004201701:	ff d2                	callq  *%rdx
		return -1;
  8004201703:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004201708:	e9 2c 02 00 00       	jmpq   8004201939 <mon_backtrace+0x2cb>
	}
	prbp = (uint64_t*)(rbp);
  800420170d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201711:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("    rbp %016x  rip %016x\n", prbp, rip);
  8004201715:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201719:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420171d:	48 89 c6             	mov    %rax,%rsi
  8004201720:	48 bf f9 d4 21 04 80 	movabs $0x800421d4f9,%rdi
  8004201727:	00 00 00 
  800420172a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420172f:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  8004201736:	00 00 00 
  8004201739:	ff d1                	callq  *%rcx
	debuginfo_rip(rip ,&info);
  800420173b:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201742:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201746:	48 89 d6             	mov    %rdx,%rsi
  8004201749:	48 89 c7             	mov    %rax,%rdi
  800420174c:	48 b8 f8 f7 20 04 80 	movabs $0x800420f7f8,%rax
  8004201753:	00 00 00 
  8004201756:	ff d0                	callq  *%rax
	
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  8004201758:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  800420175e:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  8004201765:	48 89 c6             	mov    %rax,%rsi
  8004201768:	48 bf 13 d5 21 04 80 	movabs $0x800421d513,%rdi
  800420176f:	00 00 00 
  8004201772:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201777:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420177e:	00 00 00 
  8004201781:	ff d1                	callq  *%rcx
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  8004201783:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  800420178a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420178e:	48 89 d1             	mov    %rdx,%rcx
  8004201791:	48 29 c1             	sub    %rax,%rcx
  8004201794:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  800420179b:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  80042017a1:	89 c6                	mov    %eax,%esi
  80042017a3:	48 bf 23 d5 21 04 80 	movabs $0x800421d523,%rdi
  80042017aa:	00 00 00 
  80042017ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017b2:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  80042017b9:	00 00 00 
  80042017bc:	41 ff d0             	callq  *%r8
	cprintf(" args:%d", info.rip_fn_narg);
  80042017bf:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042017c5:	89 c6                	mov    %eax,%esi
  80042017c7:	48 bf 2e d5 21 04 80 	movabs $0x800421d52e,%rdi
  80042017ce:	00 00 00 
  80042017d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017d6:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042017dd:	00 00 00 
  80042017e0:	ff d2                	callq  *%rdx
	printArgList(prbp, &info);
  80042017e2:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  80042017e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042017ed:	48 89 d6             	mov    %rdx,%rsi
  80042017f0:	48 89 c7             	mov    %rax,%rdi
  80042017f3:	48 b8 02 15 20 04 80 	movabs $0x8004201502,%rax
  80042017fa:	00 00 00 
  80042017fd:	ff d0                	callq  *%rax

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  80042017ff:	e9 09 01 00 00       	jmpq   800420190d <mon_backtrace+0x29f>
	{
		cprintf("    rbp %016x  rip %016x\n",*(prbp),*((prbp) +1));
  8004201804:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201808:	48 83 c0 08          	add    $0x8,%rax
  800420180c:	48 8b 10             	mov    (%rax),%rdx
  800420180f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201813:	48 8b 00             	mov    (%rax),%rax
  8004201816:	48 89 c6             	mov    %rax,%rsi
  8004201819:	48 bf f9 d4 21 04 80 	movabs $0x800421d4f9,%rdi
  8004201820:	00 00 00 
  8004201823:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201828:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420182f:	00 00 00 
  8004201832:	ff d1                	callq  *%rcx
		debuginfo_rip(*(prbp+1) ,&info);
  8004201834:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201838:	48 83 c0 08          	add    $0x8,%rax
  800420183c:	48 8b 00             	mov    (%rax),%rax
  800420183f:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201846:	48 89 d6             	mov    %rdx,%rsi
  8004201849:	48 89 c7             	mov    %rax,%rdi
  800420184c:	48 b8 f8 f7 20 04 80 	movabs $0x800420f7f8,%rax
  8004201853:	00 00 00 
  8004201856:	ff d0                	callq  *%rax

		cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  8004201858:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  800420185e:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  8004201865:	48 89 c6             	mov    %rax,%rsi
  8004201868:	48 bf 13 d5 21 04 80 	movabs $0x800421d513,%rdi
  800420186f:	00 00 00 
  8004201872:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201877:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420187e:	00 00 00 
  8004201881:	ff d1                	callq  *%rcx
		cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  8004201883:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  800420188a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420188e:	48 89 d1             	mov    %rdx,%rcx
  8004201891:	48 29 c1             	sub    %rax,%rcx
  8004201894:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  800420189b:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  80042018a1:	89 c6                	mov    %eax,%esi
  80042018a3:	48 bf 23 d5 21 04 80 	movabs $0x800421d523,%rdi
  80042018aa:	00 00 00 
  80042018ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018b2:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  80042018b9:	00 00 00 
  80042018bc:	41 ff d0             	callq  *%r8
		cprintf(" args:%d", info.rip_fn_narg);
  80042018bf:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  80042018c5:	89 c6                	mov    %eax,%esi
  80042018c7:	48 bf 2e d5 21 04 80 	movabs $0x800421d52e,%rdi
  80042018ce:	00 00 00 
  80042018d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018d6:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042018dd:	00 00 00 
  80042018e0:	ff d2                	callq  *%rdx
		printArgList((uint64_t*)(*(prbp)), &info);
  80042018e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042018e6:	48 8b 00             	mov    (%rax),%rax
  80042018e9:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  80042018f0:	48 89 d6             	mov    %rdx,%rsi
  80042018f3:	48 89 c7             	mov    %rax,%rdi
  80042018f6:	48 b8 02 15 20 04 80 	movabs $0x8004201502,%rax
  80042018fd:	00 00 00 
  8004201900:	ff d0                	callq  *%rax
		
		prbp = (uint64_t*)(*(prbp)); 
  8004201902:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201906:	48 8b 00             	mov    (%rax),%rax
  8004201909:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
	cprintf(" args:%d", info.rip_fn_narg);
	printArgList(prbp, &info);

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  800420190d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201912:	74 20                	je     8004201934 <mon_backtrace+0x2c6>
  8004201914:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201918:	48 8b 00             	mov    (%rax),%rax
  800420191b:	48 85 c0             	test   %rax,%rax
  800420191e:	74 14                	je     8004201934 <mon_backtrace+0x2c6>
  8004201920:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201924:	48 83 c0 08          	add    $0x8,%rax
  8004201928:	48 8b 00             	mov    (%rax),%rax
  800420192b:	48 85 c0             	test   %rax,%rax
  800420192e:	0f 85 d0 fe ff ff    	jne    8004201804 <mon_backtrace+0x196>
		cprintf(" args:%d", info.rip_fn_narg);
		printArgList((uint64_t*)(*(prbp)), &info);
		
		prbp = (uint64_t*)(*(prbp)); 
	}
	return 0;
  8004201934:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201939:	c9                   	leaveq 
  800420193a:	c3                   	retq   

000000800420193b <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  800420193b:	55                   	push   %rbp
  800420193c:	48 89 e5             	mov    %rsp,%rbp
  800420193f:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201946:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  800420194d:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201954:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  800420195b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420195e:	48 98                	cltq   
  8004201960:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201967:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  800420196c:	eb 15                	jmp    8004201983 <runcmd+0x48>
			*buf++ = 0;
  800420196e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201975:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004201979:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  8004201980:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201983:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420198a:	0f b6 00             	movzbl (%rax),%eax
  800420198d:	84 c0                	test   %al,%al
  800420198f:	74 2a                	je     80042019bb <runcmd+0x80>
  8004201991:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201998:	0f b6 00             	movzbl (%rax),%eax
  800420199b:	0f be c0             	movsbl %al,%eax
  800420199e:	89 c6                	mov    %eax,%esi
  80042019a0:	48 bf 37 d5 21 04 80 	movabs $0x800421d537,%rdi
  80042019a7:	00 00 00 
  80042019aa:	48 b8 19 0b 21 04 80 	movabs $0x8004210b19,%rax
  80042019b1:	00 00 00 
  80042019b4:	ff d0                	callq  *%rax
  80042019b6:	48 85 c0             	test   %rax,%rax
  80042019b9:	75 b3                	jne    800420196e <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  80042019bb:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042019c2:	0f b6 00             	movzbl (%rax),%eax
  80042019c5:	84 c0                	test   %al,%al
  80042019c7:	75 21                	jne    80042019ea <runcmd+0xaf>
			break;
  80042019c9:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  80042019ca:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042019cd:	48 98                	cltq   
  80042019cf:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  80042019d6:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  80042019db:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042019df:	0f 85 a1 00 00 00    	jne    8004201a86 <runcmd+0x14b>
  80042019e5:	e9 92 00 00 00       	jmpq   8004201a7c <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  80042019ea:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  80042019ee:	75 2a                	jne    8004201a1a <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  80042019f0:	be 10 00 00 00       	mov    $0x10,%esi
  80042019f5:	48 bf 3c d5 21 04 80 	movabs $0x800421d53c,%rdi
  80042019fc:	00 00 00 
  80042019ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a04:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201a0b:	00 00 00 
  8004201a0e:	ff d2                	callq  *%rdx
			return 0;
  8004201a10:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a15:	e9 30 01 00 00       	jmpq   8004201b4a <runcmd+0x20f>
		}
		argv[argc++] = buf;
  8004201a1a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201a1d:	8d 50 01             	lea    0x1(%rax),%edx
  8004201a20:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201a23:	48 98                	cltq   
  8004201a25:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201a2c:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201a33:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a34:	eb 08                	jmp    8004201a3e <runcmd+0x103>
			buf++;
  8004201a36:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201a3d:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201a3e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a45:	0f b6 00             	movzbl (%rax),%eax
  8004201a48:	84 c0                	test   %al,%al
  8004201a4a:	74 2a                	je     8004201a76 <runcmd+0x13b>
  8004201a4c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201a53:	0f b6 00             	movzbl (%rax),%eax
  8004201a56:	0f be c0             	movsbl %al,%eax
  8004201a59:	89 c6                	mov    %eax,%esi
  8004201a5b:	48 bf 37 d5 21 04 80 	movabs $0x800421d537,%rdi
  8004201a62:	00 00 00 
  8004201a65:	48 b8 19 0b 21 04 80 	movabs $0x8004210b19,%rax
  8004201a6c:	00 00 00 
  8004201a6f:	ff d0                	callq  *%rax
  8004201a71:	48 85 c0             	test   %rax,%rax
  8004201a74:	74 c0                	je     8004201a36 <runcmd+0xfb>
			buf++;
	}
  8004201a76:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201a77:	e9 07 ff ff ff       	jmpq   8004201983 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  8004201a7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a81:	e9 c4 00 00 00       	jmpq   8004201b4a <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201a86:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201a8d:	e9 82 00 00 00       	jmpq   8004201b14 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201a92:	48 b9 80 35 23 04 80 	movabs $0x8004233580,%rcx
  8004201a99:	00 00 00 
  8004201a9c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201a9f:	48 63 d0             	movslq %eax,%rdx
  8004201aa2:	48 89 d0             	mov    %rdx,%rax
  8004201aa5:	48 01 c0             	add    %rax,%rax
  8004201aa8:	48 01 d0             	add    %rdx,%rax
  8004201aab:	48 c1 e0 03          	shl    $0x3,%rax
  8004201aaf:	48 01 c8             	add    %rcx,%rax
  8004201ab2:	48 8b 10             	mov    (%rax),%rdx
  8004201ab5:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201abc:	48 89 d6             	mov    %rdx,%rsi
  8004201abf:	48 89 c7             	mov    %rax,%rdi
  8004201ac2:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  8004201ac9:	00 00 00 
  8004201acc:	ff d0                	callq  *%rax
  8004201ace:	85 c0                	test   %eax,%eax
  8004201ad0:	75 3e                	jne    8004201b10 <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004201ad2:	48 b9 80 35 23 04 80 	movabs $0x8004233580,%rcx
  8004201ad9:	00 00 00 
  8004201adc:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201adf:	48 63 d0             	movslq %eax,%rdx
  8004201ae2:	48 89 d0             	mov    %rdx,%rax
  8004201ae5:	48 01 c0             	add    %rax,%rax
  8004201ae8:	48 01 d0             	add    %rdx,%rax
  8004201aeb:	48 c1 e0 03          	shl    $0x3,%rax
  8004201aef:	48 01 c8             	add    %rcx,%rax
  8004201af2:	48 83 c0 10          	add    $0x10,%rax
  8004201af6:	48 8b 00             	mov    (%rax),%rax
  8004201af9:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201b00:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201b07:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201b0a:	89 cf                	mov    %ecx,%edi
  8004201b0c:	ff d0                	callq  *%rax
  8004201b0e:	eb 3a                	jmp    8004201b4a <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201b10:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201b14:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201b17:	83 f8 02             	cmp    $0x2,%eax
  8004201b1a:	0f 86 72 ff ff ff    	jbe    8004201a92 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201b20:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201b27:	48 89 c6             	mov    %rax,%rsi
  8004201b2a:	48 bf 59 d5 21 04 80 	movabs $0x800421d559,%rdi
  8004201b31:	00 00 00 
  8004201b34:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b39:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201b40:	00 00 00 
  8004201b43:	ff d2                	callq  *%rdx
	return 0;
  8004201b45:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201b4a:	c9                   	leaveq 
  8004201b4b:	c3                   	retq   

0000008004201b4c <monitor>:

void
monitor(struct Trapframe *tf)
{
  8004201b4c:	55                   	push   %rbp
  8004201b4d:	48 89 e5             	mov    %rsp,%rbp
  8004201b50:	48 83 ec 20          	sub    $0x20,%rsp
  8004201b54:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201b58:	48 bf 70 d5 21 04 80 	movabs $0x800421d570,%rdi
  8004201b5f:	00 00 00 
  8004201b62:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b67:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201b6e:	00 00 00 
  8004201b71:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201b73:	48 bf 98 d5 21 04 80 	movabs $0x800421d598,%rdi
  8004201b7a:	00 00 00 
  8004201b7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b82:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201b89:	00 00 00 
  8004201b8c:	ff d2                	callq  *%rdx

	if (tf != NULL)
  8004201b8e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201b93:	74 13                	je     8004201ba8 <monitor+0x5c>
		print_trapframe(tf);
  8004201b95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201b99:	48 89 c7             	mov    %rax,%rdi
  8004201b9c:	48 b8 10 c6 20 04 80 	movabs $0x800420c610,%rax
  8004201ba3:	00 00 00 
  8004201ba6:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  8004201ba8:	48 bf bd d5 21 04 80 	movabs $0x800421d5bd,%rdi
  8004201baf:	00 00 00 
  8004201bb2:	48 b8 32 07 21 04 80 	movabs $0x8004210732,%rax
  8004201bb9:	00 00 00 
  8004201bbc:	ff d0                	callq  *%rax
  8004201bbe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201bc2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201bc7:	74 20                	je     8004201be9 <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  8004201bc9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201bcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201bd1:	48 89 d6             	mov    %rdx,%rsi
  8004201bd4:	48 89 c7             	mov    %rax,%rdi
  8004201bd7:	48 b8 3b 19 20 04 80 	movabs $0x800420193b,%rax
  8004201bde:	00 00 00 
  8004201be1:	ff d0                	callq  *%rax
  8004201be3:	85 c0                	test   %eax,%eax
  8004201be5:	79 02                	jns    8004201be9 <monitor+0x9d>
				break;
  8004201be7:	eb 02                	jmp    8004201beb <monitor+0x9f>
	}
  8004201be9:	eb bd                	jmp    8004201ba8 <monitor+0x5c>
}
  8004201beb:	c9                   	leaveq 
  8004201bec:	c3                   	retq   

0000008004201bed <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004201bed:	55                   	push   %rbp
  8004201bee:	48 89 e5             	mov    %rsp,%rbp
  8004201bf1:	48 83 ec 08          	sub    $0x8,%rsp
  8004201bf5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201bf9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201bfd:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004201c04:	00 00 00 
  8004201c07:	48 8b 00             	mov    (%rax),%rax
  8004201c0a:	48 29 c2             	sub    %rax,%rdx
  8004201c0d:	48 89 d0             	mov    %rdx,%rax
  8004201c10:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201c14:	c9                   	leaveq 
  8004201c15:	c3                   	retq   

0000008004201c16 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201c16:	55                   	push   %rbp
  8004201c17:	48 89 e5             	mov    %rsp,%rbp
  8004201c1a:	48 83 ec 08          	sub    $0x8,%rsp
  8004201c1e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201c22:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c26:	48 89 c7             	mov    %rax,%rdi
  8004201c29:	48 b8 ed 1b 20 04 80 	movabs $0x8004201bed,%rax
  8004201c30:	00 00 00 
  8004201c33:	ff d0                	callq  *%rax
  8004201c35:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201c39:	c9                   	leaveq 
  8004201c3a:	c3                   	retq   

0000008004201c3b <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201c3b:	55                   	push   %rbp
  8004201c3c:	48 89 e5             	mov    %rsp,%rbp
  8004201c3f:	48 83 ec 10          	sub    $0x10,%rsp
  8004201c43:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201c47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201c4b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201c4f:	48 89 c2             	mov    %rax,%rdx
  8004201c52:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004201c59:	00 00 00 
  8004201c5c:	48 8b 00             	mov    (%rax),%rax
  8004201c5f:	48 39 c2             	cmp    %rax,%rdx
  8004201c62:	72 2a                	jb     8004201c8e <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201c64:	48 ba c8 d5 21 04 80 	movabs $0x800421d5c8,%rdx
  8004201c6b:	00 00 00 
  8004201c6e:	be 54 00 00 00       	mov    $0x54,%esi
  8004201c73:	48 bf e7 d5 21 04 80 	movabs $0x800421d5e7,%rdi
  8004201c7a:	00 00 00 
  8004201c7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c82:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  8004201c89:	00 00 00 
  8004201c8c:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201c8e:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004201c95:	00 00 00 
  8004201c98:	48 8b 00             	mov    (%rax),%rax
  8004201c9b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201c9f:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201ca3:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201ca7:	48 01 d0             	add    %rdx,%rax
}
  8004201caa:	c9                   	leaveq 
  8004201cab:	c3                   	retq   

0000008004201cac <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201cac:	55                   	push   %rbp
  8004201cad:	48 89 e5             	mov    %rsp,%rbp
  8004201cb0:	48 83 ec 20          	sub    $0x20,%rsp
  8004201cb4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201cb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201cbc:	48 89 c7             	mov    %rax,%rdi
  8004201cbf:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004201cc6:	00 00 00 
  8004201cc9:	ff d0                	callq  *%rax
  8004201ccb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201ccf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cd3:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201cd7:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201cda:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201cdd:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004201ce4:	00 00 00 
  8004201ce7:	48 8b 00             	mov    (%rax),%rax
  8004201cea:	48 39 c2             	cmp    %rax,%rdx
  8004201ced:	72 32                	jb     8004201d21 <page2kva+0x75>
  8004201cef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201cf3:	48 89 c1             	mov    %rax,%rcx
  8004201cf6:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004201cfd:	00 00 00 
  8004201d00:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004201d05:	48 bf e7 d5 21 04 80 	movabs $0x800421d5e7,%rdi
  8004201d0c:	00 00 00 
  8004201d0f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201d14:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004201d1b:	00 00 00 
  8004201d1e:	41 ff d0             	callq  *%r8
  8004201d21:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201d28:	00 00 00 
  8004201d2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d2f:	48 01 d0             	add    %rdx,%rax
}
  8004201d32:	c9                   	leaveq 
  8004201d33:	c3                   	retq   

0000008004201d34 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201d34:	55                   	push   %rbp
  8004201d35:	48 89 e5             	mov    %rsp,%rbp
  8004201d38:	48 83 ec 08          	sub    $0x8,%rsp
  8004201d3c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201d3f:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201d42:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201d46:	74 06                	je     8004201d4e <restrictive_type+0x1a>
  8004201d48:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201d4c:	75 07                	jne    8004201d55 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201d4e:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201d53:	eb 3e                	jmp    8004201d93 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201d55:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201d59:	74 06                	je     8004201d61 <restrictive_type+0x2d>
  8004201d5b:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201d5f:	75 07                	jne    8004201d68 <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201d61:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201d66:	eb 2b                	jmp    8004201d93 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201d68:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201d6c:	74 06                	je     8004201d74 <restrictive_type+0x40>
  8004201d6e:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201d72:	75 07                	jne    8004201d7b <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201d74:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201d79:	eb 18                	jmp    8004201d93 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201d7b:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201d7f:	74 06                	je     8004201d87 <restrictive_type+0x53>
  8004201d81:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201d85:	75 07                	jne    8004201d8e <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201d87:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201d8c:	eb 05                	jmp    8004201d93 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201d8e:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201d93:	c9                   	leaveq 
  8004201d94:	c3                   	retq   

0000008004201d95 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201d95:	55                   	push   %rbp
  8004201d96:	48 89 e5             	mov    %rsp,%rbp
  8004201d99:	53                   	push   %rbx
  8004201d9a:	48 83 ec 18          	sub    $0x18,%rsp
  8004201d9e:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201da1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201da4:	89 c7                	mov    %eax,%edi
  8004201da6:	48 b8 9e 92 20 04 80 	movabs $0x800420929e,%rax
  8004201dad:	00 00 00 
  8004201db0:	ff d0                	callq  *%rax
  8004201db2:	89 c3                	mov    %eax,%ebx
  8004201db4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201db7:	83 c0 01             	add    $0x1,%eax
  8004201dba:	89 c7                	mov    %eax,%edi
  8004201dbc:	48 b8 9e 92 20 04 80 	movabs $0x800420929e,%rax
  8004201dc3:	00 00 00 
  8004201dc6:	ff d0                	callq  *%rax
  8004201dc8:	c1 e0 08             	shl    $0x8,%eax
  8004201dcb:	09 d8                	or     %ebx,%eax
}
  8004201dcd:	48 83 c4 18          	add    $0x18,%rsp
  8004201dd1:	5b                   	pop    %rbx
  8004201dd2:	5d                   	pop    %rbp
  8004201dd3:	c3                   	retq   

0000008004201dd4 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201dd4:	55                   	push   %rbp
  8004201dd5:	48 89 e5             	mov    %rsp,%rbp
  8004201dd8:	41 54                	push   %r12
  8004201dda:	53                   	push   %rbx
  8004201ddb:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004201de2:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201de9:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201df0:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201df7:	48 89 e0             	mov    %rsp,%rax
  8004201dfa:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201dfd:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201e04:	8b 40 30             	mov    0x30(%rax),%eax
  8004201e07:	89 c0                	mov    %eax,%eax
  8004201e09:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201e0d:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201e14:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201e17:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201e1c:	f7 e2                	mul    %edx
  8004201e1e:	89 d0                	mov    %edx,%eax
  8004201e20:	c1 e8 04             	shr    $0x4,%eax
  8004201e23:	89 c0                	mov    %eax,%eax
  8004201e25:	48 89 c2             	mov    %rax,%rdx
  8004201e28:	48 83 ea 01          	sub    $0x1,%rdx
  8004201e2c:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201e30:	49 89 c0             	mov    %rax,%r8
  8004201e33:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201e39:	48 89 c1             	mov    %rax,%rcx
  8004201e3c:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004201e41:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e45:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201e49:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201e4e:	48 83 e8 01          	sub    $0x1,%rax
  8004201e52:	48 01 d0             	add    %rdx,%rax
  8004201e55:	bb 10 00 00 00       	mov    $0x10,%ebx
  8004201e5a:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201e5f:	48 f7 f3             	div    %rbx
  8004201e62:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201e66:	48 29 c4             	sub    %rax,%rsp
  8004201e69:	48 89 e0             	mov    %rsp,%rax
  8004201e6c:	48 83 c0 07          	add    $0x7,%rax
  8004201e70:	48 c1 e8 03          	shr    $0x3,%rax
  8004201e74:	48 c1 e0 03          	shl    $0x3,%rax
  8004201e78:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201e7c:	48 bf 1b d6 21 04 80 	movabs $0x800421d61b,%rdi
  8004201e83:	00 00 00 
  8004201e86:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e8b:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004201e92:	00 00 00 
  8004201e95:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201e97:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201e9e:	e9 6c 01 00 00       	jmpq   800420200f <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004201ea3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ea6:	48 63 d0             	movslq %eax,%rdx
  8004201ea9:	48 89 d0             	mov    %rdx,%rax
  8004201eac:	48 01 c0             	add    %rax,%rax
  8004201eaf:	48 01 d0             	add    %rdx,%rax
  8004201eb2:	48 c1 e0 03          	shl    $0x3,%rax
  8004201eb6:	48 89 c2             	mov    %rax,%rdx
  8004201eb9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004201ebd:	48 01 d0             	add    %rdx,%rax
  8004201ec0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004201ec4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ec8:	8b 40 08             	mov    0x8(%rax),%eax
  8004201ecb:	89 c0                	mov    %eax,%eax
  8004201ecd:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ed1:	48 89 c2             	mov    %rax,%rdx
  8004201ed4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ed8:	8b 40 04             	mov    0x4(%rax),%eax
  8004201edb:	89 c0                	mov    %eax,%eax
  8004201edd:	48 01 d0             	add    %rdx,%rax
  8004201ee0:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004201ee4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ee8:	8b 40 10             	mov    0x10(%rax),%eax
  8004201eeb:	89 c0                	mov    %eax,%eax
  8004201eed:	48 c1 e0 20          	shl    $0x20,%rax
  8004201ef1:	48 89 c2             	mov    %rax,%rdx
  8004201ef4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201ef8:	8b 40 0c             	mov    0xc(%rax),%eax
  8004201efb:	89 c0                	mov    %eax,%eax
  8004201efd:	48 01 d0             	add    %rdx,%rax
  8004201f00:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004201f04:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f08:	8b 70 14             	mov    0x14(%rax),%esi
  8004201f0b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f0f:	8b 00                	mov    (%rax),%eax
  8004201f11:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004201f15:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004201f19:	41 89 f0             	mov    %esi,%r8d
  8004201f1c:	89 c6                	mov    %eax,%esi
  8004201f1e:	48 bf 30 d6 21 04 80 	movabs $0x800421d630,%rdi
  8004201f25:	00 00 00 
  8004201f28:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201f2d:	49 b9 1a 96 20 04 80 	movabs $0x800420961a,%r9
  8004201f34:	00 00 00 
  8004201f37:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  8004201f3a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f3e:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f41:	83 f8 05             	cmp    $0x5,%eax
  8004201f44:	77 0b                	ja     8004201f51 <multiboot_read+0x17d>
  8004201f46:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f4a:	8b 40 14             	mov    0x14(%rax),%eax
  8004201f4d:	85 c0                	test   %eax,%eax
  8004201f4f:	75 0b                	jne    8004201f5c <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004201f51:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004201f55:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  8004201f5c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  8004201f63:	e9 85 00 00 00       	jmpq   8004201fed <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  8004201f68:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201f6c:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004201f6f:	48 63 d2             	movslq %edx,%rdx
  8004201f72:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004201f76:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004201f7a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f7e:	8b 40 08             	mov    0x8(%rax),%eax
  8004201f81:	89 c0                	mov    %eax,%eax
  8004201f83:	48 c1 e0 20          	shl    $0x20,%rax
  8004201f87:	48 89 c2             	mov    %rax,%rdx
  8004201f8a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004201f8e:	8b 40 04             	mov    0x4(%rax),%eax
  8004201f91:	89 c0                	mov    %eax,%eax
  8004201f93:	48 01 d0             	add    %rdx,%rax
  8004201f96:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  8004201f9a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004201f9e:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004201fa2:	76 45                	jbe    8004201fe9 <multiboot_read+0x215>
				int last = i+1;
  8004201fa4:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201fa7:	83 c0 01             	add    $0x1,%eax
  8004201faa:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  8004201fad:	eb 30                	jmp    8004201fdf <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  8004201faf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fb3:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004201fb6:	48 63 d2             	movslq %edx,%rdx
  8004201fb9:	48 c1 e2 03          	shl    $0x3,%rdx
  8004201fbd:	48 01 c2             	add    %rax,%rdx
  8004201fc0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201fc4:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004201fc7:	48 63 c9             	movslq %ecx,%rcx
  8004201fca:	48 c1 e1 03          	shl    $0x3,%rcx
  8004201fce:	48 83 e9 08          	sub    $0x8,%rcx
  8004201fd2:	48 01 c8             	add    %rcx,%rax
  8004201fd5:	48 8b 00             	mov    (%rax),%rax
  8004201fd8:	48 89 02             	mov    %rax,(%rdx)
					last--;
  8004201fdb:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004201fdf:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004201fe2:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004201fe5:	75 c8                	jne    8004201faf <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  8004201fe7:	eb 10                	jmp    8004201ff9 <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  8004201fe9:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004201fed:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004201ff0:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004201ff3:	0f 8c 6f ff ff ff    	jl     8004201f68 <multiboot_read+0x194>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  8004201ff9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004201ffd:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004202000:	48 63 d2             	movslq %edx,%rdx
  8004202003:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004202007:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420200b:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  800420200f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202012:	48 63 c8             	movslq %eax,%rcx
  8004202015:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420201c:	8b 40 2c             	mov    0x2c(%rax),%eax
  800420201f:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202024:	f7 e2                	mul    %edx
  8004202026:	89 d0                	mov    %edx,%eax
  8004202028:	c1 e8 04             	shr    $0x4,%eax
  800420202b:	89 c0                	mov    %eax,%eax
  800420202d:	48 39 c1             	cmp    %rax,%rcx
  8004202030:	0f 82 6d fe ff ff    	jb     8004201ea3 <multiboot_read+0xcf>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  8004202036:	48 bf 67 d6 21 04 80 	movabs $0x800421d667,%rdi
  800420203d:	00 00 00 
  8004202040:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202045:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420204c:	00 00 00 
  800420204f:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202051:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  8004202058:	e9 93 01 00 00       	jmpq   80042021f0 <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  800420205d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202060:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202063:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202067:	48 63 d2             	movslq %edx,%rdx
  800420206a:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420206e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  8004202072:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202076:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004202079:	48 63 d2             	movslq %edx,%rdx
  800420207c:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202080:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  8004202084:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202088:	8b 40 08             	mov    0x8(%rax),%eax
  800420208b:	89 c0                	mov    %eax,%eax
  800420208d:	48 c1 e0 20          	shl    $0x20,%rax
  8004202091:	48 89 c2             	mov    %rax,%rdx
  8004202094:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202098:	8b 40 04             	mov    0x4(%rax),%eax
  800420209b:	89 c0                	mov    %eax,%eax
  800420209d:	48 01 d0             	add    %rdx,%rax
  80042020a0:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  80042020a4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020a8:	8b 40 08             	mov    0x8(%rax),%eax
  80042020ab:	89 c0                	mov    %eax,%eax
  80042020ad:	48 c1 e0 20          	shl    $0x20,%rax
  80042020b1:	48 89 c2             	mov    %rax,%rdx
  80042020b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020b8:	8b 40 04             	mov    0x4(%rax),%eax
  80042020bb:	89 c0                	mov    %eax,%eax
  80042020bd:	48 01 d0             	add    %rdx,%rax
  80042020c0:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  80042020c4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020c8:	8b 40 10             	mov    0x10(%rax),%eax
  80042020cb:	89 c0                	mov    %eax,%eax
  80042020cd:	48 c1 e0 20          	shl    $0x20,%rax
  80042020d1:	48 89 c2             	mov    %rax,%rdx
  80042020d4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042020d8:	8b 40 0c             	mov    0xc(%rax),%eax
  80042020db:	89 c0                	mov    %eax,%eax
  80042020dd:	48 01 d0             	add    %rdx,%rax
  80042020e0:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  80042020e7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020eb:	8b 40 10             	mov    0x10(%rax),%eax
  80042020ee:	89 c0                	mov    %eax,%eax
  80042020f0:	48 c1 e0 20          	shl    $0x20,%rax
  80042020f4:	48 89 c2             	mov    %rax,%rdx
  80042020f7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042020fb:	8b 40 0c             	mov    0xc(%rax),%eax
  80042020fe:	89 c0                	mov    %eax,%eax
  8004202100:	48 01 d0             	add    %rdx,%rax
  8004202103:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  800420210a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202111:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202115:	48 01 d0             	add    %rdx,%rax
  8004202118:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  800420211c:	75 7c                	jne    800420219a <multiboot_read+0x3c6>
  800420211e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202122:	8b 50 14             	mov    0x14(%rax),%edx
  8004202125:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202129:	8b 40 14             	mov    0x14(%rax),%eax
  800420212c:	39 c2                	cmp    %eax,%edx
  800420212e:	75 6a                	jne    800420219a <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004202130:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202137:	89 c2                	mov    %eax,%edx
  8004202139:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202140:	01 c2                	add    %eax,%edx
  8004202142:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202146:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  8004202149:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202150:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004202157:	48 01 d0             	add    %rdx,%rax
  800420215a:	48 c1 e8 20          	shr    $0x20,%rax
  800420215e:	89 c2                	mov    %eax,%edx
  8004202160:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202164:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  8004202167:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420216b:	8b 50 04             	mov    0x4(%rax),%edx
  800420216e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202172:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  8004202175:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202179:	8b 50 08             	mov    0x8(%rax),%edx
  800420217c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202180:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  8004202183:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202186:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004202189:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420218d:	48 63 d2             	movslq %edx,%rdx
  8004202190:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  8004202197:	00 
  8004202198:	eb 52                	jmp    80042021ec <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  800420219a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042021a1:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042021a5:	48 01 d0             	add    %rdx,%rax
  80042021a8:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  80042021ac:	76 3e                	jbe    80042021ec <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  80042021ae:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021b2:	8b 50 14             	mov    0x14(%rax),%edx
  80042021b5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021b9:	8b 40 14             	mov    0x14(%rax),%eax
  80042021bc:	89 d6                	mov    %edx,%esi
  80042021be:	89 c7                	mov    %eax,%edi
  80042021c0:	48 b8 34 1d 20 04 80 	movabs $0x8004201d34,%rax
  80042021c7:	00 00 00 
  80042021ca:	ff d0                	callq  *%rax
  80042021cc:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  80042021d2:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021d6:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021dc:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  80042021df:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021e3:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  80042021e9:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042021ec:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042021f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042021f3:	48 63 c8             	movslq %eax,%rcx
  80042021f6:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042021fd:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202200:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202205:	f7 e2                	mul    %edx
  8004202207:	89 d0                	mov    %edx,%eax
  8004202209:	c1 e8 04             	shr    $0x4,%eax
  800420220c:	89 c0                	mov    %eax,%eax
  800420220e:	48 39 c1             	cmp    %rax,%rcx
  8004202211:	0f 82 46 fe ff ff    	jb     800420205d <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202217:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  800420221e:	e9 dc 00 00 00       	jmpq   80042022ff <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004202223:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202227:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420222a:	48 63 d2             	movslq %edx,%rdx
  800420222d:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202231:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  8004202238:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  800420223f:	00 
  8004202240:	0f 84 b5 00 00 00    	je     80042022fb <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  8004202246:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420224d:	8b 40 14             	mov    0x14(%rax),%eax
  8004202250:	83 f8 01             	cmp    $0x1,%eax
  8004202253:	74 13                	je     8004202268 <multiboot_read+0x494>
  8004202255:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420225c:	8b 40 14             	mov    0x14(%rax),%eax
  800420225f:	83 f8 03             	cmp    $0x3,%eax
  8004202262:	0f 85 93 00 00 00    	jne    80042022fb <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  8004202268:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420226f:	8b 40 04             	mov    0x4(%rax),%eax
  8004202272:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8004202277:	77 49                	ja     80042022c2 <multiboot_read+0x4ee>
  8004202279:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202280:	8b 40 08             	mov    0x8(%rax),%eax
  8004202283:	85 c0                	test   %eax,%eax
  8004202285:	75 3b                	jne    80042022c2 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202287:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  800420228e:	48 8b 10             	mov    (%rax),%rdx
  8004202291:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202298:	8b 40 10             	mov    0x10(%rax),%eax
  800420229b:	89 c0                	mov    %eax,%eax
  800420229d:	48 c1 e0 20          	shl    $0x20,%rax
  80042022a1:	48 89 c1             	mov    %rax,%rcx
  80042022a4:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022ab:	8b 40 0c             	mov    0xc(%rax),%eax
  80042022ae:	89 c0                	mov    %eax,%eax
  80042022b0:	48 01 c8             	add    %rcx,%rax
  80042022b3:	48 01 c2             	add    %rax,%rdx
  80042022b6:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042022bd:	48 89 10             	mov    %rdx,(%rax)
  80042022c0:	eb 39                	jmp    80042022fb <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042022c2:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042022c9:	48 8b 10             	mov    (%rax),%rdx
  80042022cc:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022d3:	8b 40 10             	mov    0x10(%rax),%eax
  80042022d6:	89 c0                	mov    %eax,%eax
  80042022d8:	48 c1 e0 20          	shl    $0x20,%rax
  80042022dc:	48 89 c1             	mov    %rax,%rcx
  80042022df:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042022e6:	8b 40 0c             	mov    0xc(%rax),%eax
  80042022e9:	89 c0                	mov    %eax,%eax
  80042022eb:	48 01 c8             	add    %rcx,%rax
  80042022ee:	48 01 c2             	add    %rax,%rdx
  80042022f1:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042022f8:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  80042022fb:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042022ff:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202302:	48 63 c8             	movslq %eax,%rcx
  8004202305:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800420230c:	8b 40 2c             	mov    0x2c(%rax),%eax
  800420230f:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202314:	f7 e2                	mul    %edx
  8004202316:	89 d0                	mov    %edx,%eax
  8004202318:	c1 e8 04             	shr    $0x4,%eax
  800420231b:	89 c0                	mov    %eax,%eax
  800420231d:	48 39 c1             	cmp    %rax,%rcx
  8004202320:	0f 82 fd fe ff ff    	jb     8004202223 <multiboot_read+0x44f>
  8004202326:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  8004202329:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  800420232d:	5b                   	pop    %rbx
  800420232e:	41 5c                	pop    %r12
  8004202330:	5d                   	pop    %rbp
  8004202331:	c3                   	retq   

0000008004202332 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202332:	55                   	push   %rbp
  8004202333:	48 89 e5             	mov    %rsp,%rbp
  8004202336:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  800420233a:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004202341:	00 
	size_t extmem = 0;
  8004202342:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004202349:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  800420234a:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202351:	00 00 00 
  8004202354:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  8004202358:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420235c:	48 8b 00             	mov    (%rax),%rax
  800420235f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  8004202363:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004202368:	74 2d                	je     8004202397 <i386_detect_memory+0x65>
  800420236a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420236e:	8b 00                	mov    (%rax),%eax
  8004202370:	83 e0 40             	and    $0x40,%eax
  8004202373:	85 c0                	test   %eax,%eax
  8004202375:	74 20                	je     8004202397 <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  8004202377:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  800420237b:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  800420237f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202383:	48 89 ce             	mov    %rcx,%rsi
  8004202386:	48 89 c7             	mov    %rax,%rdi
  8004202389:	48 b8 d4 1d 20 04 80 	movabs $0x8004201dd4,%rax
  8004202390:	00 00 00 
  8004202393:	ff d0                	callq  *%rax
  8004202395:	eb 34                	jmp    80042023cb <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  8004202397:	bf 15 00 00 00       	mov    $0x15,%edi
  800420239c:	48 b8 95 1d 20 04 80 	movabs $0x8004201d95,%rax
  80042023a3:	00 00 00 
  80042023a6:	ff d0                	callq  *%rax
  80042023a8:	c1 e0 0a             	shl    $0xa,%eax
  80042023ab:	48 98                	cltq   
  80042023ad:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  80042023b1:	bf 17 00 00 00       	mov    $0x17,%edi
  80042023b6:	48 b8 95 1d 20 04 80 	movabs $0x8004201d95,%rax
  80042023bd:	00 00 00 
  80042023c0:	ff d0                	callq  *%rax
  80042023c2:	c1 e0 0a             	shl    $0xa,%eax
  80042023c5:	48 98                	cltq   
  80042023c7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  80042023cb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042023cf:	48 85 c0             	test   %rax,%rax
  80042023d2:	75 35                	jne    8004202409 <i386_detect_memory+0xd7>
  80042023d4:	48 b9 69 d6 21 04 80 	movabs $0x800421d669,%rcx
  80042023db:	00 00 00 
  80042023de:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042023e5:	00 00 00 
  80042023e8:	be 89 00 00 00       	mov    $0x89,%esi
  80042023ed:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042023f4:	00 00 00 
  80042023f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042023fc:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202403:	00 00 00 
  8004202406:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  8004202409:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420240d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202411:	48 89 c2             	mov    %rax,%rdx
  8004202414:	48 b8 30 d2 3a 04 80 	movabs $0x80043ad230,%rax
  800420241b:	00 00 00 
  800420241e:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202421:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202425:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202429:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  800420242d:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202432:	48 b8 95 1d 20 04 80 	movabs $0x8004201d95,%rax
  8004202439:	00 00 00 
  800420243c:	ff d0                	callq  *%rax
  800420243e:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202443:	75 2c                	jne    8004202471 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202445:	bf 34 00 00 00       	mov    $0x34,%edi
  800420244a:	48 b8 95 1d 20 04 80 	movabs $0x8004201d95,%rax
  8004202451:	00 00 00 
  8004202454:	ff d0                	callq  *%rax
  8004202456:	c1 e0 10             	shl    $0x10,%eax
  8004202459:	48 98                	cltq   
  800420245b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  800420245f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202463:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  8004202469:	48 c1 e8 0c          	shr    $0xc,%rax
  800420246d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  8004202471:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004202476:	74 1a                	je     8004202492 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  8004202478:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420247c:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  8004202483:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  800420248a:	00 00 00 
  800420248d:	48 89 10             	mov    %rdx,(%rax)
  8004202490:	eb 1a                	jmp    80042024ac <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  8004202492:	48 b8 30 d2 3a 04 80 	movabs $0x80043ad230,%rax
  8004202499:	00 00 00 
  800420249c:	48 8b 10             	mov    (%rax),%rdx
  800420249f:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042024a6:	00 00 00 
  80042024a9:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024ac:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042024b3:	00 00 00 
  80042024b6:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  80042024b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042024bd:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024c1:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024c5:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  80042024c8:	48 b8 30 d2 3a 04 80 	movabs $0x80043ad230,%rax
  80042024cf:	00 00 00 
  80042024d2:	48 8b 00             	mov    (%rax),%rax
  80042024d5:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024d9:	48 c1 e8 0a          	shr    $0xa,%rax
  80042024dd:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  80042024e0:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042024e7:	00 00 00 
  80042024ea:	48 8b 00             	mov    (%rax),%rax
  80042024ed:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042024f1:	48 c1 e8 14          	shr    $0x14,%rax
  80042024f5:	49 89 f0             	mov    %rsi,%r8
  80042024f8:	48 89 c6             	mov    %rax,%rsi
  80042024fb:	48 bf 98 d6 21 04 80 	movabs $0x800421d698,%rdi
  8004202502:	00 00 00 
  8004202505:	b8 00 00 00 00       	mov    $0x0,%eax
  800420250a:	49 b9 1a 96 20 04 80 	movabs $0x800420961a,%r9
  8004202511:	00 00 00 
  8004202514:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  8004202517:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  800420251e:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  800420251f:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  8004202526:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  8004202527:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420252b:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420252f:	48 c1 e8 14          	shr    $0x14,%rax
  8004202533:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  8004202536:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420253a:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  800420253e:	48 c1 e8 14          	shr    $0x14,%rax
  8004202542:	48 89 c6             	mov    %rax,%rsi
  8004202545:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004202549:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420254d:	49 89 c8             	mov    %rcx,%r8
  8004202550:	48 89 d1             	mov    %rdx,%rcx
  8004202553:	48 89 f2             	mov    %rsi,%rdx
  8004202556:	48 89 c6             	mov    %rax,%rsi
  8004202559:	48 bf e8 d6 21 04 80 	movabs $0x800421d6e8,%rdi
  8004202560:	00 00 00 
  8004202563:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202568:	49 b9 1a 96 20 04 80 	movabs $0x800420961a,%r9
  800420256f:	00 00 00 
  8004202572:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  8004202575:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202579:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800420257d:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  8004202582:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  8004202586:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  800420258d:	00 00 00 
  8004202590:	48 8b 00             	mov    (%rax),%rax
  8004202593:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004202597:	76 3a                	jbe    80042025d3 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  8004202599:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420259d:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  80042025a4:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042025ab:	00 00 00 
  80042025ae:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042025b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042025b5:	48 89 c6             	mov    %rax,%rsi
  80042025b8:	48 bf 50 d7 21 04 80 	movabs $0x800421d750,%rdi
  80042025bf:	00 00 00 
  80042025c2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042025c7:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042025ce:	00 00 00 
  80042025d1:	ff d2                	callq  *%rdx
	}
}
  80042025d3:	c9                   	leaveq 
  80042025d4:	c3                   	retq   

00000080042025d5 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  80042025d5:	55                   	push   %rbp
  80042025d6:	48 89 e5             	mov    %rsp,%rbp
  80042025d9:	48 83 ec 40          	sub    $0x40,%rsp
  80042025dd:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  80042025e0:	48 b8 48 d2 3a 04 80 	movabs $0x80043ad248,%rax
  80042025e7:	00 00 00 
  80042025ea:	48 8b 00             	mov    (%rax),%rax
  80042025ed:	48 85 c0             	test   %rax,%rax
  80042025f0:	75 4e                	jne    8004202640 <boot_alloc+0x6b>
#ifdef VMM_GUEST
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
#else
		extern uintptr_t end_debug;
		nextfree = ROUNDUP((char *) end_debug, PGSIZE);
  80042025f2:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  80042025f9:	00 
  80042025fa:	48 b8 70 e7 3a 04 80 	movabs $0x80043ae770,%rax
  8004202601:	00 00 00 
  8004202604:	48 8b 10             	mov    (%rax),%rdx
  8004202607:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420260b:	48 01 d0             	add    %rdx,%rax
  800420260e:	48 83 e8 01          	sub    $0x1,%rax
  8004202612:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202616:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420261a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420261f:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202623:	48 89 d0             	mov    %rdx,%rax
  8004202626:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420262a:	48 29 c2             	sub    %rax,%rdx
  800420262d:	48 89 d0             	mov    %rdx,%rax
  8004202630:	48 89 c2             	mov    %rax,%rdx
  8004202633:	48 b8 48 d2 3a 04 80 	movabs $0x80043ad248,%rax
  800420263a:	00 00 00 
  800420263d:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	if (n == 0) 
  8004202640:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004202644:	75 12                	jne    8004202658 <boot_alloc+0x83>
		return nextfree;
  8004202646:	48 b8 48 d2 3a 04 80 	movabs $0x80043ad248,%rax
  800420264d:	00 00 00 
  8004202650:	48 8b 00             	mov    (%rax),%rax
  8004202653:	e9 cf 00 00 00       	jmpq   8004202727 <boot_alloc+0x152>
	result = nextfree;
  8004202658:	48 b8 48 d2 3a 04 80 	movabs $0x80043ad248,%rax
  800420265f:	00 00 00 
  8004202662:	48 8b 00             	mov    (%rax),%rax
  8004202665:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nextfree = nextfree + n;
  8004202669:	48 b8 48 d2 3a 04 80 	movabs $0x80043ad248,%rax
  8004202670:	00 00 00 
  8004202673:	48 8b 10             	mov    (%rax),%rdx
  8004202676:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004202679:	48 01 c2             	add    %rax,%rdx
  800420267c:	48 b8 48 d2 3a 04 80 	movabs $0x80043ad248,%rax
  8004202683:	00 00 00 
  8004202686:	48 89 10             	mov    %rdx,(%rax)
	nextfree = ROUNDUP(nextfree, PGSIZE);
  8004202689:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004202690:	00 
  8004202691:	48 b8 48 d2 3a 04 80 	movabs $0x80043ad248,%rax
  8004202698:	00 00 00 
  800420269b:	48 8b 00             	mov    (%rax),%rax
  800420269e:	48 89 c2             	mov    %rax,%rdx
  80042026a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042026a5:	48 01 d0             	add    %rdx,%rax
  80042026a8:	48 83 e8 01          	sub    $0x1,%rax
  80042026ac:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042026b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042026b4:	ba 00 00 00 00       	mov    $0x0,%edx
  80042026b9:	48 f7 75 e0          	divq   -0x20(%rbp)
  80042026bd:	48 89 d0             	mov    %rdx,%rax
  80042026c0:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042026c4:	48 29 c2             	sub    %rax,%rdx
  80042026c7:	48 89 d0             	mov    %rdx,%rax
  80042026ca:	48 89 c2             	mov    %rax,%rdx
  80042026cd:	48 b8 48 d2 3a 04 80 	movabs $0x80043ad248,%rax
  80042026d4:	00 00 00 
  80042026d7:	48 89 10             	mov    %rdx,(%rax)
	//process memory wrap arounds on memory full
	if((uint64_t)nextfree < (uint64_t)end)
  80042026da:	48 b8 48 d2 3a 04 80 	movabs $0x80043ad248,%rax
  80042026e1:	00 00 00 
  80042026e4:	48 8b 00             	mov    (%rax),%rax
  80042026e7:	48 89 c2             	mov    %rax,%rdx
  80042026ea:	48 b8 10 10 3f 04 80 	movabs $0x80043f1010,%rax
  80042026f1:	00 00 00 
  80042026f4:	48 39 c2             	cmp    %rax,%rdx
  80042026f7:	73 2a                	jae    8004202723 <boot_alloc+0x14e>
	{
		panic("we're out of memory");
  80042026f9:	48 ba 79 d7 21 04 80 	movabs $0x800421d779,%rdx
  8004202700:	00 00 00 
  8004202703:	be ee 00 00 00       	mov    $0xee,%esi
  8004202708:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420270f:	00 00 00 
  8004202712:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202717:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  800420271e:	00 00 00 
  8004202721:	ff d1                	callq  *%rcx
	}
	return result;
  8004202723:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004202727:	c9                   	leaveq 
  8004202728:	c3                   	retq   

0000008004202729 <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  8004202729:	55                   	push   %rbp
  800420272a:	48 89 e5             	mov    %rsp,%rbp
  800420272d:	48 83 ec 60          	sub    $0x60,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202731:	48 b8 32 23 20 04 80 	movabs $0x8004202332,%rax
  8004202738:	00 00 00 
  800420273b:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  800420273d:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004202742:	48 b8 d5 25 20 04 80 	movabs $0x80042025d5,%rax
  8004202749:	00 00 00 
  800420274c:	ff d0                	callq  *%rax
  800420274e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004202752:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202756:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420275b:	be 00 00 00 00       	mov    $0x0,%esi
  8004202760:	48 89 c7             	mov    %rax,%rdi
  8004202763:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  800420276a:	00 00 00 
  800420276d:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  800420276f:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004202776:	00 00 00 
  8004202779:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420277d:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  8004202780:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202784:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202788:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420278f:	00 00 00 
  8004202792:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  8004202796:	77 32                	ja     80042027ca <x64_vm_init+0xa1>
  8004202798:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420279c:	48 89 c1             	mov    %rax,%rcx
  800420279f:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  80042027a6:	00 00 00 
  80042027a9:	be 0c 01 00 00       	mov    $0x10c,%esi
  80042027ae:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042027b5:	00 00 00 
  80042027b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042027bd:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042027c4:	00 00 00 
  80042027c7:	41 ff d0             	callq  *%r8
  80042027ca:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042027d1:	ff ff ff 
  80042027d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042027d8:	48 01 c2             	add    %rax,%rdx
  80042027db:	48 b8 88 e7 3a 04 80 	movabs $0x80043ae788,%rax
  80042027e2:	00 00 00 
  80042027e5:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
  80042027e8:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042027ef:	00 00 00 
  80042027f2:	48 8b 00             	mov    (%rax),%rax
  80042027f5:	c1 e0 04             	shl    $0x4,%eax
  80042027f8:	89 c7                	mov    %eax,%edi
  80042027fa:	48 b8 d5 25 20 04 80 	movabs $0x80042025d5,%rax
  8004202801:	00 00 00 
  8004202804:	ff d0                	callq  *%rax
  8004202806:	48 ba a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rdx
  800420280d:	00 00 00 
  8004202810:	48 89 02             	mov    %rax,(%rdx)

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	
	envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
  8004202813:	bf 00 a0 05 00       	mov    $0x5a000,%edi
  8004202818:	48 b8 d5 25 20 04 80 	movabs $0x80042025d5,%rax
  800420281f:	00 00 00 
  8004202822:	ff d0                	callq  *%rax
  8004202824:	48 ba 58 d2 3a 04 80 	movabs $0x80043ad258,%rdx
  800420282b:	00 00 00 
  800420282e:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004202831:	48 b8 9d 2b 20 04 80 	movabs $0x8004202b9d,%rax
  8004202838:	00 00 00 
  800420283b:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
    boot_map_region(pml4e, UPAGES, npages * sizeof(struct PageInfo), PADDR(pages), PTE_U|PTE_P);
  800420283d:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202844:	00 00 00 
  8004202847:	48 8b 00             	mov    (%rax),%rax
  800420284a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420284e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202855:	00 00 00 
  8004202858:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420285c:	77 32                	ja     8004202890 <x64_vm_init+0x167>
  800420285e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202862:	48 89 c1             	mov    %rax,%rcx
  8004202865:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  800420286c:	00 00 00 
  800420286f:	be 2b 01 00 00       	mov    $0x12b,%esi
  8004202874:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420287b:	00 00 00 
  800420287e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202883:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420288a:	00 00 00 
  800420288d:	41 ff d0             	callq  *%r8
  8004202890:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202897:	ff ff ff 
  800420289a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420289e:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042028a2:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042028a9:	00 00 00 
  80042028ac:	48 8b 00             	mov    (%rax),%rax
  80042028af:	48 c1 e0 04          	shl    $0x4,%rax
  80042028b3:	48 89 c2             	mov    %rax,%rdx
  80042028b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042028ba:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  80042028c0:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  80042028c7:	00 00 00 
  80042028ca:	48 89 c7             	mov    %rax,%rdi
  80042028cd:	48 b8 1d 37 20 04 80 	movabs $0x800420371d,%rax
  80042028d4:	00 00 00 
  80042028d7:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(pml4e, UENVS, NENV * sizeof(struct Env), PADDR(envs), PTE_U|PTE_P);
  80042028d9:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  80042028e0:	00 00 00 
  80042028e3:	48 8b 00             	mov    (%rax),%rax
  80042028e6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042028ea:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042028f1:	00 00 00 
  80042028f4:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042028f8:	77 32                	ja     800420292c <x64_vm_init+0x203>
  80042028fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042028fe:	48 89 c1             	mov    %rax,%rcx
  8004202901:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  8004202908:	00 00 00 
  800420290b:	be 34 01 00 00       	mov    $0x134,%esi
  8004202910:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004202917:	00 00 00 
  800420291a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420291f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202926:	00 00 00 
  8004202929:	41 ff d0             	callq  *%r8
  800420292c:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202933:	ff ff ff 
  8004202936:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420293a:	48 01 c2             	add    %rax,%rdx
  800420293d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202941:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202947:	48 89 d1             	mov    %rdx,%rcx
  800420294a:	ba 00 a0 05 00       	mov    $0x5a000,%edx
  800420294f:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202956:	00 00 00 
  8004202959:	48 89 c7             	mov    %rax,%rdi
  800420295c:	48 b8 1d 37 20 04 80 	movabs $0x800420371d,%rax
  8004202963:	00 00 00 
  8004202966:	ff d0                	callq  *%rax
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 
	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202968:	48 b8 be 2a 20 04 80 	movabs $0x8004202abe,%rax
  800420296f:	00 00 00 
  8004202972:	ff d0                	callq  *%rax
	boot_map_region(pml4e, KERNBASE, npages*PGSIZE, 0, PTE_P|PTE_W);
  8004202974:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  800420297b:	00 00 00 
  800420297e:	48 8b 00             	mov    (%rax),%rax
  8004202981:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202985:	48 89 c2             	mov    %rax,%rdx
  8004202988:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420298c:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202992:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202997:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  800420299e:	00 00 00 
  80042029a1:	48 89 c7             	mov    %rax,%rdi
  80042029a4:	48 b8 1d 37 20 04 80 	movabs $0x800420371d,%rax
  80042029ab:	00 00 00 
  80042029ae:	ff d0                	callq  *%rax
	//check_boot_pml4e(boot_pml4e);

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE

	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  80042029b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042029b4:	48 83 c0 08          	add    $0x8,%rax
  80042029b8:	48 8b 00             	mov    (%rax),%rax
  80042029bb:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042029c1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042029c5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029c9:	48 c1 e8 0c          	shr    $0xc,%rax
  80042029cd:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  80042029d0:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042029d3:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042029da:	00 00 00 
  80042029dd:	48 8b 00             	mov    (%rax),%rax
  80042029e0:	48 39 c2             	cmp    %rax,%rdx
  80042029e3:	72 32                	jb     8004202a17 <x64_vm_init+0x2ee>
  80042029e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042029e9:	48 89 c1             	mov    %rax,%rcx
  80042029ec:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  80042029f3:	00 00 00 
  80042029f6:	be 54 01 00 00       	mov    $0x154,%esi
  80042029fb:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004202a02:	00 00 00 
  8004202a05:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a0a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202a11:	00 00 00 
  8004202a14:	41 ff d0             	callq  *%r8
  8004202a17:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202a1e:	00 00 00 
  8004202a21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202a25:	48 01 d0             	add    %rdx,%rax
  8004202a28:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202a2c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202a30:	48 8b 00             	mov    (%rax),%rax
  8004202a33:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202a39:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202a3d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a41:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202a45:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004202a48:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202a4b:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004202a52:	00 00 00 
  8004202a55:	48 8b 00             	mov    (%rax),%rax
  8004202a58:	48 39 c2             	cmp    %rax,%rdx
  8004202a5b:	72 32                	jb     8004202a8f <x64_vm_init+0x366>
  8004202a5d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a61:	48 89 c1             	mov    %rax,%rcx
  8004202a64:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004202a6b:	00 00 00 
  8004202a6e:	be 55 01 00 00       	mov    $0x155,%esi
  8004202a73:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004202a7a:	00 00 00 
  8004202a7d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a82:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202a89:	00 00 00 
  8004202a8c:	41 ff d0             	callq  *%r8
  8004202a8f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202a96:	00 00 00 
  8004202a99:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202a9d:	48 01 d0             	add    %rdx,%rax
  8004202aa0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	lcr3(boot_cr3);
  8004202aa4:	48 b8 88 e7 3a 04 80 	movabs $0x80043ae788,%rax
  8004202aab:	00 00 00 
  8004202aae:	48 8b 00             	mov    (%rax),%rax
  8004202ab1:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202ab5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202ab9:	0f 22 d8             	mov    %rax,%cr3

	/* check_page_free_list(1); */
	/* check_page_alloc(); */
	/* page_check(); */
	/* check_page_free_list(0); */
}
  8004202abc:	c9                   	leaveq 
  8004202abd:	c3                   	retq   

0000008004202abe <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  8004202abe:	55                   	push   %rbp
  8004202abf:	48 89 e5             	mov    %rsp,%rbp
  8004202ac2:	48 83 ec 20          	sub    $0x20,%rsp
	//             it will fault rather than overwrite another CPU's stack.
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
  8004202ac6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	uint64_t la = KSTACKTOP;
  8004202acd:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004202ad4:	00 00 00 
  8004202ad7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for(; i < NCPU; i++)
  8004202adb:	e9 b1 00 00 00       	jmpq   8004202b91 <mem_init_mp+0xd3>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
  8004202ae0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202ae3:	48 98                	cltq   
  8004202ae5:	48 c1 e0 10          	shl    $0x10,%rax
  8004202ae9:	48 89 c2             	mov    %rax,%rdx
  8004202aec:	48 b8 00 10 3b 04 80 	movabs $0x80043b1000,%rax
  8004202af3:	00 00 00 
  8004202af6:	48 01 d0             	add    %rdx,%rax
  8004202af9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202afd:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202b04:	00 00 00 
  8004202b07:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202b0b:	77 32                	ja     8004202b3f <mem_init_mp+0x81>
  8004202b0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202b11:	48 89 c1             	mov    %rax,%rcx
  8004202b14:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  8004202b1b:	00 00 00 
  8004202b1e:	be 7a 01 00 00       	mov    $0x17a,%esi
  8004202b23:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004202b2a:	00 00 00 
  8004202b2d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b32:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202b39:	00 00 00 
  8004202b3c:	41 ff d0             	callq  *%r8
  8004202b3f:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202b46:	ff ff ff 
  8004202b49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202b4d:	48 01 c2             	add    %rax,%rdx
  8004202b50:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202b54:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202b5b:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004202b62:	00 00 00 
  8004202b65:	48 8b 00             	mov    (%rax),%rax
  8004202b68:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202b6e:	48 89 d1             	mov    %rdx,%rcx
  8004202b71:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202b76:	48 89 c7             	mov    %rax,%rdi
  8004202b79:	48 b8 1d 37 20 04 80 	movabs $0x800420371d,%rax
  8004202b80:	00 00 00 
  8004202b83:	ff d0                	callq  *%rax
		la -= (KSTKSIZE + KSTKGAP);
  8004202b85:	48 81 6d f0 00 80 01 	subq   $0x18000,-0x10(%rbp)
  8004202b8c:	00 
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
	uint64_t la = KSTACKTOP;
	for(; i < NCPU; i++)
  8004202b8d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202b91:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004202b95:	0f 8e 45 ff ff ff    	jle    8004202ae0 <mem_init_mp+0x22>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
		la -= (KSTKSIZE + KSTKGAP);
	}
}
  8004202b9b:	c9                   	leaveq 
  8004202b9c:	c3                   	retq   

0000008004202b9d <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202b9d:	55                   	push   %rbp
  8004202b9e:	48 89 e5             	mov    %rsp,%rbp
  8004202ba1:	48 83 ec 70          	sub    $0x70,%rsp
	// NB: Make sure you preserve the direction in which your page_free_list 
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
  8004202ba5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202bac:	00 
	for (i = 0; i < npages; i++) {
  8004202bad:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202bb4:	00 
  8004202bb5:	e9 ab 00 00 00       	jmpq   8004202c65 <page_init+0xc8>
		pages[i].pp_ref = 0;
  8004202bba:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202bc1:	00 00 00 
  8004202bc4:	48 8b 00             	mov    (%rax),%rax
  8004202bc7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202bcb:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202bcf:	48 01 d0             	add    %rdx,%rax
  8004202bd2:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
		pages[i].pp_link = NULL;
  8004202bd8:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202bdf:	00 00 00 
  8004202be2:	48 8b 00             	mov    (%rax),%rax
  8004202be5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202be9:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202bed:	48 01 d0             	add    %rdx,%rax
  8004202bf0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if(last)
  8004202bf7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202bfc:	74 21                	je     8004202c1f <page_init+0x82>
			last->pp_link = &pages[i];
  8004202bfe:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202c05:	00 00 00 
  8004202c08:	48 8b 00             	mov    (%rax),%rax
  8004202c0b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c0f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c13:	48 01 c2             	add    %rax,%rdx
  8004202c16:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202c1a:	48 89 10             	mov    %rdx,(%rax)
  8004202c1d:	eb 25                	jmp    8004202c44 <page_init+0xa7>
		else
			page_free_list = &pages[i];
  8004202c1f:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202c26:	00 00 00 
  8004202c29:	48 8b 00             	mov    (%rax),%rax
  8004202c2c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c30:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c34:	48 01 c2             	add    %rax,%rdx
  8004202c37:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004202c3e:	00 00 00 
  8004202c41:	48 89 10             	mov    %rdx,(%rax)
		last = &pages[i];
  8004202c44:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202c4b:	00 00 00 
  8004202c4e:	48 8b 00             	mov    (%rax),%rax
  8004202c51:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202c55:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202c59:	48 01 d0             	add    %rdx,%rax
  8004202c5c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) {
  8004202c60:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202c65:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004202c6c:	00 00 00 
  8004202c6f:	48 8b 00             	mov    (%rax),%rax
  8004202c72:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202c76:	0f 82 3e ff ff ff    	jb     8004202bba <page_init+0x1d>
		else
			page_free_list = &pages[i];
		last = &pages[i];
	}
	//remove page 0 from page list
	page_free_list = page_free_list->pp_link;
  8004202c7c:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004202c83:	00 00 00 
  8004202c86:	48 8b 00             	mov    (%rax),%rax
  8004202c89:	48 8b 10             	mov    (%rax),%rdx
  8004202c8c:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004202c93:	00 00 00 
  8004202c96:	48 89 10             	mov    %rdx,(%rax)

	//remove entries of holes till current kernel available memory pointer
	holeS = IOPHYSMEM/PGSIZE;
  8004202c99:	48 c7 45 e8 a0 00 00 	movq   $0xa0,-0x18(%rbp)
  8004202ca0:	00 
	kernE = PADDR(boot_alloc(0))/PGSIZE;
  8004202ca1:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202ca6:	48 b8 d5 25 20 04 80 	movabs $0x80042025d5,%rax
  8004202cad:	00 00 00 
  8004202cb0:	ff d0                	callq  *%rax
  8004202cb2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202cb6:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202cbd:	00 00 00 
  8004202cc0:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202cc4:	77 32                	ja     8004202cf8 <page_init+0x15b>
  8004202cc6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202cca:	48 89 c1             	mov    %rax,%rcx
  8004202ccd:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  8004202cd4:	00 00 00 
  8004202cd7:	be b7 01 00 00       	mov    $0x1b7,%esi
  8004202cdc:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004202ce3:	00 00 00 
  8004202ce6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ceb:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202cf2:	00 00 00 
  8004202cf5:	41 ff d0             	callq  *%r8
  8004202cf8:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202cff:	ff ff ff 
  8004202d02:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202d06:	48 01 d0             	add    %rdx,%rax
  8004202d09:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d0d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	pages[holeS - 1].pp_link = &pages[kernE];
  8004202d11:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202d18:	00 00 00 
  8004202d1b:	48 8b 00             	mov    (%rax),%rax
  8004202d1e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202d22:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202d26:	48 83 ea 10          	sub    $0x10,%rdx
  8004202d2a:	48 01 c2             	add    %rax,%rdx
  8004202d2d:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202d34:	00 00 00 
  8004202d37:	48 8b 00             	mov    (%rax),%rax
  8004202d3a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004202d3e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202d42:	48 01 c8             	add    %rcx,%rax
  8004202d45:	48 89 02             	mov    %rax,(%rdx)

	bootPTS = PADDR(BOOT_PAGE_TABLE_START)/PGSIZE;	
  8004202d48:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202d4f:	00 00 00 
  8004202d52:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202d56:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d5a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202d5e:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004202d61:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004202d64:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004202d6b:	00 00 00 
  8004202d6e:	48 8b 00             	mov    (%rax),%rax
  8004202d71:	48 39 c2             	cmp    %rax,%rdx
  8004202d74:	72 32                	jb     8004202da8 <page_init+0x20b>
  8004202d76:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202d7a:	48 89 c1             	mov    %rax,%rcx
  8004202d7d:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004202d84:	00 00 00 
  8004202d87:	be ba 01 00 00       	mov    $0x1ba,%esi
  8004202d8c:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004202d93:	00 00 00 
  8004202d96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202d9b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202da2:	00 00 00 
  8004202da5:	41 ff d0             	callq  *%r8
  8004202da8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202daf:	00 00 00 
  8004202db2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202db6:	48 01 d0             	add    %rdx,%rax
  8004202db9:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202dbd:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202dc4:	00 00 00 
  8004202dc7:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202dcb:	77 32                	ja     8004202dff <page_init+0x262>
  8004202dcd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202dd1:	48 89 c1             	mov    %rax,%rcx
  8004202dd4:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  8004202ddb:	00 00 00 
  8004202dde:	be ba 01 00 00       	mov    $0x1ba,%esi
  8004202de3:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004202dea:	00 00 00 
  8004202ded:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202df2:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202df9:	00 00 00 
  8004202dfc:	41 ff d0             	callq  *%r8
  8004202dff:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202e06:	ff ff ff 
  8004202e09:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202e0d:	48 01 d0             	add    %rdx,%rax
  8004202e10:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e14:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	bootPTE = PADDR(BOOT_PAGE_TABLE_END - 1)/PGSIZE;
  8004202e18:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202e1f:	00 00 00 
  8004202e22:	48 05 00 50 00 00    	add    $0x5000,%rax
  8004202e28:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004202e2c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e30:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e34:	89 45 ac             	mov    %eax,-0x54(%rbp)
  8004202e37:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004202e3a:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004202e41:	00 00 00 
  8004202e44:	48 8b 00             	mov    (%rax),%rax
  8004202e47:	48 39 c2             	cmp    %rax,%rdx
  8004202e4a:	72 32                	jb     8004202e7e <page_init+0x2e1>
  8004202e4c:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e50:	48 89 c1             	mov    %rax,%rcx
  8004202e53:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004202e5a:	00 00 00 
  8004202e5d:	be bb 01 00 00       	mov    $0x1bb,%esi
  8004202e62:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004202e69:	00 00 00 
  8004202e6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e71:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202e78:	00 00 00 
  8004202e7b:	41 ff d0             	callq  *%r8
  8004202e7e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202e85:	00 00 00 
  8004202e88:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202e8c:	48 01 d0             	add    %rdx,%rax
  8004202e8f:	48 83 e8 01          	sub    $0x1,%rax
  8004202e93:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004202e97:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202e9e:	00 00 00 
  8004202ea1:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  8004202ea5:	77 32                	ja     8004202ed9 <page_init+0x33c>
  8004202ea7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202eab:	48 89 c1             	mov    %rax,%rcx
  8004202eae:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  8004202eb5:	00 00 00 
  8004202eb8:	be bb 01 00 00       	mov    $0x1bb,%esi
  8004202ebd:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004202ec4:	00 00 00 
  8004202ec7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202ecc:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004202ed3:	00 00 00 
  8004202ed6:	41 ff d0             	callq  *%r8
  8004202ed9:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202ee0:	ff ff ff 
  8004202ee3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202ee7:	48 01 d0             	add    %rdx,%rax
  8004202eea:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202eee:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pages[bootPTS - 1].pp_link = &pages[bootPTE + 1];
  8004202ef2:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202ef9:	00 00 00 
  8004202efc:	48 8b 00             	mov    (%rax),%rax
  8004202eff:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004202f03:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202f07:	48 83 ea 10          	sub    $0x10,%rdx
  8004202f0b:	48 01 c2             	add    %rax,%rdx
  8004202f0e:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202f15:	00 00 00 
  8004202f18:	48 8b 00             	mov    (%rax),%rax
  8004202f1b:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  8004202f1f:	48 83 c1 01          	add    $0x1,%rcx
  8004202f23:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202f27:	48 01 c8             	add    %rcx,%rax
  8004202f2a:	48 89 02             	mov    %rax,(%rdx)

	//marking page at MPENTRY_PADDR as being used 
	pages[MPENTRY_PADDR / PGSIZE - 1].pp_link = &pages[MPENTRY_PADDR / PGSIZE + 1];
  8004202f2d:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202f34:	00 00 00 
  8004202f37:	48 8b 00             	mov    (%rax),%rax
  8004202f3a:	48 8d 50 60          	lea    0x60(%rax),%rdx
  8004202f3e:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004202f45:	00 00 00 
  8004202f48:	48 8b 00             	mov    (%rax),%rax
  8004202f4b:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004202f4f:	48 89 02             	mov    %rax,(%rdx)
}
  8004202f52:	c9                   	leaveq 
  8004202f53:	c3                   	retq   

0000008004202f54 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004202f54:	55                   	push   %rbp
  8004202f55:	48 89 e5             	mov    %rsp,%rbp
  8004202f58:	48 83 ec 20          	sub    $0x20,%rsp
  8004202f5c:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	struct PageInfo * page = NULL;
  8004202f5f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202f66:	00 
	if(page_free_list)
  8004202f67:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004202f6e:	00 00 00 
  8004202f71:	48 8b 00             	mov    (%rax),%rax
  8004202f74:	48 85 c0             	test   %rax,%rax
  8004202f77:	74 6f                	je     8004202fe8 <page_alloc+0x94>
	{
		page = page_free_list;
  8004202f79:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004202f80:	00 00 00 
  8004202f83:	48 8b 00             	mov    (%rax),%rax
  8004202f86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		page_free_list = page_free_list->pp_link;
  8004202f8a:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004202f91:	00 00 00 
  8004202f94:	48 8b 00             	mov    (%rax),%rax
  8004202f97:	48 8b 10             	mov    (%rax),%rdx
  8004202f9a:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004202fa1:	00 00 00 
  8004202fa4:	48 89 10             	mov    %rdx,(%rax)
		page->pp_link = NULL;
  8004202fa7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fab:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
//		cprintf("Umesh: physical addresses =[%x]\n",page);
		if(alloc_flags & ALLOC_ZERO)
  8004202fb2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202fb5:	83 e0 01             	and    $0x1,%eax
  8004202fb8:	85 c0                	test   %eax,%eax
  8004202fba:	74 2c                	je     8004202fe8 <page_alloc+0x94>
		{
			memset(page2kva(page), '\0', PGSIZE);
  8004202fbc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202fc0:	48 89 c7             	mov    %rax,%rdi
  8004202fc3:	48 b8 ac 1c 20 04 80 	movabs $0x8004201cac,%rax
  8004202fca:	00 00 00 
  8004202fcd:	ff d0                	callq  *%rax
  8004202fcf:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004202fd4:	be 00 00 00 00       	mov    $0x0,%esi
  8004202fd9:	48 89 c7             	mov    %rax,%rdi
  8004202fdc:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004202fe3:	00 00 00 
  8004202fe6:	ff d0                	callq  *%rax
		}
	}
	else{
		//cprintf("page alloc failed\n");
	}
	return page;
  8004202fe8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004202fec:	c9                   	leaveq 
  8004202fed:	c3                   	retq   

0000008004202fee <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  8004202fee:	55                   	push   %rbp
  8004202fef:	48 89 e5             	mov    %rsp,%rbp
  8004202ff2:	48 83 ec 10          	sub    $0x10,%rsp
  8004202ff6:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  8004202ffa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202ffe:	ba 10 00 00 00       	mov    $0x10,%edx
  8004203003:	be 00 00 00 00       	mov    $0x0,%esi
  8004203008:	48 89 c7             	mov    %rax,%rdi
  800420300b:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004203012:	00 00 00 
  8004203015:	ff d0                	callq  *%rax
}
  8004203017:	c9                   	leaveq 
  8004203018:	c3                   	retq   

0000008004203019 <insertAtBegining>:

void insertAtBegining(struct PageInfo ** list, struct PageInfo * node)
{
  8004203019:	55                   	push   %rbp
  800420301a:	48 89 e5             	mov    %rsp,%rbp
  800420301d:	48 83 ec 10          	sub    $0x10,%rsp
  8004203021:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203025:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	if(*list == NULL)
  8004203029:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420302d:	48 8b 00             	mov    (%rax),%rax
  8004203030:	48 85 c0             	test   %rax,%rax
  8004203033:	75 0d                	jne    8004203042 <insertAtBegining+0x29>
	{
		*list = node;
  8004203035:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203039:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420303d:	48 89 10             	mov    %rdx,(%rax)
  8004203040:	eb 2c                	jmp    800420306e <insertAtBegining+0x55>
	}
	else if(*list != NULL && node != NULL)
  8004203042:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203046:	48 8b 00             	mov    (%rax),%rax
  8004203049:	48 85 c0             	test   %rax,%rax
  800420304c:	74 20                	je     800420306e <insertAtBegining+0x55>
  800420304e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203053:	74 19                	je     800420306e <insertAtBegining+0x55>
	{
		node->pp_link = *list;
  8004203055:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203059:	48 8b 10             	mov    (%rax),%rdx
  800420305c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203060:	48 89 10             	mov    %rdx,(%rax)
		*list = node;
  8004203063:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203067:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420306b:	48 89 10             	mov    %rdx,(%rax)
	}
}
  800420306e:	c9                   	leaveq 
  800420306f:	c3                   	retq   

0000008004203070 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  8004203070:	55                   	push   %rbp
  8004203071:	48 89 e5             	mov    %rsp,%rbp
  8004203074:	48 83 ec 10          	sub    $0x10,%rsp
  8004203078:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp->pp_ref != 0)
  800420307c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203080:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203084:	66 85 c0             	test   %ax,%ax
  8004203087:	74 2a                	je     80042030b3 <page_free+0x43>
	{	
		panic("pp->pp_ref is nonzero");
  8004203089:	48 ba b4 d7 21 04 80 	movabs $0x800421d7b4,%rdx
  8004203090:	00 00 00 
  8004203093:	be 08 02 00 00       	mov    $0x208,%esi
  8004203098:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420309f:	00 00 00 
  80042030a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030a7:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  80042030ae:	00 00 00 
  80042030b1:	ff d1                	callq  *%rcx
	}
	else if(pp->pp_link)
  80042030b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030b7:	48 8b 00             	mov    (%rax),%rax
  80042030ba:	48 85 c0             	test   %rax,%rax
  80042030bd:	74 2a                	je     80042030e9 <page_free+0x79>
	{
		panic("pp->pp_link is not NULL");
  80042030bf:	48 ba ca d7 21 04 80 	movabs $0x800421d7ca,%rdx
  80042030c6:	00 00 00 
  80042030c9:	be 0c 02 00 00       	mov    $0x20c,%esi
  80042030ce:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042030d5:	00 00 00 
  80042030d8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042030dd:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  80042030e4:	00 00 00 
  80042030e7:	ff d1                	callq  *%rcx
	}
	else
	{
		//insert node to be freed at the begining of free node list
		insertAtBegining(&page_free_list, pp);
  80042030e9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030ed:	48 89 c6             	mov    %rax,%rsi
  80042030f0:	48 bf 38 d2 3a 04 80 	movabs $0x80043ad238,%rdi
  80042030f7:	00 00 00 
  80042030fa:	48 b8 19 30 20 04 80 	movabs $0x8004203019,%rax
  8004203101:	00 00 00 
  8004203104:	ff d0                	callq  *%rax
	}
}
  8004203106:	c9                   	leaveq 
  8004203107:	c3                   	retq   

0000008004203108 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004203108:	55                   	push   %rbp
  8004203109:	48 89 e5             	mov    %rsp,%rbp
  800420310c:	48 83 ec 10          	sub    $0x10,%rsp
  8004203110:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004203114:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203118:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420311c:	8d 50 ff             	lea    -0x1(%rax),%edx
  800420311f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203123:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004203127:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420312b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420312f:	66 85 c0             	test   %ax,%ax
  8004203132:	75 13                	jne    8004203147 <page_decref+0x3f>
		page_free(pp);
  8004203134:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203138:	48 89 c7             	mov    %rax,%rdi
  800420313b:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004203142:	00 00 00 
  8004203145:	ff d0                	callq  *%rax
}
  8004203147:	c9                   	leaveq 
  8004203148:	c3                   	retq   

0000008004203149 <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  8004203149:	55                   	push   %rbp
  800420314a:	48 89 e5             	mov    %rsp,%rbp
  800420314d:	53                   	push   %rbx
  800420314e:	48 83 ec 58          	sub    $0x58,%rsp
  8004203152:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203156:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420315a:	89 55 ac             	mov    %edx,-0x54(%rbp)
	//Need to return
	pte_t * pml4eIndexPtr = NULL;
  800420315d:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004203164:	00 
	int pml4eIndex;
	int pdpeIndex;
	uint64_t temp;
	struct PageInfo * page = NULL;
  8004203165:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420316c:	00 
	if(pml4e == NULL)
  800420316d:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004203172:	75 0a                	jne    800420317e <pml4e_walk+0x35>
	{
		return NULL;
  8004203174:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203179:	e9 c5 01 00 00       	jmpq   8004203343 <pml4e_walk+0x1fa>
	}
	pml4eIndex = PML4(va);
  800420317e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203182:	48 c1 e8 27          	shr    $0x27,%rax
  8004203186:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420318b:	89 45 dc             	mov    %eax,-0x24(%rbp)

	if((uint64_t*)pml4e[pml4eIndex] == NULL && create == false)
  800420318e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203191:	48 98                	cltq   
  8004203193:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420319a:	00 
  800420319b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420319f:	48 01 d0             	add    %rdx,%rax
  80042031a2:	48 8b 00             	mov    (%rax),%rax
  80042031a5:	48 85 c0             	test   %rax,%rax
  80042031a8:	75 10                	jne    80042031ba <pml4e_walk+0x71>
  80042031aa:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042031ae:	75 0a                	jne    80042031ba <pml4e_walk+0x71>
	{
		return NULL;
  80042031b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031b5:	e9 89 01 00 00       	jmpq   8004203343 <pml4e_walk+0x1fa>
	}
	else if((uint64_t*)pml4e[pml4eIndex] == NULL && create == true)
  80042031ba:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042031bd:	48 98                	cltq   
  80042031bf:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042031c6:	00 
  80042031c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042031cb:	48 01 d0             	add    %rdx,%rax
  80042031ce:	48 8b 00             	mov    (%rax),%rax
  80042031d1:	48 85 c0             	test   %rax,%rax
  80042031d4:	75 7a                	jne    8004203250 <pml4e_walk+0x107>
  80042031d6:	83 7d ac 01          	cmpl   $0x1,-0x54(%rbp)
  80042031da:	75 74                	jne    8004203250 <pml4e_walk+0x107>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042031dc:	c7 45 d8 07 00 00 00 	movl   $0x7,-0x28(%rbp)
		page = page_alloc(ALLOC_ZERO);
  80042031e3:	bf 01 00 00 00       	mov    $0x1,%edi
  80042031e8:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042031ef:	00 00 00 
  80042031f2:	ff d0                	callq  *%rax
  80042031f4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!page)
  80042031f8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042031fd:	75 0a                	jne    8004203209 <pml4e_walk+0xc0>
			return NULL;
  80042031ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203204:	e9 3a 01 00 00       	jmpq   8004203343 <pml4e_walk+0x1fa>
		page->pp_ref++;
  8004203209:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420320d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203211:	8d 50 01             	lea    0x1(%rax),%edx
  8004203214:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203218:	66 89 50 08          	mov    %dx,0x8(%rax)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
		pml4e[pml4eIndex] = page2pa(page) | perm;
  800420321c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420321f:	48 98                	cltq   
  8004203221:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203228:	00 
  8004203229:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420322d:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203231:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203235:	48 89 c7             	mov    %rax,%rdi
  8004203238:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  800420323f:	00 00 00 
  8004203242:	ff d0                	callq  *%rax
  8004203244:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004203247:	48 63 d2             	movslq %edx,%rdx
  800420324a:	48 09 d0             	or     %rdx,%rax
  800420324d:	48 89 03             	mov    %rax,(%rbx)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
	}
	//pml4e entry with last 12 bits permissions
	temp = pml4e[pml4eIndex];
  8004203250:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203253:	48 98                	cltq   
  8004203255:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420325c:	00 
  800420325d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203261:	48 01 d0             	add    %rdx,%rax
  8004203264:	48 8b 00             	mov    (%rax),%rax
  8004203267:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  800420326b:	48 81 65 d0 00 f0 ff 	andq   $0xfffffffffffff000,-0x30(%rbp)
  8004203272:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  8004203273:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203277:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420327b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420327f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203283:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004203286:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004203289:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004203290:	00 00 00 
  8004203293:	48 8b 00             	mov    (%rax),%rax
  8004203296:	48 39 c2             	cmp    %rax,%rdx
  8004203299:	72 32                	jb     80042032cd <pml4e_walk+0x184>
  800420329b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420329f:	48 89 c1             	mov    %rax,%rcx
  80042032a2:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  80042032a9:	00 00 00 
  80042032ac:	be 5c 02 00 00       	mov    $0x25c,%esi
  80042032b1:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042032b8:	00 00 00 
  80042032bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032c0:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042032c7:	00 00 00 
  80042032ca:	41 ff d0             	callq  *%r8
  80042032cd:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042032d4:	00 00 00 
  80042032d7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042032db:	48 01 d0             	add    %rdx,%rax
  80042032de:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//increase pgtable index to get index pointer in page table
	pml4eIndexPtr = (pte_t *)pdpe_walk((pte_t *)temp, va, create); 
  80042032e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042032e6:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042032e9:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  80042032ed:	48 89 ce             	mov    %rcx,%rsi
  80042032f0:	48 89 c7             	mov    %rax,%rdi
  80042032f3:	48 b8 4a 33 20 04 80 	movabs $0x800420334a,%rax
  80042032fa:	00 00 00 
  80042032fd:	ff d0                	callq  *%rax
  80042032ff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	//Null check
	if(pml4eIndexPtr == NULL && page != NULL)
  8004203303:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203308:	75 35                	jne    800420333f <pml4e_walk+0x1f6>
  800420330a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420330f:	74 2e                	je     800420333f <pml4e_walk+0x1f6>
	{
		page_decref(page);
  8004203311:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203315:	48 89 c7             	mov    %rax,%rdi
  8004203318:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  800420331f:	00 00 00 
  8004203322:	ff d0                	callq  *%rax
        pml4e[pml4eIndex] = 0;
  8004203324:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203327:	48 98                	cltq   
  8004203329:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203330:	00 
  8004203331:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203335:	48 01 d0             	add    %rdx,%rax
  8004203338:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	return pml4eIndexPtr;
  800420333f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004203343:	48 83 c4 58          	add    $0x58,%rsp
  8004203347:	5b                   	pop    %rbx
  8004203348:	5d                   	pop    %rbp
  8004203349:	c3                   	retq   

000000800420334a <pdpe_walk>:
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create)
{
  800420334a:	55                   	push   %rbp
  800420334b:	48 89 e5             	mov    %rsp,%rbp
  800420334e:	53                   	push   %rbx
  800420334f:	48 83 ec 68          	sub    $0x68,%rsp
  8004203353:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203357:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420335b:	89 55 9c             	mov    %edx,-0x64(%rbp)
	//Need to return
	pte_t * pdpeIndexPtr = NULL;
  800420335e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203365:	00 
	int pdpeIndex = 0;
  8004203366:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	int pgdirIndex = 0;
  800420336d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	uint64_t temp;
	struct PageInfo * page = NULL;
  8004203374:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800420337b:	00 
	if(pdpe == NULL)
  800420337c:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004203381:	75 0a                	jne    800420338d <pdpe_walk+0x43>
	{
		return NULL;
  8004203383:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203388:	e9 c5 01 00 00       	jmpq   8004203552 <pdpe_walk+0x208>
	}
	pdpeIndex = PDPE(va);
  800420338d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203391:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004203395:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420339a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if(!(uint64_t*)pdpe[pdpeIndex] && create == false)
  800420339d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042033a0:	48 98                	cltq   
  80042033a2:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042033a9:	00 
  80042033aa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042033ae:	48 01 d0             	add    %rdx,%rax
  80042033b1:	48 8b 00             	mov    (%rax),%rax
  80042033b4:	48 85 c0             	test   %rax,%rax
  80042033b7:	75 10                	jne    80042033c9 <pdpe_walk+0x7f>
  80042033b9:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042033bd:	75 0a                	jne    80042033c9 <pdpe_walk+0x7f>
	{
		return NULL;
  80042033bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042033c4:	e9 89 01 00 00       	jmpq   8004203552 <pdpe_walk+0x208>
	}
	else if((uint64_t*)pdpe[pdpeIndex] == NULL && create == true)
  80042033c9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042033cc:	48 98                	cltq   
  80042033ce:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042033d5:	00 
  80042033d6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042033da:	48 01 d0             	add    %rdx,%rax
  80042033dd:	48 8b 00             	mov    (%rax),%rax
  80042033e0:	48 85 c0             	test   %rax,%rax
  80042033e3:	75 7a                	jne    800420345f <pdpe_walk+0x115>
  80042033e5:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  80042033e9:	75 74                	jne    800420345f <pdpe_walk+0x115>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042033eb:	c7 45 d4 07 00 00 00 	movl   $0x7,-0x2c(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  80042033f2:	bf 01 00 00 00       	mov    $0x1,%edi
  80042033f7:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042033fe:	00 00 00 
  8004203401:	ff d0                	callq  *%rax
  8004203403:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if(!page)
  8004203407:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420340c:	75 0a                	jne    8004203418 <pdpe_walk+0xce>
			return NULL;
  800420340e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203413:	e9 3a 01 00 00       	jmpq   8004203552 <pdpe_walk+0x208>
		page->pp_ref++;
  8004203418:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420341c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203420:	8d 50 01             	lea    0x1(%rax),%edx
  8004203423:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203427:	66 89 50 08          	mov    %dx,0x8(%rax)
		pdpe[pdpeIndex] = page2pa(page) | perm;
  800420342b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420342e:	48 98                	cltq   
  8004203430:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203437:	00 
  8004203438:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420343c:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203440:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203444:	48 89 c7             	mov    %rax,%rdi
  8004203447:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  800420344e:	00 00 00 
  8004203451:	ff d0                	callq  *%rax
  8004203453:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203456:	48 63 d2             	movslq %edx,%rdx
  8004203459:	48 09 d0             	or     %rdx,%rax
  800420345c:	48 89 03             	mov    %rax,(%rbx)
	}
	//pdpe entry with last 12 bits permissions
	temp = pdpe[pdpeIndex];
  800420345f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203462:	48 98                	cltq   
  8004203464:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420346b:	00 
  800420346c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203470:	48 01 d0             	add    %rdx,%rax
  8004203473:	48 8b 00             	mov    (%rax),%rax
  8004203476:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  800420347a:	48 81 65 c0 00 f0 ff 	andq   $0xfffffffffffff000,-0x40(%rbp)
  8004203481:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  8004203482:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203486:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  800420348a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420348e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004203492:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  8004203495:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004203498:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  800420349f:	00 00 00 
  80042034a2:	48 8b 00             	mov    (%rax),%rax
  80042034a5:	48 39 c2             	cmp    %rax,%rdx
  80042034a8:	72 32                	jb     80042034dc <pdpe_walk+0x192>
  80042034aa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042034ae:	48 89 c1             	mov    %rax,%rcx
  80042034b1:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  80042034b8:	00 00 00 
  80042034bb:	be 8d 02 00 00       	mov    $0x28d,%esi
  80042034c0:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042034c7:	00 00 00 
  80042034ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034cf:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042034d6:	00 00 00 
  80042034d9:	41 ff d0             	callq  *%r8
  80042034dc:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042034e3:	00 00 00 
  80042034e6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042034ea:	48 01 d0             	add    %rdx,%rax
  80042034ed:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//increase pgtable index to get index pointer in page table
	pdpeIndexPtr = (pte_t *)pgdir_walk((pte_t *)temp, va, create);
  80042034f1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042034f5:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042034f8:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  80042034fc:	48 89 ce             	mov    %rcx,%rsi
  80042034ff:	48 89 c7             	mov    %rax,%rdi
  8004203502:	48 b8 59 35 20 04 80 	movabs $0x8004203559,%rax
  8004203509:	00 00 00 
  800420350c:	ff d0                	callq  *%rax
  800420350e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//Null check
	if(pdpeIndexPtr == NULL && page != NULL)
  8004203512:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203517:	75 35                	jne    800420354e <pdpe_walk+0x204>
  8004203519:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420351e:	74 2e                	je     800420354e <pdpe_walk+0x204>
	{
        page_decref(page);
  8004203520:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203524:	48 89 c7             	mov    %rax,%rdi
  8004203527:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  800420352e:	00 00 00 
  8004203531:	ff d0                	callq  *%rax
        pdpe[pdpeIndex] = 0;
  8004203533:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203536:	48 98                	cltq   
  8004203538:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420353f:	00 
  8004203540:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203544:	48 01 d0             	add    %rdx,%rax
  8004203547:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR(pdpe[pdpeIndex]), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pdpeIndexPtr;
  800420354e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004203552:	48 83 c4 68          	add    $0x68,%rsp
  8004203556:	5b                   	pop    %rbx
  8004203557:	5d                   	pop    %rbp
  8004203558:	c3                   	retq   

0000008004203559 <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  8004203559:	55                   	push   %rbp
  800420355a:	48 89 e5             	mov    %rsp,%rbp
  800420355d:	53                   	push   %rbx
  800420355e:	48 83 ec 68          	sub    $0x68,%rsp
  8004203562:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203566:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420356a:	89 55 9c             	mov    %edx,-0x64(%rbp)
	// Fill this function in
	//Need to return
	pte_t * pgTblIndexPtr = NULL;
  800420356d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203574:	00 
	int dirIndex;
	int pgTblIndex;
	uint64_t temp;
	if(pgdir == NULL)
  8004203575:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  800420357a:	75 0a                	jne    8004203586 <pgdir_walk+0x2d>
	{
		return NULL;
  800420357c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203581:	e9 90 01 00 00       	jmpq   8004203716 <pgdir_walk+0x1bd>
	}
	dirIndex = PDX(va);
  8004203586:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420358a:	48 c1 e8 15          	shr    $0x15,%rax
  800420358e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203593:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	pgTblIndex = PTX(va);
  8004203596:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420359a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420359e:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042035a3:	89 45 e0             	mov    %eax,-0x20(%rbp)
	if((uint64_t*)pgdir[dirIndex] == NULL && create == false)
  80042035a6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042035a9:	48 98                	cltq   
  80042035ab:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042035b2:	00 
  80042035b3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042035b7:	48 01 d0             	add    %rdx,%rax
  80042035ba:	48 8b 00             	mov    (%rax),%rax
  80042035bd:	48 85 c0             	test   %rax,%rax
  80042035c0:	75 10                	jne    80042035d2 <pgdir_walk+0x79>
  80042035c2:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042035c6:	75 0a                	jne    80042035d2 <pgdir_walk+0x79>
	{
		return NULL;
  80042035c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042035cd:	e9 44 01 00 00       	jmpq   8004203716 <pgdir_walk+0x1bd>
	}
	else if((uint64_t*)pgdir[dirIndex] == NULL && create == true)
  80042035d2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042035d5:	48 98                	cltq   
  80042035d7:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042035de:	00 
  80042035df:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042035e3:	48 01 d0             	add    %rdx,%rax
  80042035e6:	48 8b 00             	mov    (%rax),%rax
  80042035e9:	48 85 c0             	test   %rax,%rax
  80042035ec:	75 7a                	jne    8004203668 <pgdir_walk+0x10f>
  80042035ee:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  80042035f2:	75 74                	jne    8004203668 <pgdir_walk+0x10f>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  80042035f4:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  80042035fb:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203600:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004203607:	00 00 00 
  800420360a:	ff d0                	callq  *%rax
  800420360c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!page)
  8004203610:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203615:	75 0a                	jne    8004203621 <pgdir_walk+0xc8>
			return NULL;
  8004203617:	b8 00 00 00 00       	mov    $0x0,%eax
  800420361c:	e9 f5 00 00 00       	jmpq   8004203716 <pgdir_walk+0x1bd>
		page->pp_ref++;
  8004203621:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203625:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203629:	8d 50 01             	lea    0x1(%rax),%edx
  800420362c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203630:	66 89 50 08          	mov    %dx,0x8(%rax)
		pgdir[dirIndex] = page2pa(page) | perm;
  8004203634:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203637:	48 98                	cltq   
  8004203639:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203640:	00 
  8004203641:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203645:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203649:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420364d:	48 89 c7             	mov    %rax,%rdi
  8004203650:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004203657:	00 00 00 
  800420365a:	ff d0                	callq  *%rax
  800420365c:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420365f:	48 63 d2             	movslq %edx,%rdx
  8004203662:	48 09 d0             	or     %rdx,%rax
  8004203665:	48 89 03             	mov    %rax,(%rbx)
	}
	//pgdir entry with last 12 bits permissions
	temp = pgdir[dirIndex];
  8004203668:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420366b:	48 98                	cltq   
  800420366d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203674:	00 
  8004203675:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203679:	48 01 d0             	add    %rdx,%rax
  800420367c:	48 8b 00             	mov    (%rax),%rax
  800420367f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  8004203683:	48 81 65 c8 00 f0 ff 	andq   $0xfffffffffffff000,-0x38(%rbp)
  800420368a:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  800420368b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420368f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004203693:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203697:	48 c1 e8 0c          	shr    $0xc,%rax
  800420369b:	89 45 bc             	mov    %eax,-0x44(%rbp)
  800420369e:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042036a1:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042036a8:	00 00 00 
  80042036ab:	48 8b 00             	mov    (%rax),%rax
  80042036ae:	48 39 c2             	cmp    %rax,%rdx
  80042036b1:	72 32                	jb     80042036e5 <pgdir_walk+0x18c>
  80042036b3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042036b7:	48 89 c1             	mov    %rax,%rcx
  80042036ba:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  80042036c1:	00 00 00 
  80042036c4:	be c0 02 00 00       	mov    $0x2c0,%esi
  80042036c9:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042036d0:	00 00 00 
  80042036d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036d8:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042036df:	00 00 00 
  80042036e2:	41 ff d0             	callq  *%r8
  80042036e5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042036ec:	00 00 00 
  80042036ef:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042036f3:	48 01 d0             	add    %rdx,%rax
  80042036f6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//increase pgtable index to get index pointer in page table
	pgTblIndexPtr = (pte_t *)temp + pgTblIndex;
  80042036fa:	8b 45 e0             	mov    -0x20(%rbp),%eax
  80042036fd:	48 98                	cltq   
  80042036ff:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203706:	00 
  8004203707:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420370b:	48 01 d0             	add    %rdx,%rax
  800420370e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR((uint64_t)(pgdir + dirIndex)), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pgTblIndexPtr;
  8004203712:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004203716:	48 83 c4 68          	add    $0x68,%rsp
  800420371a:	5b                   	pop    %rbx
  800420371b:	5d                   	pop    %rbp
  800420371c:	c3                   	retq   

000000800420371d <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  800420371d:	55                   	push   %rbp
  800420371e:	48 89 e5             	mov    %rsp,%rbp
  8004203721:	48 83 ec 50          	sub    $0x50,%rsp
  8004203725:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203729:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420372d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004203731:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004203735:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
        // Fill this function in
        pte_t *pte_store = NULL;
  8004203739:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203740:	00 
        pte_t * pgTblIndexPtr = NULL;
  8004203741:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203748:	00 

        int i = 0;
  8004203749:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
        if(pml4e == NULL)
  8004203750:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203755:	75 05                	jne    800420375c <boot_map_region+0x3f>
        {
                return;
  8004203757:	e9 82 00 00 00       	jmpq   80042037de <boot_map_region+0xc1>
        }

        for(; i < size / PGSIZE; i++)
  800420375c:	eb 6e                	jmp    80042037cc <boot_map_region+0xaf>
        {
        	pgTblIndexPtr = pml4e_walk(pml4e, (void *)la , 1);
  800420375e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004203762:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203766:	ba 01 00 00 00       	mov    $0x1,%edx
  800420376b:	48 89 ce             	mov    %rcx,%rsi
  800420376e:	48 89 c7             	mov    %rax,%rdi
  8004203771:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  8004203778:	00 00 00 
  800420377b:	ff d0                	callq  *%rax
  800420377d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        	if(pgTblIndexPtr == NULL)
  8004203781:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203786:	75 1d                	jne    80042037a5 <boot_map_region+0x88>
        	{
        		cprintf("Error: could not bootmap");
  8004203788:	48 bf e2 d7 21 04 80 	movabs $0x800421d7e2,%rdi
  800420378f:	00 00 00 
  8004203792:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203797:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420379e:	00 00 00 
  80042037a1:	ff d2                	callq  *%rdx
        	    continue;
  80042037a3:	eb 23                	jmp    80042037c8 <boot_map_region+0xab>
        	}
            *pgTblIndexPtr = pa | perm;
  80042037a5:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042037a8:	48 98                	cltq   
  80042037aa:	48 0b 45 c0          	or     -0x40(%rbp),%rax
  80042037ae:	48 89 c2             	mov    %rax,%rdx
  80042037b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042037b5:	48 89 10             	mov    %rdx,(%rax)
            pa += PGSIZE;
  80042037b8:	48 81 45 c0 00 10 00 	addq   $0x1000,-0x40(%rbp)
  80042037bf:	00 
            la += PGSIZE;
  80042037c0:	48 81 45 d0 00 10 00 	addq   $0x1000,-0x30(%rbp)
  80042037c7:	00 
        if(pml4e == NULL)
        {
                return;
        }

        for(; i < size / PGSIZE; i++)
  80042037c8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042037cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042037cf:	48 98                	cltq   
  80042037d1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042037d5:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042037d9:	48 39 d0             	cmp    %rdx,%rax
  80042037dc:	72 80                	jb     800420375e <boot_map_region+0x41>
        	}
            *pgTblIndexPtr = pa | perm;
            pa += PGSIZE;
            la += PGSIZE;
        }
}
  80042037de:	c9                   	leaveq 
  80042037df:	c3                   	retq   

00000080042037e0 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  80042037e0:	55                   	push   %rbp
  80042037e1:	48 89 e5             	mov    %rsp,%rbp
  80042037e4:	48 83 ec 30          	sub    $0x30,%rsp
  80042037e8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042037ec:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042037f0:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  80042037f4:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	if(pml4e == NULL || pp == NULL)
  80042037f7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042037fc:	74 07                	je     8004203805 <page_insert+0x25>
  80042037fe:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203803:	75 0a                	jne    800420380f <page_insert+0x2f>
	{
		return 0;
  8004203805:	b8 00 00 00 00       	mov    $0x0,%eax
  800420380a:	e9 2c 01 00 00       	jmpq   800420393b <page_insert+0x15b>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  800420380f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203813:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203817:	ba 01 00 00 00       	mov    $0x1,%edx
  800420381c:	48 89 ce             	mov    %rcx,%rsi
  800420381f:	48 89 c7             	mov    %rax,%rdi
  8004203822:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  8004203829:	00 00 00 
  800420382c:	ff d0                	callq  *%rax
  800420382e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//cprintf("pgTblIndexPtr %p %x\n", pgTblIndexPtr, pgTblIndexPtr);
	if(!pgTblIndexPtr)
  8004203832:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203837:	75 0a                	jne    8004203843 <page_insert+0x63>
	{
		return 	-E_NO_MEM;
  8004203839:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420383e:	e9 f8 00 00 00       	jmpq   800420393b <page_insert+0x15b>
	}
	//set present bit
	perm = perm|PTE_P;
  8004203843:	83 4d d4 01          	orl    $0x1,-0x2c(%rbp)
	bool present = *pgTblIndexPtr & PTE_P;
  8004203847:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420384b:	48 8b 00             	mov    (%rax),%rax
  800420384e:	83 e0 01             	and    $0x1,%eax
  8004203851:	48 85 c0             	test   %rax,%rax
  8004203854:	0f 95 c0             	setne  %al
  8004203857:	88 45 f7             	mov    %al,-0x9(%rbp)
	if(present &&pa2page(PTE_ADDR(*pgTblIndexPtr)) == pp)
  800420385a:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  800420385e:	74 66                	je     80042038c6 <page_insert+0xe6>
  8004203860:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203864:	48 8b 00             	mov    (%rax),%rax
  8004203867:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420386d:	48 89 c7             	mov    %rax,%rdi
  8004203870:	48 b8 3b 1c 20 04 80 	movabs $0x8004201c3b,%rax
  8004203877:	00 00 00 
  800420387a:	ff d0                	callq  *%rax
  800420387c:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004203880:	75 44                	jne    80042038c6 <page_insert+0xe6>
	{		
		*pgTblIndexPtr = (page2pa(pp) | perm);
  8004203882:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203886:	48 89 c7             	mov    %rax,%rdi
  8004203889:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004203890:	00 00 00 
  8004203893:	ff d0                	callq  *%rax
  8004203895:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203898:	48 63 d2             	movslq %edx,%rdx
  800420389b:	48 09 c2             	or     %rax,%rdx
  800420389e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042038a2:	48 89 10             	mov    %rdx,(%rax)
		tlb_invalidate(pml4e, va);
  80042038a5:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038ad:	48 89 d6             	mov    %rdx,%rsi
  80042038b0:	48 89 c7             	mov    %rax,%rdi
  80042038b3:	48 b8 65 3a 20 04 80 	movabs $0x8004203a65,%rax
  80042038ba:	00 00 00 
  80042038bd:	ff d0                	callq  *%rax
		return 0;
  80042038bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038c4:	eb 75                	jmp    800420393b <page_insert+0x15b>
	}
	//check and remove previous existing page
	else if(present)
  80042038c6:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80042038ca:	74 34                	je     8004203900 <page_insert+0x120>
	{
		page_remove(pml4e, va);
  80042038cc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038d4:	48 89 d6             	mov    %rdx,%rsi
  80042038d7:	48 89 c7             	mov    %rax,%rdi
  80042038da:	48 b8 d7 39 20 04 80 	movabs $0x80042039d7,%rax
  80042038e1:	00 00 00 
  80042038e4:	ff d0                	callq  *%rax
		//invalidate tlb
		tlb_invalidate(pml4e, va);
  80042038e6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042038ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038ee:	48 89 d6             	mov    %rdx,%rsi
  80042038f1:	48 89 c7             	mov    %rax,%rdi
  80042038f4:	48 b8 65 3a 20 04 80 	movabs $0x8004203a65,%rax
  80042038fb:	00 00 00 
  80042038fe:	ff d0                	callq  *%rax
	}

	//add new page
	*pgTblIndexPtr = (page2pa(pp) | perm);
  8004203900:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203904:	48 89 c7             	mov    %rax,%rdi
  8004203907:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  800420390e:	00 00 00 
  8004203911:	ff d0                	callq  *%rax
  8004203913:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203916:	48 63 d2             	movslq %edx,%rdx
  8004203919:	48 09 c2             	or     %rax,%rdx
  800420391c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203920:	48 89 10             	mov    %rdx,(%rax)

	//increment reference
	pp->pp_ref += 1;
  8004203923:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203927:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420392b:	8d 50 01             	lea    0x1(%rax),%edx
  800420392e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203932:	66 89 50 08          	mov    %dx,0x8(%rax)

	return 0;
  8004203936:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420393b:	c9                   	leaveq 
  800420393c:	c3                   	retq   

000000800420393d <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  800420393d:	55                   	push   %rbp
  800420393e:	48 89 e5             	mov    %rsp,%rbp
  8004203941:	48 83 ec 30          	sub    $0x30,%rsp
  8004203945:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203949:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420394d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	struct PageInfo * page = NULL;
  8004203951:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203958:	00 
	bool present;

	if(pml4e == NULL)
  8004203959:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420395e:	75 06                	jne    8004203966 <page_lookup+0x29>
	{
		return page;
  8004203960:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203964:	eb 6f                	jmp    80042039d5 <page_lookup+0x98>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  8004203966:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420396a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420396e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203973:	48 89 ce             	mov    %rcx,%rsi
  8004203976:	48 89 c7             	mov    %rax,%rdi
  8004203979:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  8004203980:	00 00 00 
  8004203983:	ff d0                	callq  *%rax
  8004203985:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(pgTblIndexPtr == NULL)
  8004203989:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420398e:	75 06                	jne    8004203996 <page_lookup+0x59>
		return page;
  8004203990:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203994:	eb 3f                	jmp    80042039d5 <page_lookup+0x98>
	
	if(*pgTblIndexPtr & PTE_P)
  8004203996:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420399a:	48 8b 00             	mov    (%rax),%rax
  800420399d:	83 e0 01             	and    $0x1,%eax
  80042039a0:	48 85 c0             	test   %rax,%rax
  80042039a3:	74 2c                	je     80042039d1 <page_lookup+0x94>
	{
		page = pa2page(*pgTblIndexPtr);				
  80042039a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042039a9:	48 8b 00             	mov    (%rax),%rax
  80042039ac:	48 89 c7             	mov    %rax,%rdi
  80042039af:	48 b8 3b 1c 20 04 80 	movabs $0x8004201c3b,%rax
  80042039b6:	00 00 00 
  80042039b9:	ff d0                	callq  *%rax
  80042039bb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if(pte_store)
  80042039bf:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042039c4:	74 0b                	je     80042039d1 <page_lookup+0x94>
		{
			*pte_store = pgTblIndexPtr;
  80042039c6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042039ca:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042039ce:	48 89 10             	mov    %rdx,(%rax)
		}
	}
	return page;
  80042039d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042039d5:	c9                   	leaveq 
  80042039d6:	c3                   	retq   

00000080042039d7 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  80042039d7:	55                   	push   %rbp
  80042039d8:	48 89 e5             	mov    %rsp,%rbp
  80042039db:	48 83 ec 20          	sub    $0x20,%rsp
  80042039df:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042039e3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	
	pte_t *pte_store = NULL;
  80042039e7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042039ee:	00 
	struct PageInfo* page_add = NULL;
  80042039ef:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042039f6:	00 
	if(pml4e == NULL)
  80042039f7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042039fc:	75 02                	jne    8004203a00 <page_remove+0x29>
	{
		return;
  80042039fe:	eb 63                	jmp    8004203a63 <page_remove+0x8c>
	}
	
	page_add =  page_lookup(pml4e, va, &pte_store);
  8004203a00:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203a04:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203a08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a0c:	48 89 ce             	mov    %rcx,%rsi
  8004203a0f:	48 89 c7             	mov    %rax,%rdi
  8004203a12:	48 b8 3d 39 20 04 80 	movabs $0x800420393d,%rax
  8004203a19:	00 00 00 
  8004203a1c:	ff d0                	callq  *%rax
  8004203a1e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(page_add == NULL)
  8004203a22:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203a27:	75 02                	jne    8004203a2b <page_remove+0x54>
		return;
  8004203a29:	eb 38                	jmp    8004203a63 <page_remove+0x8c>
	
	tlb_invalidate(pml4e, va);
  8004203a2b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203a2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a33:	48 89 d6             	mov    %rdx,%rsi
  8004203a36:	48 89 c7             	mov    %rax,%rdi
  8004203a39:	48 b8 65 3a 20 04 80 	movabs $0x8004203a65,%rax
  8004203a40:	00 00 00 
  8004203a43:	ff d0                	callq  *%rax
	page_decref(page_add);
  8004203a45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a49:	48 89 c7             	mov    %rax,%rdi
  8004203a4c:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004203a53:	00 00 00 
  8004203a56:	ff d0                	callq  *%rax
	//The pg table entry corresponding to 'va' should be set to 0.
	*pte_store = 0;
  8004203a58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203a5c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
}
  8004203a63:	c9                   	leaveq 
  8004203a64:	c3                   	retq   

0000008004203a65 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203a65:	55                   	push   %rbp
  8004203a66:	48 89 e5             	mov    %rsp,%rbp
  8004203a69:	48 83 ec 20          	sub    $0x20,%rsp
  8004203a6d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203a71:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203a75:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203a7a:	75 35                	jne    8004203ab1 <tlb_invalidate+0x4c>
  8004203a7c:	48 b9 fb d7 21 04 80 	movabs $0x800421d7fb,%rcx
  8004203a83:	00 00 00 
  8004203a86:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004203a8d:	00 00 00 
  8004203a90:	be 85 03 00 00       	mov    $0x385,%esi
  8004203a95:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004203a9c:	00 00 00 
  8004203a9f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203aa4:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004203aab:	00 00 00 
  8004203aae:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203ab1:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004203ab8:	00 00 00 
  8004203abb:	ff d0                	callq  *%rax
  8004203abd:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004203ac4:	00 00 00 
  8004203ac7:	48 98                	cltq   
  8004203ac9:	48 c1 e0 03          	shl    $0x3,%rax
  8004203acd:	48 89 c1             	mov    %rax,%rcx
  8004203ad0:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203ad4:	48 01 c8             	add    %rcx,%rax
  8004203ad7:	48 01 d0             	add    %rdx,%rax
  8004203ada:	48 83 c0 08          	add    $0x8,%rax
  8004203ade:	48 8b 00             	mov    (%rax),%rax
  8004203ae1:	48 85 c0             	test   %rax,%rax
  8004203ae4:	74 3d                	je     8004203b23 <tlb_invalidate+0xbe>
  8004203ae6:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004203aed:	00 00 00 
  8004203af0:	ff d0                	callq  *%rax
  8004203af2:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004203af9:	00 00 00 
  8004203afc:	48 98                	cltq   
  8004203afe:	48 c1 e0 03          	shl    $0x3,%rax
  8004203b02:	48 89 c1             	mov    %rax,%rcx
  8004203b05:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203b09:	48 01 c8             	add    %rcx,%rax
  8004203b0c:	48 01 d0             	add    %rdx,%rax
  8004203b0f:	48 83 c0 08          	add    $0x8,%rax
  8004203b13:	48 8b 00             	mov    (%rax),%rax
  8004203b16:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203b1d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203b21:	75 0f                	jne    8004203b32 <tlb_invalidate+0xcd>
  8004203b23:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203b27:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

    static __inline void 
invlpg(void *addr)
{ 
    __asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203b2b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b2f:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004203b32:	c9                   	leaveq 
  8004203b33:	c3                   	retq   

0000008004203b34 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203b34:	55                   	push   %rbp
  8004203b35:	48 89 e5             	mov    %rsp,%rbp
  8004203b38:	48 83 ec 30          	sub    $0x30,%rsp
  8004203b3c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203b40:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// beginning of the MMIO region.  Because this is static, its
	// value will be preserved between calls to mmio_map_region
	// (just like nextfree in boot_alloc).
	static uintptr_t base = MMIOBASE;
	uintptr_t base_prev;
	base_prev = base;
  8004203b44:	48 b8 c8 35 23 04 80 	movabs $0x80042335c8,%rax
  8004203b4b:	00 00 00 
  8004203b4e:	48 8b 00             	mov    (%rax),%rax
  8004203b51:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	/* check if base+size < MMIOLIM,roundpu size, do we need to round down/round up pa???? move base to new size,*/
	if((base+size) >= MMIOLIM){
  8004203b55:	48 b8 c8 35 23 04 80 	movabs $0x80042335c8,%rax
  8004203b5c:	00 00 00 
  8004203b5f:	48 8b 10             	mov    (%rax),%rdx
  8004203b62:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203b66:	48 01 c2             	add    %rax,%rdx
  8004203b69:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004203b70:	00 00 00 
  8004203b73:	48 39 c2             	cmp    %rax,%rdx
  8004203b76:	76 2a                	jbe    8004203ba2 <mmio_map_region+0x6e>
			panic("Out of bound memory");
  8004203b78:	48 ba 07 d8 21 04 80 	movabs $0x800421d807,%rdx
  8004203b7f:	00 00 00 
  8004203b82:	be ae 03 00 00       	mov    $0x3ae,%esi
  8004203b87:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004203b8e:	00 00 00 
  8004203b91:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203b96:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  8004203b9d:	00 00 00 
  8004203ba0:	ff d1                	callq  *%rcx
	}
	size = ROUNDUP(size, PGSIZE);
  8004203ba2:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004203ba9:	00 
  8004203baa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203bae:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203bb2:	48 01 d0             	add    %rdx,%rax
  8004203bb5:	48 83 e8 01          	sub    $0x1,%rax
  8004203bb9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203bbd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203bc1:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203bc6:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004203bca:	48 89 d0             	mov    %rdx,%rax
  8004203bcd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203bd1:	48 29 c2             	sub    %rax,%rdx
  8004203bd4:	48 89 d0             	mov    %rdx,%rax
  8004203bd7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	boot_map_region(boot_pml4e, base, size,  pa,  PTE_PCD|PTE_PWT|PTE_W|PTE_P);
  8004203bdb:	48 b8 c8 35 23 04 80 	movabs $0x80042335c8,%rax
  8004203be2:	00 00 00 
  8004203be5:	48 8b 30             	mov    (%rax),%rsi
  8004203be8:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004203bef:	00 00 00 
  8004203bf2:	48 8b 00             	mov    (%rax),%rax
  8004203bf5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203bf9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203bfd:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  8004203c03:	48 89 c7             	mov    %rax,%rdi
  8004203c06:	48 b8 1d 37 20 04 80 	movabs $0x800420371d,%rax
  8004203c0d:	00 00 00 
  8004203c10:	ff d0                	callq  *%rax
	base+= size;
  8004203c12:	48 b8 c8 35 23 04 80 	movabs $0x80042335c8,%rax
  8004203c19:	00 00 00 
  8004203c1c:	48 8b 10             	mov    (%rax),%rdx
  8004203c1f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203c23:	48 01 c2             	add    %rax,%rdx
  8004203c26:	48 b8 c8 35 23 04 80 	movabs $0x80042335c8,%rax
  8004203c2d:	00 00 00 
  8004203c30:	48 89 10             	mov    %rdx,(%rax)
	return (void*)base_prev;
  8004203c33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	//panic("mmio_map_region not implemented");

}
  8004203c37:	c9                   	leaveq 
  8004203c38:	c3                   	retq   

0000008004203c39 <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203c39:	55                   	push   %rbp
  8004203c3a:	48 89 e5             	mov    %rsp,%rbp
  8004203c3d:	48 83 ec 50          	sub    $0x50,%rsp
  8004203c41:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004203c45:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203c49:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004203c4d:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
	// LAB 3: Your code here.
	struct PageInfo * page;
	pte_t *pte_store;
	void * vaT = (void*)va;
  8004203c50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203c54:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
  8004203c58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c5c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203c60:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203c64:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203c6a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	vaE = ROUNDUP(vaT + len, PGSIZE);
  8004203c6e:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004203c75:	00 
  8004203c76:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203c7a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203c7e:	48 01 d0             	add    %rdx,%rax
  8004203c81:	48 89 c2             	mov    %rax,%rdx
  8004203c84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203c88:	48 01 d0             	add    %rdx,%rax
  8004203c8b:	48 83 e8 01          	sub    $0x1,%rax
  8004203c8f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203c93:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203c97:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203c9c:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004203ca0:	48 89 d0             	mov    %rdx,%rax
  8004203ca3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203ca7:	48 29 c2             	sub    %rax,%rdx
  8004203caa:	48 89 d0             	mov    %rdx,%rax
  8004203cad:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203cb1:	e9 8c 00 00 00       	jmpq   8004203d42 <user_mem_check+0x109>
	{
		if((uintptr_t)vaT >= ULIM || !page_lookup(env->env_pml4e, vaT, &pte_store) || !pte_store || !(*pte_store & perm))
  8004203cb6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203cba:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004203cc1:	00 00 00 
  8004203cc4:	48 39 c2             	cmp    %rax,%rdx
  8004203cc7:	77 47                	ja     8004203d10 <user_mem_check+0xd7>
  8004203cc9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203ccd:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203cd4:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004203cd8:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004203cdc:	48 89 ce             	mov    %rcx,%rsi
  8004203cdf:	48 89 c7             	mov    %rax,%rdi
  8004203ce2:	48 b8 3d 39 20 04 80 	movabs $0x800420393d,%rax
  8004203ce9:	00 00 00 
  8004203cec:	ff d0                	callq  *%rax
  8004203cee:	48 85 c0             	test   %rax,%rax
  8004203cf1:	74 1d                	je     8004203d10 <user_mem_check+0xd7>
  8004203cf3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203cf7:	48 85 c0             	test   %rax,%rax
  8004203cfa:	74 14                	je     8004203d10 <user_mem_check+0xd7>
  8004203cfc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203d00:	48 8b 10             	mov    (%rax),%rdx
  8004203d03:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004203d06:	48 98                	cltq   
  8004203d08:	48 21 d0             	and    %rdx,%rax
  8004203d0b:	48 85 c0             	test   %rax,%rax
  8004203d0e:	75 2a                	jne    8004203d3a <user_mem_check+0x101>
		{
			if(vaT < va){
  8004203d10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d14:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004203d18:	73 08                	jae    8004203d22 <user_mem_check+0xe9>
				vaT = (void*)va;
  8004203d1a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203d1e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			}
			user_mem_check_addr = (uintptr_t)vaT;
  8004203d22:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203d26:	48 b8 40 d2 3a 04 80 	movabs $0x80043ad240,%rax
  8004203d2d:	00 00 00 
  8004203d30:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;		
  8004203d33:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203d38:	eb 1b                	jmp    8004203d55 <user_mem_check+0x11c>
	pte_t *pte_store;
	void * vaT = (void*)va;
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
	vaE = ROUNDUP(vaT + len, PGSIZE);
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203d3a:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203d41:	00 
  8004203d42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d46:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203d4a:	0f 82 66 ff ff ff    	jb     8004203cb6 <user_mem_check+0x7d>
			}
			user_mem_check_addr = (uintptr_t)vaT;
			return -E_FAULT;		
		}
	}
	return 0;
  8004203d50:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203d55:	c9                   	leaveq 
  8004203d56:	c3                   	retq   

0000008004203d57 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004203d57:	55                   	push   %rbp
  8004203d58:	48 89 e5             	mov    %rsp,%rbp
  8004203d5b:	48 83 ec 20          	sub    $0x20,%rsp
  8004203d5f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203d63:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004203d67:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203d6b:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203d6e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203d71:	83 c8 04             	or     $0x4,%eax
  8004203d74:	89 c1                	mov    %eax,%ecx
  8004203d76:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203d7a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004203d7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d82:	48 89 c7             	mov    %rax,%rdi
  8004203d85:	48 b8 39 3c 20 04 80 	movabs $0x8004203c39,%rax
  8004203d8c:	00 00 00 
  8004203d8f:	ff d0                	callq  *%rax
  8004203d91:	85 c0                	test   %eax,%eax
  8004203d93:	79 47                	jns    8004203ddc <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004203d95:	48 b8 40 d2 3a 04 80 	movabs $0x80043ad240,%rax
  8004203d9c:	00 00 00 
  8004203d9f:	48 8b 10             	mov    (%rax),%rdx
  8004203da2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203da6:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004203dac:	89 c6                	mov    %eax,%esi
  8004203dae:	48 bf 20 d8 21 04 80 	movabs $0x800421d820,%rdi
  8004203db5:	00 00 00 
  8004203db8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203dbd:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  8004203dc4:	00 00 00 
  8004203dc7:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004203dc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203dcd:	48 89 c7             	mov    %rax,%rdi
  8004203dd0:	48 b8 ac 8d 20 04 80 	movabs $0x8004208dac,%rax
  8004203dd7:	00 00 00 
  8004203dda:	ff d0                	callq  *%rax
	}
}
  8004203ddc:	c9                   	leaveq 
  8004203ddd:	c3                   	retq   

0000008004203dde <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004203dde:	55                   	push   %rbp
  8004203ddf:	48 89 e5             	mov    %rsp,%rbp
  8004203de2:	48 83 ec 60          	sub    $0x60,%rsp
  8004203de6:	89 f8                	mov    %edi,%eax
  8004203de8:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203deb:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203def:	74 07                	je     8004203df8 <check_page_free_list+0x1a>
  8004203df1:	b8 01 00 00 00       	mov    $0x1,%eax
  8004203df6:	eb 05                	jmp    8004203dfd <check_page_free_list+0x1f>
  8004203df8:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203dfd:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203e00:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203e07:	00 
  8004203e08:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203e0f:	00 
	char *first_free_page;

	if (!page_free_list)
  8004203e10:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004203e17:	00 00 00 
  8004203e1a:	48 8b 00             	mov    (%rax),%rax
  8004203e1d:	48 85 c0             	test   %rax,%rax
  8004203e20:	75 2a                	jne    8004203e4c <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004203e22:	48 ba 58 d8 21 04 80 	movabs $0x800421d858,%rdx
  8004203e29:	00 00 00 
  8004203e2c:	be 07 04 00 00       	mov    $0x407,%esi
  8004203e31:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004203e38:	00 00 00 
  8004203e3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203e40:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  8004203e47:	00 00 00 
  8004203e4a:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203e4c:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203e50:	0f 84 a9 00 00 00    	je     8004203eff <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004203e56:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203e5a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203e5e:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203e62:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203e66:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004203e6d:	00 00 00 
  8004203e70:	48 8b 00             	mov    (%rax),%rax
  8004203e73:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203e77:	eb 58                	jmp    8004203ed1 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  8004203e79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e7d:	48 89 c7             	mov    %rax,%rdi
  8004203e80:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004203e87:	00 00 00 
  8004203e8a:	ff d0                	callq  *%rax
  8004203e8c:	48 c1 e8 15          	shr    $0x15,%rax
  8004203e90:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203e95:	48 89 c2             	mov    %rax,%rdx
  8004203e98:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203e9b:	48 39 c2             	cmp    %rax,%rdx
  8004203e9e:	0f 93 c0             	setae  %al
  8004203ea1:	0f b6 c0             	movzbl %al,%eax
  8004203ea4:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004203ea7:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203eaa:	48 98                	cltq   
  8004203eac:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004203eb1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203eb5:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004203eb8:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203ebc:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203ebf:	48 98                	cltq   
  8004203ec1:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203ec6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203eca:	48 8b 00             	mov    (%rax),%rax
  8004203ecd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203ed1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203ed6:	75 a1                	jne    8004203e79 <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004203ed8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203edc:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004203ee3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004203ee7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203eeb:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  8004203eee:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203ef2:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004203ef9:	00 00 00 
  8004203efc:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203eff:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004203f06:	00 00 00 
  8004203f09:	48 8b 00             	mov    (%rax),%rax
  8004203f0c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f10:	eb 5e                	jmp    8004203f70 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004203f12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f16:	48 89 c7             	mov    %rax,%rdi
  8004203f19:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004203f20:	00 00 00 
  8004203f23:	ff d0                	callq  *%rax
  8004203f25:	48 c1 e8 15          	shr    $0x15,%rax
  8004203f29:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203f2e:	48 89 c2             	mov    %rax,%rdx
  8004203f31:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203f34:	48 39 c2             	cmp    %rax,%rdx
  8004203f37:	73 2c                	jae    8004203f65 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  8004203f39:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f3d:	48 89 c7             	mov    %rax,%rdi
  8004203f40:	48 b8 ac 1c 20 04 80 	movabs $0x8004201cac,%rax
  8004203f47:	00 00 00 
  8004203f4a:	ff d0                	callq  *%rax
  8004203f4c:	ba 80 00 00 00       	mov    $0x80,%edx
  8004203f51:	be 97 00 00 00       	mov    $0x97,%esi
  8004203f56:	48 89 c7             	mov    %rax,%rdi
  8004203f59:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004203f60:	00 00 00 
  8004203f63:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004203f65:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f69:	48 8b 00             	mov    (%rax),%rax
  8004203f6c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f70:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203f75:	75 9b                	jne    8004203f12 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  8004203f77:	bf 00 00 00 00       	mov    $0x0,%edi
  8004203f7c:	48 b8 d5 25 20 04 80 	movabs $0x80042025d5,%rax
  8004203f83:	00 00 00 
  8004203f86:	ff d0                	callq  *%rax
  8004203f88:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203f8c:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004203f93:	00 00 00 
  8004203f96:	48 8b 00             	mov    (%rax),%rax
  8004203f99:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203f9d:	e9 20 03 00 00       	jmpq   80042042c2 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  8004203fa2:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004203fa9:	00 00 00 
  8004203fac:	48 8b 00             	mov    (%rax),%rax
  8004203faf:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004203fb3:	73 35                	jae    8004203fea <check_page_free_list+0x20c>
  8004203fb5:	48 b9 7c d8 21 04 80 	movabs $0x800421d87c,%rcx
  8004203fbc:	00 00 00 
  8004203fbf:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004203fc6:	00 00 00 
  8004203fc9:	be 21 04 00 00       	mov    $0x421,%esi
  8004203fce:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004203fd5:	00 00 00 
  8004203fd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203fdd:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004203fe4:	00 00 00 
  8004203fe7:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  8004203fea:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004203ff1:	00 00 00 
  8004203ff4:	48 8b 10             	mov    (%rax),%rdx
  8004203ff7:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004203ffe:	00 00 00 
  8004204001:	48 8b 00             	mov    (%rax),%rax
  8004204004:	48 c1 e0 04          	shl    $0x4,%rax
  8004204008:	48 01 d0             	add    %rdx,%rax
  800420400b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420400f:	77 35                	ja     8004204046 <check_page_free_list+0x268>
  8004204011:	48 b9 88 d8 21 04 80 	movabs $0x800421d888,%rcx
  8004204018:	00 00 00 
  800420401b:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204022:	00 00 00 
  8004204025:	be 22 04 00 00       	mov    $0x422,%esi
  800420402a:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204031:	00 00 00 
  8004204034:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204039:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204040:	00 00 00 
  8004204043:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004204046:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420404a:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004204051:	00 00 00 
  8004204054:	48 8b 00             	mov    (%rax),%rax
  8004204057:	48 29 c2             	sub    %rax,%rdx
  800420405a:	48 89 d0             	mov    %rdx,%rax
  800420405d:	83 e0 0f             	and    $0xf,%eax
  8004204060:	48 85 c0             	test   %rax,%rax
  8004204063:	74 35                	je     800420409a <check_page_free_list+0x2bc>
  8004204065:	48 b9 a0 d8 21 04 80 	movabs $0x800421d8a0,%rcx
  800420406c:	00 00 00 
  800420406f:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204076:	00 00 00 
  8004204079:	be 23 04 00 00       	mov    $0x423,%esi
  800420407e:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204085:	00 00 00 
  8004204088:	b8 00 00 00 00       	mov    $0x0,%eax
  800420408d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204094:	00 00 00 
  8004204097:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  800420409a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420409e:	48 89 c7             	mov    %rax,%rdi
  80042040a1:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  80042040a8:	00 00 00 
  80042040ab:	ff d0                	callq  *%rax
  80042040ad:	48 85 c0             	test   %rax,%rax
  80042040b0:	75 35                	jne    80042040e7 <check_page_free_list+0x309>
  80042040b2:	48 b9 d2 d8 21 04 80 	movabs $0x800421d8d2,%rcx
  80042040b9:	00 00 00 
  80042040bc:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042040c3:	00 00 00 
  80042040c6:	be 26 04 00 00       	mov    $0x426,%esi
  80042040cb:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042040d2:	00 00 00 
  80042040d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042040da:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042040e1:	00 00 00 
  80042040e4:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  80042040e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040eb:	48 89 c7             	mov    %rax,%rdi
  80042040ee:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  80042040f5:	00 00 00 
  80042040f8:	ff d0                	callq  *%rax
  80042040fa:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204100:	75 35                	jne    8004204137 <check_page_free_list+0x359>
  8004204102:	48 b9 e3 d8 21 04 80 	movabs $0x800421d8e3,%rcx
  8004204109:	00 00 00 
  800420410c:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204113:	00 00 00 
  8004204116:	be 27 04 00 00       	mov    $0x427,%esi
  800420411b:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204122:	00 00 00 
  8004204125:	b8 00 00 00 00       	mov    $0x0,%eax
  800420412a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204131:	00 00 00 
  8004204134:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004204137:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420413b:	48 89 c7             	mov    %rax,%rdi
  800420413e:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004204145:	00 00 00 
  8004204148:	ff d0                	callq  *%rax
  800420414a:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204150:	75 35                	jne    8004204187 <check_page_free_list+0x3a9>
  8004204152:	48 b9 00 d9 21 04 80 	movabs $0x800421d900,%rcx
  8004204159:	00 00 00 
  800420415c:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204163:	00 00 00 
  8004204166:	be 28 04 00 00       	mov    $0x428,%esi
  800420416b:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204172:	00 00 00 
  8004204175:	b8 00 00 00 00       	mov    $0x0,%eax
  800420417a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204181:	00 00 00 
  8004204184:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  8004204187:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420418b:	48 89 c7             	mov    %rax,%rdi
  800420418e:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004204195:	00 00 00 
  8004204198:	ff d0                	callq  *%rax
  800420419a:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042041a0:	75 35                	jne    80042041d7 <check_page_free_list+0x3f9>
  80042041a2:	48 b9 23 d9 21 04 80 	movabs $0x800421d923,%rcx
  80042041a9:	00 00 00 
  80042041ac:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042041b3:	00 00 00 
  80042041b6:	be 29 04 00 00       	mov    $0x429,%esi
  80042041bb:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042041c2:	00 00 00 
  80042041c5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041ca:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042041d1:	00 00 00 
  80042041d4:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  80042041d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041db:	48 89 c7             	mov    %rax,%rdi
  80042041de:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  80042041e5:	00 00 00 
  80042041e8:	ff d0                	callq  *%rax
  80042041ea:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042041f0:	76 4e                	jbe    8004204240 <check_page_free_list+0x462>
  80042041f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041f6:	48 89 c7             	mov    %rax,%rdi
  80042041f9:	48 b8 ac 1c 20 04 80 	movabs $0x8004201cac,%rax
  8004204200:	00 00 00 
  8004204203:	ff d0                	callq  *%rax
  8004204205:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004204209:	73 35                	jae    8004204240 <check_page_free_list+0x462>
  800420420b:	48 b9 40 d9 21 04 80 	movabs $0x800421d940,%rcx
  8004204212:	00 00 00 
  8004204215:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420421c:	00 00 00 
  800420421f:	be 2a 04 00 00       	mov    $0x42a,%esi
  8004204224:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420422b:	00 00 00 
  800420422e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204233:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420423a:	00 00 00 
  800420423d:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004204240:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204244:	48 89 c7             	mov    %rax,%rdi
  8004204247:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  800420424e:	00 00 00 
  8004204251:	ff d0                	callq  *%rax
  8004204253:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  8004204259:	75 35                	jne    8004204290 <check_page_free_list+0x4b2>
  800420425b:	48 b9 85 d9 21 04 80 	movabs $0x800421d985,%rcx
  8004204262:	00 00 00 
  8004204265:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420426c:	00 00 00 
  800420426f:	be 2c 04 00 00       	mov    $0x42c,%esi
  8004204274:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420427b:	00 00 00 
  800420427e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204283:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420428a:	00 00 00 
  800420428d:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  8004204290:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204294:	48 89 c7             	mov    %rax,%rdi
  8004204297:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  800420429e:	00 00 00 
  80042042a1:	ff d0                	callq  *%rax
  80042042a3:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042042a9:	77 07                	ja     80042042b2 <check_page_free_list+0x4d4>
			++nfree_basemem;
  80042042ab:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042042b0:	eb 05                	jmp    80042042b7 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  80042042b2:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042042b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042bb:	48 8b 00             	mov    (%rax),%rax
  80042042be:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042042c2:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042042c7:	0f 85 d5 fc ff ff    	jne    8004203fa2 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  80042042cd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042042d2:	75 35                	jne    8004204309 <check_page_free_list+0x52b>
  80042042d4:	48 b9 a2 d9 21 04 80 	movabs $0x800421d9a2,%rcx
  80042042db:	00 00 00 
  80042042de:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042042e5:	00 00 00 
  80042042e8:	be 34 04 00 00       	mov    $0x434,%esi
  80042042ed:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042042f4:	00 00 00 
  80042042f7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042fc:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204303:	00 00 00 
  8004204306:	41 ff d0             	callq  *%r8
}
  8004204309:	c9                   	leaveq 
  800420430a:	c3                   	retq   

000000800420430b <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  800420430b:	55                   	push   %rbp
  800420430c:	48 89 e5             	mov    %rsp,%rbp
  800420430f:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204313:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  800420431a:	00 00 00 
  800420431d:	48 8b 00             	mov    (%rax),%rax
  8004204320:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204324:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420432b:	eb 37                	jmp    8004204364 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  800420432d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204331:	48 89 c7             	mov    %rax,%rdi
  8004204334:	48 b8 ac 1c 20 04 80 	movabs $0x8004201cac,%rax
  800420433b:	00 00 00 
  800420433e:	ff d0                	callq  *%rax
  8004204340:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204345:	be 97 00 00 00       	mov    $0x97,%esi
  800420434a:	48 89 c7             	mov    %rax,%rdi
  800420434d:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004204354:	00 00 00 
  8004204357:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204359:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420435d:	48 8b 00             	mov    (%rax),%rax
  8004204360:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204364:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204369:	75 c2                	jne    800420432d <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420436b:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004204372:	00 00 00 
  8004204375:	48 8b 00             	mov    (%rax),%rax
  8004204378:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420437c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  8004204383:	e9 ec 01 00 00       	jmpq   8004204574 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  8004204388:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  800420438f:	00 00 00 
  8004204392:	48 8b 00             	mov    (%rax),%rax
  8004204395:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004204399:	73 35                	jae    80042043d0 <check_page_alloc+0xc5>
  800420439b:	48 b9 b3 d9 21 04 80 	movabs $0x800421d9b3,%rcx
  80042043a2:	00 00 00 
  80042043a5:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042043ac:	00 00 00 
  80042043af:	be 4d 04 00 00       	mov    $0x44d,%esi
  80042043b4:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042043bb:	00 00 00 
  80042043be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043c3:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042043ca:	00 00 00 
  80042043cd:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  80042043d0:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  80042043d7:	00 00 00 
  80042043da:	48 8b 10             	mov    (%rax),%rdx
  80042043dd:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042043e4:	00 00 00 
  80042043e7:	48 8b 00             	mov    (%rax),%rax
  80042043ea:	48 c1 e0 04          	shl    $0x4,%rax
  80042043ee:	48 01 d0             	add    %rdx,%rax
  80042043f1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042043f5:	77 35                	ja     800420442c <check_page_alloc+0x121>
  80042043f7:	48 b9 c0 d9 21 04 80 	movabs $0x800421d9c0,%rcx
  80042043fe:	00 00 00 
  8004204401:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204408:	00 00 00 
  800420440b:	be 4e 04 00 00       	mov    $0x44e,%esi
  8004204410:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204417:	00 00 00 
  800420441a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420441f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204426:	00 00 00 
  8004204429:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  800420442c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204430:	48 89 c7             	mov    %rax,%rdi
  8004204433:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  800420443a:	00 00 00 
  800420443d:	ff d0                	callq  *%rax
  800420443f:	48 85 c0             	test   %rax,%rax
  8004204442:	75 35                	jne    8004204479 <check_page_alloc+0x16e>
  8004204444:	48 b9 d5 d9 21 04 80 	movabs $0x800421d9d5,%rcx
  800420444b:	00 00 00 
  800420444e:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204455:	00 00 00 
  8004204458:	be 51 04 00 00       	mov    $0x451,%esi
  800420445d:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204464:	00 00 00 
  8004204467:	b8 00 00 00 00       	mov    $0x0,%eax
  800420446c:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204473:	00 00 00 
  8004204476:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  8004204479:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420447d:	48 89 c7             	mov    %rax,%rdi
  8004204480:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004204487:	00 00 00 
  800420448a:	ff d0                	callq  *%rax
  800420448c:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204492:	75 35                	jne    80042044c9 <check_page_alloc+0x1be>
  8004204494:	48 b9 e7 d9 21 04 80 	movabs $0x800421d9e7,%rcx
  800420449b:	00 00 00 
  800420449e:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042044a5:	00 00 00 
  80042044a8:	be 52 04 00 00       	mov    $0x452,%esi
  80042044ad:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042044b4:	00 00 00 
  80042044b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042044bc:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042044c3:	00 00 00 
  80042044c6:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  80042044c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042044cd:	48 89 c7             	mov    %rax,%rdi
  80042044d0:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  80042044d7:	00 00 00 
  80042044da:	ff d0                	callq  *%rax
  80042044dc:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  80042044e2:	75 35                	jne    8004204519 <check_page_alloc+0x20e>
  80042044e4:	48 b9 08 da 21 04 80 	movabs $0x800421da08,%rcx
  80042044eb:	00 00 00 
  80042044ee:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042044f5:	00 00 00 
  80042044f8:	be 53 04 00 00       	mov    $0x453,%esi
  80042044fd:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204504:	00 00 00 
  8004204507:	b8 00 00 00 00       	mov    $0x0,%eax
  800420450c:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204513:	00 00 00 
  8004204516:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  8004204519:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420451d:	48 89 c7             	mov    %rax,%rdi
  8004204520:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004204527:	00 00 00 
  800420452a:	ff d0                	callq  *%rax
  800420452c:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204532:	75 35                	jne    8004204569 <check_page_alloc+0x25e>
  8004204534:	48 b9 2c da 21 04 80 	movabs $0x800421da2c,%rcx
  800420453b:	00 00 00 
  800420453e:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204545:	00 00 00 
  8004204548:	be 54 04 00 00       	mov    $0x454,%esi
  800420454d:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204554:	00 00 00 
  8004204557:	b8 00 00 00 00       	mov    $0x0,%eax
  800420455c:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204563:	00 00 00 
  8004204566:	41 ff d0             	callq  *%r8
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204569:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420456d:	48 8b 00             	mov    (%rax),%rax
  8004204570:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204574:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204579:	0f 85 09 fe ff ff    	jne    8004204388 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  800420457f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204586:	00 
  8004204587:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420458b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420458f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204593:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204597:	bf 00 00 00 00       	mov    $0x0,%edi
  800420459c:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042045a3:	00 00 00 
  80042045a6:	ff d0                	callq  *%rax
  80042045a8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042045ac:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042045b1:	75 35                	jne    80042045e8 <check_page_alloc+0x2dd>
  80042045b3:	48 b9 47 da 21 04 80 	movabs $0x800421da47,%rcx
  80042045ba:	00 00 00 
  80042045bd:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042045c4:	00 00 00 
  80042045c7:	be 58 04 00 00       	mov    $0x458,%esi
  80042045cc:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042045d3:	00 00 00 
  80042045d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045db:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042045e2:	00 00 00 
  80042045e5:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  80042045e8:	bf 00 00 00 00       	mov    $0x0,%edi
  80042045ed:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042045f4:	00 00 00 
  80042045f7:	ff d0                	callq  *%rax
  80042045f9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042045fd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204602:	75 35                	jne    8004204639 <check_page_alloc+0x32e>
  8004204604:	48 b9 5d da 21 04 80 	movabs $0x800421da5d,%rcx
  800420460b:	00 00 00 
  800420460e:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204615:	00 00 00 
  8004204618:	be 59 04 00 00       	mov    $0x459,%esi
  800420461d:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204624:	00 00 00 
  8004204627:	b8 00 00 00 00       	mov    $0x0,%eax
  800420462c:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204633:	00 00 00 
  8004204636:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204639:	bf 00 00 00 00       	mov    $0x0,%edi
  800420463e:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004204645:	00 00 00 
  8004204648:	ff d0                	callq  *%rax
  800420464a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420464e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204653:	75 35                	jne    800420468a <check_page_alloc+0x37f>
  8004204655:	48 b9 73 da 21 04 80 	movabs $0x800421da73,%rcx
  800420465c:	00 00 00 
  800420465f:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204666:	00 00 00 
  8004204669:	be 5a 04 00 00       	mov    $0x45a,%esi
  800420466e:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204675:	00 00 00 
  8004204678:	b8 00 00 00 00       	mov    $0x0,%eax
  800420467d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204684:	00 00 00 
  8004204687:	41 ff d0             	callq  *%r8
	assert(pp0);
  800420468a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420468f:	75 35                	jne    80042046c6 <check_page_alloc+0x3bb>
  8004204691:	48 b9 89 da 21 04 80 	movabs $0x800421da89,%rcx
  8004204698:	00 00 00 
  800420469b:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042046a2:	00 00 00 
  80042046a5:	be 5b 04 00 00       	mov    $0x45b,%esi
  80042046aa:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042046b1:	00 00 00 
  80042046b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046b9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042046c0:	00 00 00 
  80042046c3:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  80042046c6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042046cb:	74 0a                	je     80042046d7 <check_page_alloc+0x3cc>
  80042046cd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042046d1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042046d5:	75 35                	jne    800420470c <check_page_alloc+0x401>
  80042046d7:	48 b9 8d da 21 04 80 	movabs $0x800421da8d,%rcx
  80042046de:	00 00 00 
  80042046e1:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042046e8:	00 00 00 
  80042046eb:	be 5c 04 00 00       	mov    $0x45c,%esi
  80042046f0:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042046f7:	00 00 00 
  80042046fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042046ff:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204706:	00 00 00 
  8004204709:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  800420470c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204711:	74 14                	je     8004204727 <check_page_alloc+0x41c>
  8004204713:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204717:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420471b:	74 0a                	je     8004204727 <check_page_alloc+0x41c>
  800420471d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204721:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204725:	75 35                	jne    800420475c <check_page_alloc+0x451>
  8004204727:	48 b9 a0 da 21 04 80 	movabs $0x800421daa0,%rcx
  800420472e:	00 00 00 
  8004204731:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204738:	00 00 00 
  800420473b:	be 5d 04 00 00       	mov    $0x45d,%esi
  8004204740:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204747:	00 00 00 
  800420474a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420474f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204756:	00 00 00 
  8004204759:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  800420475c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204760:	48 89 c7             	mov    %rax,%rdi
  8004204763:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  800420476a:	00 00 00 
  800420476d:	ff d0                	callq  *%rax
  800420476f:	48 ba 98 e7 3a 04 80 	movabs $0x80043ae798,%rdx
  8004204776:	00 00 00 
  8004204779:	48 8b 12             	mov    (%rdx),%rdx
  800420477c:	48 c1 e2 0c          	shl    $0xc,%rdx
  8004204780:	48 39 d0             	cmp    %rdx,%rax
  8004204783:	72 35                	jb     80042047ba <check_page_alloc+0x4af>
  8004204785:	48 b9 c0 da 21 04 80 	movabs $0x800421dac0,%rcx
  800420478c:	00 00 00 
  800420478f:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204796:	00 00 00 
  8004204799:	be 5e 04 00 00       	mov    $0x45e,%esi
  800420479e:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042047a5:	00 00 00 
  80042047a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047ad:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042047b4:	00 00 00 
  80042047b7:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  80042047ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042047be:	48 89 c7             	mov    %rax,%rdi
  80042047c1:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  80042047c8:	00 00 00 
  80042047cb:	ff d0                	callq  *%rax
  80042047cd:	48 ba 98 e7 3a 04 80 	movabs $0x80043ae798,%rdx
  80042047d4:	00 00 00 
  80042047d7:	48 8b 12             	mov    (%rdx),%rdx
  80042047da:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042047de:	48 39 d0             	cmp    %rdx,%rax
  80042047e1:	72 35                	jb     8004204818 <check_page_alloc+0x50d>
  80042047e3:	48 b9 dd da 21 04 80 	movabs $0x800421dadd,%rcx
  80042047ea:	00 00 00 
  80042047ed:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042047f4:	00 00 00 
  80042047f7:	be 5f 04 00 00       	mov    $0x45f,%esi
  80042047fc:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204803:	00 00 00 
  8004204806:	b8 00 00 00 00       	mov    $0x0,%eax
  800420480b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204812:	00 00 00 
  8004204815:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204818:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420481c:	48 89 c7             	mov    %rax,%rdi
  800420481f:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004204826:	00 00 00 
  8004204829:	ff d0                	callq  *%rax
  800420482b:	48 ba 98 e7 3a 04 80 	movabs $0x80043ae798,%rdx
  8004204832:	00 00 00 
  8004204835:	48 8b 12             	mov    (%rdx),%rdx
  8004204838:	48 c1 e2 0c          	shl    $0xc,%rdx
  800420483c:	48 39 d0             	cmp    %rdx,%rax
  800420483f:	72 35                	jb     8004204876 <check_page_alloc+0x56b>
  8004204841:	48 b9 fa da 21 04 80 	movabs $0x800421dafa,%rcx
  8004204848:	00 00 00 
  800420484b:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204852:	00 00 00 
  8004204855:	be 60 04 00 00       	mov    $0x460,%esi
  800420485a:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204861:	00 00 00 
  8004204864:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204869:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204870:	00 00 00 
  8004204873:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004204876:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  800420487d:	00 00 00 
  8004204880:	48 8b 00             	mov    (%rax),%rax
  8004204883:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  8004204887:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  800420488e:	00 00 00 
  8004204891:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004204898:	bf 00 00 00 00       	mov    $0x0,%edi
  800420489d:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042048a4:	00 00 00 
  80042048a7:	ff d0                	callq  *%rax
  80042048a9:	48 85 c0             	test   %rax,%rax
  80042048ac:	74 35                	je     80042048e3 <check_page_alloc+0x5d8>
  80042048ae:	48 b9 17 db 21 04 80 	movabs $0x800421db17,%rcx
  80042048b5:	00 00 00 
  80042048b8:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042048bf:	00 00 00 
  80042048c2:	be 67 04 00 00       	mov    $0x467,%esi
  80042048c7:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042048ce:	00 00 00 
  80042048d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048d6:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042048dd:	00 00 00 
  80042048e0:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  80042048e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048e7:	48 89 c7             	mov    %rax,%rdi
  80042048ea:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  80042048f1:	00 00 00 
  80042048f4:	ff d0                	callq  *%rax
	page_free(pp1);
  80042048f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042048fa:	48 89 c7             	mov    %rax,%rdi
  80042048fd:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004204904:	00 00 00 
  8004204907:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204909:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420490d:	48 89 c7             	mov    %rax,%rdi
  8004204910:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004204917:	00 00 00 
  800420491a:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  800420491c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204923:	00 
  8004204924:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204928:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420492c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204930:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204934:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204939:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004204940:	00 00 00 
  8004204943:	ff d0                	callq  *%rax
  8004204945:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204949:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420494e:	75 35                	jne    8004204985 <check_page_alloc+0x67a>
  8004204950:	48 b9 47 da 21 04 80 	movabs $0x800421da47,%rcx
  8004204957:	00 00 00 
  800420495a:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204961:	00 00 00 
  8004204964:	be 6e 04 00 00       	mov    $0x46e,%esi
  8004204969:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204970:	00 00 00 
  8004204973:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204978:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420497f:	00 00 00 
  8004204982:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204985:	bf 00 00 00 00       	mov    $0x0,%edi
  800420498a:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004204991:	00 00 00 
  8004204994:	ff d0                	callq  *%rax
  8004204996:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420499a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420499f:	75 35                	jne    80042049d6 <check_page_alloc+0x6cb>
  80042049a1:	48 b9 5d da 21 04 80 	movabs $0x800421da5d,%rcx
  80042049a8:	00 00 00 
  80042049ab:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042049b2:	00 00 00 
  80042049b5:	be 6f 04 00 00       	mov    $0x46f,%esi
  80042049ba:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042049c1:	00 00 00 
  80042049c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049c9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042049d0:	00 00 00 
  80042049d3:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  80042049d6:	bf 00 00 00 00       	mov    $0x0,%edi
  80042049db:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042049e2:	00 00 00 
  80042049e5:	ff d0                	callq  *%rax
  80042049e7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042049eb:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042049f0:	75 35                	jne    8004204a27 <check_page_alloc+0x71c>
  80042049f2:	48 b9 73 da 21 04 80 	movabs $0x800421da73,%rcx
  80042049f9:	00 00 00 
  80042049fc:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204a03:	00 00 00 
  8004204a06:	be 70 04 00 00       	mov    $0x470,%esi
  8004204a0b:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204a12:	00 00 00 
  8004204a15:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a1a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204a21:	00 00 00 
  8004204a24:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204a27:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204a2c:	75 35                	jne    8004204a63 <check_page_alloc+0x758>
  8004204a2e:	48 b9 89 da 21 04 80 	movabs $0x800421da89,%rcx
  8004204a35:	00 00 00 
  8004204a38:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204a3f:	00 00 00 
  8004204a42:	be 71 04 00 00       	mov    $0x471,%esi
  8004204a47:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204a4e:	00 00 00 
  8004204a51:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a56:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204a5d:	00 00 00 
  8004204a60:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204a63:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204a68:	74 0a                	je     8004204a74 <check_page_alloc+0x769>
  8004204a6a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a6e:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204a72:	75 35                	jne    8004204aa9 <check_page_alloc+0x79e>
  8004204a74:	48 b9 8d da 21 04 80 	movabs $0x800421da8d,%rcx
  8004204a7b:	00 00 00 
  8004204a7e:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204a85:	00 00 00 
  8004204a88:	be 72 04 00 00       	mov    $0x472,%esi
  8004204a8d:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204a94:	00 00 00 
  8004204a97:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a9c:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204aa3:	00 00 00 
  8004204aa6:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204aa9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204aae:	74 14                	je     8004204ac4 <check_page_alloc+0x7b9>
  8004204ab0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ab4:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204ab8:	74 0a                	je     8004204ac4 <check_page_alloc+0x7b9>
  8004204aba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204abe:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204ac2:	75 35                	jne    8004204af9 <check_page_alloc+0x7ee>
  8004204ac4:	48 b9 a0 da 21 04 80 	movabs $0x800421daa0,%rcx
  8004204acb:	00 00 00 
  8004204ace:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204ad5:	00 00 00 
  8004204ad8:	be 73 04 00 00       	mov    $0x473,%esi
  8004204add:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204ae4:	00 00 00 
  8004204ae7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204aec:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204af3:	00 00 00 
  8004204af6:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204af9:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204afe:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004204b05:	00 00 00 
  8004204b08:	ff d0                	callq  *%rax
  8004204b0a:	48 85 c0             	test   %rax,%rax
  8004204b0d:	74 35                	je     8004204b44 <check_page_alloc+0x839>
  8004204b0f:	48 b9 17 db 21 04 80 	movabs $0x800421db17,%rcx
  8004204b16:	00 00 00 
  8004204b19:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204b20:	00 00 00 
  8004204b23:	be 74 04 00 00       	mov    $0x474,%esi
  8004204b28:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204b2f:	00 00 00 
  8004204b32:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b37:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204b3e:	00 00 00 
  8004204b41:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204b44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b48:	48 89 c7             	mov    %rax,%rdi
  8004204b4b:	48 b8 ac 1c 20 04 80 	movabs $0x8004201cac,%rax
  8004204b52:	00 00 00 
  8004204b55:	ff d0                	callq  *%rax
  8004204b57:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204b5c:	be 01 00 00 00       	mov    $0x1,%esi
  8004204b61:	48 89 c7             	mov    %rax,%rdi
  8004204b64:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004204b6b:	00 00 00 
  8004204b6e:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204b70:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204b74:	48 89 c7             	mov    %rax,%rdi
  8004204b77:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004204b7e:	00 00 00 
  8004204b81:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204b83:	bf 01 00 00 00       	mov    $0x1,%edi
  8004204b88:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004204b8f:	00 00 00 
  8004204b92:	ff d0                	callq  *%rax
  8004204b94:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204b98:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204b9d:	75 35                	jne    8004204bd4 <check_page_alloc+0x8c9>
  8004204b9f:	48 b9 26 db 21 04 80 	movabs $0x800421db26,%rcx
  8004204ba6:	00 00 00 
  8004204ba9:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204bb0:	00 00 00 
  8004204bb3:	be 79 04 00 00       	mov    $0x479,%esi
  8004204bb8:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204bbf:	00 00 00 
  8004204bc2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bc7:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204bce:	00 00 00 
  8004204bd1:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004204bd4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204bd9:	74 0a                	je     8004204be5 <check_page_alloc+0x8da>
  8004204bdb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204bdf:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204be3:	74 35                	je     8004204c1a <check_page_alloc+0x90f>
  8004204be5:	48 b9 44 db 21 04 80 	movabs $0x800421db44,%rcx
  8004204bec:	00 00 00 
  8004204bef:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204bf6:	00 00 00 
  8004204bf9:	be 7a 04 00 00       	mov    $0x47a,%esi
  8004204bfe:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204c05:	00 00 00 
  8004204c08:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c0d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204c14:	00 00 00 
  8004204c17:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204c1a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204c1e:	48 89 c7             	mov    %rax,%rdi
  8004204c21:	48 b8 ac 1c 20 04 80 	movabs $0x8004201cac,%rax
  8004204c28:	00 00 00 
  8004204c2b:	ff d0                	callq  *%rax
  8004204c2d:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004204c31:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204c38:	eb 4d                	jmp    8004204c87 <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204c3a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204c3d:	48 63 d0             	movslq %eax,%rdx
  8004204c40:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204c44:	48 01 d0             	add    %rdx,%rax
  8004204c47:	0f b6 00             	movzbl (%rax),%eax
  8004204c4a:	84 c0                	test   %al,%al
  8004204c4c:	74 35                	je     8004204c83 <check_page_alloc+0x978>
  8004204c4e:	48 b9 54 db 21 04 80 	movabs $0x800421db54,%rcx
  8004204c55:	00 00 00 
  8004204c58:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204c5f:	00 00 00 
  8004204c62:	be 7d 04 00 00       	mov    $0x47d,%esi
  8004204c67:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204c6e:	00 00 00 
  8004204c71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c76:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204c7d:	00 00 00 
  8004204c80:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  8004204c83:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004204c87:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004204c8e:	7e aa                	jle    8004204c3a <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  8004204c90:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004204c97:	00 00 00 
  8004204c9a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204c9e:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  8004204ca1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ca5:	48 89 c7             	mov    %rax,%rdi
  8004204ca8:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004204caf:	00 00 00 
  8004204cb2:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204cb4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204cb8:	48 89 c7             	mov    %rax,%rdi
  8004204cbb:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004204cc2:	00 00 00 
  8004204cc5:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204cc7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ccb:	48 89 c7             	mov    %rax,%rdi
  8004204cce:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004204cd5:	00 00 00 
  8004204cd8:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004204cda:	48 bf 60 db 21 04 80 	movabs $0x800421db60,%rdi
  8004204ce1:	00 00 00 
  8004204ce4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ce9:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004204cf0:	00 00 00 
  8004204cf3:	ff d2                	callq  *%rdx
}
  8004204cf5:	c9                   	leaveq 
  8004204cf6:	c3                   	retq   

0000008004204cf7 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004204cf7:	55                   	push   %rbp
  8004204cf8:	48 89 e5             	mov    %rsp,%rbp
  8004204cfb:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004204d02:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004204d09:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004204d10:	00 00 00 
  8004204d13:	48 8b 00             	mov    (%rax),%rax
  8004204d16:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204d1a:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004204d21:	00 
  8004204d22:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004204d29:	00 00 00 
  8004204d2c:	48 8b 00             	mov    (%rax),%rax
  8004204d2f:	48 c1 e0 04          	shl    $0x4,%rax
  8004204d33:	48 89 c2             	mov    %rax,%rdx
  8004204d36:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204d3a:	48 01 d0             	add    %rdx,%rax
  8004204d3d:	48 83 e8 01          	sub    $0x1,%rax
  8004204d41:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204d45:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204d49:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204d4e:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004204d52:	48 89 d0             	mov    %rdx,%rax
  8004204d55:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204d59:	48 29 c2             	sub    %rax,%rdx
  8004204d5c:	48 89 d0             	mov    %rdx,%rax
  8004204d5f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004204d63:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204d6a:	00 
  8004204d6b:	e9 d4 00 00 00       	jmpq   8004204e44 <check_boot_pml4e+0x14d>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204d70:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  8004204d77:	00 00 00 
  8004204d7a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d7e:	48 01 c2             	add    %rax,%rdx
  8004204d81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204d85:	48 89 d6             	mov    %rdx,%rsi
  8004204d88:	48 89 c7             	mov    %rax,%rdi
  8004204d8b:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  8004204d92:	00 00 00 
  8004204d95:	ff d0                	callq  *%rax
  8004204d97:	48 ba a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rdx
  8004204d9e:	00 00 00 
  8004204da1:	48 8b 12             	mov    (%rdx),%rdx
  8004204da4:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004204da8:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204daf:	00 00 00 
  8004204db2:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  8004204db6:	77 32                	ja     8004204dea <check_boot_pml4e+0xf3>
  8004204db8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204dbc:	48 89 c1             	mov    %rax,%rcx
  8004204dbf:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  8004204dc6:	00 00 00 
  8004204dc9:	be 9c 04 00 00       	mov    $0x49c,%esi
  8004204dce:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204dd5:	00 00 00 
  8004204dd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ddd:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204de4:	00 00 00 
  8004204de7:	41 ff d0             	callq  *%r8
  8004204dea:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204df1:	ff ff ff 
  8004204df4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204df8:	48 01 d1             	add    %rdx,%rcx
  8004204dfb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204dff:	48 01 ca             	add    %rcx,%rdx
  8004204e02:	48 39 d0             	cmp    %rdx,%rax
  8004204e05:	74 35                	je     8004204e3c <check_boot_pml4e+0x145>
  8004204e07:	48 b9 80 db 21 04 80 	movabs $0x800421db80,%rcx
  8004204e0e:	00 00 00 
  8004204e11:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204e18:	00 00 00 
  8004204e1b:	be 9c 04 00 00       	mov    $0x49c,%esi
  8004204e20:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204e27:	00 00 00 
  8004204e2a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e2f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204e36:	00 00 00 
  8004204e39:	41 ff d0             	callq  *%r8
	uint64_t i, n;

	pml4e = boot_pml4e;
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204e3c:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204e43:	00 
  8004204e44:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204e48:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204e4c:	0f 82 1e ff ff ff    	jb     8004204d70 <check_boot_pml4e+0x79>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204e52:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  8004204e59:	00 
  8004204e5a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204e5e:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  8004204e64:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204e68:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204e6c:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204e71:	48 f7 75 c8          	divq   -0x38(%rbp)
  8004204e75:	48 89 d0             	mov    %rdx,%rax
  8004204e78:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004204e7c:	48 29 c2             	sub    %rax,%rdx
  8004204e7f:	48 89 d0             	mov    %rdx,%rax
  8004204e82:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004204e86:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204e8d:	00 
  8004204e8e:	e9 d4 00 00 00       	jmpq   8004204f67 <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204e93:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004204e9a:	00 00 00 
  8004204e9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ea1:	48 01 c2             	add    %rax,%rdx
  8004204ea4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ea8:	48 89 d6             	mov    %rdx,%rsi
  8004204eab:	48 89 c7             	mov    %rax,%rdi
  8004204eae:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  8004204eb5:	00 00 00 
  8004204eb8:	ff d0                	callq  *%rax
  8004204eba:	48 ba 58 d2 3a 04 80 	movabs $0x80043ad258,%rdx
  8004204ec1:	00 00 00 
  8004204ec4:	48 8b 12             	mov    (%rdx),%rdx
  8004204ec7:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004204ecb:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204ed2:	00 00 00 
  8004204ed5:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  8004204ed9:	77 32                	ja     8004204f0d <check_boot_pml4e+0x216>
  8004204edb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004204edf:	48 89 c1             	mov    %rax,%rcx
  8004204ee2:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  8004204ee9:	00 00 00 
  8004204eec:	be a2 04 00 00       	mov    $0x4a2,%esi
  8004204ef1:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204ef8:	00 00 00 
  8004204efb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f00:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204f07:	00 00 00 
  8004204f0a:	41 ff d0             	callq  *%r8
  8004204f0d:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204f14:	ff ff ff 
  8004204f17:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004204f1b:	48 01 d1             	add    %rdx,%rcx
  8004204f1e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204f22:	48 01 ca             	add    %rcx,%rdx
  8004204f25:	48 39 d0             	cmp    %rdx,%rax
  8004204f28:	74 35                	je     8004204f5f <check_boot_pml4e+0x268>
  8004204f2a:	48 b9 b8 db 21 04 80 	movabs $0x800421dbb8,%rcx
  8004204f31:	00 00 00 
  8004204f34:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204f3b:	00 00 00 
  8004204f3e:	be a2 04 00 00       	mov    $0x4a2,%esi
  8004204f43:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204f4a:	00 00 00 
  8004204f4d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f52:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204f59:	00 00 00 
  8004204f5c:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  8004204f5f:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204f66:	00 
  8004204f67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f6b:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204f6f:	0f 82 1e ff ff ff    	jb     8004204e93 <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204f75:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204f7c:	00 
  8004204f7d:	eb 6a                	jmp    8004204fe9 <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  8004204f7f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004204f86:	00 00 00 
  8004204f89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f8d:	48 01 c2             	add    %rax,%rdx
  8004204f90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204f94:	48 89 d6             	mov    %rdx,%rsi
  8004204f97:	48 89 c7             	mov    %rax,%rdi
  8004204f9a:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  8004204fa1:	00 00 00 
  8004204fa4:	ff d0                	callq  *%rax
  8004204fa6:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204faa:	74 35                	je     8004204fe1 <check_boot_pml4e+0x2ea>
  8004204fac:	48 b9 f0 db 21 04 80 	movabs $0x800421dbf0,%rcx
  8004204fb3:	00 00 00 
  8004204fb6:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004204fbd:	00 00 00 
  8004204fc0:	be a6 04 00 00       	mov    $0x4a6,%esi
  8004204fc5:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004204fcc:	00 00 00 
  8004204fcf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204fd4:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004204fdb:	00 00 00 
  8004204fde:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004204fe1:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204fe8:	00 
  8004204fe9:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004204ff0:	00 00 00 
  8004204ff3:	48 8b 00             	mov    (%rax),%rax
  8004204ff6:	48 c1 e0 0c          	shl    $0xc,%rax
  8004204ffa:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204ffe:	0f 87 7b ff ff ff    	ja     8004204f7f <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205004:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420500b:	00 
  800420500c:	e9 a1 01 00 00       	jmpq   80042051b2 <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004205011:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004205015:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004205019:	48 89 d0             	mov    %rdx,%rax
  800420501c:	48 01 c0             	add    %rax,%rax
  800420501f:	48 01 d0             	add    %rdx,%rax
  8004205022:	48 c1 e0 0f          	shl    $0xf,%rax
  8004205026:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420502d:	00 00 00 
  8004205030:	48 29 c2             	sub    %rax,%rdx
  8004205033:	48 89 d0             	mov    %rdx,%rax
  8004205036:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  800420503a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205041:	00 
  8004205042:	e9 e0 00 00 00       	jmpq   8004205127 <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004205047:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420504b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420504f:	48 01 d0             	add    %rdx,%rax
  8004205052:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  8004205059:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420505d:	48 89 d6             	mov    %rdx,%rsi
  8004205060:	48 89 c7             	mov    %rax,%rdi
  8004205063:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  800420506a:	00 00 00 
  800420506d:	ff d0                	callq  *%rax
  800420506f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004205073:	48 89 d1             	mov    %rdx,%rcx
  8004205076:	48 c1 e1 10          	shl    $0x10,%rcx
  800420507a:	48 ba 00 10 3b 04 80 	movabs $0x80043b1000,%rdx
  8004205081:	00 00 00 
  8004205084:	48 01 ca             	add    %rcx,%rdx
  8004205087:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  800420508b:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004205092:	00 00 00 
  8004205095:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  8004205099:	77 32                	ja     80042050cd <check_boot_pml4e+0x3d6>
  800420509b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420509f:	48 89 c1             	mov    %rax,%rcx
  80042050a2:	48 ba 90 d7 21 04 80 	movabs $0x800421d790,%rdx
  80042050a9:	00 00 00 
  80042050ac:	be ae 04 00 00       	mov    $0x4ae,%esi
  80042050b1:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042050b8:	00 00 00 
  80042050bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042050c0:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042050c7:	00 00 00 
  80042050ca:	41 ff d0             	callq  *%r8
  80042050cd:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  80042050d4:	ff ff ff 
  80042050d7:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  80042050db:	48 01 d1             	add    %rdx,%rcx
  80042050de:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042050e2:	48 01 ca             	add    %rcx,%rdx
  80042050e5:	48 39 d0             	cmp    %rdx,%rax
  80042050e8:	74 35                	je     800420511f <check_boot_pml4e+0x428>
  80042050ea:	48 b9 18 dc 21 04 80 	movabs $0x800421dc18,%rcx
  80042050f1:	00 00 00 
  80042050f4:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042050fb:	00 00 00 
  80042050fe:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004205103:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420510a:	00 00 00 
  800420510d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205112:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205119:	00 00 00 
  800420511c:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  800420511f:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205126:	00 
  8004205127:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  800420512e:	00 
  800420512f:	0f 86 12 ff ff ff    	jbe    8004205047 <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205135:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420513c:	00 
  800420513d:	eb 64                	jmp    80042051a3 <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  800420513f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205143:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205147:	48 01 c2             	add    %rax,%rdx
  800420514a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420514e:	48 89 d6             	mov    %rdx,%rsi
  8004205151:	48 89 c7             	mov    %rax,%rdi
  8004205154:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  800420515b:	00 00 00 
  800420515e:	ff d0                	callq  *%rax
  8004205160:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004205164:	74 35                	je     800420519b <check_boot_pml4e+0x4a4>
  8004205166:	48 b9 60 dc 21 04 80 	movabs $0x800421dc60,%rcx
  800420516d:	00 00 00 
  8004205170:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205177:	00 00 00 
  800420517a:	be b0 04 00 00       	mov    $0x4b0,%esi
  800420517f:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205186:	00 00 00 
  8004205189:	b8 00 00 00 00       	mov    $0x0,%eax
  800420518e:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205195:	00 00 00 
  8004205198:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  800420519b:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042051a2:	00 
  80042051a3:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  80042051aa:	00 
  80042051ab:	76 92                	jbe    800420513f <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  80042051ad:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042051b2:	48 83 7d f0 03       	cmpq   $0x3,-0x10(%rbp)
  80042051b7:	0f 86 54 fe ff ff    	jbe    8004205011 <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  80042051bd:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042051c4:	00 00 00 
  80042051c7:	48 8b 00             	mov    (%rax),%rax
  80042051ca:	48 83 c0 08          	add    $0x8,%rax
  80042051ce:	48 8b 00             	mov    (%rax),%rax
  80042051d1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042051d7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  80042051db:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051df:	48 c1 e8 0c          	shr    $0xc,%rax
  80042051e3:	89 45 9c             	mov    %eax,-0x64(%rbp)
  80042051e6:	8b 55 9c             	mov    -0x64(%rbp),%edx
  80042051e9:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042051f0:	00 00 00 
  80042051f3:	48 8b 00             	mov    (%rax),%rax
  80042051f6:	48 39 c2             	cmp    %rax,%rdx
  80042051f9:	72 32                	jb     800420522d <check_boot_pml4e+0x536>
  80042051fb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042051ff:	48 89 c1             	mov    %rax,%rcx
  8004205202:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004205209:	00 00 00 
  800420520c:	be b3 04 00 00       	mov    $0x4b3,%esi
  8004205211:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205218:	00 00 00 
  800420521b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205220:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205227:	00 00 00 
  800420522a:	41 ff d0             	callq  *%r8
  800420522d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205234:	00 00 00 
  8004205237:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420523b:	48 01 d0             	add    %rdx,%rax
  800420523e:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004205242:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205246:	48 8b 00             	mov    (%rax),%rax
  8004205249:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420524f:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004205253:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205257:	48 c1 e8 0c          	shr    $0xc,%rax
  800420525b:	89 45 84             	mov    %eax,-0x7c(%rbp)
  800420525e:	8b 55 84             	mov    -0x7c(%rbp),%edx
  8004205261:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004205268:	00 00 00 
  800420526b:	48 8b 00             	mov    (%rax),%rax
  800420526e:	48 39 c2             	cmp    %rax,%rdx
  8004205271:	72 32                	jb     80042052a5 <check_boot_pml4e+0x5ae>
  8004205273:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205277:	48 89 c1             	mov    %rax,%rcx
  800420527a:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004205281:	00 00 00 
  8004205284:	be b4 04 00 00       	mov    $0x4b4,%esi
  8004205289:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205290:	00 00 00 
  8004205293:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205298:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420529f:	00 00 00 
  80042052a2:	41 ff d0             	callq  *%r8
  80042052a5:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042052ac:	00 00 00 
  80042052af:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042052b3:	48 01 d0             	add    %rdx,%rax
  80042052b6:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042052bd:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042052c4:	00 
  80042052c5:	e9 50 01 00 00       	jmpq   800420541a <check_boot_pml4e+0x723>
		switch (i) {
  80042052ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052ce:	48 83 f8 04          	cmp    $0x4,%rax
  80042052d2:	72 67                	jb     800420533b <check_boot_pml4e+0x644>
  80042052d4:	48 83 f8 05          	cmp    $0x5,%rax
  80042052d8:	76 06                	jbe    80042052e0 <check_boot_pml4e+0x5e9>
  80042052da:	48 83 f8 1f          	cmp    $0x1f,%rax
  80042052de:	75 5b                	jne    800420533b <check_boot_pml4e+0x644>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  80042052e0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042052e4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042052eb:	00 
  80042052ec:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042052f3:	48 01 d0             	add    %rdx,%rax
  80042052f6:	48 8b 00             	mov    (%rax),%rax
  80042052f9:	83 e0 01             	and    $0x1,%eax
  80042052fc:	48 85 c0             	test   %rax,%rax
  80042052ff:	75 35                	jne    8004205336 <check_boot_pml4e+0x63f>
  8004205301:	48 b9 83 dc 21 04 80 	movabs $0x800421dc83,%rcx
  8004205308:	00 00 00 
  800420530b:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205312:	00 00 00 
  8004205315:	be bc 04 00 00       	mov    $0x4bc,%esi
  800420531a:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205321:	00 00 00 
  8004205324:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205329:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205330:	00 00 00 
  8004205333:	41 ff d0             	callq  *%r8
			break;
  8004205336:	e9 da 00 00 00       	jmpq   8004205415 <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  800420533b:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004205340:	0f 86 ce 00 00 00    	jbe    8004205414 <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  8004205346:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420534a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205351:	00 
  8004205352:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205359:	48 01 d0             	add    %rdx,%rax
  800420535c:	48 8b 00             	mov    (%rax),%rax
  800420535f:	83 e0 01             	and    $0x1,%eax
  8004205362:	48 85 c0             	test   %rax,%rax
  8004205365:	74 5a                	je     80042053c1 <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  8004205367:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420536b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205372:	00 
  8004205373:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420537a:	48 01 d0             	add    %rdx,%rax
  800420537d:	48 8b 00             	mov    (%rax),%rax
  8004205380:	83 e0 02             	and    $0x2,%eax
  8004205383:	48 85 c0             	test   %rax,%rax
  8004205386:	0f 85 88 00 00 00    	jne    8004205414 <check_boot_pml4e+0x71d>
  800420538c:	48 b9 94 dc 21 04 80 	movabs $0x800421dc94,%rcx
  8004205393:	00 00 00 
  8004205396:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420539d:	00 00 00 
  80042053a0:	be c1 04 00 00       	mov    $0x4c1,%esi
  80042053a5:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042053ac:	00 00 00 
  80042053af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053b4:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042053bb:	00 00 00 
  80042053be:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  80042053c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042053c5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042053cc:	00 
  80042053cd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042053d4:	48 01 d0             	add    %rdx,%rax
  80042053d7:	48 8b 00             	mov    (%rax),%rax
  80042053da:	48 85 c0             	test   %rax,%rax
  80042053dd:	74 35                	je     8004205414 <check_boot_pml4e+0x71d>
  80042053df:	48 b9 a5 dc 21 04 80 	movabs $0x800421dca5,%rcx
  80042053e6:	00 00 00 
  80042053e9:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042053f0:	00 00 00 
  80042053f3:	be c3 04 00 00       	mov    $0x4c3,%esi
  80042053f8:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042053ff:	00 00 00 
  8004205402:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205407:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420540e:	00 00 00 
  8004205411:	41 ff d0             	callq  *%r8
			} 
			break;
  8004205414:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205415:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420541a:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004205421:	00 
  8004205422:	0f 86 a2 fe ff ff    	jbe    80042052ca <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004205428:	48 bf b8 dc 21 04 80 	movabs $0x800421dcb8,%rdi
  800420542f:	00 00 00 
  8004205432:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205437:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420543e:	00 00 00 
  8004205441:	ff d2                	callq  *%rdx
}
  8004205443:	c9                   	leaveq 
  8004205444:	c3                   	retq   

0000008004205445 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004205445:	55                   	push   %rbp
  8004205446:	48 89 e5             	mov    %rsp,%rbp
  8004205449:	48 83 ec 60          	sub    $0x60,%rsp
  800420544d:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004205451:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	pml4e = &pml4e[PML4(va)];
  8004205455:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205459:	48 c1 e8 27          	shr    $0x27,%rax
  800420545d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205462:	48 c1 e0 03          	shl    $0x3,%rax
  8004205466:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	//cprintf("pml4e %x %x \n" , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  800420546a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420546e:	48 8b 00             	mov    (%rax),%rax
  8004205471:	83 e0 01             	and    $0x1,%eax
  8004205474:	48 85 c0             	test   %rax,%rax
  8004205477:	75 0c                	jne    8004205485 <check_va2pa+0x40>
		return ~0;
  8004205479:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205480:	e9 38 02 00 00       	jmpq   80042056bd <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  8004205485:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004205489:	48 8b 00             	mov    (%rax),%rax
  800420548c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205492:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004205496:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420549a:	48 c1 e8 0c          	shr    $0xc,%rax
  800420549e:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042054a1:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042054a4:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042054ab:	00 00 00 
  80042054ae:	48 8b 00             	mov    (%rax),%rax
  80042054b1:	48 39 c2             	cmp    %rax,%rdx
  80042054b4:	72 32                	jb     80042054e8 <check_va2pa+0xa3>
  80042054b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054ba:	48 89 c1             	mov    %rax,%rcx
  80042054bd:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  80042054c4:	00 00 00 
  80042054c7:	be da 04 00 00       	mov    $0x4da,%esi
  80042054cc:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042054d3:	00 00 00 
  80042054d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054db:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042054e2:	00 00 00 
  80042054e5:	41 ff d0             	callq  *%r8
  80042054e8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042054ef:	00 00 00 
  80042054f2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054f6:	48 01 d0             	add    %rdx,%rax
  80042054f9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("pdpe %x %x \n" , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  80042054fd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205501:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205505:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420550a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205511:	00 
  8004205512:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205516:	48 01 d0             	add    %rdx,%rax
  8004205519:	48 8b 00             	mov    (%rax),%rax
  800420551c:	83 e0 01             	and    $0x1,%eax
  800420551f:	48 85 c0             	test   %rax,%rax
  8004205522:	75 0c                	jne    8004205530 <check_va2pa+0xeb>
		return ~0;
  8004205524:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420552b:	e9 8d 01 00 00       	jmpq   80042056bd <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205530:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205534:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205538:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420553d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205544:	00 
  8004205545:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205549:	48 01 d0             	add    %rdx,%rax
  800420554c:	48 8b 00             	mov    (%rax),%rax
  800420554f:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205555:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004205559:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420555d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205561:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004205564:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004205567:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  800420556e:	00 00 00 
  8004205571:	48 8b 00             	mov    (%rax),%rax
  8004205574:	48 39 c2             	cmp    %rax,%rdx
  8004205577:	72 32                	jb     80042055ab <check_va2pa+0x166>
  8004205579:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420557d:	48 89 c1             	mov    %rax,%rcx
  8004205580:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004205587:	00 00 00 
  800420558a:	be de 04 00 00       	mov    $0x4de,%esi
  800420558f:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205596:	00 00 00 
  8004205599:	b8 00 00 00 00       	mov    $0x0,%eax
  800420559e:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042055a5:	00 00 00 
  80042055a8:	41 ff d0             	callq  *%r8
  80042055ab:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042055b2:	00 00 00 
  80042055b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042055b9:	48 01 d0             	add    %rdx,%rax
  80042055bc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//cprintf("pde %x %x \n" , pde, *pde);
	pde = &pde[PDX(va)];
  80042055c0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042055c4:	48 c1 e8 15          	shr    $0x15,%rax
  80042055c8:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042055cd:	48 c1 e0 03          	shl    $0x3,%rax
  80042055d1:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  80042055d5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055d9:	48 8b 00             	mov    (%rax),%rax
  80042055dc:	83 e0 01             	and    $0x1,%eax
  80042055df:	48 85 c0             	test   %rax,%rax
  80042055e2:	75 0c                	jne    80042055f0 <check_va2pa+0x1ab>
		return ~0;
  80042055e4:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042055eb:	e9 cd 00 00 00       	jmpq   80042056bd <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  80042055f0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042055f4:	48 8b 00             	mov    (%rax),%rax
  80042055f7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042055fd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205601:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205605:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205609:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  800420560c:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  800420560f:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004205616:	00 00 00 
  8004205619:	48 8b 00             	mov    (%rax),%rax
  800420561c:	48 39 c2             	cmp    %rax,%rdx
  800420561f:	72 32                	jb     8004205653 <check_va2pa+0x20e>
  8004205621:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205625:	48 89 c1             	mov    %rax,%rcx
  8004205628:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  800420562f:	00 00 00 
  8004205632:	be e3 04 00 00       	mov    $0x4e3,%esi
  8004205637:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420563e:	00 00 00 
  8004205641:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205646:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420564d:	00 00 00 
  8004205650:	41 ff d0             	callq  *%r8
  8004205653:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420565a:	00 00 00 
  800420565d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205661:	48 01 d0             	add    %rdx,%rax
  8004205664:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	//cprintf("pte %x %x %x \n" , pte, *pte, pte[PTX(va)]);
	if (!(pte[PTX(va)] & PTE_P))
  8004205668:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420566c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205670:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004205675:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420567c:	00 
  800420567d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205681:	48 01 d0             	add    %rdx,%rax
  8004205684:	48 8b 00             	mov    (%rax),%rax
  8004205687:	83 e0 01             	and    $0x1,%eax
  800420568a:	48 85 c0             	test   %rax,%rax
  800420568d:	75 09                	jne    8004205698 <check_va2pa+0x253>
		return ~0;
  800420568f:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  8004205696:	eb 25                	jmp    80042056bd <check_va2pa+0x278>
	//cprintf("page Tale Index %x %x \n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  8004205698:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420569c:	48 c1 e8 0c          	shr    $0xc,%rax
  80042056a0:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042056a5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042056ac:	00 
  80042056ad:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042056b1:	48 01 d0             	add    %rdx,%rax
  80042056b4:	48 8b 00             	mov    (%rax),%rax
  80042056b7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  80042056bd:	c9                   	leaveq 
  80042056be:	c3                   	retq   

00000080042056bf <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  80042056bf:	55                   	push   %rbp
  80042056c0:	48 89 e5             	mov    %rsp,%rbp
  80042056c3:	53                   	push   %rbx
  80042056c4:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  80042056cb:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042056d2:	00 
  80042056d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042056d7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042056db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042056df:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042056e3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042056e7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042056eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042056ef:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042056f3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042056f7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  80042056fb:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205700:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004205707:	00 00 00 
  800420570a:	ff d0                	callq  *%rax
  800420570c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205710:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205715:	75 35                	jne    800420574c <page_check+0x8d>
  8004205717:	48 b9 d7 dc 21 04 80 	movabs $0x800421dcd7,%rcx
  800420571e:	00 00 00 
  8004205721:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205728:	00 00 00 
  800420572b:	be f9 04 00 00       	mov    $0x4f9,%esi
  8004205730:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205737:	00 00 00 
  800420573a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420573f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205746:	00 00 00 
  8004205749:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  800420574c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205751:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004205758:	00 00 00 
  800420575b:	ff d0                	callq  *%rax
  800420575d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205761:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205766:	75 35                	jne    800420579d <page_check+0xde>
  8004205768:	48 b9 eb dc 21 04 80 	movabs $0x800421dceb,%rcx
  800420576f:	00 00 00 
  8004205772:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205779:	00 00 00 
  800420577c:	be fa 04 00 00       	mov    $0x4fa,%esi
  8004205781:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205788:	00 00 00 
  800420578b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205790:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205797:	00 00 00 
  800420579a:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  800420579d:	bf 00 00 00 00       	mov    $0x0,%edi
  80042057a2:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042057a9:	00 00 00 
  80042057ac:	ff d0                	callq  *%rax
  80042057ae:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042057b2:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042057b7:	75 35                	jne    80042057ee <page_check+0x12f>
  80042057b9:	48 b9 ff dc 21 04 80 	movabs $0x800421dcff,%rcx
  80042057c0:	00 00 00 
  80042057c3:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042057ca:	00 00 00 
  80042057cd:	be fb 04 00 00       	mov    $0x4fb,%esi
  80042057d2:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042057d9:	00 00 00 
  80042057dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042057e1:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042057e8:	00 00 00 
  80042057eb:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  80042057ee:	bf 00 00 00 00       	mov    $0x0,%edi
  80042057f3:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042057fa:	00 00 00 
  80042057fd:	ff d0                	callq  *%rax
  80042057ff:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205803:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205808:	75 35                	jne    800420583f <page_check+0x180>
  800420580a:	48 b9 13 dd 21 04 80 	movabs $0x800421dd13,%rcx
  8004205811:	00 00 00 
  8004205814:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420581b:	00 00 00 
  800420581e:	be fc 04 00 00       	mov    $0x4fc,%esi
  8004205823:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420582a:	00 00 00 
  800420582d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205832:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205839:	00 00 00 
  800420583c:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  800420583f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205844:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  800420584b:	00 00 00 
  800420584e:	ff d0                	callq  *%rax
  8004205850:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205854:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205859:	75 35                	jne    8004205890 <page_check+0x1d1>
  800420585b:	48 b9 27 dd 21 04 80 	movabs $0x800421dd27,%rcx
  8004205862:	00 00 00 
  8004205865:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420586c:	00 00 00 
  800420586f:	be fd 04 00 00       	mov    $0x4fd,%esi
  8004205874:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420587b:	00 00 00 
  800420587e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205883:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420588a:	00 00 00 
  800420588d:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  8004205890:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205895:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  800420589c:	00 00 00 
  800420589f:	ff d0                	callq  *%rax
  80042058a1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042058a5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042058aa:	75 35                	jne    80042058e1 <page_check+0x222>
  80042058ac:	48 b9 3b dd 21 04 80 	movabs $0x800421dd3b,%rcx
  80042058b3:	00 00 00 
  80042058b6:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042058bd:	00 00 00 
  80042058c0:	be fe 04 00 00       	mov    $0x4fe,%esi
  80042058c5:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042058cc:	00 00 00 
  80042058cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058d4:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042058db:	00 00 00 
  80042058de:	41 ff d0             	callq  *%r8

	assert(pp0);
  80042058e1:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042058e6:	75 35                	jne    800420591d <page_check+0x25e>
  80042058e8:	48 b9 89 da 21 04 80 	movabs $0x800421da89,%rcx
  80042058ef:	00 00 00 
  80042058f2:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042058f9:	00 00 00 
  80042058fc:	be 00 05 00 00       	mov    $0x500,%esi
  8004205901:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205908:	00 00 00 
  800420590b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205910:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205917:	00 00 00 
  800420591a:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  800420591d:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205922:	74 0a                	je     800420592e <page_check+0x26f>
  8004205924:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205928:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420592c:	75 35                	jne    8004205963 <page_check+0x2a4>
  800420592e:	48 b9 8d da 21 04 80 	movabs $0x800421da8d,%rcx
  8004205935:	00 00 00 
  8004205938:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420593f:	00 00 00 
  8004205942:	be 01 05 00 00       	mov    $0x501,%esi
  8004205947:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420594e:	00 00 00 
  8004205951:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205956:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420595d:	00 00 00 
  8004205960:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205963:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205968:	74 14                	je     800420597e <page_check+0x2bf>
  800420596a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420596e:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205972:	74 0a                	je     800420597e <page_check+0x2bf>
  8004205974:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205978:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800420597c:	75 35                	jne    80042059b3 <page_check+0x2f4>
  800420597e:	48 b9 a0 da 21 04 80 	movabs $0x800421daa0,%rcx
  8004205985:	00 00 00 
  8004205988:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420598f:	00 00 00 
  8004205992:	be 02 05 00 00       	mov    $0x502,%esi
  8004205997:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420599e:	00 00 00 
  80042059a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059a6:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042059ad:	00 00 00 
  80042059b0:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  80042059b3:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042059b8:	74 1e                	je     80042059d8 <page_check+0x319>
  80042059ba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059be:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042059c2:	74 14                	je     80042059d8 <page_check+0x319>
  80042059c4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059c8:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  80042059cc:	74 0a                	je     80042059d8 <page_check+0x319>
  80042059ce:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042059d2:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042059d6:	75 35                	jne    8004205a0d <page_check+0x34e>
  80042059d8:	48 b9 50 dd 21 04 80 	movabs $0x800421dd50,%rcx
  80042059df:	00 00 00 
  80042059e2:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042059e9:	00 00 00 
  80042059ec:	be 03 05 00 00       	mov    $0x503,%esi
  80042059f1:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042059f8:	00 00 00 
  80042059fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a00:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205a07:	00 00 00 
  8004205a0a:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205a0d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205a12:	74 28                	je     8004205a3c <page_check+0x37d>
  8004205a14:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a18:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205a1c:	74 1e                	je     8004205a3c <page_check+0x37d>
  8004205a1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a22:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205a26:	74 14                	je     8004205a3c <page_check+0x37d>
  8004205a28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a2c:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205a30:	74 0a                	je     8004205a3c <page_check+0x37d>
  8004205a32:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205a36:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205a3a:	75 35                	jne    8004205a71 <page_check+0x3b2>
  8004205a3c:	48 b9 80 dd 21 04 80 	movabs $0x800421dd80,%rcx
  8004205a43:	00 00 00 
  8004205a46:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205a4d:	00 00 00 
  8004205a50:	be 04 05 00 00       	mov    $0x504,%esi
  8004205a55:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205a5c:	00 00 00 
  8004205a5f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a64:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205a6b:	00 00 00 
  8004205a6e:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205a71:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205a76:	74 32                	je     8004205aaa <page_check+0x3eb>
  8004205a78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a7c:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205a80:	74 28                	je     8004205aaa <page_check+0x3eb>
  8004205a82:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a86:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205a8a:	74 1e                	je     8004205aaa <page_check+0x3eb>
  8004205a8c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a90:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205a94:	74 14                	je     8004205aaa <page_check+0x3eb>
  8004205a96:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205a9a:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205a9e:	74 0a                	je     8004205aaa <page_check+0x3eb>
  8004205aa0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205aa4:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205aa8:	75 35                	jne    8004205adf <page_check+0x420>
  8004205aaa:	48 b9 c0 dd 21 04 80 	movabs $0x800421ddc0,%rcx
  8004205ab1:	00 00 00 
  8004205ab4:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205abb:	00 00 00 
  8004205abe:	be 05 05 00 00       	mov    $0x505,%esi
  8004205ac3:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205aca:	00 00 00 
  8004205acd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ad2:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205ad9:	00 00 00 
  8004205adc:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205adf:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004205ae6:	00 00 00 
  8004205ae9:	48 8b 00             	mov    (%rax),%rax
  8004205aec:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205af0:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004205af7:	00 00 00 
  8004205afa:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205b01:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205b06:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004205b0d:	00 00 00 
  8004205b10:	ff d0                	callq  *%rax
  8004205b12:	48 85 c0             	test   %rax,%rax
  8004205b15:	74 35                	je     8004205b4c <page_check+0x48d>
  8004205b17:	48 b9 17 db 21 04 80 	movabs $0x800421db17,%rcx
  8004205b1e:	00 00 00 
  8004205b21:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205b28:	00 00 00 
  8004205b2b:	be 0c 05 00 00       	mov    $0x50c,%esi
  8004205b30:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205b37:	00 00 00 
  8004205b3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b3f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205b46:	00 00 00 
  8004205b49:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205b4c:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205b53:	00 00 00 
  8004205b56:	48 8b 00             	mov    (%rax),%rax
  8004205b59:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  8004205b60:	be 00 00 00 00       	mov    $0x0,%esi
  8004205b65:	48 89 c7             	mov    %rax,%rdi
  8004205b68:	48 b8 3d 39 20 04 80 	movabs $0x800420393d,%rax
  8004205b6f:	00 00 00 
  8004205b72:	ff d0                	callq  *%rax
  8004205b74:	48 85 c0             	test   %rax,%rax
  8004205b77:	74 35                	je     8004205bae <page_check+0x4ef>
  8004205b79:	48 b9 10 de 21 04 80 	movabs $0x800421de10,%rcx
  8004205b80:	00 00 00 
  8004205b83:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205b8a:	00 00 00 
  8004205b8d:	be 0f 05 00 00       	mov    $0x50f,%esi
  8004205b92:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205b99:	00 00 00 
  8004205b9c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ba1:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205ba8:	00 00 00 
  8004205bab:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205bae:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205bb5:	00 00 00 
  8004205bb8:	48 8b 00             	mov    (%rax),%rax
  8004205bbb:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205bbf:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205bc4:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205bc9:	48 89 c7             	mov    %rax,%rdi
  8004205bcc:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  8004205bd3:	00 00 00 
  8004205bd6:	ff d0                	callq  *%rax
  8004205bd8:	85 c0                	test   %eax,%eax
  8004205bda:	78 35                	js     8004205c11 <page_check+0x552>
  8004205bdc:	48 b9 48 de 21 04 80 	movabs $0x800421de48,%rcx
  8004205be3:	00 00 00 
  8004205be6:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205bed:	00 00 00 
  8004205bf0:	be 12 05 00 00       	mov    $0x512,%esi
  8004205bf5:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205bfc:	00 00 00 
  8004205bff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c04:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205c0b:	00 00 00 
  8004205c0e:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004205c11:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205c15:	48 89 c7             	mov    %rax,%rdi
  8004205c18:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004205c1f:	00 00 00 
  8004205c22:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205c24:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205c2b:	00 00 00 
  8004205c2e:	48 8b 00             	mov    (%rax),%rax
  8004205c31:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205c35:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205c3a:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205c3f:	48 89 c7             	mov    %rax,%rdi
  8004205c42:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  8004205c49:	00 00 00 
  8004205c4c:	ff d0                	callq  *%rax
  8004205c4e:	85 c0                	test   %eax,%eax
  8004205c50:	78 35                	js     8004205c87 <page_check+0x5c8>
  8004205c52:	48 b9 48 de 21 04 80 	movabs $0x800421de48,%rcx
  8004205c59:	00 00 00 
  8004205c5c:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205c63:	00 00 00 
  8004205c66:	be 16 05 00 00       	mov    $0x516,%esi
  8004205c6b:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205c72:	00 00 00 
  8004205c75:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c7a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205c81:	00 00 00 
  8004205c84:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004205c87:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205c8b:	48 89 c7             	mov    %rax,%rdi
  8004205c8e:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004205c95:	00 00 00 
  8004205c98:	ff d0                	callq  *%rax
	page_free(pp3);
  8004205c9a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205c9e:	48 89 c7             	mov    %rax,%rdi
  8004205ca1:	48 b8 70 30 20 04 80 	movabs $0x8004203070,%rax
  8004205ca8:	00 00 00 
  8004205cab:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  8004205cad:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205cb4:	00 00 00 
  8004205cb7:	48 8b 00             	mov    (%rax),%rax
  8004205cba:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205cbe:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205cc3:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205cc8:	48 89 c7             	mov    %rax,%rdi
  8004205ccb:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  8004205cd2:	00 00 00 
  8004205cd5:	ff d0                	callq  *%rax
  8004205cd7:	85 c0                	test   %eax,%eax
  8004205cd9:	74 35                	je     8004205d10 <page_check+0x651>
  8004205cdb:	48 b9 78 de 21 04 80 	movabs $0x800421de78,%rcx
  8004205ce2:	00 00 00 
  8004205ce5:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205cec:	00 00 00 
  8004205cef:	be 1c 05 00 00       	mov    $0x51c,%esi
  8004205cf4:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205cfb:	00 00 00 
  8004205cfe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d03:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205d0a:	00 00 00 
  8004205d0d:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205d10:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205d17:	00 00 00 
  8004205d1a:	48 8b 00             	mov    (%rax),%rax
  8004205d1d:	48 8b 00             	mov    (%rax),%rax
  8004205d20:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d26:	48 89 c3             	mov    %rax,%rbx
  8004205d29:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205d2d:	48 89 c7             	mov    %rax,%rdi
  8004205d30:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004205d37:	00 00 00 
  8004205d3a:	ff d0                	callq  *%rax
  8004205d3c:	48 39 c3             	cmp    %rax,%rbx
  8004205d3f:	0f 84 97 00 00 00    	je     8004205ddc <page_check+0x71d>
  8004205d45:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205d4c:	00 00 00 
  8004205d4f:	48 8b 00             	mov    (%rax),%rax
  8004205d52:	48 8b 00             	mov    (%rax),%rax
  8004205d55:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d5b:	48 89 c3             	mov    %rax,%rbx
  8004205d5e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205d62:	48 89 c7             	mov    %rax,%rdi
  8004205d65:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004205d6c:	00 00 00 
  8004205d6f:	ff d0                	callq  *%rax
  8004205d71:	48 39 c3             	cmp    %rax,%rbx
  8004205d74:	74 66                	je     8004205ddc <page_check+0x71d>
  8004205d76:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205d7d:	00 00 00 
  8004205d80:	48 8b 00             	mov    (%rax),%rax
  8004205d83:	48 8b 00             	mov    (%rax),%rax
  8004205d86:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205d8c:	48 89 c3             	mov    %rax,%rbx
  8004205d8f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205d93:	48 89 c7             	mov    %rax,%rdi
  8004205d96:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004205d9d:	00 00 00 
  8004205da0:	ff d0                	callq  *%rax
  8004205da2:	48 39 c3             	cmp    %rax,%rbx
  8004205da5:	74 35                	je     8004205ddc <page_check+0x71d>
  8004205da7:	48 b9 a8 de 21 04 80 	movabs $0x800421dea8,%rcx
  8004205dae:	00 00 00 
  8004205db1:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205db8:	00 00 00 
  8004205dbb:	be 1d 05 00 00       	mov    $0x51d,%esi
  8004205dc0:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205dc7:	00 00 00 
  8004205dca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205dcf:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205dd6:	00 00 00 
  8004205dd9:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004205ddc:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205de3:	00 00 00 
  8004205de6:	48 8b 00             	mov    (%rax),%rax
  8004205de9:	be 00 00 00 00       	mov    $0x0,%esi
  8004205dee:	48 89 c7             	mov    %rax,%rdi
  8004205df1:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  8004205df8:	00 00 00 
  8004205dfb:	ff d0                	callq  *%rax
  8004205dfd:	48 89 c3             	mov    %rax,%rbx
  8004205e00:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205e04:	48 89 c7             	mov    %rax,%rdi
  8004205e07:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004205e0e:	00 00 00 
  8004205e11:	ff d0                	callq  *%rax
  8004205e13:	48 39 c3             	cmp    %rax,%rbx
  8004205e16:	74 35                	je     8004205e4d <page_check+0x78e>
  8004205e18:	48 b9 30 df 21 04 80 	movabs $0x800421df30,%rcx
  8004205e1f:	00 00 00 
  8004205e22:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205e29:	00 00 00 
  8004205e2c:	be 1e 05 00 00       	mov    $0x51e,%esi
  8004205e31:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205e38:	00 00 00 
  8004205e3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e40:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205e47:	00 00 00 
  8004205e4a:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205e4d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205e51:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205e55:	66 83 f8 01          	cmp    $0x1,%ax
  8004205e59:	74 35                	je     8004205e90 <page_check+0x7d1>
  8004205e5b:	48 b9 5d df 21 04 80 	movabs $0x800421df5d,%rcx
  8004205e62:	00 00 00 
  8004205e65:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205e6c:	00 00 00 
  8004205e6f:	be 1f 05 00 00       	mov    $0x51f,%esi
  8004205e74:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205e7b:	00 00 00 
  8004205e7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e83:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205e8a:	00 00 00 
  8004205e8d:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205e90:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205e94:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205e98:	66 83 f8 01          	cmp    $0x1,%ax
  8004205e9c:	74 35                	je     8004205ed3 <page_check+0x814>
  8004205e9e:	48 b9 6e df 21 04 80 	movabs $0x800421df6e,%rcx
  8004205ea5:	00 00 00 
  8004205ea8:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205eaf:	00 00 00 
  8004205eb2:	be 20 05 00 00       	mov    $0x520,%esi
  8004205eb7:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205ebe:	00 00 00 
  8004205ec1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ec6:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205ecd:	00 00 00 
  8004205ed0:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004205ed3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ed7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205edb:	66 83 f8 01          	cmp    $0x1,%ax
  8004205edf:	74 35                	je     8004205f16 <page_check+0x857>
  8004205ee1:	48 b9 7f df 21 04 80 	movabs $0x800421df7f,%rcx
  8004205ee8:	00 00 00 
  8004205eeb:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205ef2:	00 00 00 
  8004205ef5:	be 21 05 00 00       	mov    $0x521,%esi
  8004205efa:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205f01:	00 00 00 
  8004205f04:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f09:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205f10:	00 00 00 
  8004205f13:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004205f16:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205f1d:	00 00 00 
  8004205f20:	48 8b 00             	mov    (%rax),%rax
  8004205f23:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004205f27:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205f2c:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004205f31:	48 89 c7             	mov    %rax,%rdi
  8004205f34:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  8004205f3b:	00 00 00 
  8004205f3e:	ff d0                	callq  *%rax
  8004205f40:	85 c0                	test   %eax,%eax
  8004205f42:	74 35                	je     8004205f79 <page_check+0x8ba>
  8004205f44:	48 b9 90 df 21 04 80 	movabs $0x800421df90,%rcx
  8004205f4b:	00 00 00 
  8004205f4e:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205f55:	00 00 00 
  8004205f58:	be 23 05 00 00       	mov    $0x523,%esi
  8004205f5d:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205f64:	00 00 00 
  8004205f67:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f6c:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205f73:	00 00 00 
  8004205f76:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  8004205f79:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004205f80:	00 00 00 
  8004205f83:	48 8b 00             	mov    (%rax),%rax
  8004205f86:	be 00 10 00 00       	mov    $0x1000,%esi
  8004205f8b:	48 89 c7             	mov    %rax,%rdi
  8004205f8e:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  8004205f95:	00 00 00 
  8004205f98:	ff d0                	callq  *%rax
  8004205f9a:	48 89 c3             	mov    %rax,%rbx
  8004205f9d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205fa1:	48 89 c7             	mov    %rax,%rdi
  8004205fa4:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004205fab:	00 00 00 
  8004205fae:	ff d0                	callq  *%rax
  8004205fb0:	48 39 c3             	cmp    %rax,%rbx
  8004205fb3:	74 35                	je     8004205fea <page_check+0x92b>
  8004205fb5:	48 b9 c8 df 21 04 80 	movabs $0x800421dfc8,%rcx
  8004205fbc:	00 00 00 
  8004205fbf:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004205fc6:	00 00 00 
  8004205fc9:	be 24 05 00 00       	mov    $0x524,%esi
  8004205fce:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004205fd5:	00 00 00 
  8004205fd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fdd:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004205fe4:	00 00 00 
  8004205fe7:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  8004205fea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205fee:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205ff2:	66 83 f8 02          	cmp    $0x2,%ax
  8004205ff6:	74 35                	je     800420602d <page_check+0x96e>
  8004205ff8:	48 b9 f8 df 21 04 80 	movabs $0x800421dff8,%rcx
  8004205fff:	00 00 00 
  8004206002:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206009:	00 00 00 
  800420600c:	be 25 05 00 00       	mov    $0x525,%esi
  8004206011:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206018:	00 00 00 
  800420601b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206020:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206027:	00 00 00 
  800420602a:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  800420602d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206032:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004206039:	00 00 00 
  800420603c:	ff d0                	callq  *%rax
  800420603e:	48 85 c0             	test   %rax,%rax
  8004206041:	74 35                	je     8004206078 <page_check+0x9b9>
  8004206043:	48 b9 17 db 21 04 80 	movabs $0x800421db17,%rcx
  800420604a:	00 00 00 
  800420604d:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206054:	00 00 00 
  8004206057:	be 28 05 00 00       	mov    $0x528,%esi
  800420605c:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206063:	00 00 00 
  8004206066:	b8 00 00 00 00       	mov    $0x0,%eax
  800420606b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206072:	00 00 00 
  8004206075:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206078:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  800420607f:	00 00 00 
  8004206082:	48 8b 00             	mov    (%rax),%rax
  8004206085:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206089:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420608e:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206093:	48 89 c7             	mov    %rax,%rdi
  8004206096:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  800420609d:	00 00 00 
  80042060a0:	ff d0                	callq  *%rax
  80042060a2:	85 c0                	test   %eax,%eax
  80042060a4:	74 35                	je     80042060db <page_check+0xa1c>
  80042060a6:	48 b9 90 df 21 04 80 	movabs $0x800421df90,%rcx
  80042060ad:	00 00 00 
  80042060b0:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042060b7:	00 00 00 
  80042060ba:	be 2b 05 00 00       	mov    $0x52b,%esi
  80042060bf:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042060c6:	00 00 00 
  80042060c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060ce:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042060d5:	00 00 00 
  80042060d8:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042060db:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042060e2:	00 00 00 
  80042060e5:	48 8b 00             	mov    (%rax),%rax
  80042060e8:	be 00 10 00 00       	mov    $0x1000,%esi
  80042060ed:	48 89 c7             	mov    %rax,%rdi
  80042060f0:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  80042060f7:	00 00 00 
  80042060fa:	ff d0                	callq  *%rax
  80042060fc:	48 89 c3             	mov    %rax,%rbx
  80042060ff:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206103:	48 89 c7             	mov    %rax,%rdi
  8004206106:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  800420610d:	00 00 00 
  8004206110:	ff d0                	callq  *%rax
  8004206112:	48 39 c3             	cmp    %rax,%rbx
  8004206115:	74 35                	je     800420614c <page_check+0xa8d>
  8004206117:	48 b9 c8 df 21 04 80 	movabs $0x800421dfc8,%rcx
  800420611e:	00 00 00 
  8004206121:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206128:	00 00 00 
  800420612b:	be 2c 05 00 00       	mov    $0x52c,%esi
  8004206130:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206137:	00 00 00 
  800420613a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420613f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206146:	00 00 00 
  8004206149:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420614c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206150:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206154:	66 83 f8 02          	cmp    $0x2,%ax
  8004206158:	74 35                	je     800420618f <page_check+0xad0>
  800420615a:	48 b9 f8 df 21 04 80 	movabs $0x800421dff8,%rcx
  8004206161:	00 00 00 
  8004206164:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420616b:	00 00 00 
  800420616e:	be 2d 05 00 00       	mov    $0x52d,%esi
  8004206173:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420617a:	00 00 00 
  800420617d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206182:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206189:	00 00 00 
  800420618c:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  800420618f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206194:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  800420619b:	00 00 00 
  800420619e:	ff d0                	callq  *%rax
  80042061a0:	48 85 c0             	test   %rax,%rax
  80042061a3:	74 35                	je     80042061da <page_check+0xb1b>
  80042061a5:	48 b9 17 db 21 04 80 	movabs $0x800421db17,%rcx
  80042061ac:	00 00 00 
  80042061af:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042061b6:	00 00 00 
  80042061b9:	be 31 05 00 00       	mov    $0x531,%esi
  80042061be:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042061c5:	00 00 00 
  80042061c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061cd:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042061d4:	00 00 00 
  80042061d7:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  80042061da:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042061e1:	00 00 00 
  80042061e4:	48 8b 00             	mov    (%rax),%rax
  80042061e7:	48 8b 00             	mov    (%rax),%rax
  80042061ea:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042061f0:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  80042061f4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042061f8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042061fc:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  80042061ff:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004206202:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004206209:	00 00 00 
  800420620c:	48 8b 00             	mov    (%rax),%rax
  800420620f:	48 39 c2             	cmp    %rax,%rdx
  8004206212:	72 32                	jb     8004206246 <page_check+0xb87>
  8004206214:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206218:	48 89 c1             	mov    %rax,%rcx
  800420621b:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004206222:	00 00 00 
  8004206225:	be 33 05 00 00       	mov    $0x533,%esi
  800420622a:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206231:	00 00 00 
  8004206234:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206239:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206240:	00 00 00 
  8004206243:	41 ff d0             	callq  *%r8
  8004206246:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420624d:	00 00 00 
  8004206250:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206254:	48 01 d0             	add    %rdx,%rax
  8004206257:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  800420625b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420625f:	48 8b 00             	mov    (%rax),%rax
  8004206262:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206268:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  800420626c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206270:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206274:	89 45 8c             	mov    %eax,-0x74(%rbp)
  8004206277:	8b 55 8c             	mov    -0x74(%rbp),%edx
  800420627a:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004206281:	00 00 00 
  8004206284:	48 8b 00             	mov    (%rax),%rax
  8004206287:	48 39 c2             	cmp    %rax,%rdx
  800420628a:	72 32                	jb     80042062be <page_check+0xbff>
  800420628c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004206290:	48 89 c1             	mov    %rax,%rcx
  8004206293:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  800420629a:	00 00 00 
  800420629d:	be 34 05 00 00       	mov    $0x534,%esi
  80042062a2:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042062a9:	00 00 00 
  80042062ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062b1:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042062b8:	00 00 00 
  80042062bb:	41 ff d0             	callq  *%r8
  80042062be:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042062c5:	00 00 00 
  80042062c8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042062cc:	48 01 d0             	add    %rdx,%rax
  80042062cf:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  80042062d3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042062d7:	48 8b 00             	mov    (%rax),%rax
  80042062da:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042062e0:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042062e7:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042062ee:	48 c1 e8 0c          	shr    $0xc,%rax
  80042062f2:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  80042062f8:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  80042062fe:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004206305:	00 00 00 
  8004206308:	48 8b 00             	mov    (%rax),%rax
  800420630b:	48 39 c2             	cmp    %rax,%rdx
  800420630e:	72 35                	jb     8004206345 <page_check+0xc86>
  8004206310:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206317:	48 89 c1             	mov    %rax,%rcx
  800420631a:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004206321:	00 00 00 
  8004206324:	be 35 05 00 00       	mov    $0x535,%esi
  8004206329:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206330:	00 00 00 
  8004206333:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206338:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420633f:	00 00 00 
  8004206342:	41 ff d0             	callq  *%r8
  8004206345:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420634c:	00 00 00 
  800420634f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206356:	48 01 d0             	add    %rdx,%rax
  8004206359:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  8004206360:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206367:	00 00 00 
  800420636a:	48 8b 00             	mov    (%rax),%rax
  800420636d:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206372:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206377:	48 89 c7             	mov    %rax,%rdi
  800420637a:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  8004206381:	00 00 00 
  8004206384:	ff d0                	callq  *%rax
  8004206386:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  800420638d:	48 83 c2 08          	add    $0x8,%rdx
  8004206391:	48 39 d0             	cmp    %rdx,%rax
  8004206394:	74 35                	je     80042063cb <page_check+0xd0c>
  8004206396:	48 b9 10 e0 21 04 80 	movabs $0x800421e010,%rcx
  800420639d:	00 00 00 
  80042063a0:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042063a7:	00 00 00 
  80042063aa:	be 36 05 00 00       	mov    $0x536,%esi
  80042063af:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042063b6:	00 00 00 
  80042063b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063be:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042063c5:	00 00 00 
  80042063c8:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  80042063cb:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042063d2:	00 00 00 
  80042063d5:	48 8b 00             	mov    (%rax),%rax
  80042063d8:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042063dc:	b9 04 00 00 00       	mov    $0x4,%ecx
  80042063e1:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042063e6:	48 89 c7             	mov    %rax,%rdi
  80042063e9:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  80042063f0:	00 00 00 
  80042063f3:	ff d0                	callq  *%rax
  80042063f5:	85 c0                	test   %eax,%eax
  80042063f7:	74 35                	je     800420642e <page_check+0xd6f>
  80042063f9:	48 b9 50 e0 21 04 80 	movabs $0x800421e050,%rcx
  8004206400:	00 00 00 
  8004206403:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420640a:	00 00 00 
  800420640d:	be 39 05 00 00       	mov    $0x539,%esi
  8004206412:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206419:	00 00 00 
  800420641c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206421:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206428:	00 00 00 
  800420642b:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420642e:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206435:	00 00 00 
  8004206438:	48 8b 00             	mov    (%rax),%rax
  800420643b:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206440:	48 89 c7             	mov    %rax,%rdi
  8004206443:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  800420644a:	00 00 00 
  800420644d:	ff d0                	callq  *%rax
  800420644f:	48 89 c3             	mov    %rax,%rbx
  8004206452:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206456:	48 89 c7             	mov    %rax,%rdi
  8004206459:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004206460:	00 00 00 
  8004206463:	ff d0                	callq  *%rax
  8004206465:	48 39 c3             	cmp    %rax,%rbx
  8004206468:	74 35                	je     800420649f <page_check+0xde0>
  800420646a:	48 b9 c8 df 21 04 80 	movabs $0x800421dfc8,%rcx
  8004206471:	00 00 00 
  8004206474:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420647b:	00 00 00 
  800420647e:	be 3a 05 00 00       	mov    $0x53a,%esi
  8004206483:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420648a:	00 00 00 
  800420648d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206492:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206499:	00 00 00 
  800420649c:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420649f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042064a3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042064a7:	66 83 f8 02          	cmp    $0x2,%ax
  80042064ab:	74 35                	je     80042064e2 <page_check+0xe23>
  80042064ad:	48 b9 f8 df 21 04 80 	movabs $0x800421dff8,%rcx
  80042064b4:	00 00 00 
  80042064b7:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042064be:	00 00 00 
  80042064c1:	be 3b 05 00 00       	mov    $0x53b,%esi
  80042064c6:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042064cd:	00 00 00 
  80042064d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064d5:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042064dc:	00 00 00 
  80042064df:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  80042064e2:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042064e9:	00 00 00 
  80042064ec:	48 8b 00             	mov    (%rax),%rax
  80042064ef:	ba 00 00 00 00       	mov    $0x0,%edx
  80042064f4:	be 00 10 00 00       	mov    $0x1000,%esi
  80042064f9:	48 89 c7             	mov    %rax,%rdi
  80042064fc:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  8004206503:	00 00 00 
  8004206506:	ff d0                	callq  *%rax
  8004206508:	48 8b 00             	mov    (%rax),%rax
  800420650b:	83 e0 04             	and    $0x4,%eax
  800420650e:	48 85 c0             	test   %rax,%rax
  8004206511:	75 35                	jne    8004206548 <page_check+0xe89>
  8004206513:	48 b9 90 e0 21 04 80 	movabs $0x800421e090,%rcx
  800420651a:	00 00 00 
  800420651d:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206524:	00 00 00 
  8004206527:	be 3c 05 00 00       	mov    $0x53c,%esi
  800420652c:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206533:	00 00 00 
  8004206536:	b8 00 00 00 00       	mov    $0x0,%eax
  800420653b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206542:	00 00 00 
  8004206545:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206548:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  800420654f:	00 00 00 
  8004206552:	48 8b 00             	mov    (%rax),%rax
  8004206555:	48 8b 00             	mov    (%rax),%rax
  8004206558:	83 e0 04             	and    $0x4,%eax
  800420655b:	48 85 c0             	test   %rax,%rax
  800420655e:	75 35                	jne    8004206595 <page_check+0xed6>
  8004206560:	48 b9 c3 e0 21 04 80 	movabs $0x800421e0c3,%rcx
  8004206567:	00 00 00 
  800420656a:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206571:	00 00 00 
  8004206574:	be 3d 05 00 00       	mov    $0x53d,%esi
  8004206579:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206580:	00 00 00 
  8004206583:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206588:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420658f:	00 00 00 
  8004206592:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  8004206595:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  800420659c:	00 00 00 
  800420659f:	48 8b 00             	mov    (%rax),%rax
  80042065a2:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042065a6:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042065ab:	ba 00 00 20 00       	mov    $0x200000,%edx
  80042065b0:	48 89 c7             	mov    %rax,%rdi
  80042065b3:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  80042065ba:	00 00 00 
  80042065bd:	ff d0                	callq  *%rax
  80042065bf:	85 c0                	test   %eax,%eax
  80042065c1:	78 35                	js     80042065f8 <page_check+0xf39>
  80042065c3:	48 b9 e0 e0 21 04 80 	movabs $0x800421e0e0,%rcx
  80042065ca:	00 00 00 
  80042065cd:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042065d4:	00 00 00 
  80042065d7:	be 41 05 00 00       	mov    $0x541,%esi
  80042065dc:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042065e3:	00 00 00 
  80042065e6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065eb:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042065f2:	00 00 00 
  80042065f5:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  80042065f8:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042065ff:	00 00 00 
  8004206602:	48 8b 00             	mov    (%rax),%rax
  8004206605:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206609:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420660e:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206613:	48 89 c7             	mov    %rax,%rdi
  8004206616:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  800420661d:	00 00 00 
  8004206620:	ff d0                	callq  *%rax
  8004206622:	85 c0                	test   %eax,%eax
  8004206624:	74 35                	je     800420665b <page_check+0xf9c>
  8004206626:	48 b9 18 e1 21 04 80 	movabs $0x800421e118,%rcx
  800420662d:	00 00 00 
  8004206630:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206637:	00 00 00 
  800420663a:	be 44 05 00 00       	mov    $0x544,%esi
  800420663f:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206646:	00 00 00 
  8004206649:	b8 00 00 00 00       	mov    $0x0,%eax
  800420664e:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206655:	00 00 00 
  8004206658:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  800420665b:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206662:	00 00 00 
  8004206665:	48 8b 00             	mov    (%rax),%rax
  8004206668:	ba 00 00 00 00       	mov    $0x0,%edx
  800420666d:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206672:	48 89 c7             	mov    %rax,%rdi
  8004206675:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  800420667c:	00 00 00 
  800420667f:	ff d0                	callq  *%rax
  8004206681:	48 8b 00             	mov    (%rax),%rax
  8004206684:	83 e0 04             	and    $0x4,%eax
  8004206687:	48 85 c0             	test   %rax,%rax
  800420668a:	74 35                	je     80042066c1 <page_check+0x1002>
  800420668c:	48 b9 50 e1 21 04 80 	movabs $0x800421e150,%rcx
  8004206693:	00 00 00 
  8004206696:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420669d:	00 00 00 
  80042066a0:	be 45 05 00 00       	mov    $0x545,%esi
  80042066a5:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042066ac:	00 00 00 
  80042066af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066b4:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042066bb:	00 00 00 
  80042066be:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  80042066c1:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042066c8:	00 00 00 
  80042066cb:	48 8b 00             	mov    (%rax),%rax
  80042066ce:	be 00 00 00 00       	mov    $0x0,%esi
  80042066d3:	48 89 c7             	mov    %rax,%rdi
  80042066d6:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  80042066dd:	00 00 00 
  80042066e0:	ff d0                	callq  *%rax
  80042066e2:	48 89 c3             	mov    %rax,%rbx
  80042066e5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042066e9:	48 89 c7             	mov    %rax,%rdi
  80042066ec:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  80042066f3:	00 00 00 
  80042066f6:	ff d0                	callq  *%rax
  80042066f8:	48 39 c3             	cmp    %rax,%rbx
  80042066fb:	74 35                	je     8004206732 <page_check+0x1073>
  80042066fd:	48 b9 88 e1 21 04 80 	movabs $0x800421e188,%rcx
  8004206704:	00 00 00 
  8004206707:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420670e:	00 00 00 
  8004206711:	be 48 05 00 00       	mov    $0x548,%esi
  8004206716:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420671d:	00 00 00 
  8004206720:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206725:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420672c:	00 00 00 
  800420672f:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206732:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206739:	00 00 00 
  800420673c:	48 8b 00             	mov    (%rax),%rax
  800420673f:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206744:	48 89 c7             	mov    %rax,%rdi
  8004206747:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  800420674e:	00 00 00 
  8004206751:	ff d0                	callq  *%rax
  8004206753:	48 89 c3             	mov    %rax,%rbx
  8004206756:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420675a:	48 89 c7             	mov    %rax,%rdi
  800420675d:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004206764:	00 00 00 
  8004206767:	ff d0                	callq  *%rax
  8004206769:	48 39 c3             	cmp    %rax,%rbx
  800420676c:	74 35                	je     80042067a3 <page_check+0x10e4>
  800420676e:	48 b9 b8 e1 21 04 80 	movabs $0x800421e1b8,%rcx
  8004206775:	00 00 00 
  8004206778:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420677f:	00 00 00 
  8004206782:	be 49 05 00 00       	mov    $0x549,%esi
  8004206787:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420678e:	00 00 00 
  8004206791:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206796:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420679d:	00 00 00 
  80042067a0:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  80042067a3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042067a7:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042067ab:	66 83 f8 02          	cmp    $0x2,%ax
  80042067af:	74 35                	je     80042067e6 <page_check+0x1127>
  80042067b1:	48 b9 e8 e1 21 04 80 	movabs $0x800421e1e8,%rcx
  80042067b8:	00 00 00 
  80042067bb:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042067c2:	00 00 00 
  80042067c5:	be 4b 05 00 00       	mov    $0x54b,%esi
  80042067ca:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042067d1:	00 00 00 
  80042067d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067d9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042067e0:	00 00 00 
  80042067e3:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  80042067e6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042067ea:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042067ee:	66 83 f8 01          	cmp    $0x1,%ax
  80042067f2:	74 35                	je     8004206829 <page_check+0x116a>
  80042067f4:	48 b9 f9 e1 21 04 80 	movabs $0x800421e1f9,%rcx
  80042067fb:	00 00 00 
  80042067fe:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206805:	00 00 00 
  8004206808:	be 4c 05 00 00       	mov    $0x54c,%esi
  800420680d:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206814:	00 00 00 
  8004206817:	b8 00 00 00 00       	mov    $0x0,%eax
  800420681c:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206823:	00 00 00 
  8004206826:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  8004206829:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206830:	00 00 00 
  8004206833:	48 8b 00             	mov    (%rax),%rax
  8004206836:	be 00 00 00 00       	mov    $0x0,%esi
  800420683b:	48 89 c7             	mov    %rax,%rdi
  800420683e:	48 b8 d7 39 20 04 80 	movabs $0x80042039d7,%rax
  8004206845:	00 00 00 
  8004206848:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  800420684a:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206851:	00 00 00 
  8004206854:	48 8b 00             	mov    (%rax),%rax
  8004206857:	be 00 00 00 00       	mov    $0x0,%esi
  800420685c:	48 89 c7             	mov    %rax,%rdi
  800420685f:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  8004206866:	00 00 00 
  8004206869:	ff d0                	callq  *%rax
  800420686b:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  800420686f:	74 35                	je     80042068a6 <page_check+0x11e7>
  8004206871:	48 b9 10 e2 21 04 80 	movabs $0x800421e210,%rcx
  8004206878:	00 00 00 
  800420687b:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206882:	00 00 00 
  8004206885:	be 51 05 00 00       	mov    $0x551,%esi
  800420688a:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206891:	00 00 00 
  8004206894:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206899:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042068a0:	00 00 00 
  80042068a3:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  80042068a6:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042068ad:	00 00 00 
  80042068b0:	48 8b 00             	mov    (%rax),%rax
  80042068b3:	be 00 10 00 00       	mov    $0x1000,%esi
  80042068b8:	48 89 c7             	mov    %rax,%rdi
  80042068bb:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  80042068c2:	00 00 00 
  80042068c5:	ff d0                	callq  *%rax
  80042068c7:	48 89 c3             	mov    %rax,%rbx
  80042068ca:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042068ce:	48 89 c7             	mov    %rax,%rdi
  80042068d1:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  80042068d8:	00 00 00 
  80042068db:	ff d0                	callq  *%rax
  80042068dd:	48 39 c3             	cmp    %rax,%rbx
  80042068e0:	74 35                	je     8004206917 <page_check+0x1258>
  80042068e2:	48 b9 b8 e1 21 04 80 	movabs $0x800421e1b8,%rcx
  80042068e9:	00 00 00 
  80042068ec:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042068f3:	00 00 00 
  80042068f6:	be 52 05 00 00       	mov    $0x552,%esi
  80042068fb:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206902:	00 00 00 
  8004206905:	b8 00 00 00 00       	mov    $0x0,%eax
  800420690a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206911:	00 00 00 
  8004206914:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206917:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420691b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420691f:	66 83 f8 01          	cmp    $0x1,%ax
  8004206923:	74 35                	je     800420695a <page_check+0x129b>
  8004206925:	48 b9 5d df 21 04 80 	movabs $0x800421df5d,%rcx
  800420692c:	00 00 00 
  800420692f:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206936:	00 00 00 
  8004206939:	be 53 05 00 00       	mov    $0x553,%esi
  800420693e:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206945:	00 00 00 
  8004206948:	b8 00 00 00 00       	mov    $0x0,%eax
  800420694d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206954:	00 00 00 
  8004206957:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  800420695a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420695e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206962:	66 83 f8 01          	cmp    $0x1,%ax
  8004206966:	74 35                	je     800420699d <page_check+0x12de>
  8004206968:	48 b9 f9 e1 21 04 80 	movabs $0x800421e1f9,%rcx
  800420696f:	00 00 00 
  8004206972:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206979:	00 00 00 
  800420697c:	be 54 05 00 00       	mov    $0x554,%esi
  8004206981:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206988:	00 00 00 
  800420698b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206990:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206997:	00 00 00 
  800420699a:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  800420699d:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042069a4:	00 00 00 
  80042069a7:	48 8b 00             	mov    (%rax),%rax
  80042069aa:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042069ae:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042069b3:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042069b8:	48 89 c7             	mov    %rax,%rdi
  80042069bb:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  80042069c2:	00 00 00 
  80042069c5:	ff d0                	callq  *%rax
  80042069c7:	85 c0                	test   %eax,%eax
  80042069c9:	74 35                	je     8004206a00 <page_check+0x1341>
  80042069cb:	48 b9 18 e1 21 04 80 	movabs $0x800421e118,%rcx
  80042069d2:	00 00 00 
  80042069d5:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042069dc:	00 00 00 
  80042069df:	be 58 05 00 00       	mov    $0x558,%esi
  80042069e4:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042069eb:	00 00 00 
  80042069ee:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069f3:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042069fa:	00 00 00 
  80042069fd:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206a00:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a04:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206a08:	66 85 c0             	test   %ax,%ax
  8004206a0b:	75 35                	jne    8004206a42 <page_check+0x1383>
  8004206a0d:	48 b9 33 e2 21 04 80 	movabs $0x800421e233,%rcx
  8004206a14:	00 00 00 
  8004206a17:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206a1e:	00 00 00 
  8004206a21:	be 59 05 00 00       	mov    $0x559,%esi
  8004206a26:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206a2d:	00 00 00 
  8004206a30:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a35:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206a3c:	00 00 00 
  8004206a3f:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206a42:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a46:	48 8b 00             	mov    (%rax),%rax
  8004206a49:	48 85 c0             	test   %rax,%rax
  8004206a4c:	74 35                	je     8004206a83 <page_check+0x13c4>
  8004206a4e:	48 b9 3f e2 21 04 80 	movabs $0x800421e23f,%rcx
  8004206a55:	00 00 00 
  8004206a58:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206a5f:	00 00 00 
  8004206a62:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004206a67:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206a6e:	00 00 00 
  8004206a71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a76:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206a7d:	00 00 00 
  8004206a80:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206a83:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206a8a:	00 00 00 
  8004206a8d:	48 8b 00             	mov    (%rax),%rax
  8004206a90:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206a95:	48 89 c7             	mov    %rax,%rdi
  8004206a98:	48 b8 d7 39 20 04 80 	movabs $0x80042039d7,%rax
  8004206a9f:	00 00 00 
  8004206aa2:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206aa4:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206aab:	00 00 00 
  8004206aae:	48 8b 00             	mov    (%rax),%rax
  8004206ab1:	be 00 00 00 00       	mov    $0x0,%esi
  8004206ab6:	48 89 c7             	mov    %rax,%rdi
  8004206ab9:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  8004206ac0:	00 00 00 
  8004206ac3:	ff d0                	callq  *%rax
  8004206ac5:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206ac9:	74 35                	je     8004206b00 <page_check+0x1441>
  8004206acb:	48 b9 10 e2 21 04 80 	movabs $0x800421e210,%rcx
  8004206ad2:	00 00 00 
  8004206ad5:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206adc:	00 00 00 
  8004206adf:	be 5e 05 00 00       	mov    $0x55e,%esi
  8004206ae4:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206aeb:	00 00 00 
  8004206aee:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206af3:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206afa:	00 00 00 
  8004206afd:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206b00:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206b07:	00 00 00 
  8004206b0a:	48 8b 00             	mov    (%rax),%rax
  8004206b0d:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206b12:	48 89 c7             	mov    %rax,%rdi
  8004206b15:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  8004206b1c:	00 00 00 
  8004206b1f:	ff d0                	callq  *%rax
  8004206b21:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206b25:	74 35                	je     8004206b5c <page_check+0x149d>
  8004206b27:	48 b9 58 e2 21 04 80 	movabs $0x800421e258,%rcx
  8004206b2e:	00 00 00 
  8004206b31:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206b38:	00 00 00 
  8004206b3b:	be 5f 05 00 00       	mov    $0x55f,%esi
  8004206b40:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206b47:	00 00 00 
  8004206b4a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b4f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206b56:	00 00 00 
  8004206b59:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206b5c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b60:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b64:	66 85 c0             	test   %ax,%ax
  8004206b67:	74 35                	je     8004206b9e <page_check+0x14df>
  8004206b69:	48 b9 7e e2 21 04 80 	movabs $0x800421e27e,%rcx
  8004206b70:	00 00 00 
  8004206b73:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206b7a:	00 00 00 
  8004206b7d:	be 60 05 00 00       	mov    $0x560,%esi
  8004206b82:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206b89:	00 00 00 
  8004206b8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b91:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206b98:	00 00 00 
  8004206b9b:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206b9e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206ba2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206ba6:	66 83 f8 01          	cmp    $0x1,%ax
  8004206baa:	74 35                	je     8004206be1 <page_check+0x1522>
  8004206bac:	48 b9 f9 e1 21 04 80 	movabs $0x800421e1f9,%rcx
  8004206bb3:	00 00 00 
  8004206bb6:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206bbd:	00 00 00 
  8004206bc0:	be 61 05 00 00       	mov    $0x561,%esi
  8004206bc5:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206bcc:	00 00 00 
  8004206bcf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bd4:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206bdb:	00 00 00 
  8004206bde:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  8004206be1:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206be8:	00 00 00 
  8004206beb:	48 8b 00             	mov    (%rax),%rax
  8004206bee:	48 8b 00             	mov    (%rax),%rax
  8004206bf1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206bf7:	48 89 c3             	mov    %rax,%rbx
  8004206bfa:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206bfe:	48 89 c7             	mov    %rax,%rdi
  8004206c01:	48 b8 16 1c 20 04 80 	movabs $0x8004201c16,%rax
  8004206c08:	00 00 00 
  8004206c0b:	ff d0                	callq  *%rax
  8004206c0d:	48 39 c3             	cmp    %rax,%rbx
  8004206c10:	74 35                	je     8004206c47 <page_check+0x1588>
  8004206c12:	48 b9 90 e2 21 04 80 	movabs $0x800421e290,%rcx
  8004206c19:	00 00 00 
  8004206c1c:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206c23:	00 00 00 
  8004206c26:	be 75 05 00 00       	mov    $0x575,%esi
  8004206c2b:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206c32:	00 00 00 
  8004206c35:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c3a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206c41:	00 00 00 
  8004206c44:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  8004206c47:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206c4e:	00 00 00 
  8004206c51:	48 8b 00             	mov    (%rax),%rax
  8004206c54:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004206c5b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206c5f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206c63:	66 83 f8 01          	cmp    $0x1,%ax
  8004206c67:	74 35                	je     8004206c9e <page_check+0x15df>
  8004206c69:	48 b9 f9 e1 21 04 80 	movabs $0x800421e1f9,%rcx
  8004206c70:	00 00 00 
  8004206c73:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206c7a:	00 00 00 
  8004206c7d:	be 77 05 00 00       	mov    $0x577,%esi
  8004206c82:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206c89:	00 00 00 
  8004206c8c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c91:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206c98:	00 00 00 
  8004206c9b:	41 ff d0             	callq  *%r8
	page_decref(pp3);
  8004206c9e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206ca2:	48 89 c7             	mov    %rax,%rdi
  8004206ca5:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004206cac:	00 00 00 
  8004206caf:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  8004206cb1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206cb5:	48 89 c7             	mov    %rax,%rdi
  8004206cb8:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004206cbf:	00 00 00 
  8004206cc2:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206cc4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206cc8:	48 89 c7             	mov    %rax,%rdi
  8004206ccb:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004206cd2:	00 00 00 
  8004206cd5:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004206cd7:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  8004206cde:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004206ce2:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206ce9:	00 00 00 
  8004206cec:	48 8b 00             	mov    (%rax),%rax
  8004206cef:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  8004206cf6:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206cfb:	48 89 ce             	mov    %rcx,%rsi
  8004206cfe:	48 89 c7             	mov    %rax,%rdi
  8004206d01:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  8004206d08:	00 00 00 
  8004206d0b:	ff d0                	callq  *%rax
  8004206d0d:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004206d14:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206d1b:	00 00 00 
  8004206d1e:	48 8b 00             	mov    (%rax),%rax
  8004206d21:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004206d28:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206d2c:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004206d32:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206d36:	48 01 d0             	add    %rdx,%rax
  8004206d39:	48 8b 00             	mov    (%rax),%rax
  8004206d3c:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206d42:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004206d49:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d50:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206d54:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  8004206d5a:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  8004206d60:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004206d67:	00 00 00 
  8004206d6a:	48 8b 00             	mov    (%rax),%rax
  8004206d6d:	48 39 c2             	cmp    %rax,%rdx
  8004206d70:	72 35                	jb     8004206da7 <page_check+0x16e8>
  8004206d72:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206d79:	48 89 c1             	mov    %rax,%rcx
  8004206d7c:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004206d83:	00 00 00 
  8004206d86:	be 7e 05 00 00       	mov    $0x57e,%esi
  8004206d8b:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206d92:	00 00 00 
  8004206d95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d9a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206da1:	00 00 00 
  8004206da4:	41 ff d0             	callq  *%r8
  8004206da7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206dae:	00 00 00 
  8004206db1:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206db8:	48 01 d0             	add    %rdx,%rax
  8004206dbb:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004206dbf:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206dc6:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004206dca:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206dcf:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206dd6:	00 
  8004206dd7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206ddb:	48 01 d0             	add    %rdx,%rax
  8004206dde:	48 8b 00             	mov    (%rax),%rax
  8004206de1:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206de7:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004206dee:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206df5:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206df9:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  8004206dff:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  8004206e05:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004206e0c:	00 00 00 
  8004206e0f:	48 8b 00             	mov    (%rax),%rax
  8004206e12:	48 39 c2             	cmp    %rax,%rdx
  8004206e15:	72 35                	jb     8004206e4c <page_check+0x178d>
  8004206e17:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206e1e:	48 89 c1             	mov    %rax,%rcx
  8004206e21:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004206e28:	00 00 00 
  8004206e2b:	be 7f 05 00 00       	mov    $0x57f,%esi
  8004206e30:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206e37:	00 00 00 
  8004206e3a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206e3f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206e46:	00 00 00 
  8004206e49:	41 ff d0             	callq  *%r8
  8004206e4c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206e53:	00 00 00 
  8004206e56:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206e5d:	48 01 d0             	add    %rdx,%rax
  8004206e60:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206e64:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206e6b:	48 c1 e8 15          	shr    $0x15,%rax
  8004206e6f:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206e74:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206e7b:	00 
  8004206e7c:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206e80:	48 01 d0             	add    %rdx,%rax
  8004206e83:	48 8b 00             	mov    (%rax),%rax
  8004206e86:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206e8c:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004206e93:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206e9a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206e9e:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  8004206ea4:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  8004206eaa:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004206eb1:	00 00 00 
  8004206eb4:	48 8b 00             	mov    (%rax),%rax
  8004206eb7:	48 39 c2             	cmp    %rax,%rdx
  8004206eba:	72 35                	jb     8004206ef1 <page_check+0x1832>
  8004206ebc:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206ec3:	48 89 c1             	mov    %rax,%rcx
  8004206ec6:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  8004206ecd:	00 00 00 
  8004206ed0:	be 80 05 00 00       	mov    $0x580,%esi
  8004206ed5:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206edc:	00 00 00 
  8004206edf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ee4:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206eeb:	00 00 00 
  8004206eee:	41 ff d0             	callq  *%r8
  8004206ef1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206ef8:	00 00 00 
  8004206efb:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206f02:	48 01 d0             	add    %rdx,%rax
  8004206f05:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  8004206f0c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206f13:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206f17:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206f1c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206f23:	00 
  8004206f24:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004206f2b:	48 01 c2             	add    %rax,%rdx
  8004206f2e:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004206f35:	48 39 c2             	cmp    %rax,%rdx
  8004206f38:	74 35                	je     8004206f6f <page_check+0x18b0>
  8004206f3a:	48 b9 b8 e2 21 04 80 	movabs $0x800421e2b8,%rcx
  8004206f41:	00 00 00 
  8004206f44:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004206f4b:	00 00 00 
  8004206f4e:	be 81 05 00 00       	mov    $0x581,%esi
  8004206f53:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004206f5a:	00 00 00 
  8004206f5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f62:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004206f69:	00 00 00 
  8004206f6c:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	page_decref(pp4);
  8004206f6f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206f73:	48 89 c7             	mov    %rax,%rdi
  8004206f76:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004206f7d:	00 00 00 
  8004206f80:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  8004206f82:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004206f86:	48 89 c7             	mov    %rax,%rdi
  8004206f89:	48 b8 ac 1c 20 04 80 	movabs $0x8004201cac,%rax
  8004206f90:	00 00 00 
  8004206f93:	ff d0                	callq  *%rax
  8004206f95:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206f9a:	be ff 00 00 00       	mov    $0xff,%esi
  8004206f9f:	48 89 c7             	mov    %rax,%rdi
  8004206fa2:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004206fa9:	00 00 00 
  8004206fac:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  8004206fae:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206fb5:	00 00 00 
  8004206fb8:	48 8b 00             	mov    (%rax),%rax
  8004206fbb:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206fc0:	be 00 00 00 00       	mov    $0x0,%esi
  8004206fc5:	48 89 c7             	mov    %rax,%rdi
  8004206fc8:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  8004206fcf:	00 00 00 
  8004206fd2:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004206fd4:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004206fdb:	00 00 00 
  8004206fde:	48 8b 00             	mov    (%rax),%rax
  8004206fe1:	48 8b 00             	mov    (%rax),%rax
  8004206fe4:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206fea:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004206ff1:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004206ff8:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206ffc:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004207002:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004207008:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  800420700f:	00 00 00 
  8004207012:	48 8b 00             	mov    (%rax),%rax
  8004207015:	48 39 c2             	cmp    %rax,%rdx
  8004207018:	72 35                	jb     800420704f <page_check+0x1990>
  800420701a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207021:	48 89 c1             	mov    %rax,%rcx
  8004207024:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  800420702b:	00 00 00 
  800420702e:	be 87 05 00 00       	mov    $0x587,%esi
  8004207033:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420703a:	00 00 00 
  800420703d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207042:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004207049:	00 00 00 
  800420704c:	41 ff d0             	callq  *%r8
  800420704f:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207056:	00 00 00 
  8004207059:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207060:	48 01 d0             	add    %rdx,%rax
  8004207063:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  8004207067:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420706b:	48 8b 00             	mov    (%rax),%rax
  800420706e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004207074:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  800420707b:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004207082:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207086:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  800420708c:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  8004207092:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004207099:	00 00 00 
  800420709c:	48 8b 00             	mov    (%rax),%rax
  800420709f:	48 39 c2             	cmp    %rax,%rdx
  80042070a2:	72 35                	jb     80042070d9 <page_check+0x1a1a>
  80042070a4:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042070ab:	48 89 c1             	mov    %rax,%rcx
  80042070ae:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  80042070b5:	00 00 00 
  80042070b8:	be 88 05 00 00       	mov    $0x588,%esi
  80042070bd:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042070c4:	00 00 00 
  80042070c7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070cc:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042070d3:	00 00 00 
  80042070d6:	41 ff d0             	callq  *%r8
  80042070d9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042070e0:	00 00 00 
  80042070e3:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042070ea:	48 01 d0             	add    %rdx,%rax
  80042070ed:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  80042070f1:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042070f5:	48 8b 00             	mov    (%rax),%rax
  80042070f8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042070fe:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004207105:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420710c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207110:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  8004207116:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  800420711c:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004207123:	00 00 00 
  8004207126:	48 8b 00             	mov    (%rax),%rax
  8004207129:	48 39 c2             	cmp    %rax,%rdx
  800420712c:	72 35                	jb     8004207163 <page_check+0x1aa4>
  800420712e:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207135:	48 89 c1             	mov    %rax,%rcx
  8004207138:	48 ba f8 d5 21 04 80 	movabs $0x800421d5f8,%rdx
  800420713f:	00 00 00 
  8004207142:	be 89 05 00 00       	mov    $0x589,%esi
  8004207147:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420714e:	00 00 00 
  8004207151:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207156:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420715d:	00 00 00 
  8004207160:	41 ff d0             	callq  *%r8
  8004207163:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420716a:	00 00 00 
  800420716d:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207174:	48 01 d0             	add    %rdx,%rax
  8004207177:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  800420717e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004207185:	eb 58                	jmp    80042071df <page_check+0x1b20>
		assert((ptep[i] & PTE_P) == 0);
  8004207187:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  800420718e:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004207191:	48 63 d2             	movslq %edx,%rdx
  8004207194:	48 c1 e2 03          	shl    $0x3,%rdx
  8004207198:	48 01 d0             	add    %rdx,%rax
  800420719b:	48 8b 00             	mov    (%rax),%rax
  800420719e:	83 e0 01             	and    $0x1,%eax
  80042071a1:	48 85 c0             	test   %rax,%rax
  80042071a4:	74 35                	je     80042071db <page_check+0x1b1c>
  80042071a6:	48 b9 d0 e2 21 04 80 	movabs $0x800421e2d0,%rcx
  80042071ad:	00 00 00 
  80042071b0:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042071b7:	00 00 00 
  80042071ba:	be 8b 05 00 00       	mov    $0x58b,%esi
  80042071bf:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042071c6:	00 00 00 
  80042071c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042071ce:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042071d5:	00 00 00 
  80042071d8:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  80042071db:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042071df:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  80042071e6:	7e 9f                	jle    8004207187 <page_check+0x1ac8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  80042071e8:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042071ef:	00 00 00 
  80042071f2:	48 8b 00             	mov    (%rax),%rax
  80042071f5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  80042071fc:	48 b8 38 d2 3a 04 80 	movabs $0x80043ad238,%rax
  8004207203:	00 00 00 
  8004207206:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420720a:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  800420720d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207211:	48 89 c7             	mov    %rax,%rdi
  8004207214:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  800420721b:	00 00 00 
  800420721e:	ff d0                	callq  *%rax
	page_decref(pp1);
  8004207220:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207224:	48 89 c7             	mov    %rax,%rdi
  8004207227:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  800420722e:	00 00 00 
  8004207231:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004207233:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207237:	48 89 c7             	mov    %rax,%rdi
  800420723a:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207241:	00 00 00 
  8004207244:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004207246:	be 01 10 00 00       	mov    $0x1001,%esi
  800420724b:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207250:	48 b8 34 3b 20 04 80 	movabs $0x8004203b34,%rax
  8004207257:	00 00 00 
  800420725a:	ff d0                	callq  *%rax
  800420725c:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  8004207263:	be 00 10 00 00       	mov    $0x1000,%esi
  8004207268:	bf 00 00 00 00       	mov    $0x0,%edi
  800420726d:	48 b8 34 3b 20 04 80 	movabs $0x8004203b34,%rax
  8004207274:	00 00 00 
  8004207277:	ff d0                	callq  *%rax
  8004207279:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  8004207280:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004207287:	00 00 00 
  800420728a:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  8004207291:	76 1d                	jbe    80042072b0 <page_check+0x1bf1>
  8004207293:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800420729a:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042072a1:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042072a8:	00 00 00 
  80042072ab:	48 39 c2             	cmp    %rax,%rdx
  80042072ae:	76 35                	jbe    80042072e5 <page_check+0x1c26>
  80042072b0:	48 b9 e8 e2 21 04 80 	movabs $0x800421e2e8,%rcx
  80042072b7:	00 00 00 
  80042072ba:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042072c1:	00 00 00 
  80042072c4:	be 9a 05 00 00       	mov    $0x59a,%esi
  80042072c9:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042072d0:	00 00 00 
  80042072d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042072d8:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042072df:	00 00 00 
  80042072e2:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  80042072e5:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042072ec:	00 00 00 
  80042072ef:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  80042072f6:	76 1d                	jbe    8004207315 <page_check+0x1c56>
  80042072f8:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042072ff:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207306:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  800420730d:	00 00 00 
  8004207310:	48 39 c2             	cmp    %rax,%rdx
  8004207313:	76 35                	jbe    800420734a <page_check+0x1c8b>
  8004207315:	48 b9 10 e3 21 04 80 	movabs $0x800421e310,%rcx
  800420731c:	00 00 00 
  800420731f:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004207326:	00 00 00 
  8004207329:	be 9b 05 00 00       	mov    $0x59b,%esi
  800420732e:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004207335:	00 00 00 
  8004207338:	b8 00 00 00 00       	mov    $0x0,%eax
  800420733d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004207344:	00 00 00 
  8004207347:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  800420734a:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207351:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207356:	48 85 c0             	test   %rax,%rax
  8004207359:	75 11                	jne    800420736c <page_check+0x1cad>
  800420735b:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207362:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207367:	48 85 c0             	test   %rax,%rax
  800420736a:	74 35                	je     80042073a1 <page_check+0x1ce2>
  800420736c:	48 b9 38 e3 21 04 80 	movabs $0x800421e338,%rcx
  8004207373:	00 00 00 
  8004207376:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420737d:	00 00 00 
  8004207380:	be 9d 05 00 00       	mov    $0x59d,%esi
  8004207385:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420738c:	00 00 00 
  800420738f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207394:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420739b:	00 00 00 
  800420739e:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  80042073a1:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042073a8:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  80042073ae:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  80042073b5:	76 35                	jbe    80042073ec <page_check+0x1d2d>
  80042073b7:	48 b9 5f e3 21 04 80 	movabs $0x800421e35f,%rcx
  80042073be:	00 00 00 
  80042073c1:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042073c8:	00 00 00 
  80042073cb:	be 9f 05 00 00       	mov    $0x59f,%esi
  80042073d0:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042073d7:	00 00 00 
  80042073da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042073df:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042073e6:	00 00 00 
  80042073e9:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  80042073ec:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042073f3:	00 00 00 
  80042073f6:	48 8b 00             	mov    (%rax),%rax
  80042073f9:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004207400:	48 89 d6             	mov    %rdx,%rsi
  8004207403:	48 89 c7             	mov    %rax,%rdi
  8004207406:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  800420740d:	00 00 00 
  8004207410:	ff d0                	callq  *%rax
  8004207412:	48 85 c0             	test   %rax,%rax
  8004207415:	74 35                	je     800420744c <page_check+0x1d8d>
  8004207417:	48 b9 78 e3 21 04 80 	movabs $0x800421e378,%rcx
  800420741e:	00 00 00 
  8004207421:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004207428:	00 00 00 
  800420742b:	be a2 05 00 00       	mov    $0x5a2,%esi
  8004207430:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004207437:	00 00 00 
  800420743a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420743f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004207446:	00 00 00 
  8004207449:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  800420744c:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207453:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  800420745a:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004207461:	00 00 00 
  8004207464:	48 8b 00             	mov    (%rax),%rax
  8004207467:	48 89 d6             	mov    %rdx,%rsi
  800420746a:	48 89 c7             	mov    %rax,%rdi
  800420746d:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  8004207474:	00 00 00 
  8004207477:	ff d0                	callq  *%rax
  8004207479:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  800420747f:	74 35                	je     80042074b6 <page_check+0x1df7>
  8004207481:	48 b9 a0 e3 21 04 80 	movabs $0x800421e3a0,%rcx
  8004207488:	00 00 00 
  800420748b:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004207492:	00 00 00 
  8004207495:	be a3 05 00 00       	mov    $0x5a3,%esi
  800420749a:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042074a1:	00 00 00 
  80042074a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074a9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042074b0:	00 00 00 
  80042074b3:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  80042074b6:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042074bd:	00 00 00 
  80042074c0:	48 8b 00             	mov    (%rax),%rax
  80042074c3:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  80042074ca:	48 89 d6             	mov    %rdx,%rsi
  80042074cd:	48 89 c7             	mov    %rax,%rdi
  80042074d0:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  80042074d7:	00 00 00 
  80042074da:	ff d0                	callq  *%rax
  80042074dc:	48 85 c0             	test   %rax,%rax
  80042074df:	74 35                	je     8004207516 <page_check+0x1e57>
  80042074e1:	48 b9 d0 e3 21 04 80 	movabs $0x800421e3d0,%rcx
  80042074e8:	00 00 00 
  80042074eb:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042074f2:	00 00 00 
  80042074f5:	be a4 05 00 00       	mov    $0x5a4,%esi
  80042074fa:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004207501:	00 00 00 
  8004207504:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207509:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004207510:	00 00 00 
  8004207513:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207516:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800420751d:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207524:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  800420752b:	00 00 00 
  800420752e:	48 8b 00             	mov    (%rax),%rax
  8004207531:	48 89 d6             	mov    %rdx,%rsi
  8004207534:	48 89 c7             	mov    %rax,%rdi
  8004207537:	48 b8 45 54 20 04 80 	movabs $0x8004205445,%rax
  800420753e:	00 00 00 
  8004207541:	ff d0                	callq  *%rax
  8004207543:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207547:	74 35                	je     800420757e <page_check+0x1ebf>
  8004207549:	48 b9 f8 e3 21 04 80 	movabs $0x800421e3f8,%rcx
  8004207550:	00 00 00 
  8004207553:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  800420755a:	00 00 00 
  800420755d:	be a5 05 00 00       	mov    $0x5a5,%esi
  8004207562:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  8004207569:	00 00 00 
  800420756c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207571:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004207578:	00 00 00 
  800420757b:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  800420757e:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207585:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  800420758c:	00 00 00 
  800420758f:	48 8b 00             	mov    (%rax),%rax
  8004207592:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207597:	48 89 ce             	mov    %rcx,%rsi
  800420759a:	48 89 c7             	mov    %rax,%rdi
  800420759d:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  80042075a4:	00 00 00 
  80042075a7:	ff d0                	callq  *%rax
  80042075a9:	48 8b 00             	mov    (%rax),%rax
  80042075ac:	83 e0 1a             	and    $0x1a,%eax
  80042075af:	48 85 c0             	test   %rax,%rax
  80042075b2:	75 35                	jne    80042075e9 <page_check+0x1f2a>
  80042075b4:	48 b9 28 e4 21 04 80 	movabs $0x800421e428,%rcx
  80042075bb:	00 00 00 
  80042075be:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  80042075c5:	00 00 00 
  80042075c8:	be a7 05 00 00       	mov    $0x5a7,%esi
  80042075cd:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  80042075d4:	00 00 00 
  80042075d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075dc:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042075e3:	00 00 00 
  80042075e6:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  80042075e9:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042075f0:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042075f7:	00 00 00 
  80042075fa:	48 8b 00             	mov    (%rax),%rax
  80042075fd:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207602:	48 89 ce             	mov    %rcx,%rsi
  8004207605:	48 89 c7             	mov    %rax,%rdi
  8004207608:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  800420760f:	00 00 00 
  8004207612:	ff d0                	callq  *%rax
  8004207614:	48 8b 00             	mov    (%rax),%rax
  8004207617:	83 e0 04             	and    $0x4,%eax
  800420761a:	48 85 c0             	test   %rax,%rax
  800420761d:	74 35                	je     8004207654 <page_check+0x1f95>
  800420761f:	48 b9 70 e4 21 04 80 	movabs $0x800421e470,%rcx
  8004207626:	00 00 00 
  8004207629:	48 ba 71 d6 21 04 80 	movabs $0x800421d671,%rdx
  8004207630:	00 00 00 
  8004207633:	be a8 05 00 00       	mov    $0x5a8,%esi
  8004207638:	48 bf 86 d6 21 04 80 	movabs $0x800421d686,%rdi
  800420763f:	00 00 00 
  8004207642:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207647:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420764e:	00 00 00 
  8004207651:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207654:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  800420765b:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004207662:	00 00 00 
  8004207665:	48 8b 00             	mov    (%rax),%rax
  8004207668:	ba 00 00 00 00       	mov    $0x0,%edx
  800420766d:	48 89 ce             	mov    %rcx,%rsi
  8004207670:	48 89 c7             	mov    %rax,%rdi
  8004207673:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  800420767a:	00 00 00 
  800420767d:	ff d0                	callq  *%rax
  800420767f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  8004207686:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800420768d:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207693:	48 89 c1             	mov    %rax,%rcx
  8004207696:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  800420769d:	00 00 00 
  80042076a0:	48 8b 00             	mov    (%rax),%rax
  80042076a3:	ba 00 00 00 00       	mov    $0x0,%edx
  80042076a8:	48 89 ce             	mov    %rcx,%rsi
  80042076ab:	48 89 c7             	mov    %rax,%rdi
  80042076ae:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  80042076b5:	00 00 00 
  80042076b8:	ff d0                	callq  *%rax
  80042076ba:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  80042076c1:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  80042076c8:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  80042076cf:	00 00 00 
  80042076d2:	48 8b 00             	mov    (%rax),%rax
  80042076d5:	ba 00 00 00 00       	mov    $0x0,%edx
  80042076da:	48 89 ce             	mov    %rcx,%rsi
  80042076dd:	48 89 c7             	mov    %rax,%rdi
  80042076e0:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  80042076e7:	00 00 00 
  80042076ea:	ff d0                	callq  *%rax
  80042076ec:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  80042076f3:	48 bf a3 e4 21 04 80 	movabs $0x800421e4a3,%rdi
  80042076fa:	00 00 00 
  80042076fd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207702:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004207709:	00 00 00 
  800420770c:	ff d2                	callq  *%rdx
}
  800420770e:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207715:	5b                   	pop    %rbx
  8004207716:	5d                   	pop    %rbp
  8004207717:	c3                   	retq   

0000008004207718 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207718:	55                   	push   %rbp
  8004207719:	48 89 e5             	mov    %rsp,%rbp
  800420771c:	48 83 ec 08          	sub    $0x8,%rsp
  8004207720:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207724:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207728:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  800420772f:	00 00 00 
  8004207732:	48 8b 00             	mov    (%rax),%rax
  8004207735:	48 29 c2             	sub    %rax,%rdx
  8004207738:	48 89 d0             	mov    %rdx,%rax
  800420773b:	48 c1 f8 04          	sar    $0x4,%rax
}
  800420773f:	c9                   	leaveq 
  8004207740:	c3                   	retq   

0000008004207741 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207741:	55                   	push   %rbp
  8004207742:	48 89 e5             	mov    %rsp,%rbp
  8004207745:	48 83 ec 08          	sub    $0x8,%rsp
  8004207749:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800420774d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207751:	48 89 c7             	mov    %rax,%rdi
  8004207754:	48 b8 18 77 20 04 80 	movabs $0x8004207718,%rax
  800420775b:	00 00 00 
  800420775e:	ff d0                	callq  *%rax
  8004207760:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004207764:	c9                   	leaveq 
  8004207765:	c3                   	retq   

0000008004207766 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004207766:	55                   	push   %rbp
  8004207767:	48 89 e5             	mov    %rsp,%rbp
  800420776a:	48 83 ec 10          	sub    $0x10,%rsp
  800420776e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004207772:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207776:	48 c1 e8 0c          	shr    $0xc,%rax
  800420777a:	48 89 c2             	mov    %rax,%rdx
  800420777d:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004207784:	00 00 00 
  8004207787:	48 8b 00             	mov    (%rax),%rax
  800420778a:	48 39 c2             	cmp    %rax,%rdx
  800420778d:	72 2a                	jb     80042077b9 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  800420778f:	48 ba c0 e4 21 04 80 	movabs $0x800421e4c0,%rdx
  8004207796:	00 00 00 
  8004207799:	be 54 00 00 00       	mov    $0x54,%esi
  800420779e:	48 bf df e4 21 04 80 	movabs $0x800421e4df,%rdi
  80042077a5:	00 00 00 
  80042077a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042077ad:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  80042077b4:	00 00 00 
  80042077b7:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042077b9:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  80042077c0:	00 00 00 
  80042077c3:	48 8b 00             	mov    (%rax),%rax
  80042077c6:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042077ca:	48 c1 ea 0c          	shr    $0xc,%rdx
  80042077ce:	48 c1 e2 04          	shl    $0x4,%rdx
  80042077d2:	48 01 d0             	add    %rdx,%rax
}
  80042077d5:	c9                   	leaveq 
  80042077d6:	c3                   	retq   

00000080042077d7 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  80042077d7:	55                   	push   %rbp
  80042077d8:	48 89 e5             	mov    %rsp,%rbp
  80042077db:	48 83 ec 20          	sub    $0x20,%rsp
  80042077df:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  80042077e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042077e7:	48 89 c7             	mov    %rax,%rdi
  80042077ea:	48 b8 41 77 20 04 80 	movabs $0x8004207741,%rax
  80042077f1:	00 00 00 
  80042077f4:	ff d0                	callq  *%rax
  80042077f6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042077fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042077fe:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207802:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207805:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207808:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  800420780f:	00 00 00 
  8004207812:	48 8b 00             	mov    (%rax),%rax
  8004207815:	48 39 c2             	cmp    %rax,%rdx
  8004207818:	72 32                	jb     800420784c <page2kva+0x75>
  800420781a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420781e:	48 89 c1             	mov    %rax,%rcx
  8004207821:	48 ba f0 e4 21 04 80 	movabs $0x800421e4f0,%rdx
  8004207828:	00 00 00 
  800420782b:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004207830:	48 bf df e4 21 04 80 	movabs $0x800421e4df,%rdi
  8004207837:	00 00 00 
  800420783a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420783f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004207846:	00 00 00 
  8004207849:	41 ff d0             	callq  *%r8
  800420784c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207853:	00 00 00 
  8004207856:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420785a:	48 01 d0             	add    %rdx,%rax
}
  800420785d:	c9                   	leaveq 
  800420785e:	c3                   	retq   

000000800420785f <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420785f:	55                   	push   %rbp
  8004207860:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004207863:	48 bf 40 37 23 04 80 	movabs $0x8004233740,%rdi
  800420786a:	00 00 00 
  800420786d:	48 b8 fc 7f 21 04 80 	movabs $0x8004217ffc,%rax
  8004207874:	00 00 00 
  8004207877:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  8004207879:	f3 90                	pause  
}
  800420787b:	5d                   	pop    %rbp
  800420787c:	c3                   	retq   

000000800420787d <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  800420787d:	55                   	push   %rbp
  800420787e:	48 89 e5             	mov    %rsp,%rbp
  8004207881:	53                   	push   %rbx
  8004207882:	48 83 ec 28          	sub    $0x28,%rsp
  8004207886:	89 7d dc             	mov    %edi,-0x24(%rbp)
  8004207889:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420788d:	89 d0                	mov    %edx,%eax
  800420788f:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  8004207892:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004207896:	75 41                	jne    80042078d9 <envid2env+0x5c>
		*env_store = curenv;
  8004207898:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420789f:	00 00 00 
  80042078a2:	ff d0                	callq  *%rax
  80042078a4:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  80042078ab:	00 00 00 
  80042078ae:	48 98                	cltq   
  80042078b0:	48 c1 e0 03          	shl    $0x3,%rax
  80042078b4:	48 89 c1             	mov    %rax,%rcx
  80042078b7:	48 c1 e1 04          	shl    $0x4,%rcx
  80042078bb:	48 01 c8             	add    %rcx,%rax
  80042078be:	48 01 d0             	add    %rdx,%rax
  80042078c1:	48 83 c0 08          	add    $0x8,%rax
  80042078c5:	48 8b 10             	mov    (%rax),%rdx
  80042078c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042078cc:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  80042078cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078d4:	e9 fd 00 00 00       	jmpq   80042079d6 <envid2env+0x159>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  80042078d9:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  80042078e0:	00 00 00 
  80042078e3:	48 8b 10             	mov    (%rax),%rdx
  80042078e6:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042078e9:	48 98                	cltq   
  80042078eb:	25 ff 03 00 00       	and    $0x3ff,%eax
  80042078f0:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  80042078f7:	48 01 d0             	add    %rdx,%rax
  80042078fa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  80042078fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207902:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207908:	85 c0                	test   %eax,%eax
  800420790a:	74 0f                	je     800420791b <envid2env+0x9e>
  800420790c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207910:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207916:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207919:	74 15                	je     8004207930 <envid2env+0xb3>
		*env_store = 0;
  800420791b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420791f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207926:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420792b:	e9 a6 00 00 00       	jmpq   80042079d6 <envid2env+0x159>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207930:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207934:	0f 84 8c 00 00 00    	je     80042079c6 <envid2env+0x149>
  800420793a:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004207941:	00 00 00 
  8004207944:	ff d0                	callq  *%rax
  8004207946:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420794d:	00 00 00 
  8004207950:	48 98                	cltq   
  8004207952:	48 c1 e0 03          	shl    $0x3,%rax
  8004207956:	48 89 c1             	mov    %rax,%rcx
  8004207959:	48 c1 e1 04          	shl    $0x4,%rcx
  800420795d:	48 01 c8             	add    %rcx,%rax
  8004207960:	48 01 d0             	add    %rdx,%rax
  8004207963:	48 83 c0 08          	add    $0x8,%rax
  8004207967:	48 8b 00             	mov    (%rax),%rax
  800420796a:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420796e:	74 56                	je     80042079c6 <envid2env+0x149>
  8004207970:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207974:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  800420797a:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004207981:	00 00 00 
  8004207984:	ff d0                	callq  *%rax
  8004207986:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420798d:	00 00 00 
  8004207990:	48 98                	cltq   
  8004207992:	48 c1 e0 03          	shl    $0x3,%rax
  8004207996:	48 89 c1             	mov    %rax,%rcx
  8004207999:	48 c1 e1 04          	shl    $0x4,%rcx
  800420799d:	48 01 c8             	add    %rcx,%rax
  80042079a0:	48 01 d0             	add    %rdx,%rax
  80042079a3:	48 83 c0 08          	add    $0x8,%rax
  80042079a7:	48 8b 00             	mov    (%rax),%rax
  80042079aa:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  80042079b0:	39 c3                	cmp    %eax,%ebx
  80042079b2:	74 12                	je     80042079c6 <envid2env+0x149>
		*env_store = 0;
  80042079b4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042079b8:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  80042079bf:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80042079c4:	eb 10                	jmp    80042079d6 <envid2env+0x159>
	}

	*env_store = e;
  80042079c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042079ca:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042079ce:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  80042079d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042079d6:	48 83 c4 28          	add    $0x28,%rsp
  80042079da:	5b                   	pop    %rbx
  80042079db:	5d                   	pop    %rbp
  80042079dc:	c3                   	retq   

00000080042079dd <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  80042079dd:	55                   	push   %rbp
  80042079de:	48 89 e5             	mov    %rsp,%rbp
  80042079e1:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
  80042079e5:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042079ec:	00 
	memset(envs, 0, NENV * sizeof(struct Env));
  80042079ed:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  80042079f4:	00 00 00 
  80042079f7:	48 8b 00             	mov    (%rax),%rax
  80042079fa:	ba 00 a0 05 00       	mov    $0x5a000,%edx
  80042079ff:	be 00 00 00 00       	mov    $0x0,%esi
  8004207a04:	48 89 c7             	mov    %rax,%rdi
  8004207a07:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004207a0e:	00 00 00 
  8004207a11:	ff d0                	callq  *%rax
	for (i = 0; i < NENV; i++) {
  8004207a13:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207a1a:	00 
  8004207a1b:	eb 7b                	jmp    8004207a98 <env_init+0xbb>
		if(last)
  8004207a1d:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207a22:	74 28                	je     8004207a4c <env_init+0x6f>
			last->env_link = &envs[i];
  8004207a24:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  8004207a2b:	00 00 00 
  8004207a2e:	48 8b 10             	mov    (%rax),%rdx
  8004207a31:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a35:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207a3c:	48 01 c2             	add    %rax,%rdx
  8004207a3f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207a43:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
  8004207a4a:	eb 28                	jmp    8004207a74 <env_init+0x97>
		else
			env_free_list = &envs[i];
  8004207a4c:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  8004207a53:	00 00 00 
  8004207a56:	48 8b 10             	mov    (%rax),%rdx
  8004207a59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a5d:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207a64:	48 01 c2             	add    %rax,%rdx
  8004207a67:	48 b8 60 d2 3a 04 80 	movabs $0x80043ad260,%rax
  8004207a6e:	00 00 00 
  8004207a71:	48 89 10             	mov    %rdx,(%rax)
		last = &envs[i];
  8004207a74:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  8004207a7b:	00 00 00 
  8004207a7e:	48 8b 10             	mov    (%rax),%rdx
  8004207a81:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207a85:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207a8c:	48 01 d0             	add    %rdx,%rax
  8004207a8f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
	memset(envs, 0, NENV * sizeof(struct Env));
	for (i = 0; i < NENV; i++) {
  8004207a93:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004207a98:	48 81 7d f8 ff 03 00 	cmpq   $0x3ff,-0x8(%rbp)
  8004207a9f:	00 
  8004207aa0:	0f 86 77 ff ff ff    	jbe    8004207a1d <env_init+0x40>
		else
			env_free_list = &envs[i];
		last = &envs[i];
	}
	// Per-CPU part of the initialization
	env_init_percpu();
  8004207aa6:	48 b8 b4 7a 20 04 80 	movabs $0x8004207ab4,%rax
  8004207aad:	00 00 00 
  8004207ab0:	ff d0                	callq  *%rax
}
  8004207ab2:	c9                   	leaveq 
  8004207ab3:	c3                   	retq   

0000008004207ab4 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207ab4:	55                   	push   %rbp
  8004207ab5:	48 89 e5             	mov    %rsp,%rbp
  8004207ab8:	53                   	push   %rbx
  8004207ab9:	48 83 ec 10          	sub    $0x10,%rsp
  8004207abd:	48 b8 48 36 23 04 80 	movabs $0x8004233648,%rax
  8004207ac4:	00 00 00 
  8004207ac7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

    static __inline void
lgdt(void *p)
{
    __asm __volatile("lgdt (%0)" : : "r" (p));
  8004207acb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207acf:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004207ad2:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207ad7:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004207ad9:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207ade:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  8004207ae0:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207ae5:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207ae7:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207aec:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004207aee:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207af3:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207af5:	b8 08 00 00 00       	mov    $0x8,%eax
  8004207afa:	89 c3                	mov    %eax,%ebx
  8004207afc:	53                   	push   %rbx
  8004207afd:	48 b8 0a 7b 20 04 80 	movabs $0x8004207b0a,%rax
  8004207b04:	00 00 00 
  8004207b07:	50                   	push   %rax
  8004207b08:	48 cb                	lretq  
  8004207b0a:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

    static __inline void
lldt(uint16_t sel)
{
    __asm __volatile("lldt %0" : : "r" (sel));
  8004207b10:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8004207b14:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  8004207b17:	48 83 c4 10          	add    $0x10,%rsp
  8004207b1b:	5b                   	pop    %rbx
  8004207b1c:	5d                   	pop    %rbp
  8004207b1d:	c3                   	retq   

0000008004207b1e <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004207b1e:	55                   	push   %rbp
  8004207b1f:	48 89 e5             	mov    %rsp,%rbp
  8004207b22:	48 83 ec 20          	sub    $0x20,%rsp
  8004207b26:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004207b2a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207b31:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207b32:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207b37:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004207b3e:	00 00 00 
  8004207b41:	ff d0                	callq  *%rax
  8004207b43:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207b47:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207b4c:	75 0a                	jne    8004207b58 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004207b4e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207b53:	e9 98 00 00 00       	jmpq   8004207bf0 <env_setup_vm+0xd2>
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	//Increment page reference here
	p->pp_ref++;
  8004207b58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b5c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207b60:	8d 50 01             	lea    0x1(%rax),%edx
  8004207b63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b67:	66 89 50 08          	mov    %dx,0x8(%rax)

	//fill structure values
	e->env_pml4e = (pml4e_t *)page2kva(p);
  8004207b6b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b6f:	48 89 c7             	mov    %rax,%rdi
  8004207b72:	48 b8 d7 77 20 04 80 	movabs $0x80042077d7,%rax
  8004207b79:	00 00 00 
  8004207b7c:	ff d0                	callq  *%rax
  8004207b7e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207b82:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3= page2pa(p);
  8004207b89:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b8d:	48 89 c7             	mov    %rax,%rdi
  8004207b90:	48 b8 41 77 20 04 80 	movabs $0x8004207741,%rax
  8004207b97:	00 00 00 
  8004207b9a:	ff d0                	callq  *%rax
  8004207b9c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207ba0:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)

	//copy kernel pml4e entries 
    //for (i = PML4(UTOP); i != NPDENTRIES; i++)
    //    e->env_pml4e[i] = boot_pml4e[i]|PTE_USER;
	
	e->env_pml4e[1] = boot_pml4e[1];
  8004207ba7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207bab:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207bb2:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004207bb6:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  8004207bbd:	00 00 00 
  8004207bc0:	48 8b 00             	mov    (%rax),%rax
  8004207bc3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207bc7:	48 89 02             	mov    %rax,(%rdx)
	//cprintf("envpml4e[0] [%x],envpml4e[1] [%x], env cr3[%x] ,  UTOP [%x] PML4e1 [%x]",e->env_pml4e[0],e->env_pml4e[0], e->env_cr3, UTOP, PML4(UTOP));

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 |PTE_P|PTE_W|PTE_U;
  8004207bca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207bce:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207bd5:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004207bd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207bdd:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207be4:	48 83 c8 07          	or     $0x7,%rax
  8004207be8:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  8004207beb:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207bf0:	c9                   	leaveq 
  8004207bf1:	c3                   	retq   

0000008004207bf2 <env_guest_alloc>:

#ifndef VMM_GUEST
int
env_guest_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004207bf2:	55                   	push   %rbp
  8004207bf3:	48 89 e5             	mov    %rsp,%rbp
  8004207bf6:	48 83 ec 50          	sub    $0x50,%rsp
  8004207bfa:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004207bfe:	89 75 b4             	mov    %esi,-0x4c(%rbp)
	int32_t generation;
	struct Env *e;

	if (!(e = env_free_list))
  8004207c01:	48 b8 60 d2 3a 04 80 	movabs $0x80043ad260,%rax
  8004207c08:	00 00 00 
  8004207c0b:	48 8b 00             	mov    (%rax),%rax
  8004207c0e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004207c12:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207c17:	75 0a                	jne    8004207c23 <env_guest_alloc+0x31>
		return -E_NO_FREE_ENV;
  8004207c19:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004207c1e:	e9 55 04 00 00       	jmpq   8004208078 <env_guest_alloc+0x486>

	memset(&e->env_vmxinfo, 0, sizeof(struct VmxGuestInfo));
  8004207c23:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c27:	48 05 20 01 00 00    	add    $0x120,%rax
  8004207c2d:	ba 48 00 00 00       	mov    $0x48,%edx
  8004207c32:	be 00 00 00 00       	mov    $0x0,%esi
  8004207c37:	48 89 c7             	mov    %rax,%rdi
  8004207c3a:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004207c41:	00 00 00 
  8004207c44:	ff d0                	callq  *%rax

	// allocate a page for the EPT PML4..
	struct PageInfo *p = NULL;
  8004207c46:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004207c4d:	00 

	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207c4e:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207c53:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004207c5a:	00 00 00 
  8004207c5d:	ff d0                	callq  *%rax
  8004207c5f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004207c63:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004207c68:	75 0a                	jne    8004207c74 <env_guest_alloc+0x82>
		return -E_NO_MEM;
  8004207c6a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207c6f:	e9 04 04 00 00       	jmpq   8004208078 <env_guest_alloc+0x486>

	memset(p, 0, sizeof(struct PageInfo));
  8004207c74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207c78:	ba 10 00 00 00       	mov    $0x10,%edx
  8004207c7d:	be 00 00 00 00       	mov    $0x0,%esi
  8004207c82:	48 89 c7             	mov    %rax,%rdi
  8004207c85:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004207c8c:	00 00 00 
  8004207c8f:	ff d0                	callq  *%rax
	p->pp_ref       += 1;
  8004207c91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207c95:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207c99:	8d 50 01             	lea    0x1(%rax),%edx
  8004207c9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207ca0:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_pml4e    = page2kva(p);
  8004207ca4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207ca8:	48 89 c7             	mov    %rax,%rdi
  8004207cab:	48 b8 d7 77 20 04 80 	movabs $0x80042077d7,%rax
  8004207cb2:	00 00 00 
  8004207cb5:	ff d0                	callq  *%rax
  8004207cb7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207cbb:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3      = page2pa(p);
  8004207cc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207cc6:	48 89 c7             	mov    %rax,%rdi
  8004207cc9:	48 b8 41 77 20 04 80 	movabs $0x8004207741,%rax
  8004207cd0:	00 00 00 
  8004207cd3:	ff d0                	callq  *%rax
  8004207cd5:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207cd9:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)

	// Allocate a VMCS.
	struct PageInfo *q = vmx_init_vmcs();
  8004207ce0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207ce5:	48 ba ca 9c 21 04 80 	movabs $0x8004219cca,%rdx
  8004207cec:	00 00 00 
  8004207cef:	ff d2                	callq  *%rdx
  8004207cf1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (!q) {
  8004207cf5:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004207cfa:	75 1d                	jne    8004207d19 <env_guest_alloc+0x127>
		page_decref(p);
  8004207cfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207d00:	48 89 c7             	mov    %rax,%rdi
  8004207d03:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207d0a:	00 00 00 
  8004207d0d:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004207d0f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207d14:	e9 5f 03 00 00       	jmpq   8004208078 <env_guest_alloc+0x486>
	}
	q->pp_ref += 1;
  8004207d19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207d1d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207d21:	8d 50 01             	lea    0x1(%rax),%edx
  8004207d24:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207d28:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.vmcs = page2kva(q);
  8004207d2c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207d30:	48 89 c7             	mov    %rax,%rdi
  8004207d33:	48 b8 d7 77 20 04 80 	movabs $0x80042077d7,%rax
  8004207d3a:	00 00 00 
  8004207d3d:	ff d0                	callq  *%rax
  8004207d3f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207d43:	48 89 82 28 01 00 00 	mov    %rax,0x128(%rdx)

	// Allocate a page for msr load/store area.
	struct PageInfo *r = NULL;
  8004207d4a:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004207d51:	00 
	if (!(r = page_alloc(ALLOC_ZERO))) {
  8004207d52:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207d57:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004207d5e:	00 00 00 
  8004207d61:	ff d0                	callq  *%rax
  8004207d63:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004207d67:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004207d6c:	75 30                	jne    8004207d9e <env_guest_alloc+0x1ac>
		page_decref(p);
  8004207d6e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207d72:	48 89 c7             	mov    %rax,%rdi
  8004207d75:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207d7c:	00 00 00 
  8004207d7f:	ff d0                	callq  *%rax
		page_decref(q);
  8004207d81:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207d85:	48 89 c7             	mov    %rax,%rdi
  8004207d88:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207d8f:	00 00 00 
  8004207d92:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004207d94:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207d99:	e9 da 02 00 00       	jmpq   8004208078 <env_guest_alloc+0x486>
	}
	r->pp_ref += 1;
  8004207d9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207da2:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207da6:	8d 50 01             	lea    0x1(%rax),%edx
  8004207da9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207dad:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.msr_host_area = page2kva(r);
  8004207db1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207db5:	48 89 c7             	mov    %rax,%rdi
  8004207db8:	48 b8 d7 77 20 04 80 	movabs $0x80042077d7,%rax
  8004207dbf:	00 00 00 
  8004207dc2:	ff d0                	callq  *%rax
  8004207dc4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207dc8:	48 89 82 50 01 00 00 	mov    %rax,0x150(%rdx)
	e->env_vmxinfo.msr_guest_area = page2kva(r) + PGSIZE / 2;
  8004207dcf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207dd3:	48 89 c7             	mov    %rax,%rdi
  8004207dd6:	48 b8 d7 77 20 04 80 	movabs $0x80042077d7,%rax
  8004207ddd:	00 00 00 
  8004207de0:	ff d0                	callq  *%rax
  8004207de2:	48 8d 90 00 08 00 00 	lea    0x800(%rax),%rdx
  8004207de9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ded:	48 89 90 58 01 00 00 	mov    %rdx,0x158(%rax)

	// Allocate pages for IO bitmaps.
	struct PageInfo *s = NULL;
  8004207df4:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004207dfb:	00 
	if (!(s = page_alloc(ALLOC_ZERO))) {
  8004207dfc:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207e01:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004207e08:	00 00 00 
  8004207e0b:	ff d0                	callq  *%rax
  8004207e0d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004207e11:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004207e16:	75 43                	jne    8004207e5b <env_guest_alloc+0x269>
		page_decref(p);
  8004207e18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207e1c:	48 89 c7             	mov    %rax,%rdi
  8004207e1f:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207e26:	00 00 00 
  8004207e29:	ff d0                	callq  *%rax
		page_decref(q);
  8004207e2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207e2f:	48 89 c7             	mov    %rax,%rdi
  8004207e32:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207e39:	00 00 00 
  8004207e3c:	ff d0                	callq  *%rax
		page_decref(r);
  8004207e3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207e42:	48 89 c7             	mov    %rax,%rdi
  8004207e45:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207e4c:	00 00 00 
  8004207e4f:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004207e51:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207e56:	e9 1d 02 00 00       	jmpq   8004208078 <env_guest_alloc+0x486>
	}
	s->pp_ref += 1;
  8004207e5b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207e5f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207e63:	8d 50 01             	lea    0x1(%rax),%edx
  8004207e66:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207e6a:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.io_bmap_a = page2kva(s);
  8004207e6e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207e72:	48 89 c7             	mov    %rax,%rdi
  8004207e75:	48 b8 d7 77 20 04 80 	movabs $0x80042077d7,%rax
  8004207e7c:	00 00 00 
  8004207e7f:	ff d0                	callq  *%rax
  8004207e81:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207e85:	48 89 82 38 01 00 00 	mov    %rax,0x138(%rdx)

	struct PageInfo *t = NULL;
  8004207e8c:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004207e93:	00 
	if (!(t = page_alloc(ALLOC_ZERO))) {
  8004207e94:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207e99:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004207ea0:	00 00 00 
  8004207ea3:	ff d0                	callq  *%rax
  8004207ea5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004207ea9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004207eae:	75 56                	jne    8004207f06 <env_guest_alloc+0x314>
		page_decref(p);
  8004207eb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207eb4:	48 89 c7             	mov    %rax,%rdi
  8004207eb7:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207ebe:	00 00 00 
  8004207ec1:	ff d0                	callq  *%rax
		page_decref(q);
  8004207ec3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004207ec7:	48 89 c7             	mov    %rax,%rdi
  8004207eca:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207ed1:	00 00 00 
  8004207ed4:	ff d0                	callq  *%rax
		page_decref(r);
  8004207ed6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207eda:	48 89 c7             	mov    %rax,%rdi
  8004207edd:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207ee4:	00 00 00 
  8004207ee7:	ff d0                	callq  *%rax
		page_decref(s);
  8004207ee9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207eed:	48 89 c7             	mov    %rax,%rdi
  8004207ef0:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004207ef7:	00 00 00 
  8004207efa:	ff d0                	callq  *%rax
		return -E_NO_MEM;
  8004207efc:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207f01:	e9 72 01 00 00       	jmpq   8004208078 <env_guest_alloc+0x486>
	}
	t->pp_ref += 1;
  8004207f06:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f0a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207f0e:	8d 50 01             	lea    0x1(%rax),%edx
  8004207f11:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f15:	66 89 50 08          	mov    %dx,0x8(%rax)
	e->env_vmxinfo.io_bmap_b = page2kva(t);
  8004207f19:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f1d:	48 89 c7             	mov    %rax,%rdi
  8004207f20:	48 b8 d7 77 20 04 80 	movabs $0x80042077d7,%rax
  8004207f27:	00 00 00 
  8004207f2a:	ff d0                	callq  *%rax
  8004207f2c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207f30:	48 89 82 40 01 00 00 	mov    %rax,0x140(%rdx)

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207f37:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f3b:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207f41:	05 00 10 00 00       	add    $0x1000,%eax
  8004207f46:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004207f4b:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207f4e:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207f52:	7f 07                	jg     8004207f5b <env_guest_alloc+0x369>
		generation = 1 << ENVGENSHIFT;
  8004207f54:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004207f5b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207f5f:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  8004207f66:	00 00 00 
  8004207f69:	48 8b 00             	mov    (%rax),%rax
  8004207f6c:	48 29 c2             	sub    %rax,%rdx
  8004207f6f:	48 89 d0             	mov    %rdx,%rax
  8004207f72:	48 c1 f8 03          	sar    $0x3,%rax
  8004207f76:	48 89 c2             	mov    %rax,%rdx
  8004207f79:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  8004207f80:	fa a4 4f 
  8004207f83:	48 0f af c2          	imul   %rdx,%rax
  8004207f87:	0b 45 fc             	or     -0x4(%rbp),%eax
  8004207f8a:	89 c2                	mov    %eax,%edx
  8004207f8c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f90:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207f96:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207f9a:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004207f9d:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_GUEST;
  8004207fa3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207fa7:	c7 80 d0 00 00 00 03 	movl   $0x3,0xd0(%rax)
  8004207fae:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004207fb1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207fb5:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207fbc:	00 00 00 
	e->env_runs = 0;
  8004207fbf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207fc3:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207fca:	00 00 00 
	e->env_vmxinfo.vcpunum = vcpu_count++;
  8004207fcd:	48 b8 50 d2 3a 04 80 	movabs $0x80043ad250,%rax
  8004207fd4:	00 00 00 
  8004207fd7:	8b 00                	mov    (%rax),%eax
  8004207fd9:	8d 48 01             	lea    0x1(%rax),%ecx
  8004207fdc:	48 ba 50 d2 3a 04 80 	movabs $0x80043ad250,%rdx
  8004207fe3:	00 00 00 
  8004207fe6:	89 0a                	mov    %ecx,(%rdx)
  8004207fe8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207fec:	89 82 60 01 00 00    	mov    %eax,0x160(%rdx)
    	cprintf("VCPUNUM allocated: %d\n", e->env_vmxinfo.vcpunum);
  8004207ff2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207ff6:	8b 80 60 01 00 00    	mov    0x160(%rax),%eax
  8004207ffc:	89 c6                	mov    %eax,%esi
  8004207ffe:	48 bf 13 e5 21 04 80 	movabs $0x800421e513,%rdi
  8004208005:	00 00 00 
  8004208008:	b8 00 00 00 00       	mov    $0x0,%eax
  800420800d:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004208014:	00 00 00 
  8004208017:	ff d2                	callq  *%rdx

	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004208019:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420801d:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004208022:	be 00 00 00 00       	mov    $0x0,%esi
  8004208027:	48 89 c7             	mov    %rax,%rdi
  800420802a:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004208031:	00 00 00 
  8004208034:	ff d0                	callq  *%rax

	e->env_pgfault_upcall = 0;
  8004208036:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420803a:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004208041:	00 00 00 00 
	e->env_ipc_recving = 0;
  8004208045:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208049:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004208050:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208054:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  800420805b:	48 b8 60 d2 3a 04 80 	movabs $0x80043ad260,%rax
  8004208062:	00 00 00 
  8004208065:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004208068:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420806c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208070:	48 89 10             	mov    %rdx,(%rax)

	return 0;
  8004208073:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208078:	c9                   	leaveq 
  8004208079:	c3                   	retq   

000000800420807a <env_guest_free>:

void env_guest_free(struct Env *e) {
  800420807a:	55                   	push   %rbp
  800420807b:	48 89 e5             	mov    %rsp,%rbp
  800420807e:	53                   	push   %rbx
  800420807f:	48 83 ec 38          	sub    $0x38,%rsp
  8004208083:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	// Free the VMCS.
	page_decref(pa2page(PADDR(e->env_vmxinfo.vmcs)));
  8004208087:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420808b:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  8004208092:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004208096:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420809d:	00 00 00 
  80042080a0:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  80042080a4:	77 32                	ja     80042080d8 <env_guest_free+0x5e>
  80042080a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042080aa:	48 89 c1             	mov    %rax,%rcx
  80042080ad:	48 ba 30 e5 21 04 80 	movabs $0x800421e530,%rdx
  80042080b4:	00 00 00 
  80042080b7:	be 41 01 00 00       	mov    $0x141,%esi
  80042080bc:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  80042080c3:	00 00 00 
  80042080c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042080cb:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042080d2:	00 00 00 
  80042080d5:	41 ff d0             	callq  *%r8
  80042080d8:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042080df:	ff ff ff 
  80042080e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042080e6:	48 01 d0             	add    %rdx,%rax
  80042080e9:	48 89 c7             	mov    %rax,%rdi
  80042080ec:	48 b8 66 77 20 04 80 	movabs $0x8004207766,%rax
  80042080f3:	00 00 00 
  80042080f6:	ff d0                	callq  *%rax
  80042080f8:	48 89 c7             	mov    %rax,%rdi
  80042080fb:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004208102:	00 00 00 
  8004208105:	ff d0                	callq  *%rax
	// Free msr load/store area.
	page_decref(pa2page(PADDR(e->env_vmxinfo.msr_host_area)));
  8004208107:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420810b:	48 8b 80 50 01 00 00 	mov    0x150(%rax),%rax
  8004208112:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004208116:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420811d:	00 00 00 
  8004208120:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004208124:	77 32                	ja     8004208158 <env_guest_free+0xde>
  8004208126:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420812a:	48 89 c1             	mov    %rax,%rcx
  800420812d:	48 ba 30 e5 21 04 80 	movabs $0x800421e530,%rdx
  8004208134:	00 00 00 
  8004208137:	be 43 01 00 00       	mov    $0x143,%esi
  800420813c:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  8004208143:	00 00 00 
  8004208146:	b8 00 00 00 00       	mov    $0x0,%eax
  800420814b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004208152:	00 00 00 
  8004208155:	41 ff d0             	callq  *%r8
  8004208158:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420815f:	ff ff ff 
  8004208162:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208166:	48 01 d0             	add    %rdx,%rax
  8004208169:	48 89 c7             	mov    %rax,%rdi
  800420816c:	48 b8 66 77 20 04 80 	movabs $0x8004207766,%rax
  8004208173:	00 00 00 
  8004208176:	ff d0                	callq  *%rax
  8004208178:	48 89 c7             	mov    %rax,%rdi
  800420817b:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004208182:	00 00 00 
  8004208185:	ff d0                	callq  *%rax
	// Free IO bitmaps page.
	page_decref(pa2page(PADDR(e->env_vmxinfo.io_bmap_a)));
  8004208187:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420818b:	48 8b 80 38 01 00 00 	mov    0x138(%rax),%rax
  8004208192:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004208196:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420819d:	00 00 00 
  80042081a0:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042081a4:	77 32                	ja     80042081d8 <env_guest_free+0x15e>
  80042081a6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042081aa:	48 89 c1             	mov    %rax,%rcx
  80042081ad:	48 ba 30 e5 21 04 80 	movabs $0x800421e530,%rdx
  80042081b4:	00 00 00 
  80042081b7:	be 45 01 00 00       	mov    $0x145,%esi
  80042081bc:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  80042081c3:	00 00 00 
  80042081c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042081cb:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042081d2:	00 00 00 
  80042081d5:	41 ff d0             	callq  *%r8
  80042081d8:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042081df:	ff ff ff 
  80042081e2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042081e6:	48 01 d0             	add    %rdx,%rax
  80042081e9:	48 89 c7             	mov    %rax,%rdi
  80042081ec:	48 b8 66 77 20 04 80 	movabs $0x8004207766,%rax
  80042081f3:	00 00 00 
  80042081f6:	ff d0                	callq  *%rax
  80042081f8:	48 89 c7             	mov    %rax,%rdi
  80042081fb:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004208202:	00 00 00 
  8004208205:	ff d0                	callq  *%rax
	page_decref(pa2page(PADDR(e->env_vmxinfo.io_bmap_b)));
  8004208207:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420820b:	48 8b 80 40 01 00 00 	mov    0x140(%rax),%rax
  8004208212:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004208216:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420821d:	00 00 00 
  8004208220:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  8004208224:	77 32                	ja     8004208258 <env_guest_free+0x1de>
  8004208226:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420822a:	48 89 c1             	mov    %rax,%rcx
  800420822d:	48 ba 30 e5 21 04 80 	movabs $0x800421e530,%rdx
  8004208234:	00 00 00 
  8004208237:	be 46 01 00 00       	mov    $0x146,%esi
  800420823c:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  8004208243:	00 00 00 
  8004208246:	b8 00 00 00 00       	mov    $0x0,%eax
  800420824b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004208252:	00 00 00 
  8004208255:	41 ff d0             	callq  *%r8
  8004208258:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420825f:	ff ff ff 
  8004208262:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208266:	48 01 d0             	add    %rdx,%rax
  8004208269:	48 89 c7             	mov    %rax,%rdi
  800420826c:	48 b8 66 77 20 04 80 	movabs $0x8004207766,%rax
  8004208273:	00 00 00 
  8004208276:	ff d0                	callq  *%rax
  8004208278:	48 89 c7             	mov    %rax,%rdi
  800420827b:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004208282:	00 00 00 
  8004208285:	ff d0                	callq  *%rax
    
	// Free the host pages that were allocated for the guest and 
	// the EPT tables itself.
	free_guest_mem(e->env_pml4e);
  8004208287:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420828b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208292:	48 89 c7             	mov    %rax,%rdi
  8004208295:	48 b8 f5 92 21 04 80 	movabs $0x80042192f5,%rax
  800420829c:	00 00 00 
  800420829f:	ff d0                	callq  *%rax

	// Free the EPT PML4 page.
	page_decref(pa2page(e->env_cr3));
  80042082a1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042082a5:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042082ac:	48 89 c7             	mov    %rax,%rdi
  80042082af:	48 b8 66 77 20 04 80 	movabs $0x8004207766,%rax
  80042082b6:	00 00 00 
  80042082b9:	ff d0                	callq  *%rax
  80042082bb:	48 89 c7             	mov    %rax,%rdi
  80042082be:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  80042082c5:	00 00 00 
  80042082c8:	ff d0                	callq  *%rax
	e->env_pml4e = 0;
  80042082ca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042082ce:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  80042082d5:	00 00 00 00 
	e->env_cr3 = 0;
  80042082d9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042082dd:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  80042082e4:	00 00 00 00 

	// return the environment to the free list
	e->env_status = ENV_FREE;
  80042082e8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042082ec:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042082f3:	00 00 00 
	e->env_link = env_free_list;
  80042082f6:	48 b8 60 d2 3a 04 80 	movabs $0x80043ad260,%rax
  80042082fd:	00 00 00 
  8004208300:	48 8b 10             	mov    (%rax),%rdx
  8004208303:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208307:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  800420830e:	48 b8 60 d2 3a 04 80 	movabs $0x80043ad260,%rax
  8004208315:	00 00 00 
  8004208318:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420831c:	48 89 10             	mov    %rdx,(%rax)

	cprintf("[%08x] free vmx guest env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
  800420831f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208323:	8b 98 c8 00 00 00    	mov    0xc8(%rax),%ebx
  8004208329:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208330:	00 00 00 
  8004208333:	ff d0                	callq  *%rax
  8004208335:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420833c:	00 00 00 
  800420833f:	48 98                	cltq   
  8004208341:	48 c1 e0 03          	shl    $0x3,%rax
  8004208345:	48 89 c1             	mov    %rax,%rcx
  8004208348:	48 c1 e1 04          	shl    $0x4,%rcx
  800420834c:	48 01 c8             	add    %rcx,%rax
  800420834f:	48 01 d0             	add    %rdx,%rax
  8004208352:	48 83 c0 08          	add    $0x8,%rax
  8004208356:	48 8b 00             	mov    (%rax),%rax
  8004208359:	48 85 c0             	test   %rax,%rax
  800420835c:	74 38                	je     8004208396 <env_guest_free+0x31c>
  800420835e:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208365:	00 00 00 
  8004208368:	ff d0                	callq  *%rax
  800420836a:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004208371:	00 00 00 
  8004208374:	48 98                	cltq   
  8004208376:	48 c1 e0 03          	shl    $0x3,%rax
  800420837a:	48 89 c1             	mov    %rax,%rcx
  800420837d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208381:	48 01 c8             	add    %rcx,%rax
  8004208384:	48 01 d0             	add    %rdx,%rax
  8004208387:	48 83 c0 08          	add    $0x8,%rax
  800420838b:	48 8b 00             	mov    (%rax),%rax
  800420838e:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208394:	eb 05                	jmp    800420839b <env_guest_free+0x321>
  8004208396:	b8 00 00 00 00       	mov    $0x0,%eax
  800420839b:	89 da                	mov    %ebx,%edx
  800420839d:	89 c6                	mov    %eax,%esi
  800420839f:	48 bf 60 e5 21 04 80 	movabs $0x800421e560,%rdi
  80042083a6:	00 00 00 
  80042083a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042083ae:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  80042083b5:	00 00 00 
  80042083b8:	ff d1                	callq  *%rcx
}
  80042083ba:	48 83 c4 38          	add    $0x38,%rsp
  80042083be:	5b                   	pop    %rbx
  80042083bf:	5d                   	pop    %rbp
  80042083c0:	c3                   	retq   

00000080042083c1 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  80042083c1:	55                   	push   %rbp
  80042083c2:	48 89 e5             	mov    %rsp,%rbp
  80042083c5:	48 83 ec 30          	sub    $0x30,%rsp
  80042083c9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042083cd:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  80042083d0:	48 b8 60 d2 3a 04 80 	movabs $0x80043ad260,%rax
  80042083d7:	00 00 00 
  80042083da:	48 8b 00             	mov    (%rax),%rax
  80042083dd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042083e1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  80042083e6:	75 0a                	jne    80042083f2 <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  80042083e8:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  80042083ed:	e9 76 01 00 00       	jmpq   8004208568 <env_alloc+0x1a7>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  80042083f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042083f6:	48 89 c7             	mov    %rax,%rdi
  80042083f9:	48 b8 1e 7b 20 04 80 	movabs $0x8004207b1e,%rax
  8004208400:	00 00 00 
  8004208403:	ff d0                	callq  *%rax
  8004208405:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004208408:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420840c:	79 08                	jns    8004208416 <env_alloc+0x55>
		return r;
  800420840e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208411:	e9 52 01 00 00       	jmpq   8004208568 <env_alloc+0x1a7>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004208416:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420841a:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208420:	05 00 10 00 00       	add    $0x1000,%eax
  8004208425:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  800420842a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  800420842d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004208431:	7f 07                	jg     800420843a <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004208433:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  800420843a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420843e:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  8004208445:	00 00 00 
  8004208448:	48 8b 00             	mov    (%rax),%rax
  800420844b:	48 29 c2             	sub    %rax,%rdx
  800420844e:	48 89 d0             	mov    %rdx,%rax
  8004208451:	48 c1 f8 03          	sar    $0x3,%rax
  8004208455:	48 89 c2             	mov    %rax,%rdx
  8004208458:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  800420845f:	fa a4 4f 
  8004208462:	48 0f af c2          	imul   %rdx,%rax
  8004208466:	0b 45 fc             	or     -0x4(%rbp),%eax
  8004208469:	89 c2                	mov    %eax,%edx
  800420846b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420846f:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004208475:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208479:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  800420847c:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004208482:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208486:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  800420848d:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004208490:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208494:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420849b:	00 00 00 
	e->env_runs = 0;
  800420849e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084a2:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  80042084a9:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  80042084ac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084b0:	ba c0 00 00 00       	mov    $0xc0,%edx
  80042084b5:	be 00 00 00 00       	mov    $0x0,%esi
  80042084ba:	48 89 c7             	mov    %rax,%rdi
  80042084bd:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  80042084c4:	00 00 00 
  80042084c7:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  80042084c9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084cd:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  80042084d4:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  80042084d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084da:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  80042084e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084e4:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  80042084eb:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  80042084ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084f1:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  80042084f6:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  80042084fd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208501:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004208508:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags = e->env_tf.tf_eflags |FL_IF;
  800420850a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420850e:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004208515:	80 cc 02             	or     $0x2,%ah
  8004208518:	48 89 c2             	mov    %rax,%rdx
  800420851b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420851f:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	
	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004208526:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420852a:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004208531:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004208535:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208539:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004208540:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208544:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  800420854b:	48 b8 60 d2 3a 04 80 	movabs $0x80043ad260,%rax
  8004208552:	00 00 00 
  8004208555:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004208558:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420855c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004208560:	48 89 10             	mov    %rdx,(%rax)
	//cprintf("env.tf->rsp [%x], e->env_id [%d]\n", e->env_tf.tf_rsp, e->env_id);

	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  8004208563:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208568:	c9                   	leaveq 
  8004208569:	c3                   	retq   

000000800420856a <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  800420856a:	55                   	push   %rbp
  800420856b:	48 89 e5             	mov    %rsp,%rbp
  800420856e:	48 83 ec 40          	sub    $0x40,%rsp
  8004208572:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208576:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420857a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	uint64_t temp = (uint64_t)va;
  800420857e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208582:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size_t lenDown = (uint64_t)va - temp;
  8004208586:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420858a:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  800420858e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	int i = 0;
  8004208592:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	struct PageInfo *p;
	// Address round down
	temp =  (temp / PGSIZE) * PGSIZE;
  8004208599:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420859d:	48 c1 e8 0c          	shr    $0xc,%rax
  80042085a1:	48 c1 e0 0c          	shl    $0xc,%rax
  80042085a5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	// size round up
	len += lenDown;
  80042085a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042085ad:	48 01 45 c8          	add    %rax,-0x38(%rbp)
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
  80042085b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042085b5:	48 05 00 10 00 00    	add    $0x1000,%rax
  80042085bb:	48 c1 e8 0c          	shr    $0xc,%rax
  80042085bf:	48 c1 e0 0c          	shl    $0xc,%rax
  80042085c3:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  80042085c7:	eb 79                	jmp    8004208642 <region_alloc+0xd8>
	{	
		p = page_alloc(ALLOC_ZERO);
  80042085c9:	bf 01 00 00 00       	mov    $0x1,%edi
  80042085ce:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042085d5:	00 00 00 
  80042085d8:	ff d0                	callq  *%rax
  80042085da:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(p == NULL)
  80042085de:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042085e3:	75 2a                	jne    800420860f <region_alloc+0xa5>
		    panic("Page alloc fail\n");
  80042085e5:	48 ba 80 e5 21 04 80 	movabs $0x800421e580,%rdx
  80042085ec:	00 00 00 
  80042085ef:	be c5 01 00 00       	mov    $0x1c5,%esi
  80042085f4:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  80042085fb:	00 00 00 
  80042085fe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208603:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  800420860a:	00 00 00 
  800420860d:	ff d1                	callq  *%rcx
		page_insert(e->env_pml4e, p, (void*)temp, PTE_U|PTE_P|PTE_W);
  800420860f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208613:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004208617:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420861e:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004208622:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004208627:	48 89 c7             	mov    %rax,%rdi
  800420862a:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  8004208631:	00 00 00 
  8004208634:	ff d0                	callq  *%rax
		temp+=PGSIZE;
  8004208636:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  800420863d:	00 
	len += lenDown;
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  800420863e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004208642:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004208645:	48 98                	cltq   
  8004208647:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420864b:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420864f:	48 39 d0             	cmp    %rdx,%rax
  8004208652:	0f 82 71 ff ff ff    	jb     80042085c9 <region_alloc+0x5f>
		temp+=PGSIZE;
		//cprintf("region_alloc temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);
	}
	//cprintf("region_alloc end temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);

}
  8004208658:	c9                   	leaveq 
  8004208659:	c3                   	retq   

000000800420865a <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  800420865a:	55                   	push   %rbp
  800420865b:	48 89 e5             	mov    %rsp,%rbp
  800420865e:	48 83 ec 40          	sub    $0x40,%rsp
  8004208662:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004208666:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)

	struct PageInfo *p;
	struct Elf * elfHeader;
	struct Proghdr *ph, *eph;

	if(e == NULL || binary == NULL)
  800420866a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420866f:	74 07                	je     8004208678 <load_icode+0x1e>
  8004208671:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004208676:	75 2a                	jne    80042086a2 <load_icode+0x48>
		panic("load icode Failed due to NULL input");
  8004208678:	48 ba 98 e5 21 04 80 	movabs $0x800421e598,%rdx
  800420867f:	00 00 00 
  8004208682:	be 0f 02 00 00       	mov    $0x20f,%esi
  8004208687:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  800420868e:	00 00 00 
  8004208691:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208696:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  800420869d:	00 00 00 
  80042086a0:	ff d1                	callq  *%rcx


	elfHeader = (struct Elf *) binary;	
  80042086a2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042086a6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is this a valid ELF?
	if (elfHeader->e_magic != ELF_MAGIC)
  80042086aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042086ae:	8b 00                	mov    (%rax),%eax
  80042086b0:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  80042086b5:	74 2a                	je     80042086e1 <load_icode+0x87>
		panic("load icode Failed due to Corrupt ELF");
  80042086b7:	48 ba c0 e5 21 04 80 	movabs $0x800421e5c0,%rdx
  80042086be:	00 00 00 
  80042086c1:	be 15 02 00 00       	mov    $0x215,%esi
  80042086c6:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  80042086cd:	00 00 00 
  80042086d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042086d5:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  80042086dc:	00 00 00 
  80042086df:	ff d1                	callq  *%rcx

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
  80042086e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042086e5:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042086e9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042086ed:	48 01 d0             	add    %rdx,%rax
  80042086f0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	eph = ph + elfHeader->e_phnum;
  80042086f4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042086f8:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  80042086fc:	0f b7 c0             	movzwl %ax,%eax
  80042086ff:	48 c1 e0 03          	shl    $0x3,%rax
  8004208703:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420870a:	00 
  800420870b:	48 29 c2             	sub    %rax,%rdx
  800420870e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208712:	48 01 d0             	add    %rdx,%rax
  8004208715:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	lcr3(e->env_cr3);
  8004208719:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420871d:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208724:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004208728:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420872c:	0f 22 d8             	mov    %rax,%cr3
	for (;ph < eph; ph++){
  800420872f:	e9 d3 00 00 00       	jmpq   8004208807 <load_icode+0x1ad>
		if(ELF_PROG_LOAD == ph->p_type){
  8004208734:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208738:	8b 00                	mov    (%rax),%eax
  800420873a:	83 f8 01             	cmp    $0x1,%eax
  800420873d:	0f 85 bf 00 00 00    	jne    8004208802 <load_icode+0x1a8>
			if(ph->p_filesz <= ph->p_memsz){
  8004208743:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208747:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800420874b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420874f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004208753:	48 39 c2             	cmp    %rax,%rdx
  8004208756:	0f 87 a6 00 00 00    	ja     8004208802 <load_icode+0x1a8>
				region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  800420875c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208760:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208764:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208768:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420876c:	48 89 c1             	mov    %rax,%rcx
  800420876f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208773:	48 89 ce             	mov    %rcx,%rsi
  8004208776:	48 89 c7             	mov    %rax,%rdi
  8004208779:	48 b8 6a 85 20 04 80 	movabs $0x800420856a,%rax
  8004208780:	00 00 00 
  8004208783:	ff d0                	callq  *%rax
				size_t a = e->env_pml4e[0];
  8004208785:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208789:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208790:	48 8b 00             	mov    (%rax),%rax
  8004208793:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				//cprintf("load icode Inter  e->env_pml4e is [%x], PML40 is [%x], PML41 is [%x], ph->p_filesz [%ld]\n",  e->env_pml4e, e->env_pml4e[0],e->env_pml4e[1], ph->p_filesz);

				memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz);
  8004208797:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420879b:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800420879f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042087a3:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042087a7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042087ab:	48 01 c1             	add    %rax,%rcx
  80042087ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042087b2:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042087b6:	48 89 ce             	mov    %rcx,%rsi
  80042087b9:	48 89 c7             	mov    %rax,%rdi
  80042087bc:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  80042087c3:	00 00 00 
  80042087c6:	ff d0                	callq  *%rax
				memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
  80042087c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042087cc:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042087d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042087d4:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042087d8:	48 29 c2             	sub    %rax,%rdx
  80042087db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042087df:	48 8b 48 10          	mov    0x10(%rax),%rcx
  80042087e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042087e7:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042087eb:	48 01 c8             	add    %rcx,%rax
  80042087ee:	be 00 00 00 00       	mov    $0x0,%esi
  80042087f3:	48 89 c7             	mov    %rax,%rdi
  80042087f6:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  80042087fd:	00 00 00 
  8004208800:	ff d0                	callq  *%rax
		panic("load icode Failed due to Corrupt ELF");

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
	eph = ph + elfHeader->e_phnum;
	lcr3(e->env_cr3);
	for (;ph < eph; ph++){
  8004208802:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004208807:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420880b:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800420880f:	0f 82 1f ff ff ff    	jb     8004208734 <load_icode+0xda>
		}
	}
	// call the entry point from the ELF header
	// note: does not return!
	
	region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);
  8004208815:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208819:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420881e:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004208823:	48 89 c7             	mov    %rax,%rdi
  8004208826:	48 b8 6a 85 20 04 80 	movabs $0x800420856a,%rax
  800420882d:	00 00 00 
  8004208830:	ff d0                	callq  *%rax
	e->env_tf.tf_rip = (uintptr_t)(elfHeader->e_entry);
  8004208832:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208836:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800420883a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420883e:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	e->elf = binary;
  8004208845:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208849:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420884d:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
}
  8004208854:	c9                   	leaveq 
  8004208855:	c3                   	retq   

0000008004208856 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  8004208856:	55                   	push   %rbp
  8004208857:	48 89 e5             	mov    %rsp,%rbp
  800420885a:	48 83 ec 20          	sub    $0x20,%rsp
  800420885e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004208862:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.

	struct Env *e;
	envid_t parent_id;
	if(env_alloc(&e, 0) != 0)
  8004208865:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  8004208869:	be 00 00 00 00       	mov    $0x0,%esi
  800420886e:	48 89 c7             	mov    %rax,%rdi
  8004208871:	48 b8 c1 83 20 04 80 	movabs $0x80042083c1,%rax
  8004208878:	00 00 00 
  800420887b:	ff d0                	callq  *%rax
  800420887d:	85 c0                	test   %eax,%eax
  800420887f:	74 2a                	je     80042088ab <env_create+0x55>
	{
		panic("Failed in env_alloc");
  8004208881:	48 ba e5 e5 21 04 80 	movabs $0x800421e5e5,%rdx
  8004208888:	00 00 00 
  800420888b:	be 42 02 00 00       	mov    $0x242,%esi
  8004208890:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  8004208897:	00 00 00 
  800420889a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420889f:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  80042088a6:	00 00 00 
  80042088a9:	ff d1                	callq  *%rcx
	}
	e->env_type = type;
  80042088ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042088af:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042088b2:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	if(type == ENV_TYPE_FS)
  80042088b8:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  80042088bc:	75 19                	jne    80042088d7 <env_create+0x81>
	{
		e->env_tf.tf_eflags |= FL_IOPL_MASK;
  80042088be:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042088c2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042088c6:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  80042088cd:	80 ce 30             	or     $0x30,%dh
  80042088d0:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	}
	load_icode(e, binary);
  80042088d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042088db:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042088df:	48 89 d6             	mov    %rdx,%rsi
  80042088e2:	48 89 c7             	mov    %rax,%rdi
  80042088e5:	48 b8 5a 86 20 04 80 	movabs $0x800420865a,%rax
  80042088ec:	00 00 00 
  80042088ef:	ff d0                	callq  *%rax
}
  80042088f1:	c9                   	leaveq 
  80042088f2:	c3                   	retq   

00000080042088f3 <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  80042088f3:	55                   	push   %rbp
  80042088f4:	48 89 e5             	mov    %rsp,%rbp
  80042088f7:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  80042088fe:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
	pte_t *pt;
	uint64_t pdeno, pteno;
	physaddr_t pa;

#ifndef VMM_GUEST 
	if(e->env_type == ENV_TYPE_GUEST) {
  8004208905:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420890c:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004208912:	83 f8 03             	cmp    $0x3,%eax
  8004208915:	75 1b                	jne    8004208932 <env_free+0x3f>
		env_guest_free(e);
  8004208917:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420891e:	48 89 c7             	mov    %rax,%rdi
  8004208921:	48 b8 7a 80 20 04 80 	movabs $0x800420807a,%rax
  8004208928:	00 00 00 
  800420892b:	ff d0                	callq  *%rax
		return;
  800420892d:	e9 78 04 00 00       	jmpq   8004208daa <env_free+0x4b7>
#endif

	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004208932:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208939:	00 00 00 
  800420893c:	ff d0                	callq  *%rax
  800420893e:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004208945:	00 00 00 
  8004208948:	48 98                	cltq   
  800420894a:	48 c1 e0 03          	shl    $0x3,%rax
  800420894e:	48 89 c1             	mov    %rax,%rcx
  8004208951:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208955:	48 01 c8             	add    %rcx,%rax
  8004208958:	48 01 d0             	add    %rdx,%rax
  800420895b:	48 83 c0 08          	add    $0x8,%rax
  800420895f:	48 8b 00             	mov    (%rax),%rax
  8004208962:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  8004208969:	75 18                	jne    8004208983 <env_free+0x90>
		lcr3(boot_cr3);
  800420896b:	48 b8 88 e7 3a 04 80 	movabs $0x80043ae788,%rax
  8004208972:	00 00 00 
  8004208975:	48 8b 00             	mov    (%rax),%rax
  8004208978:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  800420897c:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004208980:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  8004208983:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420898a:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208991:	48 8b 00             	mov    (%rax),%rax
  8004208994:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420899a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420899e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042089a2:	48 c1 e8 0c          	shr    $0xc,%rax
  80042089a6:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042089a9:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042089ac:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042089b3:	00 00 00 
  80042089b6:	48 8b 00             	mov    (%rax),%rax
  80042089b9:	48 39 c2             	cmp    %rax,%rdx
  80042089bc:	72 32                	jb     80042089f0 <env_free+0xfd>
  80042089be:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042089c2:	48 89 c1             	mov    %rax,%rcx
  80042089c5:	48 ba f0 e4 21 04 80 	movabs $0x800421e4f0,%rdx
  80042089cc:	00 00 00 
  80042089cf:	be 67 02 00 00       	mov    $0x267,%esi
  80042089d4:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  80042089db:	00 00 00 
  80042089de:	b8 00 00 00 00       	mov    $0x0,%eax
  80042089e3:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042089ea:	00 00 00 
  80042089ed:	41 ff d0             	callq  *%r8
  80042089f0:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042089f7:	00 00 00 
  80042089fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042089fe:	48 01 d0             	add    %rdx,%rax
  8004208a01:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208a05:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208a0c:	00 
  8004208a0d:	e9 ab 02 00 00       	jmpq   8004208cbd <env_free+0x3ca>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  8004208a12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a16:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208a1d:	00 
  8004208a1e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208a22:	48 01 d0             	add    %rdx,%rax
  8004208a25:	48 8b 00             	mov    (%rax),%rax
  8004208a28:	83 e0 01             	and    $0x1,%eax
  8004208a2b:	48 85 c0             	test   %rax,%rax
  8004208a2e:	75 05                	jne    8004208a35 <env_free+0x142>
			continue;
  8004208a30:	e9 83 02 00 00       	jmpq   8004208cb8 <env_free+0x3c5>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  8004208a35:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a39:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208a40:	00 
  8004208a41:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208a45:	48 01 d0             	add    %rdx,%rax
  8004208a48:	48 8b 00             	mov    (%rax),%rax
  8004208a4b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208a51:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004208a55:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208a59:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208a5d:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  8004208a60:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208a63:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004208a6a:	00 00 00 
  8004208a6d:	48 8b 00             	mov    (%rax),%rax
  8004208a70:	48 39 c2             	cmp    %rax,%rdx
  8004208a73:	72 32                	jb     8004208aa7 <env_free+0x1b4>
  8004208a75:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208a79:	48 89 c1             	mov    %rax,%rcx
  8004208a7c:	48 ba f0 e4 21 04 80 	movabs $0x800421e4f0,%rdx
  8004208a83:	00 00 00 
  8004208a86:	be 6f 02 00 00       	mov    $0x26f,%esi
  8004208a8b:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  8004208a92:	00 00 00 
  8004208a95:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208a9a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004208aa1:	00 00 00 
  8004208aa4:	41 ff d0             	callq  *%r8
  8004208aa7:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208aae:	00 00 00 
  8004208ab1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004208ab5:	48 01 d0             	add    %rdx,%rax
  8004208ab8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004208abc:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208ac1:	75 07                	jne    8004208aca <env_free+0x1d7>
  8004208ac3:	b8 04 00 00 00       	mov    $0x4,%eax
  8004208ac8:	eb 05                	jmp    8004208acf <env_free+0x1dc>
  8004208aca:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004208acf:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208ad2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004208ad9:	00 
  8004208ada:	e9 6e 01 00 00       	jmpq   8004208c4d <env_free+0x35a>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  8004208adf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208ae3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208aea:	00 
  8004208aeb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208aef:	48 01 d0             	add    %rdx,%rax
  8004208af2:	48 8b 00             	mov    (%rax),%rax
  8004208af5:	83 e0 01             	and    $0x1,%eax
  8004208af8:	48 85 c0             	test   %rax,%rax
  8004208afb:	75 05                	jne    8004208b02 <env_free+0x20f>
				continue;
  8004208afd:	e9 46 01 00 00       	jmpq   8004208c48 <env_free+0x355>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  8004208b02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208b06:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208b0d:	00 
  8004208b0e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208b12:	48 01 d0             	add    %rdx,%rax
  8004208b15:	48 8b 00             	mov    (%rax),%rax
  8004208b18:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208b1e:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  8004208b22:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208b26:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004208b2a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208b2e:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208b32:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004208b35:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208b38:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004208b3f:	00 00 00 
  8004208b42:	48 8b 00             	mov    (%rax),%rax
  8004208b45:	48 39 c2             	cmp    %rax,%rdx
  8004208b48:	72 32                	jb     8004208b7c <env_free+0x289>
  8004208b4a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208b4e:	48 89 c1             	mov    %rax,%rcx
  8004208b51:	48 ba f0 e4 21 04 80 	movabs $0x800421e4f0,%rdx
  8004208b58:	00 00 00 
  8004208b5b:	be 79 02 00 00       	mov    $0x279,%esi
  8004208b60:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  8004208b67:	00 00 00 
  8004208b6a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208b6f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004208b76:	00 00 00 
  8004208b79:	41 ff d0             	callq  *%r8
  8004208b7c:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004208b83:	00 00 00 
  8004208b86:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208b8a:	48 01 d0             	add    %rdx,%rax
  8004208b8d:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208b91:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004208b98:	00 
  8004208b99:	eb 67                	jmp    8004208c02 <env_free+0x30f>
				if (pt[pteno] & PTE_P){
  8004208b9b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208b9f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208ba6:	00 
  8004208ba7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004208bab:	48 01 d0             	add    %rdx,%rax
  8004208bae:	48 8b 00             	mov    (%rax),%rax
  8004208bb1:	83 e0 01             	and    $0x1,%eax
  8004208bb4:	48 85 c0             	test   %rax,%rax
  8004208bb7:	74 44                	je     8004208bfd <env_free+0x30a>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  8004208bb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208bbd:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004208bc1:	48 89 c2             	mov    %rax,%rdx
  8004208bc4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208bc8:	48 c1 e0 15          	shl    $0x15,%rax
  8004208bcc:	48 09 c2             	or     %rax,%rdx
  8004208bcf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208bd3:	48 c1 e0 0c          	shl    $0xc,%rax
  8004208bd7:	48 09 d0             	or     %rdx,%rax
  8004208bda:	48 89 c2             	mov    %rax,%rdx
  8004208bdd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208be4:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208beb:	48 89 d6             	mov    %rdx,%rsi
  8004208bee:	48 89 c7             	mov    %rax,%rdi
  8004208bf1:	48 b8 d7 39 20 04 80 	movabs $0x80042039d7,%rax
  8004208bf8:	00 00 00 
  8004208bfb:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208bfd:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004208c02:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  8004208c09:	00 
  8004208c0a:	76 8f                	jbe    8004208b9b <env_free+0x2a8>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  8004208c0c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208c10:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208c17:	00 
  8004208c18:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208c1c:	48 01 d0             	add    %rdx,%rax
  8004208c1f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  8004208c26:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208c2a:	48 89 c7             	mov    %rax,%rdi
  8004208c2d:	48 b8 66 77 20 04 80 	movabs $0x8004207766,%rax
  8004208c34:	00 00 00 
  8004208c37:	ff d0                	callq  *%rax
  8004208c39:	48 89 c7             	mov    %rax,%rdi
  8004208c3c:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004208c43:	00 00 00 
  8004208c46:	ff d0                	callq  *%rax
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208c48:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004208c4d:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004208c50:	48 98                	cltq   
  8004208c52:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208c56:	0f 87 83 fe ff ff    	ja     8004208adf <env_free+0x1ec>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  8004208c5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208c60:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208c67:	00 
  8004208c68:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208c6c:	48 01 d0             	add    %rdx,%rax
  8004208c6f:	48 8b 00             	mov    (%rax),%rax
  8004208c72:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208c78:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  8004208c7c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208c80:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208c87:	00 
  8004208c88:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208c8c:	48 01 d0             	add    %rdx,%rax
  8004208c8f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  8004208c96:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208c9a:	48 89 c7             	mov    %rax,%rdi
  8004208c9d:	48 b8 66 77 20 04 80 	movabs $0x8004207766,%rax
  8004208ca4:	00 00 00 
  8004208ca7:	ff d0                	callq  *%rax
  8004208ca9:	48 89 c7             	mov    %rax,%rdi
  8004208cac:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004208cb3:	00 00 00 
  8004208cb6:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  8004208cb8:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004208cbd:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208cc2:	0f 86 4a fd ff ff    	jbe    8004208a12 <env_free+0x11f>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  8004208cc8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208ccf:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208cd6:	48 8b 00             	mov    (%rax),%rax
  8004208cd9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208cdf:	48 89 c7             	mov    %rax,%rdi
  8004208ce2:	48 b8 66 77 20 04 80 	movabs $0x8004207766,%rax
  8004208ce9:	00 00 00 
  8004208cec:	ff d0                	callq  *%rax
  8004208cee:	48 89 c7             	mov    %rax,%rdi
  8004208cf1:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004208cf8:	00 00 00 
  8004208cfb:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208cfd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208d04:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208d0b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004208d12:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208d19:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208d20:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004208d24:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208d2b:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004208d32:	00 00 00 00 
	e->env_cr3 = 0;
  8004208d36:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208d3d:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208d44:	00 00 00 00 
	page_decref(pa2page(pa));
  8004208d48:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208d4c:	48 89 c7             	mov    %rax,%rdi
  8004208d4f:	48 b8 66 77 20 04 80 	movabs $0x8004207766,%rax
  8004208d56:	00 00 00 
  8004208d59:	ff d0                	callq  *%rax
  8004208d5b:	48 89 c7             	mov    %rax,%rdi
  8004208d5e:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004208d65:	00 00 00 
  8004208d68:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  8004208d6a:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208d71:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  8004208d78:	00 00 00 
	e->env_link = env_free_list;
  8004208d7b:	48 b8 60 d2 3a 04 80 	movabs $0x80043ad260,%rax
  8004208d82:	00 00 00 
  8004208d85:	48 8b 10             	mov    (%rax),%rdx
  8004208d88:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208d8f:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  8004208d96:	48 b8 60 d2 3a 04 80 	movabs $0x80043ad260,%rax
  8004208d9d:	00 00 00 
  8004208da0:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004208da7:	48 89 10             	mov    %rdx,(%rax)
}
  8004208daa:	c9                   	leaveq 
  8004208dab:	c3                   	retq   

0000008004208dac <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  8004208dac:	55                   	push   %rbp
  8004208dad:	48 89 e5             	mov    %rsp,%rbp
  8004208db0:	48 83 ec 10          	sub    $0x10,%rsp
  8004208db4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  8004208db8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208dbc:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208dc2:	83 f8 03             	cmp    $0x3,%eax
  8004208dc5:	75 49                	jne    8004208e10 <env_destroy+0x64>
  8004208dc7:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208dce:	00 00 00 
  8004208dd1:	ff d0                	callq  *%rax
  8004208dd3:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004208dda:	00 00 00 
  8004208ddd:	48 98                	cltq   
  8004208ddf:	48 c1 e0 03          	shl    $0x3,%rax
  8004208de3:	48 89 c1             	mov    %rax,%rcx
  8004208de6:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208dea:	48 01 c8             	add    %rcx,%rax
  8004208ded:	48 01 d0             	add    %rdx,%rax
  8004208df0:	48 83 c0 08          	add    $0x8,%rax
  8004208df4:	48 8b 00             	mov    (%rax),%rax
  8004208df7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208dfb:	74 13                	je     8004208e10 <env_destroy+0x64>
		e->env_status = ENV_DYING;
  8004208dfd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e01:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  8004208e08:	00 00 00 
		return;
  8004208e0b:	e9 89 00 00 00       	jmpq   8004208e99 <env_destroy+0xed>
	}

	env_free(e);
  8004208e10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208e14:	48 89 c7             	mov    %rax,%rdi
  8004208e17:	48 b8 f3 88 20 04 80 	movabs $0x80042088f3,%rax
  8004208e1e:	00 00 00 
  8004208e21:	ff d0                	callq  *%rax
	if (curenv == e) {
  8004208e23:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208e2a:	00 00 00 
  8004208e2d:	ff d0                	callq  *%rax
  8004208e2f:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004208e36:	00 00 00 
  8004208e39:	48 98                	cltq   
  8004208e3b:	48 c1 e0 03          	shl    $0x3,%rax
  8004208e3f:	48 89 c1             	mov    %rax,%rcx
  8004208e42:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208e46:	48 01 c8             	add    %rcx,%rax
  8004208e49:	48 01 d0             	add    %rdx,%rax
  8004208e4c:	48 83 c0 08          	add    $0x8,%rax
  8004208e50:	48 8b 00             	mov    (%rax),%rax
  8004208e53:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208e57:	75 40                	jne    8004208e99 <env_destroy+0xed>
		curenv = NULL;
  8004208e59:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208e60:	00 00 00 
  8004208e63:	ff d0                	callq  *%rax
  8004208e65:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004208e6c:	00 00 00 
  8004208e6f:	48 98                	cltq   
  8004208e71:	48 c1 e0 03          	shl    $0x3,%rax
  8004208e75:	48 89 c1             	mov    %rax,%rcx
  8004208e78:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208e7c:	48 01 c8             	add    %rcx,%rax
  8004208e7f:	48 01 d0             	add    %rdx,%rax
  8004208e82:	48 83 c0 08          	add    $0x8,%rax
  8004208e86:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  8004208e8d:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  8004208e94:	00 00 00 
  8004208e97:	ff d0                	callq  *%rax
	}
}
  8004208e99:	c9                   	leaveq 
  8004208e9a:	c3                   	retq   

0000008004208e9b <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  8004208e9b:	55                   	push   %rbp
  8004208e9c:	48 89 e5             	mov    %rsp,%rbp
  8004208e9f:	53                   	push   %rbx
  8004208ea0:	48 83 ec 18          	sub    $0x18,%rsp
  8004208ea4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  8004208ea8:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208eaf:	00 00 00 
  8004208eb2:	ff d0                	callq  *%rax
  8004208eb4:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004208ebb:	00 00 00 
  8004208ebe:	48 98                	cltq   
  8004208ec0:	48 c1 e0 03          	shl    $0x3,%rax
  8004208ec4:	48 89 c1             	mov    %rax,%rcx
  8004208ec7:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208ecb:	48 01 c8             	add    %rcx,%rax
  8004208ece:	48 01 d0             	add    %rdx,%rax
  8004208ed1:	48 83 c0 08          	add    $0x8,%rax
  8004208ed5:	48 8b 18             	mov    (%rax),%rbx
  8004208ed8:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208edf:	00 00 00 
  8004208ee2:	ff d0                	callq  *%rax
  8004208ee4:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	//cprintf("tf->rsp [%x]\n", tf->tf_rsp);
	__asm __volatile("movq %0,%%rsp\n"
  8004208eea:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  8004208eee:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004208ef2:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  8004208ef7:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208efc:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208f01:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  8004208f06:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208f0b:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004208f10:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  8004208f15:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  8004208f1a:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004208f1f:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208f24:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  8004208f29:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004208f2e:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004208f33:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  8004208f38:	48 83 c4 78          	add    $0x78,%rsp
  8004208f3c:	8e 04 24             	mov    (%rsp),%es
  8004208f3f:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004208f43:	48 83 c4 10          	add    $0x10,%rsp
  8004208f47:	48 83 c4 10          	add    $0x10,%rsp
  8004208f4b:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004208f4d:	48 ba f9 e5 21 04 80 	movabs $0x800421e5f9,%rdx
  8004208f54:	00 00 00 
  8004208f57:	be c7 02 00 00       	mov    $0x2c7,%esi
  8004208f5c:	48 bf 54 e5 21 04 80 	movabs $0x800421e554,%rdi
  8004208f63:	00 00 00 
  8004208f66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208f6b:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  8004208f72:	00 00 00 
  8004208f75:	ff d1                	callq  *%rcx

0000008004208f77 <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  8004208f77:	55                   	push   %rbp
  8004208f78:	48 89 e5             	mov    %rsp,%rbp
  8004208f7b:	48 83 ec 20          	sub    $0x20,%rsp
  8004208f7f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
	//cprintf("ENV_RUN being called from here: e->env_id [%d]",e->env_id); 
	if(curenv == e){
  8004208f83:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208f8a:	00 00 00 
  8004208f8d:	ff d0                	callq  *%rax
  8004208f8f:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004208f96:	00 00 00 
  8004208f99:	48 98                	cltq   
  8004208f9b:	48 c1 e0 03          	shl    $0x3,%rax
  8004208f9f:	48 89 c1             	mov    %rax,%rcx
  8004208fa2:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208fa6:	48 01 c8             	add    %rcx,%rax
  8004208fa9:	48 01 d0             	add    %rdx,%rax
  8004208fac:	48 83 c0 08          	add    $0x8,%rax
  8004208fb0:	48 8b 00             	mov    (%rax),%rax
  8004208fb3:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004208fb7:	0f 85 8a 00 00 00    	jne    8004209047 <env_run+0xd0>
		curenv->env_runs += 1;
  8004208fbd:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004208fc4:	00 00 00 
  8004208fc7:	ff d0                	callq  *%rax
  8004208fc9:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004208fd0:	00 00 00 
  8004208fd3:	48 98                	cltq   
  8004208fd5:	48 c1 e0 03          	shl    $0x3,%rax
  8004208fd9:	48 89 c1             	mov    %rax,%rcx
  8004208fdc:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208fe0:	48 01 c8             	add    %rcx,%rax
  8004208fe3:	48 01 d0             	add    %rdx,%rax
  8004208fe6:	48 83 c0 08          	add    $0x8,%rax
  8004208fea:	48 8b 00             	mov    (%rax),%rax
  8004208fed:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004208ff3:	83 c2 01             	add    $0x1,%edx
  8004208ff6:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
		unlock_kernel();
  8004208ffc:	48 b8 5f 78 20 04 80 	movabs $0x800420785f,%rax
  8004209003:	00 00 00 
  8004209006:	ff d0                	callq  *%rax
		env_pop_tf(&curenv->env_tf);
  8004209008:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420900f:	00 00 00 
  8004209012:	ff d0                	callq  *%rax
  8004209014:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420901b:	00 00 00 
  800420901e:	48 98                	cltq   
  8004209020:	48 c1 e0 03          	shl    $0x3,%rax
  8004209024:	48 89 c1             	mov    %rax,%rcx
  8004209027:	48 c1 e1 04          	shl    $0x4,%rcx
  800420902b:	48 01 c8             	add    %rcx,%rax
  800420902e:	48 01 d0             	add    %rdx,%rax
  8004209031:	48 83 c0 08          	add    $0x8,%rax
  8004209035:	48 8b 00             	mov    (%rax),%rax
  8004209038:	48 89 c7             	mov    %rax,%rdi
  800420903b:	48 b8 9b 8e 20 04 80 	movabs $0x8004208e9b,%rax
  8004209042:	00 00 00 
  8004209045:	ff d0                	callq  *%rax
	}
	if(curenv) //If this is a context switch
  8004209047:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420904e:	00 00 00 
  8004209051:	ff d0                	callq  *%rax
  8004209053:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420905a:	00 00 00 
  800420905d:	48 98                	cltq   
  800420905f:	48 c1 e0 03          	shl    $0x3,%rax
  8004209063:	48 89 c1             	mov    %rax,%rcx
  8004209066:	48 c1 e1 04          	shl    $0x4,%rcx
  800420906a:	48 01 c8             	add    %rcx,%rax
  800420906d:	48 01 d0             	add    %rdx,%rax
  8004209070:	48 83 c0 08          	add    $0x8,%rax
  8004209074:	48 8b 00             	mov    (%rax),%rax
  8004209077:	48 85 c0             	test   %rax,%rax
  800420907a:	74 75                	je     80042090f1 <env_run+0x17a>
	{
		if(curenv->env_status == ENV_RUNNING)
  800420907c:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004209083:	00 00 00 
  8004209086:	ff d0                	callq  *%rax
  8004209088:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420908f:	00 00 00 
  8004209092:	48 98                	cltq   
  8004209094:	48 c1 e0 03          	shl    $0x3,%rax
  8004209098:	48 89 c1             	mov    %rax,%rcx
  800420909b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420909f:	48 01 c8             	add    %rcx,%rax
  80042090a2:	48 01 d0             	add    %rdx,%rax
  80042090a5:	48 83 c0 08          	add    $0x8,%rax
  80042090a9:	48 8b 00             	mov    (%rax),%rax
  80042090ac:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042090b2:	83 f8 03             	cmp    $0x3,%eax
  80042090b5:	75 3a                	jne    80042090f1 <env_run+0x17a>
		{
			curenv->env_status = ENV_RUNNABLE;	
  80042090b7:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  80042090be:	00 00 00 
  80042090c1:	ff d0                	callq  *%rax
  80042090c3:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  80042090ca:	00 00 00 
  80042090cd:	48 98                	cltq   
  80042090cf:	48 c1 e0 03          	shl    $0x3,%rax
  80042090d3:	48 89 c1             	mov    %rax,%rcx
  80042090d6:	48 c1 e1 04          	shl    $0x4,%rcx
  80042090da:	48 01 c8             	add    %rcx,%rax
  80042090dd:	48 01 d0             	add    %rdx,%rax
  80042090e0:	48 83 c0 08          	add    $0x8,%rax
  80042090e4:	48 8b 00             	mov    (%rax),%rax
  80042090e7:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  80042090ee:	00 00 00 
		}
	}
	//make new enviornment as current enviornment
	
	curenv = e;
  80042090f1:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  80042090f8:	00 00 00 
  80042090fb:	ff d0                	callq  *%rax
  80042090fd:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004209104:	00 00 00 
  8004209107:	48 98                	cltq   
  8004209109:	48 c1 e0 03          	shl    $0x3,%rax
  800420910d:	48 89 c1             	mov    %rax,%rcx
  8004209110:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209114:	48 01 c8             	add    %rcx,%rax
  8004209117:	48 01 d0             	add    %rdx,%rax
  800420911a:	48 8d 50 08          	lea    0x8(%rax),%rdx
  800420911e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004209122:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status = ENV_RUNNING;
  8004209125:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420912c:	00 00 00 
  800420912f:	ff d0                	callq  *%rax
  8004209131:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004209138:	00 00 00 
  800420913b:	48 98                	cltq   
  800420913d:	48 c1 e0 03          	shl    $0x3,%rax
  8004209141:	48 89 c1             	mov    %rax,%rcx
  8004209144:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209148:	48 01 c8             	add    %rcx,%rax
  800420914b:	48 01 d0             	add    %rdx,%rax
  800420914e:	48 83 c0 08          	add    $0x8,%rax
  8004209152:	48 8b 00             	mov    (%rax),%rax
  8004209155:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  800420915c:	00 00 00 
	curenv->env_runs += 1;
  800420915f:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004209166:	00 00 00 
  8004209169:	ff d0                	callq  *%rax
  800420916b:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004209172:	00 00 00 
  8004209175:	48 98                	cltq   
  8004209177:	48 c1 e0 03          	shl    $0x3,%rax
  800420917b:	48 89 c1             	mov    %rax,%rcx
  800420917e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004209182:	48 01 c8             	add    %rcx,%rax
  8004209185:	48 01 d0             	add    %rdx,%rax
  8004209188:	48 83 c0 08          	add    $0x8,%rax
  800420918c:	48 8b 00             	mov    (%rax),%rax
  800420918f:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004209195:	83 c2 01             	add    $0x1,%edx
  8004209198:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	unlock_kernel();
  800420919e:	48 b8 5f 78 20 04 80 	movabs $0x800420785f,%rax
  80042091a5:	00 00 00 
  80042091a8:	ff d0                	callq  *%rax
	lcr3(curenv->env_cr3);
  80042091aa:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  80042091b1:	00 00 00 
  80042091b4:	ff d0                	callq  *%rax
  80042091b6:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  80042091bd:	00 00 00 
  80042091c0:	48 98                	cltq   
  80042091c2:	48 c1 e0 03          	shl    $0x3,%rax
  80042091c6:	48 89 c1             	mov    %rax,%rcx
  80042091c9:	48 c1 e1 04          	shl    $0x4,%rcx
  80042091cd:	48 01 c8             	add    %rcx,%rax
  80042091d0:	48 01 d0             	add    %rdx,%rax
  80042091d3:	48 83 c0 08          	add    $0x8,%rax
  80042091d7:	48 8b 00             	mov    (%rax),%rax
  80042091da:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  80042091e1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042091e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042091e9:	0f 22 d8             	mov    %rax,%cr3
	//restore the environment's registers
	//if(curenv->env_runs > 0)
	{
		env_pop_tf(&curenv->env_tf);
  80042091ec:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  80042091f3:	00 00 00 
  80042091f6:	ff d0                	callq  *%rax
  80042091f8:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  80042091ff:	00 00 00 
  8004209202:	48 98                	cltq   
  8004209204:	48 c1 e0 03          	shl    $0x3,%rax
  8004209208:	48 89 c1             	mov    %rax,%rcx
  800420920b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420920f:	48 01 c8             	add    %rcx,%rax
  8004209212:	48 01 d0             	add    %rdx,%rax
  8004209215:	48 83 c0 08          	add    $0x8,%rax
  8004209219:	48 8b 00             	mov    (%rax),%rax
  800420921c:	48 89 c7             	mov    %rax,%rdi
  800420921f:	48 b8 9b 8e 20 04 80 	movabs $0x8004208e9b,%rax
  8004209226:	00 00 00 
  8004209229:	ff d0                	callq  *%rax

000000800420922b <ipc_find_env>:

	//panic("env_run not yet implemented");
}
envid_t
ipc_find_env(enum EnvType type)
{
  800420922b:	55                   	push   %rbp
  800420922c:	48 89 e5             	mov    %rsp,%rbp
  800420922f:	48 83 ec 14          	sub    $0x14,%rsp
  8004209233:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++) {
  8004209236:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420923d:	eb 4f                	jmp    800420928e <ipc_find_env+0x63>
		if (envs[i].env_type == type)
  800420923f:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  8004209246:	00 00 00 
  8004209249:	48 8b 10             	mov    (%rax),%rdx
  800420924c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420924f:	48 98                	cltq   
  8004209251:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004209258:	48 01 d0             	add    %rdx,%rax
  800420925b:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004209261:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004209264:	75 24                	jne    800420928a <ipc_find_env+0x5f>
			return envs[i].env_id;
  8004209266:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  800420926d:	00 00 00 
  8004209270:	48 8b 10             	mov    (%rax),%rdx
  8004209273:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209276:	48 98                	cltq   
  8004209278:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420927f:	48 01 d0             	add    %rdx,%rax
  8004209282:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004209288:	eb 12                	jmp    800420929c <ipc_find_env+0x71>
}
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++) {
  800420928a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420928e:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  8004209295:	7e a8                	jle    800420923f <ipc_find_env+0x14>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	}
	return 0;
  8004209297:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420929c:	c9                   	leaveq 
  800420929d:	c3                   	retq   

000000800420929e <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  800420929e:	55                   	push   %rbp
  800420929f:	48 89 e5             	mov    %rsp,%rbp
  80042092a2:	48 83 ec 14          	sub    $0x14,%rsp
  80042092a6:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  80042092a9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042092ac:	0f b6 c0             	movzbl %al,%eax
  80042092af:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042092b6:	88 45 fb             	mov    %al,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042092b9:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042092bd:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042092c0:	ee                   	out    %al,(%dx)
  80042092c1:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042092c8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042092cb:	89 c2                	mov    %eax,%edx
  80042092cd:	ec                   	in     (%dx),%al
  80042092ce:	88 45 f3             	mov    %al,-0xd(%rbp)
    return data;
  80042092d1:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  80042092d5:	0f b6 c0             	movzbl %al,%eax
}
  80042092d8:	c9                   	leaveq 
  80042092d9:	c3                   	retq   

00000080042092da <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  80042092da:	55                   	push   %rbp
  80042092db:	48 89 e5             	mov    %rsp,%rbp
  80042092de:	48 83 ec 18          	sub    $0x18,%rsp
  80042092e2:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042092e5:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  80042092e8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042092eb:	0f b6 c0             	movzbl %al,%eax
  80042092ee:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  80042092f5:	88 45 fb             	mov    %al,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  80042092f8:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042092fc:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042092ff:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004209300:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004209303:	0f b6 c0             	movzbl %al,%eax
  8004209306:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  800420930d:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004209310:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004209314:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004209317:	ee                   	out    %al,(%dx)
}
  8004209318:	c9                   	leaveq 
  8004209319:	c3                   	retq   

000000800420931a <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  800420931a:	55                   	push   %rbp
  800420931b:	48 89 e5             	mov    %rsp,%rbp
  800420931e:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004209322:	48 b8 68 d2 3a 04 80 	movabs $0x80043ad268,%rax
  8004209329:	00 00 00 
  800420932c:	c6 00 01             	movb   $0x1,(%rax)
  800420932f:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004209336:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  800420933a:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  800420933e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209341:	ee                   	out    %al,(%dx)
  8004209342:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004209349:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  800420934d:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004209351:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004209354:	ee                   	out    %al,(%dx)
  8004209355:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  800420935c:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004209360:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004209364:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004209367:	ee                   	out    %al,(%dx)
  8004209368:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  800420936f:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004209373:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004209377:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800420937a:	ee                   	out    %al,(%dx)
  800420937b:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004209382:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004209386:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800420938a:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800420938d:	ee                   	out    %al,(%dx)
  800420938e:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004209395:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004209399:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  800420939d:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042093a0:	ee                   	out    %al,(%dx)
  80042093a1:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  80042093a8:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  80042093ac:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  80042093b0:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042093b3:	ee                   	out    %al,(%dx)
  80042093b4:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  80042093bb:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  80042093bf:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  80042093c3:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042093c6:	ee                   	out    %al,(%dx)
  80042093c7:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  80042093ce:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  80042093d2:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  80042093d6:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042093d9:	ee                   	out    %al,(%dx)
  80042093da:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  80042093e1:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  80042093e5:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  80042093e9:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  80042093ec:	ee                   	out    %al,(%dx)
  80042093ed:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  80042093f4:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  80042093f8:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  80042093fc:	8b 55 ac             	mov    -0x54(%rbp),%edx
  80042093ff:	ee                   	out    %al,(%dx)
  8004209400:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  8004209407:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  800420940b:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  800420940f:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004209412:	ee                   	out    %al,(%dx)
  8004209413:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  800420941a:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  800420941e:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004209422:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004209425:	ee                   	out    %al,(%dx)
  8004209426:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  800420942d:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004209431:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004209435:	8b 55 94             	mov    -0x6c(%rbp),%edx
  8004209438:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004209439:	48 b8 52 36 23 04 80 	movabs $0x8004233652,%rax
  8004209440:	00 00 00 
  8004209443:	0f b7 00             	movzwl (%rax),%eax
  8004209446:	66 83 f8 ff          	cmp    $0xffff,%ax
  800420944a:	74 1e                	je     800420946a <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  800420944c:	48 b8 52 36 23 04 80 	movabs $0x8004233652,%rax
  8004209453:	00 00 00 
  8004209456:	0f b7 00             	movzwl (%rax),%eax
  8004209459:	0f b7 c0             	movzwl %ax,%eax
  800420945c:	89 c7                	mov    %eax,%edi
  800420945e:	48 b8 6c 94 20 04 80 	movabs $0x800420946c,%rax
  8004209465:	00 00 00 
  8004209468:	ff d0                	callq  *%rax
}
  800420946a:	c9                   	leaveq 
  800420946b:	c3                   	retq   

000000800420946c <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  800420946c:	55                   	push   %rbp
  800420946d:	48 89 e5             	mov    %rsp,%rbp
  8004209470:	48 83 ec 30          	sub    $0x30,%rsp
  8004209474:	89 f8                	mov    %edi,%eax
  8004209476:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  800420947a:	48 b8 52 36 23 04 80 	movabs $0x8004233652,%rax
  8004209481:	00 00 00 
  8004209484:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8004209488:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  800420948b:	48 b8 68 d2 3a 04 80 	movabs $0x80043ad268,%rax
  8004209492:	00 00 00 
  8004209495:	0f b6 00             	movzbl (%rax),%eax
  8004209498:	83 f0 01             	xor    $0x1,%eax
  800420949b:	84 c0                	test   %al,%al
  800420949d:	74 05                	je     80042094a4 <irq_setmask_8259A+0x38>
		return;
  800420949f:	e9 b7 00 00 00       	jmpq   800420955b <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  80042094a4:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042094a8:	0f b6 c0             	movzbl %al,%eax
  80042094ab:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  80042094b2:	88 45 f7             	mov    %al,-0x9(%rbp)
  80042094b5:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  80042094b9:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042094bc:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  80042094bd:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  80042094c1:	66 c1 e8 08          	shr    $0x8,%ax
  80042094c5:	0f b6 c0             	movzbl %al,%eax
  80042094c8:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  80042094cf:	88 45 ef             	mov    %al,-0x11(%rbp)
  80042094d2:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  80042094d6:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042094d9:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  80042094da:	48 bf 05 e6 21 04 80 	movabs $0x800421e605,%rdi
  80042094e1:	00 00 00 
  80042094e4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042094e9:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042094f0:	00 00 00 
  80042094f3:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  80042094f5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042094fc:	eb 3c                	jmp    800420953a <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  80042094fe:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004209502:	f7 d0                	not    %eax
  8004209504:	89 c2                	mov    %eax,%edx
  8004209506:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209509:	89 c1                	mov    %eax,%ecx
  800420950b:	d3 fa                	sar    %cl,%edx
  800420950d:	89 d0                	mov    %edx,%eax
  800420950f:	83 e0 01             	and    $0x1,%eax
  8004209512:	85 c0                	test   %eax,%eax
  8004209514:	74 20                	je     8004209536 <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  8004209516:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209519:	89 c6                	mov    %eax,%esi
  800420951b:	48 bf 19 e6 21 04 80 	movabs $0x800421e619,%rdi
  8004209522:	00 00 00 
  8004209525:	b8 00 00 00 00       	mov    $0x0,%eax
  800420952a:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004209531:	00 00 00 
  8004209534:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004209536:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420953a:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  800420953e:	7e be                	jle    80042094fe <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004209540:	48 bf 1d e6 21 04 80 	movabs $0x800421e61d,%rdi
  8004209547:	00 00 00 
  800420954a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420954f:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004209556:	00 00 00 
  8004209559:	ff d2                	callq  *%rdx
}
  800420955b:	c9                   	leaveq 
  800420955c:	c3                   	retq   

000000800420955d <irq_eoi>:

void
irq_eoi(void)
{
  800420955d:	55                   	push   %rbp
  800420955e:	48 89 e5             	mov    %rsp,%rbp
  8004209561:	48 83 ec 10          	sub    $0x10,%rsp
  8004209565:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  800420956c:	c6 45 fb 20          	movb   $0x20,-0x5(%rbp)
  8004209570:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004209574:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209577:	ee                   	out    %al,(%dx)
  8004209578:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%rbp)
  800420957f:	c6 45 f3 20          	movb   $0x20,-0xd(%rbp)
  8004209583:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004209587:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420958a:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  800420958b:	c9                   	leaveq 
  800420958c:	c3                   	retq   

000000800420958d <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  800420958d:	55                   	push   %rbp
  800420958e:	48 89 e5             	mov    %rsp,%rbp
  8004209591:	48 83 ec 10          	sub    $0x10,%rsp
  8004209595:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004209598:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  800420959c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420959f:	89 c7                	mov    %eax,%edi
  80042095a1:	48 b8 6b 12 20 04 80 	movabs $0x800420126b,%rax
  80042095a8:	00 00 00 
  80042095ab:	ff d0                	callq  *%rax
	*cnt++;
  80042095ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042095b1:	48 83 c0 04          	add    $0x4,%rax
  80042095b5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  80042095b9:	c9                   	leaveq 
  80042095ba:	c3                   	retq   

00000080042095bb <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80042095bb:	55                   	push   %rbp
  80042095bc:	48 89 e5             	mov    %rsp,%rbp
  80042095bf:	48 83 ec 30          	sub    $0x30,%rsp
  80042095c3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042095c7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  80042095cb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  80042095d2:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042095d6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042095da:	48 8b 0a             	mov    (%rdx),%rcx
  80042095dd:	48 89 08             	mov    %rcx,(%rax)
  80042095e0:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042095e4:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042095e8:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042095ec:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  80042095f0:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  80042095f4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042095f8:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  80042095fc:	48 89 c6             	mov    %rax,%rsi
  80042095ff:	48 bf 8d 95 20 04 80 	movabs $0x800420958d,%rdi
  8004209606:	00 00 00 
  8004209609:	48 b8 9c ff 20 04 80 	movabs $0x800420ff9c,%rax
  8004209610:	00 00 00 
  8004209613:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004209615:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004209618:	c9                   	leaveq 
  8004209619:	c3                   	retq   

000000800420961a <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800420961a:	55                   	push   %rbp
  800420961b:	48 89 e5             	mov    %rsp,%rbp
  800420961e:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004209625:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  800420962c:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004209633:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420963a:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004209641:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004209648:	84 c0                	test   %al,%al
  800420964a:	74 20                	je     800420966c <cprintf+0x52>
  800420964c:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004209650:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004209654:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004209658:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420965c:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004209660:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004209664:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004209668:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420966c:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004209673:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  800420967a:	00 00 00 
  800420967d:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004209684:	00 00 00 
  8004209687:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420968b:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004209692:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004209699:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  80042096a0:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  80042096a7:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  80042096ae:	48 8b 0a             	mov    (%rdx),%rcx
  80042096b1:	48 89 08             	mov    %rcx,(%rax)
  80042096b4:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042096b8:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042096bc:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042096c0:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  80042096c4:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  80042096cb:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042096d2:	48 89 d6             	mov    %rdx,%rsi
  80042096d5:	48 89 c7             	mov    %rax,%rdi
  80042096d8:	48 b8 bb 95 20 04 80 	movabs $0x80042095bb,%rax
  80042096df:	00 00 00 
  80042096e2:	ff d0                	callq  *%rax
  80042096e4:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  80042096ea:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  80042096f0:	c9                   	leaveq 
  80042096f1:	c3                   	retq   

00000080042096f2 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  80042096f2:	55                   	push   %rbp
  80042096f3:	48 89 e5             	mov    %rsp,%rbp
  80042096f6:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042096fa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042096fe:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004209701:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004209705:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004209708:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420970c:	f0 87 02             	lock xchg %eax,(%rdx)
  800420970f:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004209712:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004209715:	c9                   	leaveq 
  8004209716:	c3                   	retq   

0000008004209717 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  8004209717:	55                   	push   %rbp
  8004209718:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  800420971b:	48 bf 40 37 23 04 80 	movabs $0x8004233740,%rdi
  8004209722:	00 00 00 
  8004209725:	48 b8 25 7f 21 04 80 	movabs $0x8004217f25,%rax
  800420972c:	00 00 00 
  800420972f:	ff d0                	callq  *%rax
}
  8004209731:	5d                   	pop    %rbp
  8004209732:	c3                   	retq   

0000008004209733 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004209733:	55                   	push   %rbp
  8004209734:	48 89 e5             	mov    %rsp,%rbp
  8004209737:	48 83 ec 04          	sub    $0x4,%rsp
  800420973b:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  800420973e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209741:	83 f8 13             	cmp    $0x13,%eax
  8004209744:	77 16                	ja     800420975c <trapname+0x29>
		return excnames[trapno];
  8004209746:	48 b8 60 ea 21 04 80 	movabs $0x800421ea60,%rax
  800420974d:	00 00 00 
  8004209750:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209753:	48 63 d2             	movslq %edx,%rdx
  8004209756:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420975a:	eb 34                	jmp    8004209790 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  800420975c:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  8004209760:	75 0c                	jne    800420976e <trapname+0x3b>
		return "System call";
  8004209762:	48 b8 20 e6 21 04 80 	movabs $0x800421e620,%rax
  8004209769:	00 00 00 
  800420976c:	eb 22                	jmp    8004209790 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  800420976e:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  8004209772:	7e 12                	jle    8004209786 <trapname+0x53>
  8004209774:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  8004209778:	7f 0c                	jg     8004209786 <trapname+0x53>
		return "Hardware Interrupt";
  800420977a:	48 b8 2c e6 21 04 80 	movabs $0x800421e62c,%rax
  8004209781:	00 00 00 
  8004209784:	eb 0a                	jmp    8004209790 <trapname+0x5d>
	return "(unknown trap)";
  8004209786:	48 b8 3f e6 21 04 80 	movabs $0x800421e63f,%rax
  800420978d:	00 00 00 
}
  8004209790:	c9                   	leaveq 
  8004209791:	c3                   	retq   

0000008004209792 <trap_init>:


void
trap_init(void)
{
  8004209792:	55                   	push   %rbp
  8004209793:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
    SETGATE(idt[T_DIVIDE], 0, GD_KT, XTRPX_divzero, 0);  
  8004209796:	48 b8 da d4 20 04 80 	movabs $0x800420d4da,%rax
  800420979d:	00 00 00 
  80042097a0:	89 c2                	mov    %eax,%edx
  80042097a2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042097a9:	00 00 00 
  80042097ac:	66 89 10             	mov    %dx,(%rax)
  80042097af:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042097b6:	00 00 00 
  80042097b9:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  80042097bf:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042097c6:	00 00 00 
  80042097c9:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042097cd:	83 e2 f8             	and    $0xfffffff8,%edx
  80042097d0:	88 50 04             	mov    %dl,0x4(%rax)
  80042097d3:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042097da:	00 00 00 
  80042097dd:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  80042097e1:	83 e2 07             	and    $0x7,%edx
  80042097e4:	88 50 04             	mov    %dl,0x4(%rax)
  80042097e7:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042097ee:	00 00 00 
  80042097f1:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  80042097f5:	83 e2 f0             	and    $0xfffffff0,%edx
  80042097f8:	83 ca 0e             	or     $0xe,%edx
  80042097fb:	88 50 05             	mov    %dl,0x5(%rax)
  80042097fe:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209805:	00 00 00 
  8004209808:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420980c:	83 e2 ef             	and    $0xffffffef,%edx
  800420980f:	88 50 05             	mov    %dl,0x5(%rax)
  8004209812:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209819:	00 00 00 
  800420981c:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209820:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209823:	88 50 05             	mov    %dl,0x5(%rax)
  8004209826:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420982d:	00 00 00 
  8004209830:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209834:	83 ca 80             	or     $0xffffff80,%edx
  8004209837:	88 50 05             	mov    %dl,0x5(%rax)
  800420983a:	48 b8 da d4 20 04 80 	movabs $0x800420d4da,%rax
  8004209841:	00 00 00 
  8004209844:	48 c1 e8 10          	shr    $0x10,%rax
  8004209848:	89 c2                	mov    %eax,%edx
  800420984a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209851:	00 00 00 
  8004209854:	66 89 50 06          	mov    %dx,0x6(%rax)
  8004209858:	48 b8 da d4 20 04 80 	movabs $0x800420d4da,%rax
  800420985f:	00 00 00 
  8004209862:	48 c1 e8 20          	shr    $0x20,%rax
  8004209866:	89 c2                	mov    %eax,%edx
  8004209868:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420986f:	00 00 00 
  8004209872:	89 50 08             	mov    %edx,0x8(%rax)
  8004209875:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420987c:	00 00 00 
  800420987f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
    SETGATE(idt[T_DEBUG], 0, GD_KT, XTRPX_Debug, 0);  
  8004209886:	48 b8 e4 d4 20 04 80 	movabs $0x800420d4e4,%rax
  800420988d:	00 00 00 
  8004209890:	89 c2                	mov    %eax,%edx
  8004209892:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209899:	00 00 00 
  800420989c:	66 89 50 10          	mov    %dx,0x10(%rax)
  80042098a0:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042098a7:	00 00 00 
  80042098aa:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  80042098b0:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042098b7:	00 00 00 
  80042098ba:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042098be:	83 e2 f8             	and    $0xfffffff8,%edx
  80042098c1:	88 50 14             	mov    %dl,0x14(%rax)
  80042098c4:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042098cb:	00 00 00 
  80042098ce:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  80042098d2:	83 e2 07             	and    $0x7,%edx
  80042098d5:	88 50 14             	mov    %dl,0x14(%rax)
  80042098d8:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042098df:	00 00 00 
  80042098e2:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042098e6:	83 e2 f0             	and    $0xfffffff0,%edx
  80042098e9:	83 ca 0e             	or     $0xe,%edx
  80042098ec:	88 50 15             	mov    %dl,0x15(%rax)
  80042098ef:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042098f6:	00 00 00 
  80042098f9:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  80042098fd:	83 e2 ef             	and    $0xffffffef,%edx
  8004209900:	88 50 15             	mov    %dl,0x15(%rax)
  8004209903:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420990a:	00 00 00 
  800420990d:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209911:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209914:	88 50 15             	mov    %dl,0x15(%rax)
  8004209917:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420991e:	00 00 00 
  8004209921:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209925:	83 ca 80             	or     $0xffffff80,%edx
  8004209928:	88 50 15             	mov    %dl,0x15(%rax)
  800420992b:	48 b8 e4 d4 20 04 80 	movabs $0x800420d4e4,%rax
  8004209932:	00 00 00 
  8004209935:	48 c1 e8 10          	shr    $0x10,%rax
  8004209939:	89 c2                	mov    %eax,%edx
  800420993b:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209942:	00 00 00 
  8004209945:	66 89 50 16          	mov    %dx,0x16(%rax)
  8004209949:	48 b8 e4 d4 20 04 80 	movabs $0x800420d4e4,%rax
  8004209950:	00 00 00 
  8004209953:	48 c1 e8 20          	shr    $0x20,%rax
  8004209957:	89 c2                	mov    %eax,%edx
  8004209959:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209960:	00 00 00 
  8004209963:	89 50 18             	mov    %edx,0x18(%rax)
  8004209966:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420996d:	00 00 00 
  8004209970:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
    SETGATE(idt[T_NMI], 0, GD_KT, XTRPX_NonMaskI, 0);  
  8004209977:	48 b8 ee d4 20 04 80 	movabs $0x800420d4ee,%rax
  800420997e:	00 00 00 
  8004209981:	89 c2                	mov    %eax,%edx
  8004209983:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420998a:	00 00 00 
  800420998d:	66 89 50 20          	mov    %dx,0x20(%rax)
  8004209991:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209998:	00 00 00 
  800420999b:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  80042099a1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042099a8:	00 00 00 
  80042099ab:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  80042099af:	83 e2 f8             	and    $0xfffffff8,%edx
  80042099b2:	88 50 24             	mov    %dl,0x24(%rax)
  80042099b5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042099bc:	00 00 00 
  80042099bf:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  80042099c3:	83 e2 07             	and    $0x7,%edx
  80042099c6:	88 50 24             	mov    %dl,0x24(%rax)
  80042099c9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042099d0:	00 00 00 
  80042099d3:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042099d7:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099da:	83 ca 0e             	or     $0xe,%edx
  80042099dd:	88 50 25             	mov    %dl,0x25(%rax)
  80042099e0:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042099e7:	00 00 00 
  80042099ea:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  80042099ee:	83 e2 ef             	and    $0xffffffef,%edx
  80042099f1:	88 50 25             	mov    %dl,0x25(%rax)
  80042099f4:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  80042099fb:	00 00 00 
  80042099fe:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209a02:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209a05:	88 50 25             	mov    %dl,0x25(%rax)
  8004209a08:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209a0f:	00 00 00 
  8004209a12:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209a16:	83 ca 80             	or     $0xffffff80,%edx
  8004209a19:	88 50 25             	mov    %dl,0x25(%rax)
  8004209a1c:	48 b8 ee d4 20 04 80 	movabs $0x800420d4ee,%rax
  8004209a23:	00 00 00 
  8004209a26:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a2a:	89 c2                	mov    %eax,%edx
  8004209a2c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209a33:	00 00 00 
  8004209a36:	66 89 50 26          	mov    %dx,0x26(%rax)
  8004209a3a:	48 b8 ee d4 20 04 80 	movabs $0x800420d4ee,%rax
  8004209a41:	00 00 00 
  8004209a44:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a48:	89 c2                	mov    %eax,%edx
  8004209a4a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209a51:	00 00 00 
  8004209a54:	89 50 28             	mov    %edx,0x28(%rax)
  8004209a57:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209a5e:	00 00 00 
  8004209a61:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
    SETGATE(idt[T_BRKPT], 0, GD_KT, XTRPX_Brkpt, 3);  
  8004209a68:	48 b8 f8 d4 20 04 80 	movabs $0x800420d4f8,%rax
  8004209a6f:	00 00 00 
  8004209a72:	89 c2                	mov    %eax,%edx
  8004209a74:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209a7b:	00 00 00 
  8004209a7e:	66 89 50 30          	mov    %dx,0x30(%rax)
  8004209a82:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209a89:	00 00 00 
  8004209a8c:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  8004209a92:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209a99:	00 00 00 
  8004209a9c:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209aa0:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209aa3:	88 50 34             	mov    %dl,0x34(%rax)
  8004209aa6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209aad:	00 00 00 
  8004209ab0:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  8004209ab4:	83 e2 07             	and    $0x7,%edx
  8004209ab7:	88 50 34             	mov    %dl,0x34(%rax)
  8004209aba:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209ac1:	00 00 00 
  8004209ac4:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209ac8:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209acb:	83 ca 0e             	or     $0xe,%edx
  8004209ace:	88 50 35             	mov    %dl,0x35(%rax)
  8004209ad1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209ad8:	00 00 00 
  8004209adb:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209adf:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ae2:	88 50 35             	mov    %dl,0x35(%rax)
  8004209ae5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209aec:	00 00 00 
  8004209aef:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209af3:	83 ca 60             	or     $0x60,%edx
  8004209af6:	88 50 35             	mov    %dl,0x35(%rax)
  8004209af9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209b00:	00 00 00 
  8004209b03:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209b07:	83 ca 80             	or     $0xffffff80,%edx
  8004209b0a:	88 50 35             	mov    %dl,0x35(%rax)
  8004209b0d:	48 b8 f8 d4 20 04 80 	movabs $0x800420d4f8,%rax
  8004209b14:	00 00 00 
  8004209b17:	48 c1 e8 10          	shr    $0x10,%rax
  8004209b1b:	89 c2                	mov    %eax,%edx
  8004209b1d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209b24:	00 00 00 
  8004209b27:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004209b2b:	48 b8 f8 d4 20 04 80 	movabs $0x800420d4f8,%rax
  8004209b32:	00 00 00 
  8004209b35:	48 c1 e8 20          	shr    $0x20,%rax
  8004209b39:	89 c2                	mov    %eax,%edx
  8004209b3b:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209b42:	00 00 00 
  8004209b45:	89 50 38             	mov    %edx,0x38(%rax)
  8004209b48:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209b4f:	00 00 00 
  8004209b52:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
    SETGATE(idt[T_OFLOW], 0, GD_KT, XTRPX_OFlow, 0);  
  8004209b59:	48 b8 02 d5 20 04 80 	movabs $0x800420d502,%rax
  8004209b60:	00 00 00 
  8004209b63:	89 c2                	mov    %eax,%edx
  8004209b65:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209b6c:	00 00 00 
  8004209b6f:	66 89 50 40          	mov    %dx,0x40(%rax)
  8004209b73:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209b7a:	00 00 00 
  8004209b7d:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  8004209b83:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209b8a:	00 00 00 
  8004209b8d:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209b91:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209b94:	88 50 44             	mov    %dl,0x44(%rax)
  8004209b97:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209b9e:	00 00 00 
  8004209ba1:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  8004209ba5:	83 e2 07             	and    $0x7,%edx
  8004209ba8:	88 50 44             	mov    %dl,0x44(%rax)
  8004209bab:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209bb2:	00 00 00 
  8004209bb5:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209bb9:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209bbc:	83 ca 0e             	or     $0xe,%edx
  8004209bbf:	88 50 45             	mov    %dl,0x45(%rax)
  8004209bc2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209bc9:	00 00 00 
  8004209bcc:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209bd0:	83 e2 ef             	and    $0xffffffef,%edx
  8004209bd3:	88 50 45             	mov    %dl,0x45(%rax)
  8004209bd6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209bdd:	00 00 00 
  8004209be0:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209be4:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209be7:	88 50 45             	mov    %dl,0x45(%rax)
  8004209bea:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209bf1:	00 00 00 
  8004209bf4:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209bf8:	83 ca 80             	or     $0xffffff80,%edx
  8004209bfb:	88 50 45             	mov    %dl,0x45(%rax)
  8004209bfe:	48 b8 02 d5 20 04 80 	movabs $0x800420d502,%rax
  8004209c05:	00 00 00 
  8004209c08:	48 c1 e8 10          	shr    $0x10,%rax
  8004209c0c:	89 c2                	mov    %eax,%edx
  8004209c0e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209c15:	00 00 00 
  8004209c18:	66 89 50 46          	mov    %dx,0x46(%rax)
  8004209c1c:	48 b8 02 d5 20 04 80 	movabs $0x800420d502,%rax
  8004209c23:	00 00 00 
  8004209c26:	48 c1 e8 20          	shr    $0x20,%rax
  8004209c2a:	89 c2                	mov    %eax,%edx
  8004209c2c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209c33:	00 00 00 
  8004209c36:	89 50 48             	mov    %edx,0x48(%rax)
  8004209c39:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209c40:	00 00 00 
  8004209c43:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
    SETGATE(idt[T_BOUND], 0, GD_KT, XTRPX_Bound, 0);  
  8004209c4a:	48 b8 0c d5 20 04 80 	movabs $0x800420d50c,%rax
  8004209c51:	00 00 00 
  8004209c54:	89 c2                	mov    %eax,%edx
  8004209c56:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209c5d:	00 00 00 
  8004209c60:	66 89 50 50          	mov    %dx,0x50(%rax)
  8004209c64:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209c6b:	00 00 00 
  8004209c6e:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  8004209c74:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209c7b:	00 00 00 
  8004209c7e:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209c82:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209c85:	88 50 54             	mov    %dl,0x54(%rax)
  8004209c88:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209c8f:	00 00 00 
  8004209c92:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  8004209c96:	83 e2 07             	and    $0x7,%edx
  8004209c99:	88 50 54             	mov    %dl,0x54(%rax)
  8004209c9c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209ca3:	00 00 00 
  8004209ca6:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209caa:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209cad:	83 ca 0e             	or     $0xe,%edx
  8004209cb0:	88 50 55             	mov    %dl,0x55(%rax)
  8004209cb3:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209cba:	00 00 00 
  8004209cbd:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209cc1:	83 e2 ef             	and    $0xffffffef,%edx
  8004209cc4:	88 50 55             	mov    %dl,0x55(%rax)
  8004209cc7:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209cce:	00 00 00 
  8004209cd1:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209cd5:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209cd8:	88 50 55             	mov    %dl,0x55(%rax)
  8004209cdb:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209ce2:	00 00 00 
  8004209ce5:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209ce9:	83 ca 80             	or     $0xffffff80,%edx
  8004209cec:	88 50 55             	mov    %dl,0x55(%rax)
  8004209cef:	48 b8 0c d5 20 04 80 	movabs $0x800420d50c,%rax
  8004209cf6:	00 00 00 
  8004209cf9:	48 c1 e8 10          	shr    $0x10,%rax
  8004209cfd:	89 c2                	mov    %eax,%edx
  8004209cff:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209d06:	00 00 00 
  8004209d09:	66 89 50 56          	mov    %dx,0x56(%rax)
  8004209d0d:	48 b8 0c d5 20 04 80 	movabs $0x800420d50c,%rax
  8004209d14:	00 00 00 
  8004209d17:	48 c1 e8 20          	shr    $0x20,%rax
  8004209d1b:	89 c2                	mov    %eax,%edx
  8004209d1d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209d24:	00 00 00 
  8004209d27:	89 50 58             	mov    %edx,0x58(%rax)
  8004209d2a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209d31:	00 00 00 
  8004209d34:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
    SETGATE(idt[T_ILLOP], 0, GD_KT, XTRPX_Illop, 0);  
  8004209d3b:	48 b8 16 d5 20 04 80 	movabs $0x800420d516,%rax
  8004209d42:	00 00 00 
  8004209d45:	89 c2                	mov    %eax,%edx
  8004209d47:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209d4e:	00 00 00 
  8004209d51:	66 89 50 60          	mov    %dx,0x60(%rax)
  8004209d55:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209d5c:	00 00 00 
  8004209d5f:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  8004209d65:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209d6c:	00 00 00 
  8004209d6f:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209d73:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209d76:	88 50 64             	mov    %dl,0x64(%rax)
  8004209d79:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209d80:	00 00 00 
  8004209d83:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  8004209d87:	83 e2 07             	and    $0x7,%edx
  8004209d8a:	88 50 64             	mov    %dl,0x64(%rax)
  8004209d8d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209d94:	00 00 00 
  8004209d97:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209d9b:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209d9e:	83 ca 0e             	or     $0xe,%edx
  8004209da1:	88 50 65             	mov    %dl,0x65(%rax)
  8004209da4:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209dab:	00 00 00 
  8004209dae:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209db2:	83 e2 ef             	and    $0xffffffef,%edx
  8004209db5:	88 50 65             	mov    %dl,0x65(%rax)
  8004209db8:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209dbf:	00 00 00 
  8004209dc2:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209dc6:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209dc9:	88 50 65             	mov    %dl,0x65(%rax)
  8004209dcc:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209dd3:	00 00 00 
  8004209dd6:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  8004209dda:	83 ca 80             	or     $0xffffff80,%edx
  8004209ddd:	88 50 65             	mov    %dl,0x65(%rax)
  8004209de0:	48 b8 16 d5 20 04 80 	movabs $0x800420d516,%rax
  8004209de7:	00 00 00 
  8004209dea:	48 c1 e8 10          	shr    $0x10,%rax
  8004209dee:	89 c2                	mov    %eax,%edx
  8004209df0:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209df7:	00 00 00 
  8004209dfa:	66 89 50 66          	mov    %dx,0x66(%rax)
  8004209dfe:	48 b8 16 d5 20 04 80 	movabs $0x800420d516,%rax
  8004209e05:	00 00 00 
  8004209e08:	48 c1 e8 20          	shr    $0x20,%rax
  8004209e0c:	89 c2                	mov    %eax,%edx
  8004209e0e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209e15:	00 00 00 
  8004209e18:	89 50 68             	mov    %edx,0x68(%rax)
  8004209e1b:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209e22:	00 00 00 
  8004209e25:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
    SETGATE(idt[T_DEVICE], 0, GD_KT, XTRPX_Device, 0);  
  8004209e2c:	48 b8 20 d5 20 04 80 	movabs $0x800420d520,%rax
  8004209e33:	00 00 00 
  8004209e36:	89 c2                	mov    %eax,%edx
  8004209e38:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209e3f:	00 00 00 
  8004209e42:	66 89 50 70          	mov    %dx,0x70(%rax)
  8004209e46:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209e4d:	00 00 00 
  8004209e50:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  8004209e56:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209e5d:	00 00 00 
  8004209e60:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209e64:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209e67:	88 50 74             	mov    %dl,0x74(%rax)
  8004209e6a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209e71:	00 00 00 
  8004209e74:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  8004209e78:	83 e2 07             	and    $0x7,%edx
  8004209e7b:	88 50 74             	mov    %dl,0x74(%rax)
  8004209e7e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209e85:	00 00 00 
  8004209e88:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209e8c:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e8f:	83 ca 0e             	or     $0xe,%edx
  8004209e92:	88 50 75             	mov    %dl,0x75(%rax)
  8004209e95:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209e9c:	00 00 00 
  8004209e9f:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209ea3:	83 e2 ef             	and    $0xffffffef,%edx
  8004209ea6:	88 50 75             	mov    %dl,0x75(%rax)
  8004209ea9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209eb0:	00 00 00 
  8004209eb3:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209eb7:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209eba:	88 50 75             	mov    %dl,0x75(%rax)
  8004209ebd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209ec4:	00 00 00 
  8004209ec7:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209ecb:	83 ca 80             	or     $0xffffff80,%edx
  8004209ece:	88 50 75             	mov    %dl,0x75(%rax)
  8004209ed1:	48 b8 20 d5 20 04 80 	movabs $0x800420d520,%rax
  8004209ed8:	00 00 00 
  8004209edb:	48 c1 e8 10          	shr    $0x10,%rax
  8004209edf:	89 c2                	mov    %eax,%edx
  8004209ee1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209ee8:	00 00 00 
  8004209eeb:	66 89 50 76          	mov    %dx,0x76(%rax)
  8004209eef:	48 b8 20 d5 20 04 80 	movabs $0x800420d520,%rax
  8004209ef6:	00 00 00 
  8004209ef9:	48 c1 e8 20          	shr    $0x20,%rax
  8004209efd:	89 c2                	mov    %eax,%edx
  8004209eff:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209f06:	00 00 00 
  8004209f09:	89 50 78             	mov    %edx,0x78(%rax)
  8004209f0c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209f13:	00 00 00 
  8004209f16:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
    SETGATE(idt[T_DBLFLT], 0, GD_KT, XTRPX_DblFlt, 0);  
  8004209f1d:	48 b8 2a d5 20 04 80 	movabs $0x800420d52a,%rax
  8004209f24:	00 00 00 
  8004209f27:	89 c2                	mov    %eax,%edx
  8004209f29:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209f30:	00 00 00 
  8004209f33:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  8004209f3a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209f41:	00 00 00 
  8004209f44:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  8004209f4b:	08 00 
  8004209f4d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209f54:	00 00 00 
  8004209f57:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209f5e:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f61:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209f67:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209f6e:	00 00 00 
  8004209f71:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  8004209f78:	83 e2 07             	and    $0x7,%edx
  8004209f7b:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  8004209f81:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209f88:	00 00 00 
  8004209f8b:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209f92:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209f95:	83 ca 0e             	or     $0xe,%edx
  8004209f98:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209f9e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209fa5:	00 00 00 
  8004209fa8:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209faf:	83 e2 ef             	and    $0xffffffef,%edx
  8004209fb2:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209fb8:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209fbf:	00 00 00 
  8004209fc2:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209fc9:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209fcc:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209fd2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  8004209fd9:	00 00 00 
  8004209fdc:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209fe3:	83 ca 80             	or     $0xffffff80,%edx
  8004209fe6:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209fec:	48 b8 2a d5 20 04 80 	movabs $0x800420d52a,%rax
  8004209ff3:	00 00 00 
  8004209ff6:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ffa:	89 c2                	mov    %eax,%edx
  8004209ffc:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a003:	00 00 00 
  800420a006:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  800420a00d:	48 b8 2a d5 20 04 80 	movabs $0x800420d52a,%rax
  800420a014:	00 00 00 
  800420a017:	48 c1 e8 20          	shr    $0x20,%rax
  800420a01b:	89 c2                	mov    %eax,%edx
  800420a01d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a024:	00 00 00 
  800420a027:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  800420a02d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a034:	00 00 00 
  800420a037:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  800420a03e:	00 00 00 
    SETGATE(idt[T_TSS], 0, GD_KT, XTRPX_Tss, 0);  
  800420a041:	48 b8 32 d5 20 04 80 	movabs $0x800420d532,%rax
  800420a048:	00 00 00 
  800420a04b:	89 c2                	mov    %eax,%edx
  800420a04d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a054:	00 00 00 
  800420a057:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  800420a05e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a065:	00 00 00 
  800420a068:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  800420a06f:	08 00 
  800420a071:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a078:	00 00 00 
  800420a07b:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a082:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a085:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a08b:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a092:	00 00 00 
  800420a095:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  800420a09c:	83 e2 07             	and    $0x7,%edx
  800420a09f:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  800420a0a5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a0ac:	00 00 00 
  800420a0af:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a0b6:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a0b9:	83 ca 0e             	or     $0xe,%edx
  800420a0bc:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a0c2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a0c9:	00 00 00 
  800420a0cc:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a0d3:	83 e2 ef             	and    $0xffffffef,%edx
  800420a0d6:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a0dc:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a0e3:	00 00 00 
  800420a0e6:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a0ed:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a0f0:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a0f6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a0fd:	00 00 00 
  800420a100:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  800420a107:	83 ca 80             	or     $0xffffff80,%edx
  800420a10a:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  800420a110:	48 b8 32 d5 20 04 80 	movabs $0x800420d532,%rax
  800420a117:	00 00 00 
  800420a11a:	48 c1 e8 10          	shr    $0x10,%rax
  800420a11e:	89 c2                	mov    %eax,%edx
  800420a120:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a127:	00 00 00 
  800420a12a:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  800420a131:	48 b8 32 d5 20 04 80 	movabs $0x800420d532,%rax
  800420a138:	00 00 00 
  800420a13b:	48 c1 e8 20          	shr    $0x20,%rax
  800420a13f:	89 c2                	mov    %eax,%edx
  800420a141:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a148:	00 00 00 
  800420a14b:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  800420a151:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a158:	00 00 00 
  800420a15b:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  800420a162:	00 00 00 
    SETGATE(idt[T_SEGNP], 0, GD_KT, XTRPX_Segnp, 0);  
  800420a165:	48 b8 3a d5 20 04 80 	movabs $0x800420d53a,%rax
  800420a16c:	00 00 00 
  800420a16f:	89 c2                	mov    %eax,%edx
  800420a171:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a178:	00 00 00 
  800420a17b:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  800420a182:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a189:	00 00 00 
  800420a18c:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  800420a193:	08 00 
  800420a195:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a19c:	00 00 00 
  800420a19f:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420a1a6:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a1a9:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420a1af:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a1b6:	00 00 00 
  800420a1b9:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  800420a1c0:	83 e2 07             	and    $0x7,%edx
  800420a1c3:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  800420a1c9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a1d0:	00 00 00 
  800420a1d3:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a1da:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a1dd:	83 ca 0e             	or     $0xe,%edx
  800420a1e0:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a1e6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a1ed:	00 00 00 
  800420a1f0:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a1f7:	83 e2 ef             	and    $0xffffffef,%edx
  800420a1fa:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a200:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a207:	00 00 00 
  800420a20a:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a211:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a214:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a21a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a221:	00 00 00 
  800420a224:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  800420a22b:	83 ca 80             	or     $0xffffff80,%edx
  800420a22e:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  800420a234:	48 b8 3a d5 20 04 80 	movabs $0x800420d53a,%rax
  800420a23b:	00 00 00 
  800420a23e:	48 c1 e8 10          	shr    $0x10,%rax
  800420a242:	89 c2                	mov    %eax,%edx
  800420a244:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a24b:	00 00 00 
  800420a24e:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  800420a255:	48 b8 3a d5 20 04 80 	movabs $0x800420d53a,%rax
  800420a25c:	00 00 00 
  800420a25f:	48 c1 e8 20          	shr    $0x20,%rax
  800420a263:	89 c2                	mov    %eax,%edx
  800420a265:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a26c:	00 00 00 
  800420a26f:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  800420a275:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a27c:	00 00 00 
  800420a27f:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  800420a286:	00 00 00 
    SETGATE(idt[T_STACK], 0, GD_KT, XTRPX_Stack, 0);  
  800420a289:	48 b8 42 d5 20 04 80 	movabs $0x800420d542,%rax
  800420a290:	00 00 00 
  800420a293:	89 c2                	mov    %eax,%edx
  800420a295:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a29c:	00 00 00 
  800420a29f:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  800420a2a6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a2ad:	00 00 00 
  800420a2b0:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  800420a2b7:	08 00 
  800420a2b9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a2c0:	00 00 00 
  800420a2c3:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420a2ca:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a2cd:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420a2d3:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a2da:	00 00 00 
  800420a2dd:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  800420a2e4:	83 e2 07             	and    $0x7,%edx
  800420a2e7:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  800420a2ed:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a2f4:	00 00 00 
  800420a2f7:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a2fe:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a301:	83 ca 0e             	or     $0xe,%edx
  800420a304:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a30a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a311:	00 00 00 
  800420a314:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a31b:	83 e2 ef             	and    $0xffffffef,%edx
  800420a31e:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a324:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a32b:	00 00 00 
  800420a32e:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a335:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a338:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a33e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a345:	00 00 00 
  800420a348:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  800420a34f:	83 ca 80             	or     $0xffffff80,%edx
  800420a352:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  800420a358:	48 b8 42 d5 20 04 80 	movabs $0x800420d542,%rax
  800420a35f:	00 00 00 
  800420a362:	48 c1 e8 10          	shr    $0x10,%rax
  800420a366:	89 c2                	mov    %eax,%edx
  800420a368:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a36f:	00 00 00 
  800420a372:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  800420a379:	48 b8 42 d5 20 04 80 	movabs $0x800420d542,%rax
  800420a380:	00 00 00 
  800420a383:	48 c1 e8 20          	shr    $0x20,%rax
  800420a387:	89 c2                	mov    %eax,%edx
  800420a389:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a390:	00 00 00 
  800420a393:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  800420a399:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a3a0:	00 00 00 
  800420a3a3:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  800420a3aa:	00 00 00 
    SETGATE(idt[T_GPFLT], 0, GD_KT, XTRPX_Gpflt, 0);  
  800420a3ad:	48 b8 4a d5 20 04 80 	movabs $0x800420d54a,%rax
  800420a3b4:	00 00 00 
  800420a3b7:	89 c2                	mov    %eax,%edx
  800420a3b9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a3c0:	00 00 00 
  800420a3c3:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  800420a3ca:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a3d1:	00 00 00 
  800420a3d4:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  800420a3db:	08 00 
  800420a3dd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a3e4:	00 00 00 
  800420a3e7:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420a3ee:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a3f1:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420a3f7:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a3fe:	00 00 00 
  800420a401:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  800420a408:	83 e2 07             	and    $0x7,%edx
  800420a40b:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  800420a411:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a418:	00 00 00 
  800420a41b:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a422:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a425:	83 ca 0e             	or     $0xe,%edx
  800420a428:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a42e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a435:	00 00 00 
  800420a438:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a43f:	83 e2 ef             	and    $0xffffffef,%edx
  800420a442:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a448:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a44f:	00 00 00 
  800420a452:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a459:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a45c:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a462:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a469:	00 00 00 
  800420a46c:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  800420a473:	83 ca 80             	or     $0xffffff80,%edx
  800420a476:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  800420a47c:	48 b8 4a d5 20 04 80 	movabs $0x800420d54a,%rax
  800420a483:	00 00 00 
  800420a486:	48 c1 e8 10          	shr    $0x10,%rax
  800420a48a:	89 c2                	mov    %eax,%edx
  800420a48c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a493:	00 00 00 
  800420a496:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  800420a49d:	48 b8 4a d5 20 04 80 	movabs $0x800420d54a,%rax
  800420a4a4:	00 00 00 
  800420a4a7:	48 c1 e8 20          	shr    $0x20,%rax
  800420a4ab:	89 c2                	mov    %eax,%edx
  800420a4ad:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a4b4:	00 00 00 
  800420a4b7:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  800420a4bd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a4c4:	00 00 00 
  800420a4c7:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  800420a4ce:	00 00 00 
    SETGATE(idt[T_PGFLT], 0, GD_KT, XTRPX_Pgflt, 0);  
  800420a4d1:	48 b8 52 d5 20 04 80 	movabs $0x800420d552,%rax
  800420a4d8:	00 00 00 
  800420a4db:	89 c2                	mov    %eax,%edx
  800420a4dd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a4e4:	00 00 00 
  800420a4e7:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  800420a4ee:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a4f5:	00 00 00 
  800420a4f8:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  800420a4ff:	08 00 
  800420a501:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a508:	00 00 00 
  800420a50b:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420a512:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a515:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420a51b:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a522:	00 00 00 
  800420a525:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  800420a52c:	83 e2 07             	and    $0x7,%edx
  800420a52f:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  800420a535:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a53c:	00 00 00 
  800420a53f:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a546:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a549:	83 ca 0e             	or     $0xe,%edx
  800420a54c:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a552:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a559:	00 00 00 
  800420a55c:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a563:	83 e2 ef             	and    $0xffffffef,%edx
  800420a566:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a56c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a573:	00 00 00 
  800420a576:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a57d:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a580:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a586:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a58d:	00 00 00 
  800420a590:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  800420a597:	83 ca 80             	or     $0xffffff80,%edx
  800420a59a:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  800420a5a0:	48 b8 52 d5 20 04 80 	movabs $0x800420d552,%rax
  800420a5a7:	00 00 00 
  800420a5aa:	48 c1 e8 10          	shr    $0x10,%rax
  800420a5ae:	89 c2                	mov    %eax,%edx
  800420a5b0:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a5b7:	00 00 00 
  800420a5ba:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  800420a5c1:	48 b8 52 d5 20 04 80 	movabs $0x800420d552,%rax
  800420a5c8:	00 00 00 
  800420a5cb:	48 c1 e8 20          	shr    $0x20,%rax
  800420a5cf:	89 c2                	mov    %eax,%edx
  800420a5d1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a5d8:	00 00 00 
  800420a5db:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  800420a5e1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a5e8:	00 00 00 
  800420a5eb:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  800420a5f2:	00 00 00 
    SETGATE(idt[T_FPERR], 0, GD_KT, XTRPX_FpErr, 0);  
  800420a5f5:	48 b8 5a d5 20 04 80 	movabs $0x800420d55a,%rax
  800420a5fc:	00 00 00 
  800420a5ff:	89 c2                	mov    %eax,%edx
  800420a601:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a608:	00 00 00 
  800420a60b:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  800420a612:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a619:	00 00 00 
  800420a61c:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  800420a623:	08 00 
  800420a625:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a62c:	00 00 00 
  800420a62f:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420a636:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a639:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420a63f:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a646:	00 00 00 
  800420a649:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  800420a650:	83 e2 07             	and    $0x7,%edx
  800420a653:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  800420a659:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a660:	00 00 00 
  800420a663:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a66a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a66d:	83 ca 0e             	or     $0xe,%edx
  800420a670:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a676:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a67d:	00 00 00 
  800420a680:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a687:	83 e2 ef             	and    $0xffffffef,%edx
  800420a68a:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a690:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a697:	00 00 00 
  800420a69a:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a6a1:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a6a4:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a6aa:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a6b1:	00 00 00 
  800420a6b4:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a6bb:	83 ca 80             	or     $0xffffff80,%edx
  800420a6be:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a6c4:	48 b8 5a d5 20 04 80 	movabs $0x800420d55a,%rax
  800420a6cb:	00 00 00 
  800420a6ce:	48 c1 e8 10          	shr    $0x10,%rax
  800420a6d2:	89 c2                	mov    %eax,%edx
  800420a6d4:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a6db:	00 00 00 
  800420a6de:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  800420a6e5:	48 b8 5a d5 20 04 80 	movabs $0x800420d55a,%rax
  800420a6ec:	00 00 00 
  800420a6ef:	48 c1 e8 20          	shr    $0x20,%rax
  800420a6f3:	89 c2                	mov    %eax,%edx
  800420a6f5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a6fc:	00 00 00 
  800420a6ff:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  800420a705:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a70c:	00 00 00 
  800420a70f:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  800420a716:	00 00 00 
    SETGATE(idt[T_ALIGN], 0, GD_KT, XTRPX_Align, 0);  
  800420a719:	48 b8 64 d5 20 04 80 	movabs $0x800420d564,%rax
  800420a720:	00 00 00 
  800420a723:	89 c2                	mov    %eax,%edx
  800420a725:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a72c:	00 00 00 
  800420a72f:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  800420a736:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a73d:	00 00 00 
  800420a740:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  800420a747:	08 00 
  800420a749:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a750:	00 00 00 
  800420a753:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a75a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a75d:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a763:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a76a:	00 00 00 
  800420a76d:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a774:	83 e2 07             	and    $0x7,%edx
  800420a777:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a77d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a784:	00 00 00 
  800420a787:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a78e:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a791:	83 ca 0e             	or     $0xe,%edx
  800420a794:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a79a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a7a1:	00 00 00 
  800420a7a4:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a7ab:	83 e2 ef             	and    $0xffffffef,%edx
  800420a7ae:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a7b4:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a7bb:	00 00 00 
  800420a7be:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a7c5:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a7c8:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a7ce:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a7d5:	00 00 00 
  800420a7d8:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a7df:	83 ca 80             	or     $0xffffff80,%edx
  800420a7e2:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a7e8:	48 b8 64 d5 20 04 80 	movabs $0x800420d564,%rax
  800420a7ef:	00 00 00 
  800420a7f2:	48 c1 e8 10          	shr    $0x10,%rax
  800420a7f6:	89 c2                	mov    %eax,%edx
  800420a7f8:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a7ff:	00 00 00 
  800420a802:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  800420a809:	48 b8 64 d5 20 04 80 	movabs $0x800420d564,%rax
  800420a810:	00 00 00 
  800420a813:	48 c1 e8 20          	shr    $0x20,%rax
  800420a817:	89 c2                	mov    %eax,%edx
  800420a819:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a820:	00 00 00 
  800420a823:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  800420a829:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a830:	00 00 00 
  800420a833:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  800420a83a:	00 00 00 
    SETGATE(idt[T_MCHK], 0, GD_KT, XTRPX_Mchk, 0);  
  800420a83d:	48 b8 68 d5 20 04 80 	movabs $0x800420d568,%rax
  800420a844:	00 00 00 
  800420a847:	89 c2                	mov    %eax,%edx
  800420a849:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a850:	00 00 00 
  800420a853:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420a85a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a861:	00 00 00 
  800420a864:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420a86b:	08 00 
  800420a86d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a874:	00 00 00 
  800420a877:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a87e:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a881:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a887:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a88e:	00 00 00 
  800420a891:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a898:	83 e2 07             	and    $0x7,%edx
  800420a89b:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a8a1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a8a8:	00 00 00 
  800420a8ab:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a8b2:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a8b5:	83 ca 0e             	or     $0xe,%edx
  800420a8b8:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a8be:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a8c5:	00 00 00 
  800420a8c8:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a8cf:	83 e2 ef             	and    $0xffffffef,%edx
  800420a8d2:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a8d8:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a8df:	00 00 00 
  800420a8e2:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a8e9:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a8ec:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a8f2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a8f9:	00 00 00 
  800420a8fc:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a903:	83 ca 80             	or     $0xffffff80,%edx
  800420a906:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a90c:	48 b8 68 d5 20 04 80 	movabs $0x800420d568,%rax
  800420a913:	00 00 00 
  800420a916:	48 c1 e8 10          	shr    $0x10,%rax
  800420a91a:	89 c2                	mov    %eax,%edx
  800420a91c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a923:	00 00 00 
  800420a926:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420a92d:	48 b8 68 d5 20 04 80 	movabs $0x800420d568,%rax
  800420a934:	00 00 00 
  800420a937:	48 c1 e8 20          	shr    $0x20,%rax
  800420a93b:	89 c2                	mov    %eax,%edx
  800420a93d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a944:	00 00 00 
  800420a947:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420a94d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a954:	00 00 00 
  800420a957:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420a95e:	00 00 00 
    SETGATE(idt[T_SIMDERR], 0, GD_KT, XTRPX_SimdErr, 0);  
  800420a961:	48 b8 6e d5 20 04 80 	movabs $0x800420d56e,%rax
  800420a968:	00 00 00 
  800420a96b:	89 c2                	mov    %eax,%edx
  800420a96d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a974:	00 00 00 
  800420a977:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  800420a97e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a985:	00 00 00 
  800420a988:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  800420a98f:	08 00 
  800420a991:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a998:	00 00 00 
  800420a99b:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a9a2:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a9a5:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a9ab:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a9b2:	00 00 00 
  800420a9b5:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a9bc:	83 e2 07             	and    $0x7,%edx
  800420a9bf:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a9c5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a9cc:	00 00 00 
  800420a9cf:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a9d6:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a9d9:	83 ca 0e             	or     $0xe,%edx
  800420a9dc:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a9e2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420a9e9:	00 00 00 
  800420a9ec:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a9f3:	83 e2 ef             	and    $0xffffffef,%edx
  800420a9f6:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a9fc:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aa03:	00 00 00 
  800420aa06:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420aa0d:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aa10:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420aa16:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aa1d:	00 00 00 
  800420aa20:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420aa27:	83 ca 80             	or     $0xffffff80,%edx
  800420aa2a:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420aa30:	48 b8 6e d5 20 04 80 	movabs $0x800420d56e,%rax
  800420aa37:	00 00 00 
  800420aa3a:	48 c1 e8 10          	shr    $0x10,%rax
  800420aa3e:	89 c2                	mov    %eax,%edx
  800420aa40:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aa47:	00 00 00 
  800420aa4a:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  800420aa51:	48 b8 6e d5 20 04 80 	movabs $0x800420d56e,%rax
  800420aa58:	00 00 00 
  800420aa5b:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa5f:	89 c2                	mov    %eax,%edx
  800420aa61:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aa68:	00 00 00 
  800420aa6b:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  800420aa71:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aa78:	00 00 00 
  800420aa7b:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  800420aa82:	00 00 00 
    SETGATE(idt[T_SYSCALL], 0, GD_KT, XTRPX_Syscall, 3);
  800420aa85:	48 b8 74 d5 20 04 80 	movabs $0x800420d574,%rax
  800420aa8c:	00 00 00 
  800420aa8f:	89 c2                	mov    %eax,%edx
  800420aa91:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aa98:	00 00 00 
  800420aa9b:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420aaa2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aaa9:	00 00 00 
  800420aaac:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420aab3:	08 00 
  800420aab5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aabc:	00 00 00 
  800420aabf:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420aac6:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aac9:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420aacf:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aad6:	00 00 00 
  800420aad9:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420aae0:	83 e2 07             	and    $0x7,%edx
  800420aae3:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420aae9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aaf0:	00 00 00 
  800420aaf3:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420aafa:	83 e2 f0             	and    $0xfffffff0,%edx
  800420aafd:	83 ca 0e             	or     $0xe,%edx
  800420ab00:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420ab06:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ab0d:	00 00 00 
  800420ab10:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420ab17:	83 e2 ef             	and    $0xffffffef,%edx
  800420ab1a:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420ab20:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ab27:	00 00 00 
  800420ab2a:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420ab31:	83 ca 60             	or     $0x60,%edx
  800420ab34:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420ab3a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ab41:	00 00 00 
  800420ab44:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420ab4b:	83 ca 80             	or     $0xffffff80,%edx
  800420ab4e:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420ab54:	48 b8 74 d5 20 04 80 	movabs $0x800420d574,%rax
  800420ab5b:	00 00 00 
  800420ab5e:	48 c1 e8 10          	shr    $0x10,%rax
  800420ab62:	89 c2                	mov    %eax,%edx
  800420ab64:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ab6b:	00 00 00 
  800420ab6e:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420ab75:	48 b8 74 d5 20 04 80 	movabs $0x800420d574,%rax
  800420ab7c:	00 00 00 
  800420ab7f:	48 c1 e8 20          	shr    $0x20,%rax
  800420ab83:	89 c2                	mov    %eax,%edx
  800420ab85:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ab8c:	00 00 00 
  800420ab8f:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420ab95:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ab9c:	00 00 00 
  800420ab9f:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420aba6:	00 00 00 
    SETGATE(idt[T_DEFAULT], 0, GD_KT, XTRPX_Default, 0);
  800420aba9:	48 b8 7a d5 20 04 80 	movabs $0x800420d57a,%rax
  800420abb0:	00 00 00 
  800420abb3:	89 c2                	mov    %eax,%edx
  800420abb5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420abbc:	00 00 00 
  800420abbf:	66 89 90 40 1f 00 00 	mov    %dx,0x1f40(%rax)
  800420abc6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420abcd:	00 00 00 
  800420abd0:	66 c7 80 42 1f 00 00 	movw   $0x8,0x1f42(%rax)
  800420abd7:	08 00 
  800420abd9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420abe0:	00 00 00 
  800420abe3:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420abea:	83 e2 f8             	and    $0xfffffff8,%edx
  800420abed:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420abf3:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420abfa:	00 00 00 
  800420abfd:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420ac04:	83 e2 07             	and    $0x7,%edx
  800420ac07:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420ac0d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ac14:	00 00 00 
  800420ac17:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420ac1e:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ac21:	83 ca 0e             	or     $0xe,%edx
  800420ac24:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420ac2a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ac31:	00 00 00 
  800420ac34:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420ac3b:	83 e2 ef             	and    $0xffffffef,%edx
  800420ac3e:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420ac44:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ac4b:	00 00 00 
  800420ac4e:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420ac55:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ac58:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420ac5e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ac65:	00 00 00 
  800420ac68:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420ac6f:	83 ca 80             	or     $0xffffff80,%edx
  800420ac72:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420ac78:	48 b8 7a d5 20 04 80 	movabs $0x800420d57a,%rax
  800420ac7f:	00 00 00 
  800420ac82:	48 c1 e8 10          	shr    $0x10,%rax
  800420ac86:	89 c2                	mov    %eax,%edx
  800420ac88:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ac8f:	00 00 00 
  800420ac92:	66 89 90 46 1f 00 00 	mov    %dx,0x1f46(%rax)
  800420ac99:	48 b8 7a d5 20 04 80 	movabs $0x800420d57a,%rax
  800420aca0:	00 00 00 
  800420aca3:	48 c1 e8 20          	shr    $0x20,%rax
  800420aca7:	89 c2                	mov    %eax,%edx
  800420aca9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420acb0:	00 00 00 
  800420acb3:	89 90 48 1f 00 00    	mov    %edx,0x1f48(%rax)
  800420acb9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420acc0:	00 00 00 
  800420acc3:	c7 80 4c 1f 00 00 00 	movl   $0x0,0x1f4c(%rax)
  800420acca:	00 00 00 
	
    SETGATE(idt[IRQ_OFFSET+IRQ_TIMER], 0, GD_KT, XTRPX_IRQ0, 0);
  800420accd:	48 b8 84 d5 20 04 80 	movabs $0x800420d584,%rax
  800420acd4:	00 00 00 
  800420acd7:	89 c2                	mov    %eax,%edx
  800420acd9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ace0:	00 00 00 
  800420ace3:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420acea:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420acf1:	00 00 00 
  800420acf4:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420acfb:	08 00 
  800420acfd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ad04:	00 00 00 
  800420ad07:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420ad0e:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ad11:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420ad17:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ad1e:	00 00 00 
  800420ad21:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420ad28:	83 e2 07             	and    $0x7,%edx
  800420ad2b:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420ad31:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ad38:	00 00 00 
  800420ad3b:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ad42:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ad45:	83 ca 0e             	or     $0xe,%edx
  800420ad48:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ad4e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ad55:	00 00 00 
  800420ad58:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ad5f:	83 e2 ef             	and    $0xffffffef,%edx
  800420ad62:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ad68:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ad6f:	00 00 00 
  800420ad72:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ad79:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ad7c:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ad82:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ad89:	00 00 00 
  800420ad8c:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420ad93:	83 ca 80             	or     $0xffffff80,%edx
  800420ad96:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420ad9c:	48 b8 84 d5 20 04 80 	movabs $0x800420d584,%rax
  800420ada3:	00 00 00 
  800420ada6:	48 c1 e8 10          	shr    $0x10,%rax
  800420adaa:	89 c2                	mov    %eax,%edx
  800420adac:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420adb3:	00 00 00 
  800420adb6:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420adbd:	48 b8 84 d5 20 04 80 	movabs $0x800420d584,%rax
  800420adc4:	00 00 00 
  800420adc7:	48 c1 e8 20          	shr    $0x20,%rax
  800420adcb:	89 c2                	mov    %eax,%edx
  800420adcd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420add4:	00 00 00 
  800420add7:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420addd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ade4:	00 00 00 
  800420ade7:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420adee:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_KBD], 0, GD_KT, XTRPX_IRQ1, 0);
  800420adf1:	48 b8 8a d5 20 04 80 	movabs $0x800420d58a,%rax
  800420adf8:	00 00 00 
  800420adfb:	89 c2                	mov    %eax,%edx
  800420adfd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ae04:	00 00 00 
  800420ae07:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420ae0e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ae15:	00 00 00 
  800420ae18:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420ae1f:	08 00 
  800420ae21:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ae28:	00 00 00 
  800420ae2b:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420ae32:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ae35:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420ae3b:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ae42:	00 00 00 
  800420ae45:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420ae4c:	83 e2 07             	and    $0x7,%edx
  800420ae4f:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420ae55:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ae5c:	00 00 00 
  800420ae5f:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ae66:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ae69:	83 ca 0e             	or     $0xe,%edx
  800420ae6c:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ae72:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ae79:	00 00 00 
  800420ae7c:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ae83:	83 e2 ef             	and    $0xffffffef,%edx
  800420ae86:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420ae8c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ae93:	00 00 00 
  800420ae96:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420ae9d:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aea0:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420aea6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aead:	00 00 00 
  800420aeb0:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420aeb7:	83 ca 80             	or     $0xffffff80,%edx
  800420aeba:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420aec0:	48 b8 8a d5 20 04 80 	movabs $0x800420d58a,%rax
  800420aec7:	00 00 00 
  800420aeca:	48 c1 e8 10          	shr    $0x10,%rax
  800420aece:	89 c2                	mov    %eax,%edx
  800420aed0:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aed7:	00 00 00 
  800420aeda:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420aee1:	48 b8 8a d5 20 04 80 	movabs $0x800420d58a,%rax
  800420aee8:	00 00 00 
  800420aeeb:	48 c1 e8 20          	shr    $0x20,%rax
  800420aeef:	89 c2                	mov    %eax,%edx
  800420aef1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420aef8:	00 00 00 
  800420aefb:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420af01:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420af08:	00 00 00 
  800420af0b:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420af12:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+2], 0, GD_KT, XTRPX_IRQ2, 0);
  800420af15:	48 b8 90 d5 20 04 80 	movabs $0x800420d590,%rax
  800420af1c:	00 00 00 
  800420af1f:	89 c2                	mov    %eax,%edx
  800420af21:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420af28:	00 00 00 
  800420af2b:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420af32:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420af39:	00 00 00 
  800420af3c:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420af43:	08 00 
  800420af45:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420af4c:	00 00 00 
  800420af4f:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420af56:	83 e2 f8             	and    $0xfffffff8,%edx
  800420af59:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420af5f:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420af66:	00 00 00 
  800420af69:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420af70:	83 e2 07             	and    $0x7,%edx
  800420af73:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420af79:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420af80:	00 00 00 
  800420af83:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420af8a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420af8d:	83 ca 0e             	or     $0xe,%edx
  800420af90:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420af96:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420af9d:	00 00 00 
  800420afa0:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420afa7:	83 e2 ef             	and    $0xffffffef,%edx
  800420afaa:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420afb0:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420afb7:	00 00 00 
  800420afba:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420afc1:	83 e2 9f             	and    $0xffffff9f,%edx
  800420afc4:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420afca:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420afd1:	00 00 00 
  800420afd4:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420afdb:	83 ca 80             	or     $0xffffff80,%edx
  800420afde:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420afe4:	48 b8 90 d5 20 04 80 	movabs $0x800420d590,%rax
  800420afeb:	00 00 00 
  800420afee:	48 c1 e8 10          	shr    $0x10,%rax
  800420aff2:	89 c2                	mov    %eax,%edx
  800420aff4:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420affb:	00 00 00 
  800420affe:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420b005:	48 b8 90 d5 20 04 80 	movabs $0x800420d590,%rax
  800420b00c:	00 00 00 
  800420b00f:	48 c1 e8 20          	shr    $0x20,%rax
  800420b013:	89 c2                	mov    %eax,%edx
  800420b015:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b01c:	00 00 00 
  800420b01f:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420b025:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b02c:	00 00 00 
  800420b02f:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420b036:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+3], 0, GD_KT, XTRPX_IRQ3, 0);
  800420b039:	48 b8 96 d5 20 04 80 	movabs $0x800420d596,%rax
  800420b040:	00 00 00 
  800420b043:	89 c2                	mov    %eax,%edx
  800420b045:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b04c:	00 00 00 
  800420b04f:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420b056:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b05d:	00 00 00 
  800420b060:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420b067:	08 00 
  800420b069:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b070:	00 00 00 
  800420b073:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420b07a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b07d:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420b083:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b08a:	00 00 00 
  800420b08d:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420b094:	83 e2 07             	and    $0x7,%edx
  800420b097:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420b09d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b0a4:	00 00 00 
  800420b0a7:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b0ae:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b0b1:	83 ca 0e             	or     $0xe,%edx
  800420b0b4:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b0ba:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b0c1:	00 00 00 
  800420b0c4:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b0cb:	83 e2 ef             	and    $0xffffffef,%edx
  800420b0ce:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b0d4:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b0db:	00 00 00 
  800420b0de:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b0e5:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b0e8:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b0ee:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b0f5:	00 00 00 
  800420b0f8:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420b0ff:	83 ca 80             	or     $0xffffff80,%edx
  800420b102:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420b108:	48 b8 96 d5 20 04 80 	movabs $0x800420d596,%rax
  800420b10f:	00 00 00 
  800420b112:	48 c1 e8 10          	shr    $0x10,%rax
  800420b116:	89 c2                	mov    %eax,%edx
  800420b118:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b11f:	00 00 00 
  800420b122:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420b129:	48 b8 96 d5 20 04 80 	movabs $0x800420d596,%rax
  800420b130:	00 00 00 
  800420b133:	48 c1 e8 20          	shr    $0x20,%rax
  800420b137:	89 c2                	mov    %eax,%edx
  800420b139:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b140:	00 00 00 
  800420b143:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420b149:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b150:	00 00 00 
  800420b153:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420b15a:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SERIAL], 0, GD_KT, XTRPX_IRQ4, 0);
  800420b15d:	48 b8 9c d5 20 04 80 	movabs $0x800420d59c,%rax
  800420b164:	00 00 00 
  800420b167:	89 c2                	mov    %eax,%edx
  800420b169:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b170:	00 00 00 
  800420b173:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420b17a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b181:	00 00 00 
  800420b184:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420b18b:	08 00 
  800420b18d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b194:	00 00 00 
  800420b197:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420b19e:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b1a1:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420b1a7:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b1ae:	00 00 00 
  800420b1b1:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420b1b8:	83 e2 07             	and    $0x7,%edx
  800420b1bb:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420b1c1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b1c8:	00 00 00 
  800420b1cb:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b1d2:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b1d5:	83 ca 0e             	or     $0xe,%edx
  800420b1d8:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b1de:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b1e5:	00 00 00 
  800420b1e8:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b1ef:	83 e2 ef             	and    $0xffffffef,%edx
  800420b1f2:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b1f8:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b1ff:	00 00 00 
  800420b202:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b209:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b20c:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b212:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b219:	00 00 00 
  800420b21c:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420b223:	83 ca 80             	or     $0xffffff80,%edx
  800420b226:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420b22c:	48 b8 9c d5 20 04 80 	movabs $0x800420d59c,%rax
  800420b233:	00 00 00 
  800420b236:	48 c1 e8 10          	shr    $0x10,%rax
  800420b23a:	89 c2                	mov    %eax,%edx
  800420b23c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b243:	00 00 00 
  800420b246:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420b24d:	48 b8 9c d5 20 04 80 	movabs $0x800420d59c,%rax
  800420b254:	00 00 00 
  800420b257:	48 c1 e8 20          	shr    $0x20,%rax
  800420b25b:	89 c2                	mov    %eax,%edx
  800420b25d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b264:	00 00 00 
  800420b267:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420b26d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b274:	00 00 00 
  800420b277:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420b27e:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+5], 0, GD_KT, XTRPX_IRQ5, 0);
  800420b281:	48 b8 a2 d5 20 04 80 	movabs $0x800420d5a2,%rax
  800420b288:	00 00 00 
  800420b28b:	89 c2                	mov    %eax,%edx
  800420b28d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b294:	00 00 00 
  800420b297:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420b29e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b2a5:	00 00 00 
  800420b2a8:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420b2af:	08 00 
  800420b2b1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b2b8:	00 00 00 
  800420b2bb:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b2c2:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b2c5:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b2cb:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b2d2:	00 00 00 
  800420b2d5:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420b2dc:	83 e2 07             	and    $0x7,%edx
  800420b2df:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420b2e5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b2ec:	00 00 00 
  800420b2ef:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b2f6:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b2f9:	83 ca 0e             	or     $0xe,%edx
  800420b2fc:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b302:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b309:	00 00 00 
  800420b30c:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b313:	83 e2 ef             	and    $0xffffffef,%edx
  800420b316:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b31c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b323:	00 00 00 
  800420b326:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b32d:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b330:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b336:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b33d:	00 00 00 
  800420b340:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420b347:	83 ca 80             	or     $0xffffff80,%edx
  800420b34a:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420b350:	48 b8 a2 d5 20 04 80 	movabs $0x800420d5a2,%rax
  800420b357:	00 00 00 
  800420b35a:	48 c1 e8 10          	shr    $0x10,%rax
  800420b35e:	89 c2                	mov    %eax,%edx
  800420b360:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b367:	00 00 00 
  800420b36a:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420b371:	48 b8 a2 d5 20 04 80 	movabs $0x800420d5a2,%rax
  800420b378:	00 00 00 
  800420b37b:	48 c1 e8 20          	shr    $0x20,%rax
  800420b37f:	89 c2                	mov    %eax,%edx
  800420b381:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b388:	00 00 00 
  800420b38b:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420b391:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b398:	00 00 00 
  800420b39b:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420b3a2:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+6], 0, GD_KT, XTRPX_IRQ6, 0);
  800420b3a5:	48 b8 a8 d5 20 04 80 	movabs $0x800420d5a8,%rax
  800420b3ac:	00 00 00 
  800420b3af:	89 c2                	mov    %eax,%edx
  800420b3b1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b3b8:	00 00 00 
  800420b3bb:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420b3c2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b3c9:	00 00 00 
  800420b3cc:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420b3d3:	08 00 
  800420b3d5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b3dc:	00 00 00 
  800420b3df:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b3e6:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b3e9:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b3ef:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b3f6:	00 00 00 
  800420b3f9:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420b400:	83 e2 07             	and    $0x7,%edx
  800420b403:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420b409:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b410:	00 00 00 
  800420b413:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b41a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b41d:	83 ca 0e             	or     $0xe,%edx
  800420b420:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b426:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b42d:	00 00 00 
  800420b430:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b437:	83 e2 ef             	and    $0xffffffef,%edx
  800420b43a:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b440:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b447:	00 00 00 
  800420b44a:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b451:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b454:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b45a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b461:	00 00 00 
  800420b464:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420b46b:	83 ca 80             	or     $0xffffff80,%edx
  800420b46e:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420b474:	48 b8 a8 d5 20 04 80 	movabs $0x800420d5a8,%rax
  800420b47b:	00 00 00 
  800420b47e:	48 c1 e8 10          	shr    $0x10,%rax
  800420b482:	89 c2                	mov    %eax,%edx
  800420b484:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b48b:	00 00 00 
  800420b48e:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420b495:	48 b8 a8 d5 20 04 80 	movabs $0x800420d5a8,%rax
  800420b49c:	00 00 00 
  800420b49f:	48 c1 e8 20          	shr    $0x20,%rax
  800420b4a3:	89 c2                	mov    %eax,%edx
  800420b4a5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b4ac:	00 00 00 
  800420b4af:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420b4b5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b4bc:	00 00 00 
  800420b4bf:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420b4c6:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SPURIOUS], 0, GD_KT, XTRPX_IRQ7, 0);
  800420b4c9:	48 b8 ae d5 20 04 80 	movabs $0x800420d5ae,%rax
  800420b4d0:	00 00 00 
  800420b4d3:	89 c2                	mov    %eax,%edx
  800420b4d5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b4dc:	00 00 00 
  800420b4df:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420b4e6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b4ed:	00 00 00 
  800420b4f0:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420b4f7:	08 00 
  800420b4f9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b500:	00 00 00 
  800420b503:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420b50a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b50d:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420b513:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b51a:	00 00 00 
  800420b51d:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420b524:	83 e2 07             	and    $0x7,%edx
  800420b527:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420b52d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b534:	00 00 00 
  800420b537:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b53e:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b541:	83 ca 0e             	or     $0xe,%edx
  800420b544:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b54a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b551:	00 00 00 
  800420b554:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b55b:	83 e2 ef             	and    $0xffffffef,%edx
  800420b55e:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b564:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b56b:	00 00 00 
  800420b56e:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b575:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b578:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b57e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b585:	00 00 00 
  800420b588:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420b58f:	83 ca 80             	or     $0xffffff80,%edx
  800420b592:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420b598:	48 b8 ae d5 20 04 80 	movabs $0x800420d5ae,%rax
  800420b59f:	00 00 00 
  800420b5a2:	48 c1 e8 10          	shr    $0x10,%rax
  800420b5a6:	89 c2                	mov    %eax,%edx
  800420b5a8:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b5af:	00 00 00 
  800420b5b2:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420b5b9:	48 b8 ae d5 20 04 80 	movabs $0x800420d5ae,%rax
  800420b5c0:	00 00 00 
  800420b5c3:	48 c1 e8 20          	shr    $0x20,%rax
  800420b5c7:	89 c2                	mov    %eax,%edx
  800420b5c9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b5d0:	00 00 00 
  800420b5d3:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420b5d9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b5e0:	00 00 00 
  800420b5e3:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420b5ea:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+8], 0, GD_KT, XTRPX_IRQ8, 0);
  800420b5ed:	48 b8 b4 d5 20 04 80 	movabs $0x800420d5b4,%rax
  800420b5f4:	00 00 00 
  800420b5f7:	89 c2                	mov    %eax,%edx
  800420b5f9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b600:	00 00 00 
  800420b603:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420b60a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b611:	00 00 00 
  800420b614:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420b61b:	08 00 
  800420b61d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b624:	00 00 00 
  800420b627:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420b62e:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b631:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420b637:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b63e:	00 00 00 
  800420b641:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420b648:	83 e2 07             	and    $0x7,%edx
  800420b64b:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420b651:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b658:	00 00 00 
  800420b65b:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b662:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b665:	83 ca 0e             	or     $0xe,%edx
  800420b668:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b66e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b675:	00 00 00 
  800420b678:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b67f:	83 e2 ef             	and    $0xffffffef,%edx
  800420b682:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b688:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b68f:	00 00 00 
  800420b692:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b699:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b69c:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b6a2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b6a9:	00 00 00 
  800420b6ac:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420b6b3:	83 ca 80             	or     $0xffffff80,%edx
  800420b6b6:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b6bc:	48 b8 b4 d5 20 04 80 	movabs $0x800420d5b4,%rax
  800420b6c3:	00 00 00 
  800420b6c6:	48 c1 e8 10          	shr    $0x10,%rax
  800420b6ca:	89 c2                	mov    %eax,%edx
  800420b6cc:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b6d3:	00 00 00 
  800420b6d6:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420b6dd:	48 b8 b4 d5 20 04 80 	movabs $0x800420d5b4,%rax
  800420b6e4:	00 00 00 
  800420b6e7:	48 c1 e8 20          	shr    $0x20,%rax
  800420b6eb:	89 c2                	mov    %eax,%edx
  800420b6ed:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b6f4:	00 00 00 
  800420b6f7:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420b6fd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b704:	00 00 00 
  800420b707:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420b70e:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+9], 0, GD_KT, XTRPX_IRQ9, 0);
  800420b711:	48 b8 ba d5 20 04 80 	movabs $0x800420d5ba,%rax
  800420b718:	00 00 00 
  800420b71b:	89 c2                	mov    %eax,%edx
  800420b71d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b724:	00 00 00 
  800420b727:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420b72e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b735:	00 00 00 
  800420b738:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420b73f:	08 00 
  800420b741:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b748:	00 00 00 
  800420b74b:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b752:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b755:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b75b:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b762:	00 00 00 
  800420b765:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b76c:	83 e2 07             	and    $0x7,%edx
  800420b76f:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b775:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b77c:	00 00 00 
  800420b77f:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b786:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b789:	83 ca 0e             	or     $0xe,%edx
  800420b78c:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b792:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b799:	00 00 00 
  800420b79c:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b7a3:	83 e2 ef             	and    $0xffffffef,%edx
  800420b7a6:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b7ac:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b7b3:	00 00 00 
  800420b7b6:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b7bd:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b7c0:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b7c6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b7cd:	00 00 00 
  800420b7d0:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b7d7:	83 ca 80             	or     $0xffffff80,%edx
  800420b7da:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b7e0:	48 b8 ba d5 20 04 80 	movabs $0x800420d5ba,%rax
  800420b7e7:	00 00 00 
  800420b7ea:	48 c1 e8 10          	shr    $0x10,%rax
  800420b7ee:	89 c2                	mov    %eax,%edx
  800420b7f0:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b7f7:	00 00 00 
  800420b7fa:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420b801:	48 b8 ba d5 20 04 80 	movabs $0x800420d5ba,%rax
  800420b808:	00 00 00 
  800420b80b:	48 c1 e8 20          	shr    $0x20,%rax
  800420b80f:	89 c2                	mov    %eax,%edx
  800420b811:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b818:	00 00 00 
  800420b81b:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420b821:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b828:	00 00 00 
  800420b82b:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420b832:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+10], 0, GD_KT, XTRPX_IRQa, 0);
  800420b835:	48 b8 c0 d5 20 04 80 	movabs $0x800420d5c0,%rax
  800420b83c:	00 00 00 
  800420b83f:	89 c2                	mov    %eax,%edx
  800420b841:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b848:	00 00 00 
  800420b84b:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420b852:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b859:	00 00 00 
  800420b85c:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420b863:	08 00 
  800420b865:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b86c:	00 00 00 
  800420b86f:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b876:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b879:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b87f:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b886:	00 00 00 
  800420b889:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b890:	83 e2 07             	and    $0x7,%edx
  800420b893:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b899:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b8a0:	00 00 00 
  800420b8a3:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b8aa:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b8ad:	83 ca 0e             	or     $0xe,%edx
  800420b8b0:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b8b6:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b8bd:	00 00 00 
  800420b8c0:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b8c7:	83 e2 ef             	and    $0xffffffef,%edx
  800420b8ca:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b8d0:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b8d7:	00 00 00 
  800420b8da:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b8e1:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b8e4:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b8ea:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b8f1:	00 00 00 
  800420b8f4:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b8fb:	83 ca 80             	or     $0xffffff80,%edx
  800420b8fe:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b904:	48 b8 c0 d5 20 04 80 	movabs $0x800420d5c0,%rax
  800420b90b:	00 00 00 
  800420b90e:	48 c1 e8 10          	shr    $0x10,%rax
  800420b912:	89 c2                	mov    %eax,%edx
  800420b914:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b91b:	00 00 00 
  800420b91e:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420b925:	48 b8 c0 d5 20 04 80 	movabs $0x800420d5c0,%rax
  800420b92c:	00 00 00 
  800420b92f:	48 c1 e8 20          	shr    $0x20,%rax
  800420b933:	89 c2                	mov    %eax,%edx
  800420b935:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b93c:	00 00 00 
  800420b93f:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420b945:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b94c:	00 00 00 
  800420b94f:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420b956:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+11], 0, GD_KT, XTRPX_IRQb, 0);
  800420b959:	48 b8 c6 d5 20 04 80 	movabs $0x800420d5c6,%rax
  800420b960:	00 00 00 
  800420b963:	89 c2                	mov    %eax,%edx
  800420b965:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b96c:	00 00 00 
  800420b96f:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420b976:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b97d:	00 00 00 
  800420b980:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420b987:	08 00 
  800420b989:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b990:	00 00 00 
  800420b993:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b99a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b99d:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b9a3:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b9aa:	00 00 00 
  800420b9ad:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b9b4:	83 e2 07             	and    $0x7,%edx
  800420b9b7:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b9bd:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b9c4:	00 00 00 
  800420b9c7:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b9ce:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b9d1:	83 ca 0e             	or     $0xe,%edx
  800420b9d4:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b9da:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b9e1:	00 00 00 
  800420b9e4:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b9eb:	83 e2 ef             	and    $0xffffffef,%edx
  800420b9ee:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b9f4:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420b9fb:	00 00 00 
  800420b9fe:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420ba05:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ba08:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420ba0e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ba15:	00 00 00 
  800420ba18:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420ba1f:	83 ca 80             	or     $0xffffff80,%edx
  800420ba22:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420ba28:	48 b8 c6 d5 20 04 80 	movabs $0x800420d5c6,%rax
  800420ba2f:	00 00 00 
  800420ba32:	48 c1 e8 10          	shr    $0x10,%rax
  800420ba36:	89 c2                	mov    %eax,%edx
  800420ba38:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ba3f:	00 00 00 
  800420ba42:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420ba49:	48 b8 c6 d5 20 04 80 	movabs $0x800420d5c6,%rax
  800420ba50:	00 00 00 
  800420ba53:	48 c1 e8 20          	shr    $0x20,%rax
  800420ba57:	89 c2                	mov    %eax,%edx
  800420ba59:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ba60:	00 00 00 
  800420ba63:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420ba69:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ba70:	00 00 00 
  800420ba73:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420ba7a:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+12], 0, GD_KT, XTRPX_IRQc, 0);
  800420ba7d:	48 b8 cc d5 20 04 80 	movabs $0x800420d5cc,%rax
  800420ba84:	00 00 00 
  800420ba87:	89 c2                	mov    %eax,%edx
  800420ba89:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420ba90:	00 00 00 
  800420ba93:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420ba9a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420baa1:	00 00 00 
  800420baa4:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420baab:	08 00 
  800420baad:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bab4:	00 00 00 
  800420bab7:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420babe:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bac1:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420bac7:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bace:	00 00 00 
  800420bad1:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420bad8:	83 e2 07             	and    $0x7,%edx
  800420badb:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420bae1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bae8:	00 00 00 
  800420baeb:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420baf2:	83 e2 f0             	and    $0xfffffff0,%edx
  800420baf5:	83 ca 0e             	or     $0xe,%edx
  800420baf8:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420bafe:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bb05:	00 00 00 
  800420bb08:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420bb0f:	83 e2 ef             	and    $0xffffffef,%edx
  800420bb12:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420bb18:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bb1f:	00 00 00 
  800420bb22:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420bb29:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bb2c:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420bb32:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bb39:	00 00 00 
  800420bb3c:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420bb43:	83 ca 80             	or     $0xffffff80,%edx
  800420bb46:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420bb4c:	48 b8 cc d5 20 04 80 	movabs $0x800420d5cc,%rax
  800420bb53:	00 00 00 
  800420bb56:	48 c1 e8 10          	shr    $0x10,%rax
  800420bb5a:	89 c2                	mov    %eax,%edx
  800420bb5c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bb63:	00 00 00 
  800420bb66:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420bb6d:	48 b8 cc d5 20 04 80 	movabs $0x800420d5cc,%rax
  800420bb74:	00 00 00 
  800420bb77:	48 c1 e8 20          	shr    $0x20,%rax
  800420bb7b:	89 c2                	mov    %eax,%edx
  800420bb7d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bb84:	00 00 00 
  800420bb87:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420bb8d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bb94:	00 00 00 
  800420bb97:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420bb9e:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+13], 0, GD_KT, XTRPX_IRQd, 0);
  800420bba1:	48 b8 d2 d5 20 04 80 	movabs $0x800420d5d2,%rax
  800420bba8:	00 00 00 
  800420bbab:	89 c2                	mov    %eax,%edx
  800420bbad:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bbb4:	00 00 00 
  800420bbb7:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420bbbe:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bbc5:	00 00 00 
  800420bbc8:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420bbcf:	08 00 
  800420bbd1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bbd8:	00 00 00 
  800420bbdb:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420bbe2:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bbe5:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420bbeb:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bbf2:	00 00 00 
  800420bbf5:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420bbfc:	83 e2 07             	and    $0x7,%edx
  800420bbff:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420bc05:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bc0c:	00 00 00 
  800420bc0f:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420bc16:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bc19:	83 ca 0e             	or     $0xe,%edx
  800420bc1c:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bc22:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bc29:	00 00 00 
  800420bc2c:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420bc33:	83 e2 ef             	and    $0xffffffef,%edx
  800420bc36:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bc3c:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bc43:	00 00 00 
  800420bc46:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420bc4d:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bc50:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bc56:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bc5d:	00 00 00 
  800420bc60:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420bc67:	83 ca 80             	or     $0xffffff80,%edx
  800420bc6a:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420bc70:	48 b8 d2 d5 20 04 80 	movabs $0x800420d5d2,%rax
  800420bc77:	00 00 00 
  800420bc7a:	48 c1 e8 10          	shr    $0x10,%rax
  800420bc7e:	89 c2                	mov    %eax,%edx
  800420bc80:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bc87:	00 00 00 
  800420bc8a:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420bc91:	48 b8 d2 d5 20 04 80 	movabs $0x800420d5d2,%rax
  800420bc98:	00 00 00 
  800420bc9b:	48 c1 e8 20          	shr    $0x20,%rax
  800420bc9f:	89 c2                	mov    %eax,%edx
  800420bca1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bca8:	00 00 00 
  800420bcab:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420bcb1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bcb8:	00 00 00 
  800420bcbb:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420bcc2:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_IDE], 0, GD_KT, XTRPX_IRQe, 0);
  800420bcc5:	48 b8 d8 d5 20 04 80 	movabs $0x800420d5d8,%rax
  800420bccc:	00 00 00 
  800420bccf:	89 c2                	mov    %eax,%edx
  800420bcd1:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bcd8:	00 00 00 
  800420bcdb:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420bce2:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bce9:	00 00 00 
  800420bcec:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420bcf3:	08 00 
  800420bcf5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bcfc:	00 00 00 
  800420bcff:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420bd06:	83 e2 f8             	and    $0xfffffff8,%edx
  800420bd09:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420bd0f:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bd16:	00 00 00 
  800420bd19:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420bd20:	83 e2 07             	and    $0x7,%edx
  800420bd23:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420bd29:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bd30:	00 00 00 
  800420bd33:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bd3a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bd3d:	83 ca 0e             	or     $0xe,%edx
  800420bd40:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bd46:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bd4d:	00 00 00 
  800420bd50:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bd57:	83 e2 ef             	and    $0xffffffef,%edx
  800420bd5a:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bd60:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bd67:	00 00 00 
  800420bd6a:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bd71:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bd74:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bd7a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bd81:	00 00 00 
  800420bd84:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420bd8b:	83 ca 80             	or     $0xffffff80,%edx
  800420bd8e:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420bd94:	48 b8 d8 d5 20 04 80 	movabs $0x800420d5d8,%rax
  800420bd9b:	00 00 00 
  800420bd9e:	48 c1 e8 10          	shr    $0x10,%rax
  800420bda2:	89 c2                	mov    %eax,%edx
  800420bda4:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bdab:	00 00 00 
  800420bdae:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420bdb5:	48 b8 d8 d5 20 04 80 	movabs $0x800420d5d8,%rax
  800420bdbc:	00 00 00 
  800420bdbf:	48 c1 e8 20          	shr    $0x20,%rax
  800420bdc3:	89 c2                	mov    %eax,%edx
  800420bdc5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bdcc:	00 00 00 
  800420bdcf:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420bdd5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bddc:	00 00 00 
  800420bddf:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420bde6:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+15], 0, GD_KT, XTRPX_IRQf, 0);
  800420bde9:	48 b8 de d5 20 04 80 	movabs $0x800420d5de,%rax
  800420bdf0:	00 00 00 
  800420bdf3:	89 c2                	mov    %eax,%edx
  800420bdf5:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bdfc:	00 00 00 
  800420bdff:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420be06:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420be0d:	00 00 00 
  800420be10:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420be17:	08 00 
  800420be19:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420be20:	00 00 00 
  800420be23:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420be2a:	83 e2 f8             	and    $0xfffffff8,%edx
  800420be2d:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420be33:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420be3a:	00 00 00 
  800420be3d:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420be44:	83 e2 07             	and    $0x7,%edx
  800420be47:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420be4d:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420be54:	00 00 00 
  800420be57:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420be5e:	83 e2 f0             	and    $0xfffffff0,%edx
  800420be61:	83 ca 0e             	or     $0xe,%edx
  800420be64:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420be6a:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420be71:	00 00 00 
  800420be74:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420be7b:	83 e2 ef             	and    $0xffffffef,%edx
  800420be7e:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420be84:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420be8b:	00 00 00 
  800420be8e:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420be95:	83 e2 9f             	and    $0xffffff9f,%edx
  800420be98:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420be9e:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bea5:	00 00 00 
  800420bea8:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420beaf:	83 ca 80             	or     $0xffffff80,%edx
  800420beb2:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420beb8:	48 b8 de d5 20 04 80 	movabs $0x800420d5de,%rax
  800420bebf:	00 00 00 
  800420bec2:	48 c1 e8 10          	shr    $0x10,%rax
  800420bec6:	89 c2                	mov    %eax,%edx
  800420bec8:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420becf:	00 00 00 
  800420bed2:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420bed9:	48 b8 de d5 20 04 80 	movabs $0x800420d5de,%rax
  800420bee0:	00 00 00 
  800420bee3:	48 c1 e8 20          	shr    $0x20,%rax
  800420bee7:	89 c2                	mov    %eax,%edx
  800420bee9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bef0:	00 00 00 
  800420bef3:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420bef9:	48 b8 80 d2 3a 04 80 	movabs $0x80043ad280,%rax
  800420bf00:	00 00 00 
  800420bf03:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420bf0a:	00 00 00 
	
    idt_pd.pd_lim = sizeof(idt)-1;
  800420bf0d:	48 b8 80 e2 3a 04 80 	movabs $0x80043ae280,%rax
  800420bf14:	00 00 00 
  800420bf17:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
    idt_pd.pd_base = (uint64_t)idt;
  800420bf1c:	48 ba 80 d2 3a 04 80 	movabs $0x80043ad280,%rdx
  800420bf23:	00 00 00 
  800420bf26:	48 b8 80 e2 3a 04 80 	movabs $0x80043ae280,%rax
  800420bf2d:	00 00 00 
  800420bf30:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420bf34:	48 b8 42 bf 20 04 80 	movabs $0x800420bf42,%rax
  800420bf3b:	00 00 00 
  800420bf3e:	ff d0                	callq  *%rax
}
  800420bf40:	5d                   	pop    %rbp
  800420bf41:	c3                   	retq   

000000800420bf42 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420bf42:	55                   	push   %rbp
  800420bf43:	48 89 e5             	mov    %rsp,%rbp
  800420bf46:	53                   	push   %rbx
  800420bf47:	48 83 ec 18          	sub    $0x18,%rsp
	//
	// LAB 4: Your code here:

	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP + thiscpu->cpu_id * (KSTKSIZE+KSTKGAP);
  800420bf4b:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420bf52:	00 00 00 
  800420bf55:	ff d0                	callq  *%rax
  800420bf57:	89 c3                	mov    %eax,%ebx
  800420bf59:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420bf60:	00 00 00 
  800420bf63:	ff d0                	callq  *%rax
  800420bf65:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420bf6c:	00 00 00 
  800420bf6f:	48 98                	cltq   
  800420bf71:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf75:	48 89 c1             	mov    %rax,%rcx
  800420bf78:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bf7c:	48 01 c8             	add    %rcx,%rax
  800420bf7f:	48 01 d0             	add    %rdx,%rax
  800420bf82:	0f b6 00             	movzbl (%rax),%eax
  800420bf85:	0f b6 d0             	movzbl %al,%edx
  800420bf88:	89 d0                	mov    %edx,%eax
  800420bf8a:	01 c0                	add    %eax,%eax
  800420bf8c:	01 d0                	add    %edx,%eax
  800420bf8e:	c1 e0 0f             	shl    $0xf,%eax
  800420bf91:	48 63 d0             	movslq %eax,%rdx
  800420bf94:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420bf9b:	00 00 00 
  800420bf9e:	48 01 d0             	add    %rdx,%rax
  800420bfa1:	48 89 c2             	mov    %rax,%rdx
  800420bfa4:	48 b9 20 00 3b 04 80 	movabs $0x80043b0020,%rcx
  800420bfab:	00 00 00 
  800420bfae:	48 63 c3             	movslq %ebx,%rax
  800420bfb1:	48 c1 e0 03          	shl    $0x3,%rax
  800420bfb5:	48 89 c6             	mov    %rax,%rsi
  800420bfb8:	48 c1 e6 04          	shl    $0x4,%rsi
  800420bfbc:	48 01 f0             	add    %rsi,%rax
  800420bfbf:	48 01 c8             	add    %rcx,%rax
  800420bfc2:	48 83 c0 10          	add    $0x10,%rax
  800420bfc6:	48 89 50 04          	mov    %rdx,0x4(%rax)
	//	thiscpu->cpu_ts.ts_ss0 = GD_KD;
	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *) (&gdt[(GD_TSS0>>3) + (thiscpu->cpu_id*2)]),STS_T64A,
  800420bfca:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420bfd1:	00 00 00 
  800420bfd4:	ff d0                	callq  *%rax
  800420bfd6:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420bfdd:	00 00 00 
  800420bfe0:	48 98                	cltq   
  800420bfe2:	48 c1 e0 03          	shl    $0x3,%rax
  800420bfe6:	48 89 c1             	mov    %rax,%rcx
  800420bfe9:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bfed:	48 01 c8             	add    %rcx,%rax
  800420bff0:	48 01 d0             	add    %rdx,%rax
  800420bff3:	0f b6 00             	movzbl (%rax),%eax
  800420bff6:	0f b6 c0             	movzbl %al,%eax
  800420bff9:	01 c0                	add    %eax,%eax
  800420bffb:	83 c0 05             	add    $0x5,%eax
  800420bffe:	48 98                	cltq   
  800420c000:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c007:	00 
  800420c008:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c00f:	00 00 00 
  800420c012:	48 01 d0             	add    %rdx,%rax
  800420c015:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420c01a:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c021:	00 00 00 
  800420c024:	ff d0                	callq  *%rax
  800420c026:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c02d:	00 00 00 
  800420c030:	48 98                	cltq   
  800420c032:	48 c1 e0 03          	shl    $0x3,%rax
  800420c036:	48 89 c1             	mov    %rax,%rcx
  800420c039:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c03d:	48 01 c8             	add    %rcx,%rax
  800420c040:	48 01 d0             	add    %rdx,%rax
  800420c043:	0f b6 00             	movzbl (%rax),%eax
  800420c046:	0f b6 c0             	movzbl %al,%eax
  800420c049:	01 c0                	add    %eax,%eax
  800420c04b:	83 c0 05             	add    $0x5,%eax
  800420c04e:	48 98                	cltq   
  800420c050:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c057:	00 
  800420c058:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c05f:	00 00 00 
  800420c062:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420c066:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c06d:	00 00 00 
  800420c070:	ff d0                	callq  *%rax
  800420c072:	48 98                	cltq   
  800420c074:	48 c1 e0 03          	shl    $0x3,%rax
  800420c078:	48 89 c2             	mov    %rax,%rdx
  800420c07b:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c07f:	48 01 d0             	add    %rdx,%rax
  800420c082:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c086:	48 b8 20 00 3b 04 80 	movabs $0x80043b0020,%rax
  800420c08d:	00 00 00 
  800420c090:	48 01 d0             	add    %rdx,%rax
  800420c093:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420c097:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c09e:	00 00 00 
  800420c0a1:	ff d0                	callq  *%rax
  800420c0a3:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c0aa:	00 00 00 
  800420c0ad:	48 98                	cltq   
  800420c0af:	48 c1 e0 03          	shl    $0x3,%rax
  800420c0b3:	48 89 c1             	mov    %rax,%rcx
  800420c0b6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c0ba:	48 01 c8             	add    %rcx,%rax
  800420c0bd:	48 01 d0             	add    %rdx,%rax
  800420c0c0:	0f b6 00             	movzbl (%rax),%eax
  800420c0c3:	0f b6 c0             	movzbl %al,%eax
  800420c0c6:	01 c0                	add    %eax,%eax
  800420c0c8:	83 c0 05             	add    $0x5,%eax
  800420c0cb:	48 98                	cltq   
  800420c0cd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c0d4:	00 
  800420c0d5:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c0dc:	00 00 00 
  800420c0df:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420c0e3:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c0ea:	00 00 00 
  800420c0ed:	ff d0                	callq  *%rax
  800420c0ef:	48 98                	cltq   
  800420c0f1:	48 c1 e0 03          	shl    $0x3,%rax
  800420c0f5:	48 89 c2             	mov    %rax,%rdx
  800420c0f8:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c0fc:	48 01 d0             	add    %rdx,%rax
  800420c0ff:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c103:	48 b8 20 00 3b 04 80 	movabs $0x80043b0020,%rax
  800420c10a:	00 00 00 
  800420c10d:	48 01 d0             	add    %rdx,%rax
  800420c110:	48 c1 e8 10          	shr    $0x10,%rax
  800420c114:	88 43 04             	mov    %al,0x4(%rbx)
  800420c117:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c11e:	00 00 00 
  800420c121:	ff d0                	callq  *%rax
  800420c123:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c12a:	00 00 00 
  800420c12d:	48 98                	cltq   
  800420c12f:	48 c1 e0 03          	shl    $0x3,%rax
  800420c133:	48 89 c1             	mov    %rax,%rcx
  800420c136:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c13a:	48 01 c8             	add    %rcx,%rax
  800420c13d:	48 01 d0             	add    %rdx,%rax
  800420c140:	0f b6 00             	movzbl (%rax),%eax
  800420c143:	0f b6 c0             	movzbl %al,%eax
  800420c146:	01 c0                	add    %eax,%eax
  800420c148:	83 c0 05             	add    $0x5,%eax
  800420c14b:	48 98                	cltq   
  800420c14d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c154:	00 
  800420c155:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c15c:	00 00 00 
  800420c15f:	48 01 d0             	add    %rdx,%rax
  800420c162:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c166:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c169:	83 ca 09             	or     $0x9,%edx
  800420c16c:	88 50 05             	mov    %dl,0x5(%rax)
  800420c16f:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c176:	00 00 00 
  800420c179:	ff d0                	callq  *%rax
  800420c17b:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c182:	00 00 00 
  800420c185:	48 98                	cltq   
  800420c187:	48 c1 e0 03          	shl    $0x3,%rax
  800420c18b:	48 89 c1             	mov    %rax,%rcx
  800420c18e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c192:	48 01 c8             	add    %rcx,%rax
  800420c195:	48 01 d0             	add    %rdx,%rax
  800420c198:	0f b6 00             	movzbl (%rax),%eax
  800420c19b:	0f b6 c0             	movzbl %al,%eax
  800420c19e:	01 c0                	add    %eax,%eax
  800420c1a0:	83 c0 05             	add    $0x5,%eax
  800420c1a3:	48 98                	cltq   
  800420c1a5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c1ac:	00 
  800420c1ad:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c1b4:	00 00 00 
  800420c1b7:	48 01 d0             	add    %rdx,%rax
  800420c1ba:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c1be:	83 e2 ef             	and    $0xffffffef,%edx
  800420c1c1:	88 50 05             	mov    %dl,0x5(%rax)
  800420c1c4:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c1cb:	00 00 00 
  800420c1ce:	ff d0                	callq  *%rax
  800420c1d0:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c1d7:	00 00 00 
  800420c1da:	48 98                	cltq   
  800420c1dc:	48 c1 e0 03          	shl    $0x3,%rax
  800420c1e0:	48 89 c1             	mov    %rax,%rcx
  800420c1e3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c1e7:	48 01 c8             	add    %rcx,%rax
  800420c1ea:	48 01 d0             	add    %rdx,%rax
  800420c1ed:	0f b6 00             	movzbl (%rax),%eax
  800420c1f0:	0f b6 c0             	movzbl %al,%eax
  800420c1f3:	01 c0                	add    %eax,%eax
  800420c1f5:	83 c0 05             	add    $0x5,%eax
  800420c1f8:	48 98                	cltq   
  800420c1fa:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c201:	00 
  800420c202:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c209:	00 00 00 
  800420c20c:	48 01 d0             	add    %rdx,%rax
  800420c20f:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c213:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c216:	88 50 05             	mov    %dl,0x5(%rax)
  800420c219:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c220:	00 00 00 
  800420c223:	ff d0                	callq  *%rax
  800420c225:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c22c:	00 00 00 
  800420c22f:	48 98                	cltq   
  800420c231:	48 c1 e0 03          	shl    $0x3,%rax
  800420c235:	48 89 c1             	mov    %rax,%rcx
  800420c238:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c23c:	48 01 c8             	add    %rcx,%rax
  800420c23f:	48 01 d0             	add    %rdx,%rax
  800420c242:	0f b6 00             	movzbl (%rax),%eax
  800420c245:	0f b6 c0             	movzbl %al,%eax
  800420c248:	01 c0                	add    %eax,%eax
  800420c24a:	83 c0 05             	add    $0x5,%eax
  800420c24d:	48 98                	cltq   
  800420c24f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c256:	00 
  800420c257:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c25e:	00 00 00 
  800420c261:	48 01 d0             	add    %rdx,%rax
  800420c264:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420c268:	83 ca 80             	or     $0xffffff80,%edx
  800420c26b:	88 50 05             	mov    %dl,0x5(%rax)
  800420c26e:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c275:	00 00 00 
  800420c278:	ff d0                	callq  *%rax
  800420c27a:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c281:	00 00 00 
  800420c284:	48 98                	cltq   
  800420c286:	48 c1 e0 03          	shl    $0x3,%rax
  800420c28a:	48 89 c1             	mov    %rax,%rcx
  800420c28d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c291:	48 01 c8             	add    %rcx,%rax
  800420c294:	48 01 d0             	add    %rdx,%rax
  800420c297:	0f b6 00             	movzbl (%rax),%eax
  800420c29a:	0f b6 c0             	movzbl %al,%eax
  800420c29d:	01 c0                	add    %eax,%eax
  800420c29f:	83 c0 05             	add    $0x5,%eax
  800420c2a2:	48 98                	cltq   
  800420c2a4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c2ab:	00 
  800420c2ac:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c2b3:	00 00 00 
  800420c2b6:	48 01 d0             	add    %rdx,%rax
  800420c2b9:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c2bd:	83 e2 f0             	and    $0xfffffff0,%edx
  800420c2c0:	88 50 06             	mov    %dl,0x6(%rax)
  800420c2c3:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c2ca:	00 00 00 
  800420c2cd:	ff d0                	callq  *%rax
  800420c2cf:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c2d6:	00 00 00 
  800420c2d9:	48 98                	cltq   
  800420c2db:	48 c1 e0 03          	shl    $0x3,%rax
  800420c2df:	48 89 c1             	mov    %rax,%rcx
  800420c2e2:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c2e6:	48 01 c8             	add    %rcx,%rax
  800420c2e9:	48 01 d0             	add    %rdx,%rax
  800420c2ec:	0f b6 00             	movzbl (%rax),%eax
  800420c2ef:	0f b6 c0             	movzbl %al,%eax
  800420c2f2:	01 c0                	add    %eax,%eax
  800420c2f4:	83 c0 05             	add    $0x5,%eax
  800420c2f7:	48 98                	cltq   
  800420c2f9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c300:	00 
  800420c301:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c308:	00 00 00 
  800420c30b:	48 01 d0             	add    %rdx,%rax
  800420c30e:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c312:	83 e2 ef             	and    $0xffffffef,%edx
  800420c315:	88 50 06             	mov    %dl,0x6(%rax)
  800420c318:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c31f:	00 00 00 
  800420c322:	ff d0                	callq  *%rax
  800420c324:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c32b:	00 00 00 
  800420c32e:	48 98                	cltq   
  800420c330:	48 c1 e0 03          	shl    $0x3,%rax
  800420c334:	48 89 c1             	mov    %rax,%rcx
  800420c337:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c33b:	48 01 c8             	add    %rcx,%rax
  800420c33e:	48 01 d0             	add    %rdx,%rax
  800420c341:	0f b6 00             	movzbl (%rax),%eax
  800420c344:	0f b6 c0             	movzbl %al,%eax
  800420c347:	01 c0                	add    %eax,%eax
  800420c349:	83 c0 05             	add    $0x5,%eax
  800420c34c:	48 98                	cltq   
  800420c34e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c355:	00 
  800420c356:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c35d:	00 00 00 
  800420c360:	48 01 d0             	add    %rdx,%rax
  800420c363:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c367:	83 e2 9f             	and    $0xffffff9f,%edx
  800420c36a:	88 50 06             	mov    %dl,0x6(%rax)
  800420c36d:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c374:	00 00 00 
  800420c377:	ff d0                	callq  *%rax
  800420c379:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c380:	00 00 00 
  800420c383:	48 98                	cltq   
  800420c385:	48 c1 e0 03          	shl    $0x3,%rax
  800420c389:	48 89 c1             	mov    %rax,%rcx
  800420c38c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c390:	48 01 c8             	add    %rcx,%rax
  800420c393:	48 01 d0             	add    %rdx,%rax
  800420c396:	0f b6 00             	movzbl (%rax),%eax
  800420c399:	0f b6 c0             	movzbl %al,%eax
  800420c39c:	01 c0                	add    %eax,%eax
  800420c39e:	83 c0 05             	add    $0x5,%eax
  800420c3a1:	48 98                	cltq   
  800420c3a3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c3aa:	00 
  800420c3ab:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c3b2:	00 00 00 
  800420c3b5:	48 01 d0             	add    %rdx,%rax
  800420c3b8:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420c3bc:	83 e2 7f             	and    $0x7f,%edx
  800420c3bf:	88 50 06             	mov    %dl,0x6(%rax)
  800420c3c2:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c3c9:	00 00 00 
  800420c3cc:	ff d0                	callq  *%rax
  800420c3ce:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c3d5:	00 00 00 
  800420c3d8:	48 98                	cltq   
  800420c3da:	48 c1 e0 03          	shl    $0x3,%rax
  800420c3de:	48 89 c1             	mov    %rax,%rcx
  800420c3e1:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c3e5:	48 01 c8             	add    %rcx,%rax
  800420c3e8:	48 01 d0             	add    %rdx,%rax
  800420c3eb:	0f b6 00             	movzbl (%rax),%eax
  800420c3ee:	0f b6 c0             	movzbl %al,%eax
  800420c3f1:	01 c0                	add    %eax,%eax
  800420c3f3:	83 c0 05             	add    $0x5,%eax
  800420c3f6:	48 98                	cltq   
  800420c3f8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c3ff:	00 
  800420c400:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c407:	00 00 00 
  800420c40a:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420c40e:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c415:	00 00 00 
  800420c418:	ff d0                	callq  *%rax
  800420c41a:	48 98                	cltq   
  800420c41c:	48 c1 e0 03          	shl    $0x3,%rax
  800420c420:	48 89 c2             	mov    %rax,%rdx
  800420c423:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c427:	48 01 d0             	add    %rdx,%rax
  800420c42a:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c42e:	48 b8 20 00 3b 04 80 	movabs $0x80043b0020,%rax
  800420c435:	00 00 00 
  800420c438:	48 01 d0             	add    %rdx,%rax
  800420c43b:	48 c1 e8 18          	shr    $0x18,%rax
  800420c43f:	88 43 07             	mov    %al,0x7(%rbx)
  800420c442:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c449:	00 00 00 
  800420c44c:	ff d0                	callq  *%rax
  800420c44e:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c455:	00 00 00 
  800420c458:	48 98                	cltq   
  800420c45a:	48 c1 e0 03          	shl    $0x3,%rax
  800420c45e:	48 89 c1             	mov    %rax,%rcx
  800420c461:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c465:	48 01 c8             	add    %rcx,%rax
  800420c468:	48 01 d0             	add    %rdx,%rax
  800420c46b:	0f b6 00             	movzbl (%rax),%eax
  800420c46e:	0f b6 c0             	movzbl %al,%eax
  800420c471:	01 c0                	add    %eax,%eax
  800420c473:	83 c0 05             	add    $0x5,%eax
  800420c476:	48 98                	cltq   
  800420c478:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c47f:	00 
  800420c480:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c487:	00 00 00 
  800420c48a:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420c48e:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c495:	00 00 00 
  800420c498:	ff d0                	callq  *%rax
  800420c49a:	48 98                	cltq   
  800420c49c:	48 c1 e0 03          	shl    $0x3,%rax
  800420c4a0:	48 89 c2             	mov    %rax,%rdx
  800420c4a3:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c4a7:	48 01 d0             	add    %rdx,%rax
  800420c4aa:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420c4ae:	48 b8 20 00 3b 04 80 	movabs $0x80043b0020,%rax
  800420c4b5:	00 00 00 
  800420c4b8:	48 01 d0             	add    %rdx,%rax
  800420c4bb:	48 c1 e8 20          	shr    $0x20,%rax
  800420c4bf:	89 43 08             	mov    %eax,0x8(%rbx)
  800420c4c2:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c4c9:	00 00 00 
  800420c4cc:	ff d0                	callq  *%rax
  800420c4ce:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c4d5:	00 00 00 
  800420c4d8:	48 98                	cltq   
  800420c4da:	48 c1 e0 03          	shl    $0x3,%rax
  800420c4de:	48 89 c1             	mov    %rax,%rcx
  800420c4e1:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c4e5:	48 01 c8             	add    %rcx,%rax
  800420c4e8:	48 01 d0             	add    %rdx,%rax
  800420c4eb:	0f b6 00             	movzbl (%rax),%eax
  800420c4ee:	0f b6 c0             	movzbl %al,%eax
  800420c4f1:	01 c0                	add    %eax,%eax
  800420c4f3:	83 c0 05             	add    $0x5,%eax
  800420c4f6:	48 98                	cltq   
  800420c4f8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c4ff:	00 
  800420c500:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c507:	00 00 00 
  800420c50a:	48 01 d0             	add    %rdx,%rax
  800420c50d:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420c511:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c518:	00 00 00 
  800420c51b:	ff d0                	callq  *%rax
  800420c51d:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c524:	00 00 00 
  800420c527:	48 98                	cltq   
  800420c529:	48 c1 e0 03          	shl    $0x3,%rax
  800420c52d:	48 89 c1             	mov    %rax,%rcx
  800420c530:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c534:	48 01 c8             	add    %rcx,%rax
  800420c537:	48 01 d0             	add    %rdx,%rax
  800420c53a:	0f b6 00             	movzbl (%rax),%eax
  800420c53d:	0f b6 c0             	movzbl %al,%eax
  800420c540:	01 c0                	add    %eax,%eax
  800420c542:	83 c0 05             	add    $0x5,%eax
  800420c545:	48 98                	cltq   
  800420c547:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c54e:	00 
  800420c54f:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c556:	00 00 00 
  800420c559:	48 01 d0             	add    %rdx,%rax
  800420c55c:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420c560:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c567:	00 00 00 
  800420c56a:	ff d0                	callq  *%rax
  800420c56c:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c573:	00 00 00 
  800420c576:	48 98                	cltq   
  800420c578:	48 c1 e0 03          	shl    $0x3,%rax
  800420c57c:	48 89 c1             	mov    %rax,%rcx
  800420c57f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c583:	48 01 c8             	add    %rcx,%rax
  800420c586:	48 01 d0             	add    %rdx,%rax
  800420c589:	0f b6 00             	movzbl (%rax),%eax
  800420c58c:	0f b6 c0             	movzbl %al,%eax
  800420c58f:	01 c0                	add    %eax,%eax
  800420c591:	83 c0 05             	add    $0x5,%eax
  800420c594:	48 98                	cltq   
  800420c596:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420c59d:	00 
  800420c59e:	48 b8 e0 35 23 04 80 	movabs $0x80042335e0,%rax
  800420c5a5:	00 00 00 
  800420c5a8:	48 01 d0             	add    %rdx,%rax
  800420c5ab:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
				(uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(((GD_TSS0>>3) + (thiscpu->cpu_id*2))*8);
  800420c5b1:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c5b8:	00 00 00 
  800420c5bb:	ff d0                	callq  *%rax
  800420c5bd:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420c5c4:	00 00 00 
  800420c5c7:	48 98                	cltq   
  800420c5c9:	48 c1 e0 03          	shl    $0x3,%rax
  800420c5cd:	48 89 c1             	mov    %rax,%rcx
  800420c5d0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c5d4:	48 01 c8             	add    %rcx,%rax
  800420c5d7:	48 01 d0             	add    %rdx,%rax
  800420c5da:	0f b6 00             	movzbl (%rax),%eax
  800420c5dd:	0f b6 c0             	movzbl %al,%eax
  800420c5e0:	c1 e0 04             	shl    $0x4,%eax
  800420c5e3:	83 c0 28             	add    $0x28,%eax
  800420c5e6:	0f b7 c0             	movzwl %ax,%eax
  800420c5e9:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    __asm __volatile("lgdt (%0)" : : "r" (p));
}
    static __inline void
ltr(uint16_t sel)
{
    __asm __volatile("ltr %0" : : "r" (sel));
  800420c5ed:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420c5f1:	0f 00 d8             	ltr    %ax
  800420c5f4:	48 b8 80 e2 3a 04 80 	movabs $0x80043ae280,%rax
  800420c5fb:	00 00 00 
  800420c5fe:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

    static __inline void
lidt(void *p)
{
    __asm __volatile("lidt (%0)" : : "r" (p));
  800420c602:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420c606:	0f 01 18             	lidt   (%rax)

	// Load the IDT
	lidt(&idt_pd);
}
  800420c609:	48 83 c4 18          	add    $0x18,%rsp
  800420c60d:	5b                   	pop    %rbx
  800420c60e:	5d                   	pop    %rbp
  800420c60f:	c3                   	retq   

000000800420c610 <print_trapframe>:
void
print_trapframe(struct Trapframe *tf)
{
  800420c610:	55                   	push   %rbp
  800420c611:	48 89 e5             	mov    %rsp,%rbp
  800420c614:	48 83 ec 20          	sub    $0x20,%rsp
  800420c618:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420c61c:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420c623:	00 00 00 
  800420c626:	ff d0                	callq  *%rax
  800420c628:	89 c2                	mov    %eax,%edx
  800420c62a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c62e:	48 89 c6             	mov    %rax,%rsi
  800420c631:	48 bf 4e e6 21 04 80 	movabs $0x800421e64e,%rdi
  800420c638:	00 00 00 
  800420c63b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c640:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420c647:	00 00 00 
  800420c64a:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420c64c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c650:	48 89 c7             	mov    %rax,%rdi
  800420c653:	48 b8 21 c9 20 04 80 	movabs $0x800420c921,%rax
  800420c65a:	00 00 00 
  800420c65d:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420c65f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c663:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420c667:	0f b7 c0             	movzwl %ax,%eax
  800420c66a:	89 c6                	mov    %eax,%esi
  800420c66c:	48 bf 6c e6 21 04 80 	movabs $0x800421e66c,%rdi
  800420c673:	00 00 00 
  800420c676:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c67b:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c682:	00 00 00 
  800420c685:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420c687:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c68b:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420c692:	0f b7 c0             	movzwl %ax,%eax
  800420c695:	89 c6                	mov    %eax,%esi
  800420c697:	48 bf 7f e6 21 04 80 	movabs $0x800421e67f,%rdi
  800420c69e:	00 00 00 
  800420c6a1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6a6:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c6ad:	00 00 00 
  800420c6b0:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420c6b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c6b6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c6bd:	89 c7                	mov    %eax,%edi
  800420c6bf:	48 b8 33 97 20 04 80 	movabs $0x8004209733,%rax
  800420c6c6:	00 00 00 
  800420c6c9:	ff d0                	callq  *%rax
  800420c6cb:	48 89 c2             	mov    %rax,%rdx
  800420c6ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c6d2:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c6d9:	48 89 c6             	mov    %rax,%rsi
  800420c6dc:	48 bf 92 e6 21 04 80 	movabs $0x800421e692,%rdi
  800420c6e3:	00 00 00 
  800420c6e6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c6eb:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420c6f2:	00 00 00 
  800420c6f5:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420c6f7:	48 b8 90 e2 3a 04 80 	movabs $0x80043ae290,%rax
  800420c6fe:	00 00 00 
  800420c701:	48 8b 00             	mov    (%rax),%rax
  800420c704:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420c708:	75 3a                	jne    800420c744 <print_trapframe+0x134>
  800420c70a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c70e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c715:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c719:	75 29                	jne    800420c744 <print_trapframe+0x134>

    static __inline uint64_t
rcr2(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420c71b:	0f 20 d0             	mov    %cr2,%rax
  800420c71e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    return val;
  800420c722:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420c726:	48 89 c6             	mov    %rax,%rsi
  800420c729:	48 bf a4 e6 21 04 80 	movabs $0x800421e6a4,%rdi
  800420c730:	00 00 00 
  800420c733:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c738:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c73f:	00 00 00 
  800420c742:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420c744:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c748:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c74f:	48 89 c6             	mov    %rax,%rsi
  800420c752:	48 bf b3 e6 21 04 80 	movabs $0x800421e6b3,%rdi
  800420c759:	00 00 00 
  800420c75c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c761:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c768:	00 00 00 
  800420c76b:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420c76d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c771:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c778:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c77c:	0f 85 9c 00 00 00    	jne    800420c81e <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420c782:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c786:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c78d:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c790:	48 85 c0             	test   %rax,%rax
  800420c793:	74 0c                	je     800420c7a1 <print_trapframe+0x191>
  800420c795:	48 b9 c1 e6 21 04 80 	movabs $0x800421e6c1,%rcx
  800420c79c:	00 00 00 
  800420c79f:	eb 0a                	jmp    800420c7ab <print_trapframe+0x19b>
  800420c7a1:	48 b9 cc e6 21 04 80 	movabs $0x800421e6cc,%rcx
  800420c7a8:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420c7ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c7af:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c7b6:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c7b9:	48 85 c0             	test   %rax,%rax
  800420c7bc:	74 0c                	je     800420c7ca <print_trapframe+0x1ba>
  800420c7be:	48 ba d8 e6 21 04 80 	movabs $0x800421e6d8,%rdx
  800420c7c5:	00 00 00 
  800420c7c8:	eb 0a                	jmp    800420c7d4 <print_trapframe+0x1c4>
  800420c7ca:	48 ba de e6 21 04 80 	movabs $0x800421e6de,%rdx
  800420c7d1:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420c7d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c7d8:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c7df:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c7e2:	48 85 c0             	test   %rax,%rax
  800420c7e5:	74 0c                	je     800420c7f3 <print_trapframe+0x1e3>
  800420c7e7:	48 b8 e3 e6 21 04 80 	movabs $0x800421e6e3,%rax
  800420c7ee:	00 00 00 
  800420c7f1:	eb 0a                	jmp    800420c7fd <print_trapframe+0x1ed>
  800420c7f3:	48 b8 e8 e6 21 04 80 	movabs $0x800421e6e8,%rax
  800420c7fa:	00 00 00 
  800420c7fd:	48 89 c6             	mov    %rax,%rsi
  800420c800:	48 bf ef e6 21 04 80 	movabs $0x800421e6ef,%rdi
  800420c807:	00 00 00 
  800420c80a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c80f:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  800420c816:	00 00 00 
  800420c819:	41 ff d0             	callq  *%r8
  800420c81c:	eb 1b                	jmp    800420c839 <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420c81e:	48 bf fe e6 21 04 80 	movabs $0x800421e6fe,%rdi
  800420c825:	00 00 00 
  800420c828:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c82d:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c834:	00 00 00 
  800420c837:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420c839:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c83d:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420c844:	48 89 c6             	mov    %rax,%rsi
  800420c847:	48 bf 00 e7 21 04 80 	movabs $0x800421e700,%rdi
  800420c84e:	00 00 00 
  800420c851:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c856:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c85d:	00 00 00 
  800420c860:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420c862:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c866:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c86d:	0f b7 c0             	movzwl %ax,%eax
  800420c870:	89 c6                	mov    %eax,%esi
  800420c872:	48 bf 0f e7 21 04 80 	movabs $0x800421e70f,%rdi
  800420c879:	00 00 00 
  800420c87c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c881:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c888:	00 00 00 
  800420c88b:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420c88d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c891:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420c898:	48 89 c6             	mov    %rax,%rsi
  800420c89b:	48 bf 22 e7 21 04 80 	movabs $0x800421e722,%rdi
  800420c8a2:	00 00 00 
  800420c8a5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8aa:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c8b1:	00 00 00 
  800420c8b4:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420c8b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c8ba:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c8c1:	0f b7 c0             	movzwl %ax,%eax
  800420c8c4:	83 e0 03             	and    $0x3,%eax
  800420c8c7:	85 c0                	test   %eax,%eax
  800420c8c9:	74 54                	je     800420c91f <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420c8cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c8cf:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420c8d6:	48 89 c6             	mov    %rax,%rsi
  800420c8d9:	48 bf 31 e7 21 04 80 	movabs $0x800421e731,%rdi
  800420c8e0:	00 00 00 
  800420c8e3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c8e8:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c8ef:	00 00 00 
  800420c8f2:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420c8f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c8f8:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420c8ff:	0f b7 c0             	movzwl %ax,%eax
  800420c902:	89 c6                	mov    %eax,%esi
  800420c904:	48 bf 40 e7 21 04 80 	movabs $0x800421e740,%rdi
  800420c90b:	00 00 00 
  800420c90e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c913:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c91a:	00 00 00 
  800420c91d:	ff d2                	callq  *%rdx
	}
}
  800420c91f:	c9                   	leaveq 
  800420c920:	c3                   	retq   

000000800420c921 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420c921:	55                   	push   %rbp
  800420c922:	48 89 e5             	mov    %rsp,%rbp
  800420c925:	48 83 ec 10          	sub    $0x10,%rsp
  800420c929:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420c92d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c931:	48 8b 00             	mov    (%rax),%rax
  800420c934:	48 89 c6             	mov    %rax,%rsi
  800420c937:	48 bf 53 e7 21 04 80 	movabs $0x800421e753,%rdi
  800420c93e:	00 00 00 
  800420c941:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c946:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c94d:	00 00 00 
  800420c950:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420c952:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c956:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c95a:	48 89 c6             	mov    %rax,%rsi
  800420c95d:	48 bf 62 e7 21 04 80 	movabs $0x800421e762,%rdi
  800420c964:	00 00 00 
  800420c967:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c96c:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c973:	00 00 00 
  800420c976:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420c978:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c97c:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c980:	48 89 c6             	mov    %rax,%rsi
  800420c983:	48 bf 71 e7 21 04 80 	movabs $0x800421e771,%rdi
  800420c98a:	00 00 00 
  800420c98d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c992:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c999:	00 00 00 
  800420c99c:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420c99e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c9a2:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c9a6:	48 89 c6             	mov    %rax,%rsi
  800420c9a9:	48 bf 80 e7 21 04 80 	movabs $0x800421e780,%rdi
  800420c9b0:	00 00 00 
  800420c9b3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c9b8:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c9bf:	00 00 00 
  800420c9c2:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420c9c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c9c8:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420c9cc:	48 89 c6             	mov    %rax,%rsi
  800420c9cf:	48 bf 8f e7 21 04 80 	movabs $0x800421e78f,%rdi
  800420c9d6:	00 00 00 
  800420c9d9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c9de:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420c9e5:	00 00 00 
  800420c9e8:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420c9ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c9ee:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c9f2:	48 89 c6             	mov    %rax,%rsi
  800420c9f5:	48 bf 9e e7 21 04 80 	movabs $0x800421e79e,%rdi
  800420c9fc:	00 00 00 
  800420c9ff:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca04:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420ca0b:	00 00 00 
  800420ca0e:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420ca10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ca14:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420ca18:	48 89 c6             	mov    %rax,%rsi
  800420ca1b:	48 bf ad e7 21 04 80 	movabs $0x800421e7ad,%rdi
  800420ca22:	00 00 00 
  800420ca25:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca2a:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420ca31:	00 00 00 
  800420ca34:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420ca36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ca3a:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420ca3e:	48 89 c6             	mov    %rax,%rsi
  800420ca41:	48 bf bb e7 21 04 80 	movabs $0x800421e7bb,%rdi
  800420ca48:	00 00 00 
  800420ca4b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca50:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420ca57:	00 00 00 
  800420ca5a:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420ca5c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ca60:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420ca64:	48 89 c6             	mov    %rax,%rsi
  800420ca67:	48 bf c9 e7 21 04 80 	movabs $0x800421e7c9,%rdi
  800420ca6e:	00 00 00 
  800420ca71:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca76:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420ca7d:	00 00 00 
  800420ca80:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420ca82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ca86:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420ca8a:	48 89 c6             	mov    %rax,%rsi
  800420ca8d:	48 bf d8 e7 21 04 80 	movabs $0x800421e7d8,%rdi
  800420ca94:	00 00 00 
  800420ca97:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca9c:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420caa3:	00 00 00 
  800420caa6:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420caa8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420caac:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420cab0:	48 89 c6             	mov    %rax,%rsi
  800420cab3:	48 bf e7 e7 21 04 80 	movabs $0x800421e7e7,%rdi
  800420caba:	00 00 00 
  800420cabd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cac2:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420cac9:	00 00 00 
  800420cacc:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420cace:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cad2:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420cad6:	48 89 c6             	mov    %rax,%rsi
  800420cad9:	48 bf f6 e7 21 04 80 	movabs $0x800421e7f6,%rdi
  800420cae0:	00 00 00 
  800420cae3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cae8:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420caef:	00 00 00 
  800420caf2:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420caf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420caf8:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420cafc:	48 89 c6             	mov    %rax,%rsi
  800420caff:	48 bf 05 e8 21 04 80 	movabs $0x800421e805,%rdi
  800420cb06:	00 00 00 
  800420cb09:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cb0e:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420cb15:	00 00 00 
  800420cb18:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420cb1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cb1e:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420cb22:	48 89 c6             	mov    %rax,%rsi
  800420cb25:	48 bf 14 e8 21 04 80 	movabs $0x800421e814,%rdi
  800420cb2c:	00 00 00 
  800420cb2f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cb34:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420cb3b:	00 00 00 
  800420cb3e:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420cb40:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cb44:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420cb48:	48 89 c6             	mov    %rax,%rsi
  800420cb4b:	48 bf 23 e8 21 04 80 	movabs $0x800421e823,%rdi
  800420cb52:	00 00 00 
  800420cb55:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cb5a:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420cb61:	00 00 00 
  800420cb64:	ff d2                	callq  *%rdx
}
  800420cb66:	c9                   	leaveq 
  800420cb67:	c3                   	retq   

000000800420cb68 <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420cb68:	55                   	push   %rbp
  800420cb69:	48 89 e5             	mov    %rsp,%rbp
  800420cb6c:	48 83 ec 10          	sub    $0x10,%rsp
  800420cb70:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.
	//print_trapframe(tf);
	if(tf->tf_trapno == T_PGFLT)
  800420cb74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cb78:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cb7f:	48 83 f8 0e          	cmp    $0xe,%rax
  800420cb83:	75 18                	jne    800420cb9d <trap_dispatch+0x35>
    {
        page_fault_handler(tf);
  800420cb85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cb89:	48 89 c7             	mov    %rax,%rdi
  800420cb8c:	48 b8 e1 d0 20 04 80 	movabs $0x800420d0e1,%rax
  800420cb93:	00 00 00 
  800420cb96:	ff d0                	callq  *%rax
  800420cb98:	e9 8c 00 00 00       	jmpq   800420cc29 <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_BRKPT)
  800420cb9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cba1:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cba8:	48 83 f8 03          	cmp    $0x3,%rax
  800420cbac:	75 15                	jne    800420cbc3 <trap_dispatch+0x5b>
    {
        monitor(tf);
  800420cbae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cbb2:	48 89 c7             	mov    %rax,%rdi
  800420cbb5:	48 b8 4c 1b 20 04 80 	movabs $0x8004201b4c,%rax
  800420cbbc:	00 00 00 
  800420cbbf:	ff d0                	callq  *%rax
  800420cbc1:	eb 66                	jmp    800420cc29 <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_SYSCALL)
  800420cbc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cbc7:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cbce:	48 83 f8 30          	cmp    $0x30,%rax
  800420cbd2:	75 55                	jne    800420cc29 <trap_dispatch+0xc1>
    {
        tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx,
  800420cbd4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cbd8:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420cbdc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cbe0:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420cbe4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cbe8:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420cbec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cbf0:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420cbf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cbf8:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420cbfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cc00:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420cc04:	4d 89 c1             	mov    %r8,%r9
  800420cc07:	49 89 f8             	mov    %rdi,%r8
  800420cc0a:	48 89 c7             	mov    %rax,%rdi
  800420cc0d:	48 b8 ba ed 20 04 80 	movabs $0x800420edba,%rax
  800420cc14:	00 00 00 
  800420cc17:	ff d0                	callq  *%rax
  800420cc19:	48 89 c2             	mov    %rax,%rdx
  800420cc1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cc20:	48 89 50 70          	mov    %rdx,0x70(%rax)
                        tf->tf_regs.reg_rcx, tf->tf_regs.reg_rbx,
                        tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
        return;
  800420cc24:	e9 59 01 00 00       	jmpq   800420cd82 <trap_dispatch+0x21a>
    }

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420cc29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cc2d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cc34:	48 83 f8 27          	cmp    $0x27,%rax
  800420cc38:	75 33                	jne    800420cc6d <trap_dispatch+0x105>
		cprintf("Spurious interrupt on irq 7\n");
  800420cc3a:	48 bf 32 e8 21 04 80 	movabs $0x800421e832,%rdi
  800420cc41:	00 00 00 
  800420cc44:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cc49:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420cc50:	00 00 00 
  800420cc53:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420cc55:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cc59:	48 89 c7             	mov    %rax,%rdi
  800420cc5c:	48 b8 10 c6 20 04 80 	movabs $0x800420c610,%rax
  800420cc63:	00 00 00 
  800420cc66:	ff d0                	callq  *%rax
		return;
  800420cc68:	e9 15 01 00 00       	jmpq   800420cd82 <trap_dispatch+0x21a>
	// LAB 6: Your code here.


	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_TIMER))
  800420cc6d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cc71:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420cc78:	48 83 f8 20          	cmp    $0x20,%rax
  800420cc7c:	75 24                	jne    800420cca2 <trap_dispatch+0x13a>
	{
		lapic_eoi();
  800420cc7e:	48 b8 cf 7b 21 04 80 	movabs $0x8004217bcf,%rax
  800420cc85:	00 00 00 
  800420cc88:	ff d0                	callq  *%rax
		time_tick();
  800420cc8a:	48 b8 56 8d 21 04 80 	movabs $0x8004218d56,%rax
  800420cc91:	00 00 00 
  800420cc94:	ff d0                	callq  *%rax
		sched_yield();
  800420cc96:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  800420cc9d:	00 00 00 
  800420cca0:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_KBD))
  800420cca2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cca6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420ccad:	48 83 f8 21          	cmp    $0x21,%rax
  800420ccb1:	75 18                	jne    800420cccb <trap_dispatch+0x163>
	{
		kbd_intr();
  800420ccb3:	48 b8 44 10 20 04 80 	movabs $0x8004201044,%rax
  800420ccba:	00 00 00 
  800420ccbd:	ff d0                	callq  *%rax
		sched_yield();
  800420ccbf:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  800420ccc6:	00 00 00 
  800420ccc9:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_SERIAL))
  800420cccb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cccf:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420ccd6:	48 83 f8 24          	cmp    $0x24,%rax
  800420ccda:	75 18                	jne    800420ccf4 <trap_dispatch+0x18c>
	{
		serial_intr();
  800420ccdc:	48 b8 f5 07 20 04 80 	movabs $0x80042007f5,%rax
  800420cce3:	00 00 00 
  800420cce6:	ff d0                	callq  *%rax
		sched_yield();
  800420cce8:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  800420ccef:	00 00 00 
  800420ccf2:	ff d0                	callq  *%rax
	}
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420ccf4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420ccf8:	48 89 c7             	mov    %rax,%rdi
  800420ccfb:	48 b8 10 c6 20 04 80 	movabs $0x800420c610,%rax
  800420cd02:	00 00 00 
  800420cd05:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420cd07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420cd0b:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420cd12:	66 83 f8 08          	cmp    $0x8,%ax
  800420cd16:	75 2a                	jne    800420cd42 <trap_dispatch+0x1da>
		panic("unhandled trap in kernel");
  800420cd18:	48 ba 4f e8 21 04 80 	movabs $0x800421e84f,%rdx
  800420cd1f:	00 00 00 
  800420cd22:	be 16 01 00 00       	mov    $0x116,%esi
  800420cd27:	48 bf 68 e8 21 04 80 	movabs $0x800421e868,%rdi
  800420cd2e:	00 00 00 
  800420cd31:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cd36:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  800420cd3d:	00 00 00 
  800420cd40:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420cd42:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420cd49:	00 00 00 
  800420cd4c:	ff d0                	callq  *%rax
  800420cd4e:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420cd55:	00 00 00 
  800420cd58:	48 98                	cltq   
  800420cd5a:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd5e:	48 89 c1             	mov    %rax,%rcx
  800420cd61:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cd65:	48 01 c8             	add    %rcx,%rax
  800420cd68:	48 01 d0             	add    %rdx,%rax
  800420cd6b:	48 83 c0 08          	add    $0x8,%rax
  800420cd6f:	48 8b 00             	mov    (%rax),%rax
  800420cd72:	48 89 c7             	mov    %rax,%rdi
  800420cd75:	48 b8 ac 8d 20 04 80 	movabs $0x8004208dac,%rax
  800420cd7c:	00 00 00 
  800420cd7f:	ff d0                	callq  *%rax
		return;
  800420cd81:	90                   	nop
	}
}
  800420cd82:	c9                   	leaveq 
  800420cd83:	c3                   	retq   

000000800420cd84 <trap>:

void
trap(struct Trapframe *tf)
{
  800420cd84:	55                   	push   %rbp
  800420cd85:	48 89 e5             	mov    %rsp,%rbp
  800420cd88:	48 83 ec 20          	sub    $0x20,%rsp
  800420cd8c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420cd90:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420cd91:	48 b8 78 e7 3a 04 80 	movabs $0x80043ae778,%rax
  800420cd98:	00 00 00 
  800420cd9b:	48 8b 00             	mov    (%rax),%rax
  800420cd9e:	48 85 c0             	test   %rax,%rax
  800420cda1:	74 01                	je     800420cda4 <trap+0x20>
		asm volatile("hlt");
  800420cda3:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420cda4:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420cdab:	00 00 00 
  800420cdae:	ff d0                	callq  *%rax
  800420cdb0:	48 98                	cltq   
  800420cdb2:	48 c1 e0 03          	shl    $0x3,%rax
  800420cdb6:	48 89 c2             	mov    %rax,%rdx
  800420cdb9:	48 c1 e2 04          	shl    $0x4,%rdx
  800420cdbd:	48 01 d0             	add    %rdx,%rax
  800420cdc0:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420cdc7:	00 00 00 
  800420cdca:	48 01 d0             	add    %rdx,%rax
  800420cdcd:	48 83 c0 04          	add    $0x4,%rax
  800420cdd1:	be 01 00 00 00       	mov    $0x1,%esi
  800420cdd6:	48 89 c7             	mov    %rax,%rdi
  800420cdd9:	48 b8 f2 96 20 04 80 	movabs $0x80042096f2,%rax
  800420cde0:	00 00 00 
  800420cde3:	ff d0                	callq  *%rax
  800420cde5:	83 f8 02             	cmp    $0x2,%eax
  800420cde8:	75 0c                	jne    800420cdf6 <trap+0x72>
		lock_kernel();
  800420cdea:	48 b8 17 97 20 04 80 	movabs $0x8004209717,%rax
  800420cdf1:	00 00 00 
  800420cdf4:	ff d0                	callq  *%rax

    static __inline uint64_t
read_eflags(void)
{
    uint64_t rflags;
    __asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420cdf6:	9c                   	pushfq 
  800420cdf7:	58                   	pop    %rax
  800420cdf8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    return rflags;
  800420cdfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420ce00:	25 00 02 00 00       	and    $0x200,%eax
  800420ce05:	48 85 c0             	test   %rax,%rax
  800420ce08:	74 35                	je     800420ce3f <trap+0xbb>
  800420ce0a:	48 b9 74 e8 21 04 80 	movabs $0x800421e874,%rcx
  800420ce11:	00 00 00 
  800420ce14:	48 ba 8d e8 21 04 80 	movabs $0x800421e88d,%rdx
  800420ce1b:	00 00 00 
  800420ce1e:	be 31 01 00 00       	mov    $0x131,%esi
  800420ce23:	48 bf 68 e8 21 04 80 	movabs $0x800421e868,%rdi
  800420ce2a:	00 00 00 
  800420ce2d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ce32:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420ce39:	00 00 00 
  800420ce3c:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420ce3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ce43:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420ce4a:	0f b7 c0             	movzwl %ax,%eax
  800420ce4d:	83 e0 03             	and    $0x3,%eax
  800420ce50:	83 f8 03             	cmp    $0x3,%eax
  800420ce53:	0f 85 a9 01 00 00    	jne    800420d002 <trap+0x27e>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420ce59:	48 b8 17 97 20 04 80 	movabs $0x8004209717,%rax
  800420ce60:	00 00 00 
  800420ce63:	ff d0                	callq  *%rax
		assert(curenv);
  800420ce65:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420ce6c:	00 00 00 
  800420ce6f:	ff d0                	callq  *%rax
  800420ce71:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420ce78:	00 00 00 
  800420ce7b:	48 98                	cltq   
  800420ce7d:	48 c1 e0 03          	shl    $0x3,%rax
  800420ce81:	48 89 c1             	mov    %rax,%rcx
  800420ce84:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ce88:	48 01 c8             	add    %rcx,%rax
  800420ce8b:	48 01 d0             	add    %rdx,%rax
  800420ce8e:	48 83 c0 08          	add    $0x8,%rax
  800420ce92:	48 8b 00             	mov    (%rax),%rax
  800420ce95:	48 85 c0             	test   %rax,%rax
  800420ce98:	75 35                	jne    800420cecf <trap+0x14b>
  800420ce9a:	48 b9 a2 e8 21 04 80 	movabs $0x800421e8a2,%rcx
  800420cea1:	00 00 00 
  800420cea4:	48 ba 8d e8 21 04 80 	movabs $0x800421e88d,%rdx
  800420ceab:	00 00 00 
  800420ceae:	be 39 01 00 00       	mov    $0x139,%esi
  800420ceb3:	48 bf 68 e8 21 04 80 	movabs $0x800421e868,%rdi
  800420ceba:	00 00 00 
  800420cebd:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cec2:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420cec9:	00 00 00 
  800420cecc:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420cecf:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420ced6:	00 00 00 
  800420ced9:	ff d0                	callq  *%rax
  800420cedb:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420cee2:	00 00 00 
  800420cee5:	48 98                	cltq   
  800420cee7:	48 c1 e0 03          	shl    $0x3,%rax
  800420ceeb:	48 89 c1             	mov    %rax,%rcx
  800420ceee:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cef2:	48 01 c8             	add    %rcx,%rax
  800420cef5:	48 01 d0             	add    %rdx,%rax
  800420cef8:	48 83 c0 08          	add    $0x8,%rax
  800420cefc:	48 8b 00             	mov    (%rax),%rax
  800420ceff:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420cf05:	83 f8 01             	cmp    $0x1,%eax
  800420cf08:	75 7f                	jne    800420cf89 <trap+0x205>
			env_free(curenv);
  800420cf0a:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420cf11:	00 00 00 
  800420cf14:	ff d0                	callq  *%rax
  800420cf16:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420cf1d:	00 00 00 
  800420cf20:	48 98                	cltq   
  800420cf22:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf26:	48 89 c1             	mov    %rax,%rcx
  800420cf29:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cf2d:	48 01 c8             	add    %rcx,%rax
  800420cf30:	48 01 d0             	add    %rdx,%rax
  800420cf33:	48 83 c0 08          	add    $0x8,%rax
  800420cf37:	48 8b 00             	mov    (%rax),%rax
  800420cf3a:	48 89 c7             	mov    %rax,%rdi
  800420cf3d:	48 b8 f3 88 20 04 80 	movabs $0x80042088f3,%rax
  800420cf44:	00 00 00 
  800420cf47:	ff d0                	callq  *%rax
			curenv = NULL;
  800420cf49:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420cf50:	00 00 00 
  800420cf53:	ff d0                	callq  *%rax
  800420cf55:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420cf5c:	00 00 00 
  800420cf5f:	48 98                	cltq   
  800420cf61:	48 c1 e0 03          	shl    $0x3,%rax
  800420cf65:	48 89 c1             	mov    %rax,%rcx
  800420cf68:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cf6c:	48 01 c8             	add    %rcx,%rax
  800420cf6f:	48 01 d0             	add    %rdx,%rax
  800420cf72:	48 83 c0 08          	add    $0x8,%rax
  800420cf76:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420cf7d:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  800420cf84:	00 00 00 
  800420cf87:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420cf89:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420cf90:	00 00 00 
  800420cf93:	ff d0                	callq  *%rax
  800420cf95:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420cf9c:	00 00 00 
  800420cf9f:	48 98                	cltq   
  800420cfa1:	48 c1 e0 03          	shl    $0x3,%rax
  800420cfa5:	48 89 c1             	mov    %rax,%rcx
  800420cfa8:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cfac:	48 01 c8             	add    %rcx,%rax
  800420cfaf:	48 01 d0             	add    %rdx,%rax
  800420cfb2:	48 83 c0 08          	add    $0x8,%rax
  800420cfb6:	48 8b 10             	mov    (%rax),%rdx
  800420cfb9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cfbd:	48 89 c6             	mov    %rax,%rsi
  800420cfc0:	b8 18 00 00 00       	mov    $0x18,%eax
  800420cfc5:	48 89 d7             	mov    %rdx,%rdi
  800420cfc8:	48 89 c1             	mov    %rax,%rcx
  800420cfcb:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420cfce:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420cfd5:	00 00 00 
  800420cfd8:	ff d0                	callq  *%rax
  800420cfda:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420cfe1:	00 00 00 
  800420cfe4:	48 98                	cltq   
  800420cfe6:	48 c1 e0 03          	shl    $0x3,%rax
  800420cfea:	48 89 c1             	mov    %rax,%rcx
  800420cfed:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cff1:	48 01 c8             	add    %rcx,%rax
  800420cff4:	48 01 d0             	add    %rdx,%rax
  800420cff7:	48 83 c0 08          	add    $0x8,%rax
  800420cffb:	48 8b 00             	mov    (%rax),%rax
  800420cffe:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420d002:	48 b8 90 e2 3a 04 80 	movabs $0x80043ae290,%rax
  800420d009:	00 00 00 
  800420d00c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d010:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420d013:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d017:	48 89 c7             	mov    %rax,%rdi
  800420d01a:	48 b8 68 cb 20 04 80 	movabs $0x800420cb68,%rax
  800420d021:	00 00 00 
  800420d024:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420d026:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d02d:	00 00 00 
  800420d030:	ff d0                	callq  *%rax
  800420d032:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d039:	00 00 00 
  800420d03c:	48 98                	cltq   
  800420d03e:	48 c1 e0 03          	shl    $0x3,%rax
  800420d042:	48 89 c1             	mov    %rax,%rcx
  800420d045:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d049:	48 01 c8             	add    %rcx,%rax
  800420d04c:	48 01 d0             	add    %rdx,%rax
  800420d04f:	48 83 c0 08          	add    $0x8,%rax
  800420d053:	48 8b 00             	mov    (%rax),%rax
  800420d056:	48 85 c0             	test   %rax,%rax
  800420d059:	74 7a                	je     800420d0d5 <trap+0x351>
  800420d05b:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d062:	00 00 00 
  800420d065:	ff d0                	callq  *%rax
  800420d067:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d06e:	00 00 00 
  800420d071:	48 98                	cltq   
  800420d073:	48 c1 e0 03          	shl    $0x3,%rax
  800420d077:	48 89 c1             	mov    %rax,%rcx
  800420d07a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d07e:	48 01 c8             	add    %rcx,%rax
  800420d081:	48 01 d0             	add    %rdx,%rax
  800420d084:	48 83 c0 08          	add    $0x8,%rax
  800420d088:	48 8b 00             	mov    (%rax),%rax
  800420d08b:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d091:	83 f8 03             	cmp    $0x3,%eax
  800420d094:	75 3f                	jne    800420d0d5 <trap+0x351>
		env_run(curenv);
  800420d096:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d09d:	00 00 00 
  800420d0a0:	ff d0                	callq  *%rax
  800420d0a2:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d0a9:	00 00 00 
  800420d0ac:	48 98                	cltq   
  800420d0ae:	48 c1 e0 03          	shl    $0x3,%rax
  800420d0b2:	48 89 c1             	mov    %rax,%rcx
  800420d0b5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d0b9:	48 01 c8             	add    %rcx,%rax
  800420d0bc:	48 01 d0             	add    %rdx,%rax
  800420d0bf:	48 83 c0 08          	add    $0x8,%rax
  800420d0c3:	48 8b 00             	mov    (%rax),%rax
  800420d0c6:	48 89 c7             	mov    %rax,%rdi
  800420d0c9:	48 b8 77 8f 20 04 80 	movabs $0x8004208f77,%rax
  800420d0d0:	00 00 00 
  800420d0d3:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420d0d5:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  800420d0dc:	00 00 00 
  800420d0df:	ff d0                	callq  *%rax

000000800420d0e1 <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420d0e1:	55                   	push   %rbp
  800420d0e2:	48 89 e5             	mov    %rsp,%rbp
  800420d0e5:	53                   	push   %rbx
  800420d0e6:	48 83 ec 38          	sub    $0x38,%rsp
  800420d0ea:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

    static __inline uint64_t
rcr2(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420d0ee:	0f 20 d0             	mov    %cr2,%rax
  800420d0f1:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    return val;
  800420d0f5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420d0f9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	struct PageInfo *pp;

	// Handle kernel-mode page faults.
	
	// LAB 3: Your code here.
	if((tf->tf_cs & 3) == 0)
  800420d0fd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d101:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d108:	0f b7 c0             	movzwl %ax,%eax
  800420d10b:	83 e0 03             	and    $0x3,%eax
  800420d10e:	85 c0                	test   %eax,%eax
  800420d110:	75 5f                	jne    800420d171 <page_fault_handler+0x90>
	{
		cprintf("fault_va is [%x]",fault_va);
  800420d112:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d116:	48 89 c6             	mov    %rax,%rsi
  800420d119:	48 bf a9 e8 21 04 80 	movabs $0x800421e8a9,%rdi
  800420d120:	00 00 00 
  800420d123:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d128:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420d12f:	00 00 00 
  800420d132:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420d134:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d138:	48 89 c7             	mov    %rax,%rdi
  800420d13b:	48 b8 10 c6 20 04 80 	movabs $0x800420c610,%rax
  800420d142:	00 00 00 
  800420d145:	ff d0                	callq  *%rax
		panic("Page fault hapened in kernel mode");
  800420d147:	48 ba c0 e8 21 04 80 	movabs $0x800421e8c0,%rdx
  800420d14e:	00 00 00 
  800420d151:	be 6c 01 00 00       	mov    $0x16c,%esi
  800420d156:	48 bf 68 e8 21 04 80 	movabs $0x800421e868,%rdi
  800420d15d:	00 00 00 
  800420d160:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d165:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  800420d16c:	00 00 00 
  800420d16f:	ff d1                	callq  *%rcx
	// LAB 4: Your code here.
	
	/*check if user env has registered a pg fault upcall.*/
		//cprintf("hello1");
	//cprintf("hello2");
    if(curenv->env_pgfault_upcall){
  800420d171:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d178:	00 00 00 
  800420d17b:	ff d0                	callq  *%rax
  800420d17d:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d184:	00 00 00 
  800420d187:	48 98                	cltq   
  800420d189:	48 c1 e0 03          	shl    $0x3,%rax
  800420d18d:	48 89 c1             	mov    %rax,%rcx
  800420d190:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d194:	48 01 c8             	add    %rcx,%rax
  800420d197:	48 01 d0             	add    %rdx,%rax
  800420d19a:	48 83 c0 08          	add    $0x8,%rax
  800420d19e:	48 8b 00             	mov    (%rax),%rax
  800420d1a1:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420d1a8:	48 85 c0             	test   %rax,%rax
  800420d1ab:	0f 84 6a 02 00 00    	je     800420d41b <page_fault_handler+0x33a>
		//user_mem_assert(curenv,(const void *)curenv->env_pgfault_upcall,8,PTE_P|PTE_U);
		user_mem_assert(curenv,(const void *)UXSTACKTOP-PGSIZE,PGSIZE, PTE_W | PTE_U | PTE_P);
  800420d1b1:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d1b8:	00 00 00 
  800420d1bb:	ff d0                	callq  *%rax
  800420d1bd:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d1c4:	00 00 00 
  800420d1c7:	48 98                	cltq   
  800420d1c9:	48 c1 e0 03          	shl    $0x3,%rax
  800420d1cd:	48 89 c1             	mov    %rax,%rcx
  800420d1d0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d1d4:	48 01 c8             	add    %rcx,%rax
  800420d1d7:	48 01 d0             	add    %rdx,%rax
  800420d1da:	48 83 c0 08          	add    $0x8,%rax
  800420d1de:	48 8b 00             	mov    (%rax),%rax
  800420d1e1:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420d1e6:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420d1eb:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  800420d1f0:	48 89 c7             	mov    %rax,%rdi
  800420d1f3:	48 b8 57 3d 20 04 80 	movabs $0x8004203d57,%rax
  800420d1fa:	00 00 00 
  800420d1fd:	ff d0                	callq  *%rax
		/*If user mem assert returns , then the address is valid for the env*/	
		if(!(tf->tf_rsp < UXSTACKTOP && tf->tf_rsp > UXSTACKTOP-PGSIZE)){
  800420d1ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d203:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d20a:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420d20f:	48 39 c2             	cmp    %rax,%rdx
  800420d212:	77 15                	ja     800420d229 <page_fault_handler+0x148>
  800420d214:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d218:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d21f:	b8 00 f0 7f ef       	mov    $0xef7ff000,%eax
  800420d224:	48 39 c2             	cmp    %rax,%rdx
  800420d227:	77 0b                	ja     800420d234 <page_fault_handler+0x153>
			/*1st Page Fault*/
			utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe));
  800420d229:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420d22e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420d232:	eb 72                	jmp    800420d2a6 <page_fault_handler+0x1c5>
		}else{
			if(tf->tf_rsp - sizeof(struct UTrapframe) - 8 < (UXSTACKTOP-PGSIZE)){
  800420d234:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d238:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420d23f:	48 8d 90 58 ff ff ff 	lea    -0xa8(%rax),%rdx
  800420d246:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420d24b:	48 39 c2             	cmp    %rax,%rdx
  800420d24e:	77 41                	ja     800420d291 <page_fault_handler+0x1b0>
				env_destroy(curenv);
  800420d250:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d257:	00 00 00 
  800420d25a:	ff d0                	callq  *%rax
  800420d25c:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d263:	00 00 00 
  800420d266:	48 98                	cltq   
  800420d268:	48 c1 e0 03          	shl    $0x3,%rax
  800420d26c:	48 89 c1             	mov    %rax,%rcx
  800420d26f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d273:	48 01 c8             	add    %rcx,%rax
  800420d276:	48 01 d0             	add    %rdx,%rax
  800420d279:	48 83 c0 08          	add    $0x8,%rax
  800420d27d:	48 8b 00             	mov    (%rax),%rax
  800420d280:	48 89 c7             	mov    %rax,%rdi
  800420d283:	48 b8 ac 8d 20 04 80 	movabs $0x8004208dac,%rax
  800420d28a:	00 00 00 
  800420d28d:	ff d0                	callq  *%rax
  800420d28f:	eb 15                	jmp    800420d2a6 <page_fault_handler+0x1c5>
			}
			else
			{
				utf = (struct UTrapframe *)(tf->tf_rsp - sizeof(struct UTrapframe) - 8);
  800420d291:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d295:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420d29c:	48 2d a8 00 00 00    	sub    $0xa8,%rax
  800420d2a2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			/*Nested Page Fault*/
			
		}
		/*Populate the Utrapframe*/
		//user_mem_assert(curenv,(const void *)utf,sizeof(struct UTrapframe),PTE_W|PTE_U);
		utf->utf_eflags = tf->tf_eflags;
  800420d2a6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d2aa:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420d2b1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d2b5:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utf->utf_err = tf->tf_err;
  800420d2bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d2c0:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420d2c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d2cb:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_fault_va = fault_va;
  800420d2cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d2d3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d2d7:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_regs = tf->tf_regs;
  800420d2da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d2de:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420d2e2:	48 8b 0a             	mov    (%rdx),%rcx
  800420d2e5:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420d2e9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420d2ed:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420d2f1:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420d2f5:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420d2f9:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420d2fd:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420d301:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420d305:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420d309:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420d30d:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420d311:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420d315:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420d319:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420d31d:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420d321:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420d325:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420d329:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420d32d:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420d331:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420d335:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420d339:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420d33d:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420d341:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420d345:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420d349:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420d34d:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420d351:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420d355:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rip = tf->tf_rip;
  800420d35c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d360:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420d367:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d36b:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420d372:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d376:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420d37d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d381:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rip = (uint64_t)curenv->env_pgfault_upcall;
  800420d388:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d38f:	00 00 00 
  800420d392:	ff d0                	callq  *%rax
  800420d394:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d39b:	00 00 00 
  800420d39e:	48 98                	cltq   
  800420d3a0:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3a4:	48 89 c1             	mov    %rax,%rcx
  800420d3a7:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d3ab:	48 01 c8             	add    %rcx,%rax
  800420d3ae:	48 01 d0             	add    %rdx,%rax
  800420d3b1:	48 83 c0 08          	add    $0x8,%rax
  800420d3b5:	48 8b 00             	mov    (%rax),%rax
  800420d3b8:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420d3bf:	48 89 c2             	mov    %rax,%rdx
  800420d3c2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d3c6:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rsp = (uint64_t)utf;
  800420d3cd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d3d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d3d5:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		

		
		env_run(curenv);
  800420d3dc:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d3e3:	00 00 00 
  800420d3e6:	ff d0                	callq  *%rax
  800420d3e8:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d3ef:	00 00 00 
  800420d3f2:	48 98                	cltq   
  800420d3f4:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3f8:	48 89 c1             	mov    %rax,%rcx
  800420d3fb:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d3ff:	48 01 c8             	add    %rcx,%rax
  800420d402:	48 01 d0             	add    %rdx,%rax
  800420d405:	48 83 c0 08          	add    $0x8,%rax
  800420d409:	48 8b 00             	mov    (%rax),%rax
  800420d40c:	48 89 c7             	mov    %rax,%rdi
  800420d40f:	48 b8 77 8f 20 04 80 	movabs $0x8004208f77,%rax
  800420d416:	00 00 00 
  800420d419:	ff d0                	callq  *%rax
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420d41b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d41f:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
			curenv->env_id, fault_va, tf->tf_rip);
  800420d426:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d42d:	00 00 00 
  800420d430:	ff d0                	callq  *%rax
  800420d432:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d439:	00 00 00 
  800420d43c:	48 98                	cltq   
  800420d43e:	48 c1 e0 03          	shl    $0x3,%rax
  800420d442:	48 89 c1             	mov    %rax,%rcx
  800420d445:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d449:	48 01 c8             	add    %rcx,%rax
  800420d44c:	48 01 d0             	add    %rdx,%rax
  800420d44f:	48 83 c0 08          	add    $0x8,%rax
  800420d453:	48 8b 00             	mov    (%rax),%rax
		
		env_run(curenv);
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420d456:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420d45c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d460:	48 89 d9             	mov    %rbx,%rcx
  800420d463:	89 c6                	mov    %eax,%esi
  800420d465:	48 bf e8 e8 21 04 80 	movabs $0x800421e8e8,%rdi
  800420d46c:	00 00 00 
  800420d46f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d474:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  800420d47b:	00 00 00 
  800420d47e:	41 ff d0             	callq  *%r8
			curenv->env_id, fault_va, tf->tf_rip);
		print_trapframe(tf);
  800420d481:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420d485:	48 89 c7             	mov    %rax,%rdi
  800420d488:	48 b8 10 c6 20 04 80 	movabs $0x800420c610,%rax
  800420d48f:	00 00 00 
  800420d492:	ff d0                	callq  *%rax
		env_destroy(curenv);
  800420d494:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d49b:	00 00 00 
  800420d49e:	ff d0                	callq  *%rax
  800420d4a0:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d4a7:	00 00 00 
  800420d4aa:	48 98                	cltq   
  800420d4ac:	48 c1 e0 03          	shl    $0x3,%rax
  800420d4b0:	48 89 c1             	mov    %rax,%rcx
  800420d4b3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d4b7:	48 01 c8             	add    %rcx,%rax
  800420d4ba:	48 01 d0             	add    %rdx,%rax
  800420d4bd:	48 83 c0 08          	add    $0x8,%rax
  800420d4c1:	48 8b 00             	mov    (%rax),%rax
  800420d4c4:	48 89 c7             	mov    %rax,%rdi
  800420d4c7:	48 b8 ac 8d 20 04 80 	movabs $0x8004208dac,%rax
  800420d4ce:	00 00 00 
  800420d4d1:	ff d0                	callq  *%rax
    }
}
  800420d4d3:	48 83 c4 38          	add    $0x38,%rsp
  800420d4d7:	5b                   	pop    %rbx
  800420d4d8:	5d                   	pop    %rbp
  800420d4d9:	c3                   	retq   

000000800420d4da <XTRPX_divzero>:
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */

	TRAPHANDLER_NOEC(XTRPX_divzero, T_DIVIDE)
  800420d4da:	6a 00                	pushq  $0x0
  800420d4dc:	6a 00                	pushq  $0x0
  800420d4de:	e9 01 01 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d4e3:	90                   	nop

000000800420d4e4 <XTRPX_Debug>:
	TRAPHANDLER_NOEC(XTRPX_Debug, T_DEBUG)
  800420d4e4:	6a 00                	pushq  $0x0
  800420d4e6:	6a 01                	pushq  $0x1
  800420d4e8:	e9 f7 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d4ed:	90                   	nop

000000800420d4ee <XTRPX_NonMaskI>:
	TRAPHANDLER_NOEC(XTRPX_NonMaskI, T_NMI)
  800420d4ee:	6a 00                	pushq  $0x0
  800420d4f0:	6a 02                	pushq  $0x2
  800420d4f2:	e9 ed 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d4f7:	90                   	nop

000000800420d4f8 <XTRPX_Brkpt>:
	TRAPHANDLER_NOEC(XTRPX_Brkpt, T_BRKPT)
  800420d4f8:	6a 00                	pushq  $0x0
  800420d4fa:	6a 03                	pushq  $0x3
  800420d4fc:	e9 e3 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d501:	90                   	nop

000000800420d502 <XTRPX_OFlow>:
	TRAPHANDLER_NOEC(XTRPX_OFlow, T_OFLOW)
  800420d502:	6a 00                	pushq  $0x0
  800420d504:	6a 04                	pushq  $0x4
  800420d506:	e9 d9 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d50b:	90                   	nop

000000800420d50c <XTRPX_Bound>:
	TRAPHANDLER_NOEC(XTRPX_Bound, T_BOUND)
  800420d50c:	6a 00                	pushq  $0x0
  800420d50e:	6a 05                	pushq  $0x5
  800420d510:	e9 cf 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d515:	90                   	nop

000000800420d516 <XTRPX_Illop>:
	TRAPHANDLER_NOEC(XTRPX_Illop, T_ILLOP)
  800420d516:	6a 00                	pushq  $0x0
  800420d518:	6a 06                	pushq  $0x6
  800420d51a:	e9 c5 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d51f:	90                   	nop

000000800420d520 <XTRPX_Device>:
	TRAPHANDLER_NOEC(XTRPX_Device, T_DEVICE)
  800420d520:	6a 00                	pushq  $0x0
  800420d522:	6a 07                	pushq  $0x7
  800420d524:	e9 bb 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d529:	90                   	nop

000000800420d52a <XTRPX_DblFlt>:
	TRAPHANDLER(XTRPX_DblFlt, T_DBLFLT)
  800420d52a:	6a 08                	pushq  $0x8
  800420d52c:	e9 b3 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d531:	90                   	nop

000000800420d532 <XTRPX_Tss>:
	TRAPHANDLER(XTRPX_Tss, T_TSS)
  800420d532:	6a 0a                	pushq  $0xa
  800420d534:	e9 ab 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d539:	90                   	nop

000000800420d53a <XTRPX_Segnp>:
	TRAPHANDLER(XTRPX_Segnp, T_SEGNP)
  800420d53a:	6a 0b                	pushq  $0xb
  800420d53c:	e9 a3 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d541:	90                   	nop

000000800420d542 <XTRPX_Stack>:
	TRAPHANDLER(XTRPX_Stack, T_STACK)
  800420d542:	6a 0c                	pushq  $0xc
  800420d544:	e9 9b 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d549:	90                   	nop

000000800420d54a <XTRPX_Gpflt>:
	TRAPHANDLER(XTRPX_Gpflt, T_GPFLT)
  800420d54a:	6a 0d                	pushq  $0xd
  800420d54c:	e9 93 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d551:	90                   	nop

000000800420d552 <XTRPX_Pgflt>:
	TRAPHANDLER(XTRPX_Pgflt, T_PGFLT)
  800420d552:	6a 0e                	pushq  $0xe
  800420d554:	e9 8b 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d559:	90                   	nop

000000800420d55a <XTRPX_FpErr>:
	TRAPHANDLER_NOEC(XTRPX_FpErr, T_FPERR)
  800420d55a:	6a 00                	pushq  $0x0
  800420d55c:	6a 10                	pushq  $0x10
  800420d55e:	e9 81 00 00 00       	jmpq   800420d5e4 <_alltraps>
  800420d563:	90                   	nop

000000800420d564 <XTRPX_Align>:
	TRAPHANDLER(XTRPX_Align, T_ALIGN)
  800420d564:	6a 11                	pushq  $0x11
  800420d566:	eb 7c                	jmp    800420d5e4 <_alltraps>

000000800420d568 <XTRPX_Mchk>:
	TRAPHANDLER_NOEC(XTRPX_Mchk, T_MCHK)
  800420d568:	6a 00                	pushq  $0x0
  800420d56a:	6a 12                	pushq  $0x12
  800420d56c:	eb 76                	jmp    800420d5e4 <_alltraps>

000000800420d56e <XTRPX_SimdErr>:
	TRAPHANDLER_NOEC(XTRPX_SimdErr, T_SIMDERR)
  800420d56e:	6a 00                	pushq  $0x0
  800420d570:	6a 13                	pushq  $0x13
  800420d572:	eb 70                	jmp    800420d5e4 <_alltraps>

000000800420d574 <XTRPX_Syscall>:
	TRAPHANDLER_NOEC(XTRPX_Syscall, T_SYSCALL)
  800420d574:	6a 00                	pushq  $0x0
  800420d576:	6a 30                	pushq  $0x30
  800420d578:	eb 6a                	jmp    800420d5e4 <_alltraps>

000000800420d57a <XTRPX_Default>:
	TRAPHANDLER_NOEC(XTRPX_Default, T_DEFAULT)
  800420d57a:	6a 00                	pushq  $0x0
  800420d57c:	68 f4 01 00 00       	pushq  $0x1f4
  800420d581:	eb 61                	jmp    800420d5e4 <_alltraps>
  800420d583:	90                   	nop

000000800420d584 <XTRPX_IRQ0>:
	TRAPHANDLER_NOEC(XTRPX_IRQ0, IRQ_OFFSET+IRQ_TIMER)
  800420d584:	6a 00                	pushq  $0x0
  800420d586:	6a 20                	pushq  $0x20
  800420d588:	eb 5a                	jmp    800420d5e4 <_alltraps>

000000800420d58a <XTRPX_IRQ1>:
	TRAPHANDLER_NOEC(XTRPX_IRQ1, IRQ_OFFSET+IRQ_KBD)
  800420d58a:	6a 00                	pushq  $0x0
  800420d58c:	6a 21                	pushq  $0x21
  800420d58e:	eb 54                	jmp    800420d5e4 <_alltraps>

000000800420d590 <XTRPX_IRQ2>:
	TRAPHANDLER_NOEC(XTRPX_IRQ2, IRQ_OFFSET+2)
  800420d590:	6a 00                	pushq  $0x0
  800420d592:	6a 22                	pushq  $0x22
  800420d594:	eb 4e                	jmp    800420d5e4 <_alltraps>

000000800420d596 <XTRPX_IRQ3>:
	TRAPHANDLER_NOEC(XTRPX_IRQ3, IRQ_OFFSET+3)
  800420d596:	6a 00                	pushq  $0x0
  800420d598:	6a 23                	pushq  $0x23
  800420d59a:	eb 48                	jmp    800420d5e4 <_alltraps>

000000800420d59c <XTRPX_IRQ4>:
	TRAPHANDLER_NOEC(XTRPX_IRQ4, IRQ_OFFSET+IRQ_SERIAL)
  800420d59c:	6a 00                	pushq  $0x0
  800420d59e:	6a 24                	pushq  $0x24
  800420d5a0:	eb 42                	jmp    800420d5e4 <_alltraps>

000000800420d5a2 <XTRPX_IRQ5>:
	TRAPHANDLER_NOEC(XTRPX_IRQ5, IRQ_OFFSET+5)
  800420d5a2:	6a 00                	pushq  $0x0
  800420d5a4:	6a 25                	pushq  $0x25
  800420d5a6:	eb 3c                	jmp    800420d5e4 <_alltraps>

000000800420d5a8 <XTRPX_IRQ6>:
	TRAPHANDLER_NOEC(XTRPX_IRQ6, IRQ_OFFSET+6)
  800420d5a8:	6a 00                	pushq  $0x0
  800420d5aa:	6a 26                	pushq  $0x26
  800420d5ac:	eb 36                	jmp    800420d5e4 <_alltraps>

000000800420d5ae <XTRPX_IRQ7>:
	TRAPHANDLER_NOEC(XTRPX_IRQ7, IRQ_OFFSET+IRQ_SPURIOUS)
  800420d5ae:	6a 00                	pushq  $0x0
  800420d5b0:	6a 27                	pushq  $0x27
  800420d5b2:	eb 30                	jmp    800420d5e4 <_alltraps>

000000800420d5b4 <XTRPX_IRQ8>:
	TRAPHANDLER_NOEC(XTRPX_IRQ8, IRQ_OFFSET+8)
  800420d5b4:	6a 00                	pushq  $0x0
  800420d5b6:	6a 28                	pushq  $0x28
  800420d5b8:	eb 2a                	jmp    800420d5e4 <_alltraps>

000000800420d5ba <XTRPX_IRQ9>:
	TRAPHANDLER_NOEC(XTRPX_IRQ9, IRQ_OFFSET+9)
  800420d5ba:	6a 00                	pushq  $0x0
  800420d5bc:	6a 29                	pushq  $0x29
  800420d5be:	eb 24                	jmp    800420d5e4 <_alltraps>

000000800420d5c0 <XTRPX_IRQa>:
	TRAPHANDLER_NOEC(XTRPX_IRQa, IRQ_OFFSET+10)
  800420d5c0:	6a 00                	pushq  $0x0
  800420d5c2:	6a 2a                	pushq  $0x2a
  800420d5c4:	eb 1e                	jmp    800420d5e4 <_alltraps>

000000800420d5c6 <XTRPX_IRQb>:
	TRAPHANDLER_NOEC(XTRPX_IRQb, IRQ_OFFSET+11)
  800420d5c6:	6a 00                	pushq  $0x0
  800420d5c8:	6a 2b                	pushq  $0x2b
  800420d5ca:	eb 18                	jmp    800420d5e4 <_alltraps>

000000800420d5cc <XTRPX_IRQc>:
	TRAPHANDLER_NOEC(XTRPX_IRQc, IRQ_OFFSET+12)
  800420d5cc:	6a 00                	pushq  $0x0
  800420d5ce:	6a 2c                	pushq  $0x2c
  800420d5d0:	eb 12                	jmp    800420d5e4 <_alltraps>

000000800420d5d2 <XTRPX_IRQd>:
	TRAPHANDLER_NOEC(XTRPX_IRQd, IRQ_OFFSET+13)
  800420d5d2:	6a 00                	pushq  $0x0
  800420d5d4:	6a 2d                	pushq  $0x2d
  800420d5d6:	eb 0c                	jmp    800420d5e4 <_alltraps>

000000800420d5d8 <XTRPX_IRQe>:
	TRAPHANDLER_NOEC(XTRPX_IRQe, IRQ_OFFSET+IRQ_IDE)
  800420d5d8:	6a 00                	pushq  $0x0
  800420d5da:	6a 2e                	pushq  $0x2e
  800420d5dc:	eb 06                	jmp    800420d5e4 <_alltraps>

000000800420d5de <XTRPX_IRQf>:
	TRAPHANDLER_NOEC(XTRPX_IRQf, IRQ_OFFSET+15)
  800420d5de:	6a 00                	pushq  $0x0
  800420d5e0:	6a 2f                	pushq  $0x2f
  800420d5e2:	eb 00                	jmp    800420d5e4 <_alltraps>

000000800420d5e4 <_alltraps>:
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */
    _alltraps:
    	/* Since ES and DS registers can't be pushed in x86-64. So moving them to r15 first */
		xor %r15, %r15
  800420d5e4:	4d 31 ff             	xor    %r15,%r15
		movw %ds,%r15 
  800420d5e7:	66 41 8c df          	mov    %ds,%r15w
		pushq %r15
  800420d5eb:	41 57                	push   %r15
		movw %es, %r15
  800420d5ed:	66 41 8c c7          	mov    %es,%r15w
		pushq %r15
  800420d5f1:	41 57                	push   %r15
		/* Now push all registers onto the stack */
		PUSHA
  800420d5f3:	48 83 ec 78          	sub    $0x78,%rsp
  800420d5f7:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420d5fc:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420d601:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420d606:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420d60b:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420d610:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420d615:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420d61a:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420d61f:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420d624:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420d629:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420d62e:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420d633:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420d638:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420d63d:	4c 89 3c 24          	mov    %r15,(%rsp)
		/* Far pointer addressing*/
		mov %rsp, %rdi
  800420d641:	48 89 e7             	mov    %rsp,%rdi
		/* filling es and ds now */
		xor %r15, %r15
  800420d644:	4d 31 ff             	xor    %r15,%r15
		movw $(GD_KD), %r15
  800420d647:	66 41 c7 c7 10 00    	mov    $0x10,%r15w
		movw %r15, %es
  800420d64d:	41 8e c7             	mov    %r15d,%es
		movw %r15, %ds
  800420d650:	41 8e df             	mov    %r15d,%ds
		call trap
  800420d653:	e8 2c f7 ff ff       	callq  800420cd84 <trap>
		POPA_
  800420d658:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420d65c:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420d661:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420d666:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420d66b:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420d670:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420d675:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420d67a:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420d67f:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420d684:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420d689:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420d68e:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420d693:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420d698:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420d69d:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420d6a2:	48 83 c4 78          	add    $0x78,%rsp
		/*Now make the stack same as we got from CPU*/
		xor %r15, %r15
  800420d6a6:	4d 31 ff             	xor    %r15,%r15
		popq %r15
  800420d6a9:	41 5f                	pop    %r15
		movw %r15, %es
  800420d6ab:	41 8e c7             	mov    %r15d,%es
		popq %r15
  800420d6ae:	41 5f                	pop    %r15
		movw %r15, %ds
  800420d6b0:	41 8e df             	mov    %r15d,%ds
		iret 
  800420d6b3:	cf                   	iret   

000000800420d6b4 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420d6b4:	55                   	push   %rbp
  800420d6b5:	48 89 e5             	mov    %rsp,%rbp
  800420d6b8:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420d6bc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d6c0:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420d6c3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d6c7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420d6ca:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d6ce:	f0 87 02             	lock xchg %eax,(%rdx)
  800420d6d1:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420d6d4:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420d6d7:	c9                   	leaveq 
  800420d6d8:	c3                   	retq   

000000800420d6d9 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420d6d9:	55                   	push   %rbp
  800420d6da:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420d6dd:	48 bf 40 37 23 04 80 	movabs $0x8004233740,%rdi
  800420d6e4:	00 00 00 
  800420d6e7:	48 b8 fc 7f 21 04 80 	movabs $0x8004217ffc,%rax
  800420d6ee:	00 00 00 
  800420d6f1:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420d6f3:	f3 90                	pause  
}
  800420d6f5:	5d                   	pop    %rbp
  800420d6f6:	c3                   	retq   

000000800420d6f7 <vmxon>:


#ifndef VMM_GUEST
#include <vmm/vmx.h>
static int
vmxon() {
  800420d6f7:	55                   	push   %rbp
  800420d6f8:	48 89 e5             	mov    %rsp,%rbp
  800420d6fb:	48 83 ec 10          	sub    $0x10,%rsp
	int r;
	if(!thiscpu->is_vmx_root) {
  800420d6ff:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d706:	00 00 00 
  800420d709:	ff d0                	callq  *%rax
  800420d70b:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d712:	00 00 00 
  800420d715:	48 98                	cltq   
  800420d717:	48 c1 e0 03          	shl    $0x3,%rax
  800420d71b:	48 89 c1             	mov    %rax,%rcx
  800420d71e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d722:	48 01 c8             	add    %rcx,%rax
  800420d725:	48 01 d0             	add    %rdx,%rax
  800420d728:	48 83 c0 70          	add    $0x70,%rax
  800420d72c:	0f b6 40 08          	movzbl 0x8(%rax),%eax
  800420d730:	83 f0 01             	xor    $0x1,%eax
  800420d733:	84 c0                	test   %al,%al
  800420d735:	74 5a                	je     800420d791 <vmxon+0x9a>
		r = vmx_init_vmxon();
  800420d737:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d73c:	48 ba d0 9d 21 04 80 	movabs $0x8004219dd0,%rdx
  800420d743:	00 00 00 
  800420d746:	ff d2                	callq  *%rdx
  800420d748:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(r < 0) {
  800420d74b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d74f:	79 25                	jns    800420d776 <vmxon+0x7f>
			cprintf("Error executing VMXON: %e\n", r);
  800420d751:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d754:	89 c6                	mov    %eax,%esi
  800420d756:	48 bf 00 eb 21 04 80 	movabs $0x800421eb00,%rdi
  800420d75d:	00 00 00 
  800420d760:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d765:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420d76c:	00 00 00 
  800420d76f:	ff d2                	callq  *%rdx
			return r;
  800420d771:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d774:	eb 20                	jmp    800420d796 <vmxon+0x9f>
		}
		cprintf("VMXON\n");
  800420d776:	48 bf 1b eb 21 04 80 	movabs $0x800421eb1b,%rdi
  800420d77d:	00 00 00 
  800420d780:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d785:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420d78c:	00 00 00 
  800420d78f:	ff d2                	callq  *%rdx
	}
	return 0;
  800420d791:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d796:	c9                   	leaveq 
  800420d797:	c3                   	retq   

000000800420d798 <sched_yield>:
#endif

// Choose a user environment to run and run it.
void
sched_yield(void)
{	
  800420d798:	55                   	push   %rbp
  800420d799:	48 89 e5             	mov    %rsp,%rbp
  800420d79c:	48 83 ec 10          	sub    $0x10,%rsp
		// no runnable environments, simply drop through to the code
		// below to halt the cpu.	
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
  800420d7a0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420d7a7:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  800420d7ae:	e9 93 02 00 00       	jmpq   800420da46 <sched_yield+0x2ae>
			if(envs[(env_counter+i)%NENV].env_status == ENV_RUNNABLE){
  800420d7b3:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  800420d7ba:	00 00 00 
  800420d7bd:	48 8b 10             	mov    (%rax),%rdx
  800420d7c0:	48 b8 98 e2 3a 04 80 	movabs $0x80043ae298,%rax
  800420d7c7:	00 00 00 
  800420d7ca:	8b 08                	mov    (%rax),%ecx
  800420d7cc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d7cf:	01 c8                	add    %ecx,%eax
  800420d7d1:	89 c0                	mov    %eax,%eax
  800420d7d3:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420d7d8:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d7df:	48 01 d0             	add    %rdx,%rax
  800420d7e2:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d7e8:	83 f8 02             	cmp    $0x2,%eax
  800420d7eb:	0f 85 51 02 00 00    	jne    800420da42 <sched_yield+0x2aa>
				env_counter = (env_counter+i)%NENV;
  800420d7f1:	48 b8 98 e2 3a 04 80 	movabs $0x80043ae298,%rax
  800420d7f8:	00 00 00 
  800420d7fb:	8b 10                	mov    (%rax),%edx
  800420d7fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d800:	01 d0                	add    %edx,%eax
  800420d802:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420d807:	89 c2                	mov    %eax,%edx
  800420d809:	48 b8 98 e2 3a 04 80 	movabs $0x80043ae298,%rax
  800420d810:	00 00 00 
  800420d813:	89 10                	mov    %edx,(%rax)
				//cprintf("going to run now = [%d],status is [%d]\n",env_counter,envs[env_counter].env_status);
			#ifndef VMM_GUEST
				if(envs[env_counter].env_type==ENV_TYPE_GUEST)
  800420d815:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  800420d81c:	00 00 00 
  800420d81f:	48 8b 10             	mov    (%rax),%rdx
  800420d822:	48 b8 98 e2 3a 04 80 	movabs $0x80043ae298,%rax
  800420d829:	00 00 00 
  800420d82c:	8b 00                	mov    (%rax),%eax
  800420d82e:	89 c0                	mov    %eax,%eax
  800420d830:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d837:	48 01 d0             	add    %rdx,%rax
  800420d83a:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420d840:	83 f8 03             	cmp    $0x3,%eax
  800420d843:	0f 85 c3 01 00 00    	jne    800420da0c <sched_yield+0x274>
				{
					if(curenv != NULL){
  800420d849:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d850:	00 00 00 
  800420d853:	ff d0                	callq  *%rax
  800420d855:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d85c:	00 00 00 
  800420d85f:	48 98                	cltq   
  800420d861:	48 c1 e0 03          	shl    $0x3,%rax
  800420d865:	48 89 c1             	mov    %rax,%rcx
  800420d868:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d86c:	48 01 c8             	add    %rcx,%rax
  800420d86f:	48 01 d0             	add    %rdx,%rax
  800420d872:	48 83 c0 08          	add    $0x8,%rax
  800420d876:	48 8b 00             	mov    (%rax),%rax
  800420d879:	48 85 c0             	test   %rax,%rax
  800420d87c:	74 75                	je     800420d8f3 <sched_yield+0x15b>
				    	if(curenv->env_status==ENV_RUNNING)
  800420d87e:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d885:	00 00 00 
  800420d888:	ff d0                	callq  *%rax
  800420d88a:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d891:	00 00 00 
  800420d894:	48 98                	cltq   
  800420d896:	48 c1 e0 03          	shl    $0x3,%rax
  800420d89a:	48 89 c1             	mov    %rax,%rcx
  800420d89d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d8a1:	48 01 c8             	add    %rcx,%rax
  800420d8a4:	48 01 d0             	add    %rdx,%rax
  800420d8a7:	48 83 c0 08          	add    $0x8,%rax
  800420d8ab:	48 8b 00             	mov    (%rax),%rax
  800420d8ae:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d8b4:	83 f8 03             	cmp    $0x3,%eax
  800420d8b7:	75 3a                	jne    800420d8f3 <sched_yield+0x15b>
					    	curenv->env_status=ENV_RUNNABLE;
  800420d8b9:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d8c0:	00 00 00 
  800420d8c3:	ff d0                	callq  *%rax
  800420d8c5:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d8cc:	00 00 00 
  800420d8cf:	48 98                	cltq   
  800420d8d1:	48 c1 e0 03          	shl    $0x3,%rax
  800420d8d5:	48 89 c1             	mov    %rax,%rcx
  800420d8d8:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d8dc:	48 01 c8             	add    %rcx,%rax
  800420d8df:	48 01 d0             	add    %rdx,%rax
  800420d8e2:	48 83 c0 08          	add    $0x8,%rax
  800420d8e6:	48 8b 00             	mov    (%rax),%rax
  800420d8e9:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420d8f0:	00 00 00 
				    }
				    curenv = &envs[env_counter];
  800420d8f3:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d8fa:	00 00 00 
  800420d8fd:	ff d0                	callq  *%rax
  800420d8ff:	48 ba 58 d2 3a 04 80 	movabs $0x80043ad258,%rdx
  800420d906:	00 00 00 
  800420d909:	48 8b 0a             	mov    (%rdx),%rcx
  800420d90c:	48 ba 98 e2 3a 04 80 	movabs $0x80043ae298,%rdx
  800420d913:	00 00 00 
  800420d916:	8b 12                	mov    (%rdx),%edx
  800420d918:	89 d2                	mov    %edx,%edx
  800420d91a:	48 69 d2 68 01 00 00 	imul   $0x168,%rdx,%rdx
  800420d921:	48 01 ca             	add    %rcx,%rdx
  800420d924:	48 b9 20 00 3b 04 80 	movabs $0x80043b0020,%rcx
  800420d92b:	00 00 00 
  800420d92e:	48 98                	cltq   
  800420d930:	48 c1 e0 03          	shl    $0x3,%rax
  800420d934:	48 89 c6             	mov    %rax,%rsi
  800420d937:	48 c1 e6 04          	shl    $0x4,%rsi
  800420d93b:	48 01 f0             	add    %rsi,%rax
  800420d93e:	48 01 c8             	add    %rcx,%rax
  800420d941:	48 83 c0 08          	add    $0x8,%rax
  800420d945:	48 89 10             	mov    %rdx,(%rax)
				    curenv->env_status = ENV_RUNNING;
  800420d948:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d94f:	00 00 00 
  800420d952:	ff d0                	callq  *%rax
  800420d954:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d95b:	00 00 00 
  800420d95e:	48 98                	cltq   
  800420d960:	48 c1 e0 03          	shl    $0x3,%rax
  800420d964:	48 89 c1             	mov    %rax,%rcx
  800420d967:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d96b:	48 01 c8             	add    %rcx,%rax
  800420d96e:	48 01 d0             	add    %rdx,%rax
  800420d971:	48 83 c0 08          	add    $0x8,%rax
  800420d975:	48 8b 00             	mov    (%rax),%rax
  800420d978:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  800420d97f:	00 00 00 
				    curenv->env_runs++;
  800420d982:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420d989:	00 00 00 
  800420d98c:	ff d0                	callq  *%rax
  800420d98e:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420d995:	00 00 00 
  800420d998:	48 98                	cltq   
  800420d99a:	48 c1 e0 03          	shl    $0x3,%rax
  800420d99e:	48 89 c1             	mov    %rax,%rcx
  800420d9a1:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d9a5:	48 01 c8             	add    %rcx,%rax
  800420d9a8:	48 01 d0             	add    %rdx,%rax
  800420d9ab:	48 83 c0 08          	add    $0x8,%rax
  800420d9af:	48 8b 00             	mov    (%rax),%rax
  800420d9b2:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  800420d9b8:	83 c2 01             	add    $0x1,%edx
  800420d9bb:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
					if(!vmxon())
  800420d9c1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d9c6:	48 ba f7 d6 20 04 80 	movabs $0x800420d6f7,%rdx
  800420d9cd:	00 00 00 
  800420d9d0:	ff d2                	callq  *%rdx
  800420d9d2:	85 c0                	test   %eax,%eax
  800420d9d4:	75 6a                	jne    800420da40 <sched_yield+0x2a8>
				    	vmx_vmrun(&envs[env_counter]);
  800420d9d6:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  800420d9dd:	00 00 00 
  800420d9e0:	48 8b 10             	mov    (%rax),%rdx
  800420d9e3:	48 b8 98 e2 3a 04 80 	movabs $0x80043ae298,%rax
  800420d9ea:	00 00 00 
  800420d9ed:	8b 00                	mov    (%rax),%eax
  800420d9ef:	89 c0                	mov    %eax,%eax
  800420d9f1:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d9f8:	48 01 d0             	add    %rdx,%rax
  800420d9fb:	48 89 c7             	mov    %rax,%rdi
  800420d9fe:	48 b8 2a c0 21 04 80 	movabs $0x800421c02a,%rax
  800420da05:	00 00 00 
  800420da08:	ff d0                	callq  *%rax
				else
			#endif					
				{
					env_run(&envs[env_counter]);
				}
				break;
  800420da0a:	eb 47                	jmp    800420da53 <sched_yield+0x2bb>
				    	vmx_vmrun(&envs[env_counter]);
				}
				else
			#endif					
				{
					env_run(&envs[env_counter]);
  800420da0c:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  800420da13:	00 00 00 
  800420da16:	48 8b 10             	mov    (%rax),%rdx
  800420da19:	48 b8 98 e2 3a 04 80 	movabs $0x80043ae298,%rax
  800420da20:	00 00 00 
  800420da23:	8b 00                	mov    (%rax),%eax
  800420da25:	89 c0                	mov    %eax,%eax
  800420da27:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420da2e:	48 01 d0             	add    %rdx,%rax
  800420da31:	48 89 c7             	mov    %rax,%rdi
  800420da34:	48 b8 77 8f 20 04 80 	movabs $0x8004208f77,%rax
  800420da3b:	00 00 00 
  800420da3e:	ff d0                	callq  *%rax
				}
				break;
  800420da40:	eb 11                	jmp    800420da53 <sched_yield+0x2bb>
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420da42:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420da46:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420da4d:	0f 86 60 fd ff ff    	jbe    800420d7b3 <sched_yield+0x1b>
				}
				break;
			}
		}
		//cprintf("envcounter2 = [%d]\n",env_counter);
		if(curenv && curenv->env_status == ENV_RUNNING){
  800420da53:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420da5a:	00 00 00 
  800420da5d:	ff d0                	callq  *%rax
  800420da5f:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420da66:	00 00 00 
  800420da69:	48 98                	cltq   
  800420da6b:	48 c1 e0 03          	shl    $0x3,%rax
  800420da6f:	48 89 c1             	mov    %rax,%rcx
  800420da72:	48 c1 e1 04          	shl    $0x4,%rcx
  800420da76:	48 01 c8             	add    %rcx,%rax
  800420da79:	48 01 d0             	add    %rdx,%rax
  800420da7c:	48 83 c0 08          	add    $0x8,%rax
  800420da80:	48 8b 00             	mov    (%rax),%rax
  800420da83:	48 85 c0             	test   %rax,%rax
  800420da86:	0f 84 58 01 00 00    	je     800420dbe4 <sched_yield+0x44c>
  800420da8c:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420da93:	00 00 00 
  800420da96:	ff d0                	callq  *%rax
  800420da98:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420da9f:	00 00 00 
  800420daa2:	48 98                	cltq   
  800420daa4:	48 c1 e0 03          	shl    $0x3,%rax
  800420daa8:	48 89 c1             	mov    %rax,%rcx
  800420daab:	48 c1 e1 04          	shl    $0x4,%rcx
  800420daaf:	48 01 c8             	add    %rcx,%rax
  800420dab2:	48 01 d0             	add    %rdx,%rax
  800420dab5:	48 83 c0 08          	add    $0x8,%rax
  800420dab9:	48 8b 00             	mov    (%rax),%rax
  800420dabc:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420dac2:	83 f8 03             	cmp    $0x3,%eax
  800420dac5:	0f 85 19 01 00 00    	jne    800420dbe4 <sched_yield+0x44c>
		#ifndef VMM_GUEST
			if(curenv->env_type==ENV_TYPE_GUEST)
  800420dacb:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420dad2:	00 00 00 
  800420dad5:	ff d0                	callq  *%rax
  800420dad7:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420dade:	00 00 00 
  800420dae1:	48 98                	cltq   
  800420dae3:	48 c1 e0 03          	shl    $0x3,%rax
  800420dae7:	48 89 c1             	mov    %rax,%rcx
  800420daea:	48 c1 e1 04          	shl    $0x4,%rcx
  800420daee:	48 01 c8             	add    %rcx,%rax
  800420daf1:	48 01 d0             	add    %rdx,%rax
  800420daf4:	48 83 c0 08          	add    $0x8,%rax
  800420daf8:	48 8b 00             	mov    (%rax),%rax
  800420dafb:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420db01:	83 f8 03             	cmp    $0x3,%eax
  800420db04:	0f 85 99 00 00 00    	jne    800420dba3 <sched_yield+0x40b>
			{
				curenv->env_runs++;
  800420db0a:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420db11:	00 00 00 
  800420db14:	ff d0                	callq  *%rax
  800420db16:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420db1d:	00 00 00 
  800420db20:	48 98                	cltq   
  800420db22:	48 c1 e0 03          	shl    $0x3,%rax
  800420db26:	48 89 c1             	mov    %rax,%rcx
  800420db29:	48 c1 e1 04          	shl    $0x4,%rcx
  800420db2d:	48 01 c8             	add    %rcx,%rax
  800420db30:	48 01 d0             	add    %rdx,%rax
  800420db33:	48 83 c0 08          	add    $0x8,%rax
  800420db37:	48 8b 00             	mov    (%rax),%rax
  800420db3a:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  800420db40:	83 c2 01             	add    $0x1,%edx
  800420db43:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
				if(!vmxon())
  800420db49:	b8 00 00 00 00       	mov    $0x0,%eax
  800420db4e:	48 ba f7 d6 20 04 80 	movabs $0x800420d6f7,%rdx
  800420db55:	00 00 00 
  800420db58:	ff d2                	callq  *%rdx
  800420db5a:	85 c0                	test   %eax,%eax
  800420db5c:	0f 85 80 00 00 00    	jne    800420dbe2 <sched_yield+0x44a>
					vmx_vmrun(curenv);
  800420db62:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420db69:	00 00 00 
  800420db6c:	ff d0                	callq  *%rax
  800420db6e:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420db75:	00 00 00 
  800420db78:	48 98                	cltq   
  800420db7a:	48 c1 e0 03          	shl    $0x3,%rax
  800420db7e:	48 89 c1             	mov    %rax,%rcx
  800420db81:	48 c1 e1 04          	shl    $0x4,%rcx
  800420db85:	48 01 c8             	add    %rcx,%rax
  800420db88:	48 01 d0             	add    %rdx,%rax
  800420db8b:	48 83 c0 08          	add    $0x8,%rax
  800420db8f:	48 8b 00             	mov    (%rax),%rax
  800420db92:	48 89 c7             	mov    %rax,%rdi
  800420db95:	48 b8 2a c0 21 04 80 	movabs $0x800421c02a,%rax
  800420db9c:	00 00 00 
  800420db9f:	ff d0                	callq  *%rax
			}
		}
		//cprintf("envcounter2 = [%d]\n",env_counter);
		if(curenv && curenv->env_status == ENV_RUNNING){
		#ifndef VMM_GUEST
			if(curenv->env_type==ENV_TYPE_GUEST)
  800420dba1:	eb 4d                	jmp    800420dbf0 <sched_yield+0x458>
					vmx_vmrun(curenv);
			}
			else
		#endif		
			{
				env_run(curenv);
  800420dba3:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420dbaa:	00 00 00 
  800420dbad:	ff d0                	callq  *%rax
  800420dbaf:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420dbb6:	00 00 00 
  800420dbb9:	48 98                	cltq   
  800420dbbb:	48 c1 e0 03          	shl    $0x3,%rax
  800420dbbf:	48 89 c1             	mov    %rax,%rcx
  800420dbc2:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dbc6:	48 01 c8             	add    %rcx,%rax
  800420dbc9:	48 01 d0             	add    %rdx,%rax
  800420dbcc:	48 83 c0 08          	add    $0x8,%rax
  800420dbd0:	48 8b 00             	mov    (%rax),%rax
  800420dbd3:	48 89 c7             	mov    %rax,%rdi
  800420dbd6:	48 b8 77 8f 20 04 80 	movabs $0x8004208f77,%rax
  800420dbdd:	00 00 00 
  800420dbe0:	ff d0                	callq  *%rax
			}
		}
		//cprintf("envcounter2 = [%d]\n",env_counter);
		if(curenv && curenv->env_status == ENV_RUNNING){
		#ifndef VMM_GUEST
			if(curenv->env_type==ENV_TYPE_GUEST)
  800420dbe2:	eb 0c                	jmp    800420dbf0 <sched_yield+0x458>
			{
				env_run(curenv);
			}
		}
		else{
			sched_halt();	
  800420dbe4:	48 b8 f2 db 20 04 80 	movabs $0x800420dbf2,%rax
  800420dbeb:	00 00 00 
  800420dbee:	ff d0                	callq  *%rax
		}
	}
  800420dbf0:	c9                   	leaveq 
  800420dbf1:	c3                   	retq   

000000800420dbf2 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
	{
  800420dbf2:	55                   	push   %rbp
  800420dbf3:	48 89 e5             	mov    %rsp,%rbp
  800420dbf6:	48 83 ec 20          	sub    $0x20,%rsp
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420dbfa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420dc01:	eb 79                	jmp    800420dc7c <sched_halt+0x8a>
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420dc03:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  800420dc0a:	00 00 00 
  800420dc0d:	48 8b 10             	mov    (%rax),%rdx
  800420dc10:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dc13:	48 98                	cltq   
  800420dc15:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dc1c:	48 01 d0             	add    %rdx,%rax
  800420dc1f:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420dc25:	83 f8 02             	cmp    $0x2,%eax
  800420dc28:	74 5f                	je     800420dc89 <sched_halt+0x97>
				 envs[i].env_status == ENV_RUNNING ||
  800420dc2a:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  800420dc31:	00 00 00 
  800420dc34:	48 8b 10             	mov    (%rax),%rdx
  800420dc37:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dc3a:	48 98                	cltq   
  800420dc3c:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dc43:	48 01 d0             	add    %rdx,%rax
  800420dc46:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420dc4c:	83 f8 03             	cmp    $0x3,%eax
  800420dc4f:	74 38                	je     800420dc89 <sched_halt+0x97>
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
  800420dc51:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  800420dc58:	00 00 00 
  800420dc5b:	48 8b 10             	mov    (%rax),%rdx
  800420dc5e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dc61:	48 98                	cltq   
  800420dc63:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420dc6a:	48 01 d0             	add    %rdx,%rax
  800420dc6d:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
  800420dc73:	83 f8 01             	cmp    $0x1,%eax
  800420dc76:	74 11                	je     800420dc89 <sched_halt+0x97>
	{
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420dc78:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420dc7c:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420dc83:	0f 8e 7a ff ff ff    	jle    800420dc03 <sched_halt+0x11>
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
				break;
		}
		if (i == NENV) {
  800420dc89:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420dc90:	75 2e                	jne    800420dcc0 <sched_halt+0xce>
			cprintf("No runnable environments in the system!\n");
  800420dc92:	48 bf 28 eb 21 04 80 	movabs $0x800421eb28,%rdi
  800420dc99:	00 00 00 
  800420dc9c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dca1:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420dca8:	00 00 00 
  800420dcab:	ff d2                	callq  *%rdx
			while (1)
				monitor(NULL);
  800420dcad:	bf 00 00 00 00       	mov    $0x0,%edi
  800420dcb2:	48 b8 4c 1b 20 04 80 	movabs $0x8004201b4c,%rax
  800420dcb9:	00 00 00 
  800420dcbc:	ff d0                	callq  *%rax
  800420dcbe:	eb ed                	jmp    800420dcad <sched_halt+0xbb>
		}
	
		// Mark that no environment is running on this CPU
		curenv = NULL;
  800420dcc0:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420dcc7:	00 00 00 
  800420dcca:	ff d0                	callq  *%rax
  800420dccc:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420dcd3:	00 00 00 
  800420dcd6:	48 98                	cltq   
  800420dcd8:	48 c1 e0 03          	shl    $0x3,%rax
  800420dcdc:	48 89 c1             	mov    %rax,%rcx
  800420dcdf:	48 c1 e1 04          	shl    $0x4,%rcx
  800420dce3:	48 01 c8             	add    %rcx,%rax
  800420dce6:	48 01 d0             	add    %rdx,%rax
  800420dce9:	48 83 c0 08          	add    $0x8,%rax
  800420dced:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		lcr3(PADDR(boot_pml4e));
  800420dcf4:	48 b8 90 e7 3a 04 80 	movabs $0x80043ae790,%rax
  800420dcfb:	00 00 00 
  800420dcfe:	48 8b 00             	mov    (%rax),%rax
  800420dd01:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420dd05:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420dd0c:	00 00 00 
  800420dd0f:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420dd13:	77 32                	ja     800420dd47 <sched_halt+0x155>
  800420dd15:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd19:	48 89 c1             	mov    %rax,%rcx
  800420dd1c:	48 ba 58 eb 21 04 80 	movabs $0x800421eb58,%rdx
  800420dd23:	00 00 00 
  800420dd26:	be 79 00 00 00       	mov    $0x79,%esi
  800420dd2b:	48 bf 7c eb 21 04 80 	movabs $0x800421eb7c,%rdi
  800420dd32:	00 00 00 
  800420dd35:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dd3a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420dd41:	00 00 00 
  800420dd44:	41 ff d0             	callq  *%r8
  800420dd47:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420dd4e:	ff ff ff 
  800420dd51:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd55:	48 01 d0             	add    %rdx,%rax
  800420dd58:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420dd5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dd60:	0f 22 d8             	mov    %rax,%cr3
	
		// Mark that this CPU is in the HALT state, so that when
		// timer interupts come in, we know we should re-acquire the
		// big kernel lock
		xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420dd63:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420dd6a:	00 00 00 
  800420dd6d:	ff d0                	callq  *%rax
  800420dd6f:	48 98                	cltq   
  800420dd71:	48 c1 e0 03          	shl    $0x3,%rax
  800420dd75:	48 89 c2             	mov    %rax,%rdx
  800420dd78:	48 c1 e2 04          	shl    $0x4,%rdx
  800420dd7c:	48 01 d0             	add    %rdx,%rax
  800420dd7f:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420dd86:	00 00 00 
  800420dd89:	48 01 d0             	add    %rdx,%rax
  800420dd8c:	48 83 c0 04          	add    $0x4,%rax
  800420dd90:	be 02 00 00 00       	mov    $0x2,%esi
  800420dd95:	48 89 c7             	mov    %rax,%rdi
  800420dd98:	48 b8 b4 d6 20 04 80 	movabs $0x800420d6b4,%rax
  800420dd9f:	00 00 00 
  800420dda2:	ff d0                	callq  *%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
  800420dda4:	48 b8 d9 d6 20 04 80 	movabs $0x800420d6d9,%rax
  800420ddab:	00 00 00 
  800420ddae:	ff d0                	callq  *%rax
			"movq %0, %%rsp\n"
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420ddb0:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420ddb7:	00 00 00 
  800420ddba:	ff d0                	callq  *%rax
  800420ddbc:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420ddc3:	00 00 00 
  800420ddc6:	48 98                	cltq   
  800420ddc8:	48 c1 e0 03          	shl    $0x3,%rax
  800420ddcc:	48 89 c1             	mov    %rax,%rcx
  800420ddcf:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ddd3:	48 01 c8             	add    %rcx,%rax
  800420ddd6:	48 01 d0             	add    %rdx,%rax
  800420ddd9:	48 83 c0 10          	add    $0x10,%rax
  800420dddd:	48 8b 40 04          	mov    0x4(%rax),%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
	
		// Reset stack pointer, enable interrupts and then halt.
		asm volatile (
  800420dde1:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420dde8:	48 89 c4             	mov    %rax,%rsp
  800420ddeb:	6a 00                	pushq  $0x0
  800420dded:	6a 00                	pushq  $0x0
  800420ddef:	fb                   	sti    
  800420ddf0:	f4                   	hlt    
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
	}
  800420ddf1:	c9                   	leaveq 
  800420ddf2:	c3                   	retq   

000000800420ddf3 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800420ddf3:	55                   	push   %rbp
  800420ddf4:	48 89 e5             	mov    %rsp,%rbp
  800420ddf7:	48 83 ec 08          	sub    $0x8,%rsp
  800420ddfb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800420ddff:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420de03:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  800420de0a:	00 00 00 
  800420de0d:	48 8b 00             	mov    (%rax),%rax
  800420de10:	48 29 c2             	sub    %rax,%rdx
  800420de13:	48 89 d0             	mov    %rdx,%rax
  800420de16:	48 c1 f8 04          	sar    $0x4,%rax
}
  800420de1a:	c9                   	leaveq 
  800420de1b:	c3                   	retq   

000000800420de1c <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800420de1c:	55                   	push   %rbp
  800420de1d:	48 89 e5             	mov    %rsp,%rbp
  800420de20:	48 83 ec 08          	sub    $0x8,%rsp
  800420de24:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800420de28:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de2c:	48 89 c7             	mov    %rax,%rdi
  800420de2f:	48 b8 f3 dd 20 04 80 	movabs $0x800420ddf3,%rax
  800420de36:	00 00 00 
  800420de39:	ff d0                	callq  *%rax
  800420de3b:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800420de3f:	c9                   	leaveq 
  800420de40:	c3                   	retq   

000000800420de41 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  800420de41:	55                   	push   %rbp
  800420de42:	48 89 e5             	mov    %rsp,%rbp
  800420de45:	48 83 ec 20          	sub    $0x20,%rsp
  800420de49:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800420de4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420de51:	48 89 c7             	mov    %rax,%rdi
  800420de54:	48 b8 1c de 20 04 80 	movabs $0x800420de1c,%rax
  800420de5b:	00 00 00 
  800420de5e:	ff d0                	callq  *%rax
  800420de60:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420de64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de68:	48 c1 e8 0c          	shr    $0xc,%rax
  800420de6c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420de6f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420de72:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  800420de79:	00 00 00 
  800420de7c:	48 8b 00             	mov    (%rax),%rax
  800420de7f:	48 39 c2             	cmp    %rax,%rdx
  800420de82:	72 32                	jb     800420deb6 <page2kva+0x75>
  800420de84:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420de88:	48 89 c1             	mov    %rax,%rcx
  800420de8b:	48 ba 90 eb 21 04 80 	movabs $0x800421eb90,%rdx
  800420de92:	00 00 00 
  800420de95:	be 5b 00 00 00       	mov    $0x5b,%esi
  800420de9a:	48 bf b3 eb 21 04 80 	movabs $0x800421ebb3,%rdi
  800420dea1:	00 00 00 
  800420dea4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dea9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420deb0:	00 00 00 
  800420deb3:	41 ff d0             	callq  *%r8
  800420deb6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420debd:	00 00 00 
  800420dec0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420dec4:	48 01 d0             	add    %rdx,%rax
}
  800420dec7:	c9                   	leaveq 
  800420dec8:	c3                   	retq   

000000800420dec9 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420dec9:	55                   	push   %rbp
  800420deca:	48 89 e5             	mov    %rsp,%rbp
  800420decd:	48 83 ec 10          	sub    $0x10,%rsp
  800420ded1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420ded5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, (const void *)s, len, PTE_U );
  800420ded9:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420dee0:	00 00 00 
  800420dee3:	ff d0                	callq  *%rax
  800420dee5:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420deec:	00 00 00 
  800420deef:	48 98                	cltq   
  800420def1:	48 c1 e0 03          	shl    $0x3,%rax
  800420def5:	48 89 c1             	mov    %rax,%rcx
  800420def8:	48 c1 e1 04          	shl    $0x4,%rcx
  800420defc:	48 01 c8             	add    %rcx,%rax
  800420deff:	48 01 d0             	add    %rdx,%rax
  800420df02:	48 83 c0 08          	add    $0x8,%rax
  800420df06:	48 8b 00             	mov    (%rax),%rax
  800420df09:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420df0d:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420df11:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420df16:	48 89 c7             	mov    %rax,%rdi
  800420df19:	48 b8 57 3d 20 04 80 	movabs $0x8004203d57,%rax
  800420df20:	00 00 00 
  800420df23:	ff d0                	callq  *%rax
	
	// Print the string supplied by the user.
	
	cprintf("%.*s", len, s);
  800420df25:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420df29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420df2d:	48 89 c6             	mov    %rax,%rsi
  800420df30:	48 bf c1 eb 21 04 80 	movabs $0x800421ebc1,%rdi
  800420df37:	00 00 00 
  800420df3a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420df3f:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420df46:	00 00 00 
  800420df49:	ff d1                	callq  *%rcx
}
  800420df4b:	c9                   	leaveq 
  800420df4c:	c3                   	retq   

000000800420df4d <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420df4d:	55                   	push   %rbp
  800420df4e:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420df51:	48 b8 1e 11 20 04 80 	movabs $0x800420111e,%rax
  800420df58:	00 00 00 
  800420df5b:	ff d0                	callq  *%rax
}
  800420df5d:	5d                   	pop    %rbp
  800420df5e:	c3                   	retq   

000000800420df5f <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420df5f:	55                   	push   %rbp
  800420df60:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420df63:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420df6a:	00 00 00 
  800420df6d:	ff d0                	callq  *%rax
  800420df6f:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420df76:	00 00 00 
  800420df79:	48 98                	cltq   
  800420df7b:	48 c1 e0 03          	shl    $0x3,%rax
  800420df7f:	48 89 c1             	mov    %rax,%rcx
  800420df82:	48 c1 e1 04          	shl    $0x4,%rcx
  800420df86:	48 01 c8             	add    %rcx,%rax
  800420df89:	48 01 d0             	add    %rdx,%rax
  800420df8c:	48 83 c0 08          	add    $0x8,%rax
  800420df90:	48 8b 00             	mov    (%rax),%rax
  800420df93:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420df99:	5d                   	pop    %rbp
  800420df9a:	c3                   	retq   

000000800420df9b <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420df9b:	55                   	push   %rbp
  800420df9c:	48 89 e5             	mov    %rsp,%rbp
  800420df9f:	48 83 ec 20          	sub    $0x20,%rsp
  800420dfa3:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420dfa6:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420dfaa:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420dfad:	ba 01 00 00 00       	mov    $0x1,%edx
  800420dfb2:	48 89 ce             	mov    %rcx,%rsi
  800420dfb5:	89 c7                	mov    %eax,%edi
  800420dfb7:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420dfbe:	00 00 00 
  800420dfc1:	ff d0                	callq  *%rax
  800420dfc3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420dfc6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420dfca:	79 05                	jns    800420dfd1 <sys_env_destroy+0x36>
		return r;
  800420dfcc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420dfcf:	eb 18                	jmp    800420dfe9 <sys_env_destroy+0x4e>
	env_destroy(e);
  800420dfd1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dfd5:	48 89 c7             	mov    %rax,%rdi
  800420dfd8:	48 b8 ac 8d 20 04 80 	movabs $0x8004208dac,%rax
  800420dfdf:	00 00 00 
  800420dfe2:	ff d0                	callq  *%rax
	return 0;
  800420dfe4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dfe9:	c9                   	leaveq 
  800420dfea:	c3                   	retq   

000000800420dfeb <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420dfeb:	55                   	push   %rbp
  800420dfec:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420dfef:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  800420dff6:	00 00 00 
  800420dff9:	ff d0                	callq  *%rax

000000800420dffb <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420dffb:	55                   	push   %rbp
  800420dffc:	48 89 e5             	mov    %rsp,%rbp
  800420dfff:	53                   	push   %rbx
  800420e000:	48 83 ec 18          	sub    $0x18,%rsp
	// from the current environment -- but tweaked so sys_exofork
	// will appear to return 0.

	// LAB 4: Your code here.
	struct Env *newenv_store;
	uint32_t  result = 0;
  800420e004:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	result= env_alloc(&newenv_store, curenv->env_id);
  800420e00b:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420e012:	00 00 00 
  800420e015:	ff d0                	callq  *%rax
  800420e017:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420e01e:	00 00 00 
  800420e021:	48 98                	cltq   
  800420e023:	48 c1 e0 03          	shl    $0x3,%rax
  800420e027:	48 89 c1             	mov    %rax,%rcx
  800420e02a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e02e:	48 01 c8             	add    %rcx,%rax
  800420e031:	48 01 d0             	add    %rdx,%rax
  800420e034:	48 83 c0 08          	add    $0x8,%rax
  800420e038:	48 8b 00             	mov    (%rax),%rax
  800420e03b:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420e041:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420e045:	89 d6                	mov    %edx,%esi
  800420e047:	48 89 c7             	mov    %rax,%rdi
  800420e04a:	48 b8 c1 83 20 04 80 	movabs $0x80042083c1,%rax
  800420e051:	00 00 00 
  800420e054:	ff d0                	callq  *%rax
  800420e056:	89 45 ec             	mov    %eax,-0x14(%rbp)

	if(result != 0)
  800420e059:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420e05d:	74 05                	je     800420e064 <sys_exofork+0x69>
		return result;
  800420e05f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e062:	eb 6c                	jmp    800420e0d0 <sys_exofork+0xd5>
	//cprintf("curenv->env_id [%d], newenv_store->env_parent_id [%d],  newenv_store->env_id [%d]\n",curenv->env_id, newenv_store->env_parent_id,newenv_store->env_id);

	newenv_store->env_status = ENV_NOT_RUNNABLE;
  800420e064:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e068:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420e06f:	00 00 00 
	newenv_store->env_tf = curenv->env_tf;
  800420e072:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420e076:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420e07d:	00 00 00 
  800420e080:	ff d0                	callq  *%rax
  800420e082:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420e089:	00 00 00 
  800420e08c:	48 98                	cltq   
  800420e08e:	48 c1 e0 03          	shl    $0x3,%rax
  800420e092:	48 89 c1             	mov    %rax,%rcx
  800420e095:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e099:	48 01 c8             	add    %rcx,%rax
  800420e09c:	48 01 d0             	add    %rdx,%rax
  800420e09f:	48 83 c0 08          	add    $0x8,%rax
  800420e0a3:	48 8b 00             	mov    (%rax),%rax
  800420e0a6:	48 89 da             	mov    %rbx,%rdx
  800420e0a9:	48 89 c6             	mov    %rax,%rsi
  800420e0ac:	b8 18 00 00 00       	mov    $0x18,%eax
  800420e0b1:	48 89 d7             	mov    %rdx,%rdi
  800420e0b4:	48 89 c1             	mov    %rax,%rcx
  800420e0b7:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	newenv_store->env_tf.tf_regs.reg_rax = 0x00;
  800420e0ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e0be:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420e0c5:	00 
	return newenv_store->env_id;
  800420e0c6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e0ca:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

	//panic("sys_exofork not implemented");
}
  800420e0d0:	48 83 c4 18          	add    $0x18,%rsp
  800420e0d4:	5b                   	pop    %rbx
  800420e0d5:	5d                   	pop    %rbp
  800420e0d6:	c3                   	retq   

000000800420e0d7 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420e0d7:	55                   	push   %rbp
  800420e0d8:	48 89 e5             	mov    %rsp,%rbp
  800420e0db:	48 83 ec 20          	sub    $0x20,%rsp
  800420e0df:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e0e2:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// You should set envid2env's third argument to 1, which will
	// check whether the current environment has permission to set
	// envid's status.

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420e0e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420e0ec:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e0f0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e0f3:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e0f8:	48 89 ce             	mov    %rcx,%rsi
  800420e0fb:	89 c7                	mov    %eax,%edi
  800420e0fd:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e104:	00 00 00 
  800420e107:	ff d0                	callq  *%rax
  800420e109:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420e10c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e110:	74 05                	je     800420e117 <sys_env_set_status+0x40>
		return result;
  800420e112:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e115:	eb 23                	jmp    800420e13a <sys_env_set_status+0x63>
	if(status< 0 || status >4)
  800420e117:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800420e11b:	78 06                	js     800420e123 <sys_env_set_status+0x4c>
  800420e11d:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420e121:	7e 07                	jle    800420e12a <sys_env_set_status+0x53>
		return -E_INVAL;
  800420e123:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e128:	eb 10                	jmp    800420e13a <sys_env_set_status+0x63>
	
	env_store->env_status = status;
  800420e12a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e12e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420e131:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return result;
  800420e137:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_env_set_status not implemented");
}
  800420e13a:	c9                   	leaveq 
  800420e13b:	c3                   	retq   

000000800420e13c <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
	{
  800420e13c:	55                   	push   %rbp
  800420e13d:	48 89 e5             	mov    %rsp,%rbp
  800420e140:	48 83 ec 20          	sub    $0x20,%rsp
  800420e144:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e147:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
		// LAB 5: Your code here.
		// Remember to check whether the user has supplied us with a good
		// address!
		//panic("sys_env_set_trapframe not implemented");
		uint32_t  result = 0;
  800420e14b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		struct Env *env_store;
		if(!tf)
  800420e152:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e157:	75 07                	jne    800420e160 <sys_env_set_trapframe+0x24>
			return -E_BAD_ENV;
  800420e159:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420e15e:	eb 73                	jmp    800420e1d3 <sys_env_set_trapframe+0x97>
		result = envid2env(envid,&env_store,1);
  800420e160:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e164:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e167:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e16c:	48 89 ce             	mov    %rcx,%rsi
  800420e16f:	89 c7                	mov    %eax,%edi
  800420e171:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e178:	00 00 00 
  800420e17b:	ff d0                	callq  *%rax
  800420e17d:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(result < 0)
			return result;
		//user_mem_assert(env_store, tf, sizeof(struct Trapframe), PTE_U|PTE_P);
		tf->tf_cs |= 0x3;
  800420e180:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e184:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420e18b:	83 c8 03             	or     $0x3,%eax
  800420e18e:	89 c2                	mov    %eax,%edx
  800420e190:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e194:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
		tf->tf_eflags |= FL_IF;
  800420e19b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e19f:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420e1a6:	80 cc 02             	or     $0x2,%ah
  800420e1a9:	48 89 c2             	mov    %rax,%rdx
  800420e1ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e1b0:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
		env_store->env_tf = *tf;
  800420e1b7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e1bb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e1bf:	48 89 c6             	mov    %rax,%rsi
  800420e1c2:	b8 18 00 00 00       	mov    $0x18,%eax
  800420e1c7:	48 89 d7             	mov    %rdx,%rdi
  800420e1ca:	48 89 c1             	mov    %rax,%rcx
  800420e1cd:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		return result;
  800420e1d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
	}
  800420e1d3:	c9                   	leaveq 
  800420e1d4:	c3                   	retq   

000000800420e1d5 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420e1d5:	55                   	push   %rbp
  800420e1d6:	48 89 e5             	mov    %rsp,%rbp
  800420e1d9:	48 83 ec 20          	sub    $0x20,%rsp
  800420e1dd:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e1e0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.
	
	uint32_t  result =0;
  800420e1e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420e1eb:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420e1ef:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e1f2:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e1f7:	48 89 ce             	mov    %rcx,%rsi
  800420e1fa:	89 c7                	mov    %eax,%edi
  800420e1fc:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e203:	00 00 00 
  800420e206:	ff d0                	callq  *%rax
  800420e208:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420e20b:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e20f:	74 05                	je     800420e216 <sys_env_set_pgfault_upcall+0x41>
		return result;
  800420e211:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e214:	eb 14                	jmp    800420e22a <sys_env_set_pgfault_upcall+0x55>

	env_store->env_pgfault_upcall = func;
  800420e216:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420e21a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e21e:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420e225:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420e22a:	c9                   	leaveq 
  800420e22b:	c3                   	retq   

000000800420e22c <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420e22c:	55                   	push   %rbp
  800420e22d:	48 89 e5             	mov    %rsp,%rbp
  800420e230:	48 83 ec 30          	sub    $0x30,%rsp
  800420e234:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420e237:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420e23b:	89 55 d8             	mov    %edx,-0x28(%rbp)
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420e23e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	struct PageInfo * pp;
	pte_t *pte_store;
	//cprintf("sys page alloc [%d]",result);
	result = envid2env(envid,&env_store,1);
  800420e245:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e249:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420e24c:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e251:	48 89 ce             	mov    %rcx,%rsi
  800420e254:	89 c7                	mov    %eax,%edi
  800420e256:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e25d:	00 00 00 
  800420e260:	ff d0                	callq  *%rax
  800420e262:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420e265:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e269:	74 08                	je     800420e273 <sys_page_alloc+0x47>
		return result;
  800420e26b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e26e:	e9 a2 00 00 00       	jmpq   800420e315 <sys_page_alloc+0xe9>

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420e273:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e276:	83 e0 04             	and    $0x4,%eax
  800420e279:	85 c0                	test   %eax,%eax
  800420e27b:	74 16                	je     800420e293 <sys_page_alloc+0x67>
  800420e27d:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e280:	83 e0 01             	and    $0x1,%eax
  800420e283:	85 c0                	test   %eax,%eax
  800420e285:	74 0c                	je     800420e293 <sys_page_alloc+0x67>
  800420e287:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e28a:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e28f:	85 c0                	test   %eax,%eax
  800420e291:	74 07                	je     800420e29a <sys_page_alloc+0x6e>
		return -E_INVAL;
  800420e293:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e298:	eb 7b                	jmp    800420e315 <sys_page_alloc+0xe9>

	if(((uint64_t)va%PGSIZE !=0) ||((uint64_t)va> UTOP))
  800420e29a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e29e:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e2a3:	48 85 c0             	test   %rax,%rax
  800420e2a6:	75 13                	jne    800420e2bb <sys_page_alloc+0x8f>
  800420e2a8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e2ac:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420e2b3:	00 00 00 
  800420e2b6:	48 39 c2             	cmp    %rax,%rdx
  800420e2b9:	76 07                	jbe    800420e2c2 <sys_page_alloc+0x96>
		return -E_INVAL;
  800420e2bb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e2c0:	eb 53                	jmp    800420e315 <sys_page_alloc+0xe9>
	
    pp = page_alloc(0);
  800420e2c2:	bf 00 00 00 00       	mov    $0x0,%edi
  800420e2c7:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  800420e2ce:	00 00 00 
  800420e2d1:	ff d0                	callq  *%rax
  800420e2d3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(!pp)
  800420e2d7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e2dc:	75 07                	jne    800420e2e5 <sys_page_alloc+0xb9>
		return -E_NO_MEM;
  800420e2de:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420e2e3:	eb 30                	jmp    800420e315 <sys_page_alloc+0xe9>
	

	result = page_insert(env_store->env_pml4e,pp,va,perm|PTE_P);
  800420e2e5:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420e2e8:	83 c8 01             	or     $0x1,%eax
  800420e2eb:	89 c1                	mov    %eax,%ecx
  800420e2ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e2f1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e2f8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e2fc:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420e300:	48 89 c7             	mov    %rax,%rdi
  800420e303:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  800420e30a:	00 00 00 
  800420e30d:	ff d0                	callq  *%rax
  800420e30f:	89 45 fc             	mov    %eax,-0x4(%rbp)
	//cprintf("sys page alloc [%d]",result);
	return result;
  800420e312:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_alloc not implemented");
}
  800420e315:	c9                   	leaveq 
  800420e316:	c3                   	retq   

000000800420e317 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420e317:	55                   	push   %rbp
  800420e318:	48 89 e5             	mov    %rsp,%rbp
  800420e31b:	48 83 ec 50          	sub    $0x50,%rsp
  800420e31f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420e322:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420e326:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420e329:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420e32d:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	//   check the current permissions on the page.

	// LAB 4: Your code here.

	
	uint32_t  result =0;
  800420e331:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store_src;
	struct Env *env_store_dst;
	struct PageInfo * pp;
	pte_t *pte_store;
	result = envid2env(srcenvid,&env_store_src,1);
  800420e338:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e33c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420e33f:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e344:	48 89 ce             	mov    %rcx,%rsi
  800420e347:	89 c7                	mov    %eax,%edi
  800420e349:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e350:	00 00 00 
  800420e353:	ff d0                	callq  *%rax
  800420e355:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0){
  800420e358:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e35c:	74 08                	je     800420e366 <sys_page_map+0x4f>
		//cprintf("need 1stcheckperm to be 0\n");
		return result;
  800420e35e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e361:	e9 1c 01 00 00       	jmpq   800420e482 <sys_page_map+0x16b>
	}
	result = envid2env(dstenvid,&env_store_dst,0);
  800420e366:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420e36a:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420e36d:	ba 00 00 00 00       	mov    $0x0,%edx
  800420e372:	48 89 ce             	mov    %rcx,%rsi
  800420e375:	89 c7                	mov    %eax,%edi
  800420e377:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e37e:	00 00 00 
  800420e381:	ff d0                	callq  *%rax
  800420e383:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result != 0){
  800420e386:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420e38a:	74 08                	je     800420e394 <sys_page_map+0x7d>
		//cprintf("need 2ndcheckperm to be 0\n");
		return result;
  800420e38c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420e38f:	e9 ee 00 00 00       	jmpq   800420e482 <sys_page_map+0x16b>
	}

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420e394:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420e397:	83 e0 04             	and    $0x4,%eax
  800420e39a:	85 c0                	test   %eax,%eax
  800420e39c:	74 16                	je     800420e3b4 <sys_page_map+0x9d>
  800420e39e:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420e3a1:	83 e0 01             	and    $0x1,%eax
  800420e3a4:	85 c0                	test   %eax,%eax
  800420e3a6:	74 0c                	je     800420e3b4 <sys_page_map+0x9d>
  800420e3a8:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420e3ab:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420e3b0:	85 c0                	test   %eax,%eax
  800420e3b2:	74 0a                	je     800420e3be <sys_page_map+0xa7>
		return -E_INVAL;
  800420e3b4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e3b9:	e9 c4 00 00 00       	jmpq   800420e482 <sys_page_map+0x16b>

	
	if(((uint64_t)dstva%PGSIZE !=0 || (uint64_t)dstva> UTOP)||((uint64_t)srcva%PGSIZE !=0 || (uint64_t)srcva> UTOP))
  800420e3be:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420e3c2:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e3c7:	48 85 c0             	test   %rax,%rax
  800420e3ca:	75 34                	jne    800420e400 <sys_page_map+0xe9>
  800420e3cc:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e3d0:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420e3d7:	00 00 00 
  800420e3da:	48 39 c2             	cmp    %rax,%rdx
  800420e3dd:	77 21                	ja     800420e400 <sys_page_map+0xe9>
  800420e3df:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e3e3:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e3e8:	48 85 c0             	test   %rax,%rax
  800420e3eb:	75 13                	jne    800420e400 <sys_page_map+0xe9>
  800420e3ed:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420e3f1:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420e3f8:	00 00 00 
  800420e3fb:	48 39 c2             	cmp    %rax,%rdx
  800420e3fe:	76 07                	jbe    800420e407 <sys_page_map+0xf0>
		return -E_INVAL;
  800420e400:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e405:	eb 7b                	jmp    800420e482 <sys_page_map+0x16b>
	pp = page_lookup(env_store_src->env_pml4e, srcva, &pte_store);
  800420e407:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e40b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e412:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420e416:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420e41a:	48 89 ce             	mov    %rcx,%rsi
  800420e41d:	48 89 c7             	mov    %rax,%rdi
  800420e420:	48 b8 3d 39 20 04 80 	movabs $0x800420393d,%rax
  800420e427:	00 00 00 
  800420e42a:	ff d0                	callq  *%rax
  800420e42c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(NULL == pp || (((*(pte_store) & PTE_W) == 0) && ((perm & PTE_W) != 0)))
  800420e430:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420e435:	74 19                	je     800420e450 <sys_page_map+0x139>
  800420e437:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e43b:	48 8b 00             	mov    (%rax),%rax
  800420e43e:	83 e0 02             	and    $0x2,%eax
  800420e441:	48 85 c0             	test   %rax,%rax
  800420e444:	75 11                	jne    800420e457 <sys_page_map+0x140>
  800420e446:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420e449:	83 e0 02             	and    $0x2,%eax
  800420e44c:	85 c0                	test   %eax,%eax
  800420e44e:	74 07                	je     800420e457 <sys_page_map+0x140>
		return -E_INVAL;	
  800420e450:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e455:	eb 2b                	jmp    800420e482 <sys_page_map+0x16b>

	
	result = page_insert(env_store_dst->env_pml4e,pp,dstva,perm);
  800420e457:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e45b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e462:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420e465:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420e469:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420e46d:	48 89 c7             	mov    %rax,%rdi
  800420e470:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  800420e477:	00 00 00 
  800420e47a:	ff d0                	callq  *%rax
  800420e47c:	89 45 fc             	mov    %eax,-0x4(%rbp)
	
	return result;
  800420e47f:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_map not implemented");
}
  800420e482:	c9                   	leaveq 
  800420e483:	c3                   	retq   

000000800420e484 <sys_page_unmap>:
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.

static int
sys_page_unmap(envid_t envid, void *va)
{
  800420e484:	55                   	push   %rbp
  800420e485:	48 89 e5             	mov    %rsp,%rbp
  800420e488:	48 83 ec 20          	sub    $0x20,%rsp
  800420e48c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420e48f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Hint: This function is a wrapper around page_remove().
	
	// LAB 4: Your code here.
	struct Env* env;
	if(envid2env(envid, &env,1) != 0)
  800420e493:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  800420e497:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420e49a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420e49f:	48 89 ce             	mov    %rcx,%rsi
  800420e4a2:	89 c7                	mov    %eax,%edi
  800420e4a4:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e4ab:	00 00 00 
  800420e4ae:	ff d0                	callq  *%rax
  800420e4b0:	85 c0                	test   %eax,%eax
  800420e4b2:	74 07                	je     800420e4bb <sys_page_unmap+0x37>
	{
		return -E_BAD_ENV;
  800420e4b4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420e4b9:	eb 55                	jmp    800420e510 <sys_page_unmap+0x8c>
	}
	if(va == NULL || (uint64_t)va >= UTOP || (uint64_t)va  % PGSIZE != 0)
  800420e4bb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420e4c0:	74 21                	je     800420e4e3 <sys_page_unmap+0x5f>
  800420e4c2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e4c6:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e4cd:	00 00 00 
  800420e4d0:	48 39 c2             	cmp    %rax,%rdx
  800420e4d3:	77 0e                	ja     800420e4e3 <sys_page_unmap+0x5f>
  800420e4d5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e4d9:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e4de:	48 85 c0             	test   %rax,%rax
  800420e4e1:	74 07                	je     800420e4ea <sys_page_unmap+0x66>
	{
		return -E_INVAL;
  800420e4e3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e4e8:	eb 26                	jmp    800420e510 <sys_page_unmap+0x8c>
	}
	page_remove(env->env_pml4e, va);
  800420e4ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e4ee:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e4f5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e4f9:	48 89 d6             	mov    %rdx,%rsi
  800420e4fc:	48 89 c7             	mov    %rax,%rdi
  800420e4ff:	48 b8 d7 39 20 04 80 	movabs $0x80042039d7,%rax
  800420e506:	00 00 00 
  800420e509:	ff d0                	callq  *%rax
	return 0;
  800420e50b:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_unmap not implemented");
}
  800420e510:	c9                   	leaveq 
  800420e511:	c3                   	retq   

000000800420e512 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420e512:	55                   	push   %rbp
  800420e513:	48 89 e5             	mov    %rsp,%rbp
  800420e516:	48 83 ec 50          	sub    $0x50,%rsp
  800420e51a:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420e51d:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800420e520:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420e524:	89 4d bc             	mov    %ecx,-0x44(%rbp)
	// LAB 4: Your code here.
	struct Env* dstenv;
	struct Env* srcenv;
	pte_t* pte_store;
	int srcperm , result;
	struct PageInfo *pp = NULL;
  800420e527:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420e52e:	00 
	perm|= PTE_P;
  800420e52f:	83 4d bc 01          	orl    $0x1,-0x44(%rbp)
	if(envid2env(envid, &dstenv,0) != 0)
  800420e533:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420e537:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420e53a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420e53f:	48 89 ce             	mov    %rcx,%rsi
  800420e542:	89 c7                	mov    %eax,%edi
  800420e544:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e54b:	00 00 00 
  800420e54e:	ff d0                	callq  *%rax
  800420e550:	85 c0                	test   %eax,%eax
  800420e552:	74 0a                	je     800420e55e <sys_ipc_try_send+0x4c>
		return -E_BAD_ENV;
  800420e554:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420e559:	e9 c3 02 00 00       	jmpq   800420e821 <sys_ipc_try_send+0x30f>

	if(envid2env(0, &srcenv,0) != 0)
  800420e55e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420e562:	ba 00 00 00 00       	mov    $0x0,%edx
  800420e567:	48 89 c6             	mov    %rax,%rsi
  800420e56a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420e56f:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e576:	00 00 00 
  800420e579:	ff d0                	callq  *%rax
  800420e57b:	85 c0                	test   %eax,%eax
  800420e57d:	74 0a                	je     800420e589 <sys_ipc_try_send+0x77>
		return -E_BAD_ENV;
  800420e57f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420e584:	e9 98 02 00 00       	jmpq   800420e821 <sys_ipc_try_send+0x30f>
	
	if(!dstenv->env_ipc_recving)
  800420e589:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e58d:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420e594:	83 f0 01             	xor    $0x1,%eax
  800420e597:	84 c0                	test   %al,%al
  800420e599:	74 0a                	je     800420e5a5 <sys_ipc_try_send+0x93>
		return -E_IPC_NOT_RECV;
  800420e59b:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420e5a0:	e9 7c 02 00 00       	jmpq   800420e821 <sys_ipc_try_send+0x30f>
//#ifndef VMM_GUEST
		pp =page_lookup(srcenv->env_pml4e,srcva,&pte_store); 
  800420e5a5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e5a9:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e5b0:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420e5b4:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420e5b8:	48 89 ce             	mov    %rcx,%rsi
  800420e5bb:	48 89 c7             	mov    %rax,%rdi
  800420e5be:	48 b8 3d 39 20 04 80 	movabs $0x800420393d,%rax
  800420e5c5:	00 00 00 
  800420e5c8:	ff d0                	callq  *%rax
  800420e5ca:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if(!pp)
  800420e5ce:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420e5d3:	75 1a                	jne    800420e5ef <sys_ipc_try_send+0xdd>
			if(srcva <(void*)UTOP)
  800420e5d5:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e5dc:	00 00 00 
  800420e5df:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420e5e3:	77 0a                	ja     800420e5ef <sys_ipc_try_send+0xdd>
				return -E_INVAL;
  800420e5e5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e5ea:	e9 32 02 00 00       	jmpq   800420e821 <sys_ipc_try_send+0x30f>
//#else
		;;//result = ept_lookup_gpa(srcenv->env_pml4e, srcva,0,&pte_store);

//#endif
	srcperm = *pte_store&PTE_SYSCALL;
  800420e5ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420e5f3:	48 8b 00             	mov    (%rax),%rax
  800420e5f6:	25 07 0e 00 00       	and    $0xe07,%eax
  800420e5fb:	89 45 f4             	mov    %eax,-0xc(%rbp)
	if(srcva <(void*)UTOP)
  800420e5fe:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e605:	00 00 00 
  800420e608:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420e60c:	77 23                	ja     800420e631 <sys_ipc_try_send+0x11f>
		if((((uint64_t)srcva)%PGSIZE!=0) || ((srcperm & (PTE_U | PTE_P))!=(PTE_U | PTE_P)))
  800420e60e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420e612:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e617:	48 85 c0             	test   %rax,%rax
  800420e61a:	75 0b                	jne    800420e627 <sys_ipc_try_send+0x115>
  800420e61c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e61f:	83 e0 05             	and    $0x5,%eax
  800420e622:	83 f8 05             	cmp    $0x5,%eax
  800420e625:	74 0a                	je     800420e631 <sys_ipc_try_send+0x11f>
			return -E_INVAL;
  800420e627:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e62c:	e9 f0 01 00 00       	jmpq   800420e821 <sys_ipc_try_send+0x30f>
	if((srcva <(void*)UTOP) && ((perm & PTE_W) !=0) &&(((srcperm& PTE_W) == 0)))
  800420e631:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e638:	00 00 00 
  800420e63b:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420e63f:	77 1e                	ja     800420e65f <sys_ipc_try_send+0x14d>
  800420e641:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420e644:	83 e0 02             	and    $0x2,%eax
  800420e647:	85 c0                	test   %eax,%eax
  800420e649:	74 14                	je     800420e65f <sys_ipc_try_send+0x14d>
  800420e64b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420e64e:	83 e0 02             	and    $0x2,%eax
  800420e651:	85 c0                	test   %eax,%eax
  800420e653:	75 0a                	jne    800420e65f <sys_ipc_try_send+0x14d>
		return -E_INVAL;
  800420e655:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e65a:	e9 c2 01 00 00       	jmpq   800420e821 <sys_ipc_try_send+0x30f>

	if(envid == curenv->env_id)
  800420e65f:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420e666:	00 00 00 
  800420e669:	ff d0                	callq  *%rax
  800420e66b:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420e672:	00 00 00 
  800420e675:	48 98                	cltq   
  800420e677:	48 c1 e0 03          	shl    $0x3,%rax
  800420e67b:	48 89 c1             	mov    %rax,%rcx
  800420e67e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e682:	48 01 c8             	add    %rcx,%rax
  800420e685:	48 01 d0             	add    %rdx,%rax
  800420e688:	48 83 c0 08          	add    $0x8,%rax
  800420e68c:	48 8b 00             	mov    (%rax),%rax
  800420e68f:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420e695:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420e698:	75 2a                	jne    800420e6c4 <sys_ipc_try_send+0x1b2>
		panic("what the hell. how can this be????");
  800420e69a:	48 ba c8 eb 21 04 80 	movabs $0x800421ebc8,%rdx
  800420e6a1:	00 00 00 
  800420e6a4:	be 9b 01 00 00       	mov    $0x19b,%esi
  800420e6a9:	48 bf eb eb 21 04 80 	movabs $0x800421ebeb,%rdi
  800420e6b0:	00 00 00 
  800420e6b3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e6b8:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  800420e6bf:	00 00 00 
  800420e6c2:	ff d1                	callq  *%rcx

	dstenv->env_ipc_recving = 0;
  800420e6c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e6c8:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	dstenv->env_ipc_from = srcenv->env_id;
  800420e6cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e6d3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420e6d7:	8b 92 c8 00 00 00    	mov    0xc8(%rdx),%edx
  800420e6dd:	89 90 0c 01 00 00    	mov    %edx,0x10c(%rax)
	dstenv->env_ipc_value = value;
  800420e6e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e6e7:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800420e6ea:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	//cprintf("dstenv -> envID is:[%d]\n",dstenv->env_id);
	if(srcva <(void*)UTOP && dstenv->env_ipc_dstva <(void*)UTOP){
  800420e6f0:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e6f7:	00 00 00 
  800420e6fa:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420e6fe:	0f 87 0a 01 00 00    	ja     800420e80e <sys_ipc_try_send+0x2fc>
  800420e704:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e708:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e70f:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e716:	00 00 00 
  800420e719:	48 39 c2             	cmp    %rax,%rdx
  800420e71c:	0f 87 ec 00 00 00    	ja     800420e80e <sys_ipc_try_send+0x2fc>
		dstenv->env_ipc_perm = perm;
  800420e722:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e726:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420e729:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
#ifndef VMM_GUEST
				// guest OS related changes : Lab7-ex7
				if ( curenv->env_type != ENV_TYPE_GUEST) {
  800420e72f:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420e736:	00 00 00 
  800420e739:	ff d0                	callq  *%rax
  800420e73b:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420e742:	00 00 00 
  800420e745:	48 98                	cltq   
  800420e747:	48 c1 e0 03          	shl    $0x3,%rax
  800420e74b:	48 89 c1             	mov    %rax,%rcx
  800420e74e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e752:	48 01 c8             	add    %rcx,%rax
  800420e755:	48 01 d0             	add    %rdx,%rax
  800420e758:	48 83 c0 08          	add    $0x8,%rax
  800420e75c:	48 8b 00             	mov    (%rax),%rax
  800420e75f:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420e765:	83 f8 03             	cmp    $0x3,%eax
  800420e768:	74 52                	je     800420e7bc <sys_ipc_try_send+0x2aa>
#endif
					if(page_insert(dstenv->env_pml4e, pp, dstenv->env_ipc_dstva , perm) < 0) {
  800420e76a:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  800420e76d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e771:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e778:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e77c:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e783:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420e787:	48 89 c7             	mov    %rax,%rdi
  800420e78a:	48 b8 e0 37 20 04 80 	movabs $0x80042037e0,%rax
  800420e791:	00 00 00 
  800420e794:	ff d0                	callq  *%rax
  800420e796:	85 c0                	test   %eax,%eax
  800420e798:	79 74                	jns    800420e80e <sys_ipc_try_send+0x2fc>
						cprintf("\n No memory to map the page to target env\n");
  800420e79a:	48 bf 00 ec 21 04 80 	movabs $0x800421ec00,%rdi
  800420e7a1:	00 00 00 
  800420e7a4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e7a9:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420e7b0:	00 00 00 
  800420e7b3:	ff d2                	callq  *%rdx
						return -E_NO_MEM;
  800420e7b5:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420e7ba:	eb 65                	jmp    800420e821 <sys_ipc_try_send+0x30f>
					}
#ifndef VMM_GUEST
				}
				else {
					if (ept_page_insert(dstenv->env_pml4e, pp, dstenv->env_ipc_dstva, perm) <0) {
  800420e7bc:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  800420e7bf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e7c3:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420e7ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e7ce:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e7d5:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420e7d9:	48 89 c7             	mov    %rax,%rdi
  800420e7dc:	48 b8 29 93 21 04 80 	movabs $0x8004219329,%rax
  800420e7e3:	00 00 00 
  800420e7e6:	ff d0                	callq  *%rax
  800420e7e8:	85 c0                	test   %eax,%eax
  800420e7ea:	79 22                	jns    800420e80e <sys_ipc_try_send+0x2fc>
						cprintf("\n No memory to map the page to target env\n");
  800420e7ec:	48 bf 00 ec 21 04 80 	movabs $0x800421ec00,%rdi
  800420e7f3:	00 00 00 
  800420e7f6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e7fb:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420e802:	00 00 00 
  800420e805:	ff d2                	callq  *%rdx
									return -E_NO_MEM;
  800420e807:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420e80c:	eb 13                	jmp    800420e821 <sys_ipc_try_send+0x30f>
								}
				}
#endif

	}
	dstenv->env_status = ENV_RUNNABLE;
  800420e80e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e812:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420e819:	00 00 00 
	return 0;
  800420e81c:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_ipc_try_send not implemented");
}
  800420e821:	c9                   	leaveq 
  800420e822:	c3                   	retq   

000000800420e823 <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:

static int
sys_ipc_recv(void *dstva)
{
  800420e823:	55                   	push   %rbp
  800420e824:	48 89 e5             	mov    %rsp,%rbp
  800420e827:	48 83 ec 20          	sub    $0x20,%rsp
  800420e82b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// LAB 4: Your code here.
	struct Env* env;
	void *addr;
	addr = 0 ;
  800420e82f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e836:	00 
	if(envid2env(0, &env,0) != 0)
  800420e837:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  800420e83b:	ba 00 00 00 00       	mov    $0x0,%edx
  800420e840:	48 89 c6             	mov    %rax,%rsi
  800420e843:	bf 00 00 00 00       	mov    $0x0,%edi
  800420e848:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420e84f:	00 00 00 
  800420e852:	ff d0                	callq  *%rax
  800420e854:	85 c0                	test   %eax,%eax
  800420e856:	74 0a                	je     800420e862 <sys_ipc_recv+0x3f>
	{
		return -E_BAD_ENV;
  800420e858:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420e85d:	e9 85 01 00 00       	jmpq   800420e9e7 <sys_ipc_recv+0x1c4>
	}
	if(dstva <(void*)UTOP && (uint64_t)dstva%PGSIZE!=0)
  800420e862:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e869:	00 00 00 
  800420e86c:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420e870:	77 18                	ja     800420e88a <sys_ipc_recv+0x67>
  800420e872:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e876:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420e87b:	48 85 c0             	test   %rax,%rax
  800420e87e:	74 0a                	je     800420e88a <sys_ipc_recv+0x67>
		return -E_INVAL;
  800420e880:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420e885:	e9 5d 01 00 00       	jmpq   800420e9e7 <sys_ipc_recv+0x1c4>
	if(dstva <(void*)UTOP)
  800420e88a:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420e891:	00 00 00 
  800420e894:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420e898:	77 0f                	ja     800420e8a9 <sys_ipc_recv+0x86>
		env->env_ipc_dstva = dstva;
  800420e89a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e89e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e8a2:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)

	env->env_ipc_recving = 1;
  800420e8a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e8ad:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
#ifndef VMM_GUEST
	if (curenv->env_type == ENV_TYPE_GUEST) {
  800420e8b4:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420e8bb:	00 00 00 
  800420e8be:	ff d0                	callq  *%rax
  800420e8c0:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420e8c7:	00 00 00 
  800420e8ca:	48 98                	cltq   
  800420e8cc:	48 c1 e0 03          	shl    $0x3,%rax
  800420e8d0:	48 89 c1             	mov    %rax,%rcx
  800420e8d3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e8d7:	48 01 c8             	add    %rcx,%rax
  800420e8da:	48 01 d0             	add    %rdx,%rax
  800420e8dd:	48 83 c0 08          	add    $0x8,%rax
  800420e8e1:	48 8b 00             	mov    (%rax),%rax
  800420e8e4:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420e8ea:	83 f8 03             	cmp    $0x3,%eax
  800420e8ed:	0f 85 8e 00 00 00    	jne    800420e981 <sys_ipc_recv+0x15e>
		ept_gpa2hva(curenv->env_pml4e,dstva,&addr);
  800420e8f3:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420e8fa:	00 00 00 
  800420e8fd:	ff d0                	callq  *%rax
  800420e8ff:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420e906:	00 00 00 
  800420e909:	48 98                	cltq   
  800420e90b:	48 c1 e0 03          	shl    $0x3,%rax
  800420e90f:	48 89 c1             	mov    %rax,%rcx
  800420e912:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e916:	48 01 c8             	add    %rcx,%rax
  800420e919:	48 01 d0             	add    %rdx,%rax
  800420e91c:	48 83 c0 08          	add    $0x8,%rax
  800420e920:	48 8b 00             	mov    (%rax),%rax
  800420e923:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420e92a:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  800420e92e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420e932:	48 89 ce             	mov    %rcx,%rsi
  800420e935:	48 89 c7             	mov    %rax,%rdi
  800420e938:	48 b8 3d 90 21 04 80 	movabs $0x800421903d,%rax
  800420e93f:	00 00 00 
  800420e942:	ff d0                	callq  *%rax
		curenv->env_ipc_dstva = addr;
  800420e944:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420e94b:	00 00 00 
  800420e94e:	ff d0                	callq  *%rax
  800420e950:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420e957:	00 00 00 
  800420e95a:	48 98                	cltq   
  800420e95c:	48 c1 e0 03          	shl    $0x3,%rax
  800420e960:	48 89 c1             	mov    %rax,%rcx
  800420e963:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e967:	48 01 c8             	add    %rcx,%rax
  800420e96a:	48 01 d0             	add    %rdx,%rax
  800420e96d:	48 83 c0 08          	add    $0x8,%rax
  800420e971:	48 8b 00             	mov    (%rax),%rax
  800420e974:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e978:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
  800420e97f:	eb 3b                	jmp    800420e9bc <sys_ipc_recv+0x199>
	}
	else
		curenv->env_ipc_dstva = dstva;	
  800420e981:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420e988:	00 00 00 
  800420e98b:	ff d0                	callq  *%rax
  800420e98d:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420e994:	00 00 00 
  800420e997:	48 98                	cltq   
  800420e999:	48 c1 e0 03          	shl    $0x3,%rax
  800420e99d:	48 89 c1             	mov    %rax,%rcx
  800420e9a0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e9a4:	48 01 c8             	add    %rcx,%rax
  800420e9a7:	48 01 d0             	add    %rdx,%rax
  800420e9aa:	48 83 c0 08          	add    $0x8,%rax
  800420e9ae:	48 8b 00             	mov    (%rax),%rax
  800420e9b1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e9b5:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)
#endif

	env->env_status = ENV_NOT_RUNNABLE;
  800420e9bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e9c0:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420e9c7:	00 00 00 
	env->env_tf.tf_regs.reg_rax = 0;
  800420e9ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e9ce:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420e9d5:	00 
	sys_yield();
  800420e9d6:	48 b8 eb df 20 04 80 	movabs $0x800420dfeb,%rax
  800420e9dd:	00 00 00 
  800420e9e0:	ff d0                	callq  *%rax
	
	//panic("sys_ipc_recv not implemented");
	return 0;
  800420e9e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e9e7:	c9                   	leaveq 
  800420e9e8:	c3                   	retq   

000000800420e9e9 <sys_time_msec>:


static int
sys_time_msec(void)
{
  800420e9e9:	55                   	push   %rbp
  800420e9ea:	48 89 e5             	mov    %rsp,%rbp
	// LAB 6: Your code here.
	panic("sys_time_msec not implemented");
  800420e9ed:	48 ba 2b ec 21 04 80 	movabs $0x800421ec2b,%rdx
  800420e9f4:	00 00 00 
  800420e9f7:	be ed 01 00 00       	mov    $0x1ed,%esi
  800420e9fc:	48 bf eb eb 21 04 80 	movabs $0x800421ebeb,%rdi
  800420ea03:	00 00 00 
  800420ea06:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea0b:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  800420ea12:	00 00 00 
  800420ea15:	ff d1                	callq  *%rcx

000000800420ea17 <sys_vmx_list_vms>:
// Hint: The TA solution uses ept_map_hva2gpa().  A guest environment uses 
//       env_pml4e to store the root of the extended page tables.
// 
#ifndef VMM_GUEST
static void
sys_vmx_list_vms() {
  800420ea17:	55                   	push   %rbp
  800420ea18:	48 89 e5             	mov    %rsp,%rbp
	vmx_list_vms();
  800420ea1b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea20:	48 ba 33 99 21 04 80 	movabs $0x8004219933,%rdx
  800420ea27:	00 00 00 
  800420ea2a:	ff d2                	callq  *%rdx
}
  800420ea2c:	5d                   	pop    %rbp
  800420ea2d:	c3                   	retq   

000000800420ea2e <sys_vmx_sel_resume>:

static bool
sys_vmx_sel_resume(int i) {
  800420ea2e:	55                   	push   %rbp
  800420ea2f:	48 89 e5             	mov    %rsp,%rbp
  800420ea32:	48 83 ec 10          	sub    $0x10,%rsp
  800420ea36:	89 7d fc             	mov    %edi,-0x4(%rbp)
	return vmx_sel_resume(i);
  800420ea39:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ea3c:	89 c7                	mov    %eax,%edi
  800420ea3e:	48 b8 f3 99 21 04 80 	movabs $0x80042199f3,%rax
  800420ea45:	00 00 00 
  800420ea48:	ff d0                	callq  *%rax
}
  800420ea4a:	c9                   	leaveq 
  800420ea4b:	c3                   	retq   

000000800420ea4c <sys_vmx_get_vmdisk_number>:

static int
sys_vmx_get_vmdisk_number() {
  800420ea4c:	55                   	push   %rbp
  800420ea4d:	48 89 e5             	mov    %rsp,%rbp
	return vmx_get_vmdisk_number();
  800420ea50:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea55:	48 ba 7a c4 21 04 80 	movabs $0x800421c47a,%rdx
  800420ea5c:	00 00 00 
  800420ea5f:	ff d2                	callq  *%rdx
}
  800420ea61:	5d                   	pop    %rbp
  800420ea62:	c3                   	retq   

000000800420ea63 <sys_vmx_incr_vmdisk_number>:

static void
sys_vmx_incr_vmdisk_number() {
  800420ea63:	55                   	push   %rbp
  800420ea64:	48 89 e5             	mov    %rsp,%rbp
	vmx_incr_vmdisk_number();
  800420ea67:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ea6c:	48 ba 8c c4 21 04 80 	movabs $0x800421c48c,%rdx
  800420ea73:	00 00 00 
  800420ea76:	ff d2                	callq  *%rdx
}
  800420ea78:	5d                   	pop    %rbp
  800420ea79:	c3                   	retq   

000000800420ea7a <sys_ept_map>:

static int
sys_ept_map(envid_t srcenvid, void *srcva,
	    envid_t guest, void* guest_pa, int perm)
{
  800420ea7a:	55                   	push   %rbp
  800420ea7b:	48 89 e5             	mov    %rsp,%rbp
  800420ea7e:	48 83 ec 50          	sub    $0x50,%rsp
  800420ea82:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420ea85:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420ea89:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420ea8c:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420ea90:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	uint32_t  result =0;
  800420ea94:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store_src;
	struct Env *env_store_guest;
	struct PageInfo * pp;
	pte_t *pte_store;
	result = envid2env(srcenvid,&env_store_src,1);
  800420ea9b:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420ea9f:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420eaa2:	ba 01 00 00 00       	mov    $0x1,%edx
  800420eaa7:	48 89 ce             	mov    %rcx,%rsi
  800420eaaa:	89 c7                	mov    %eax,%edi
  800420eaac:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420eab3:	00 00 00 
  800420eab6:	ff d0                	callq  *%rax
  800420eab8:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(result != 0){
  800420eabb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420eabf:	74 25                	je     800420eae6 <sys_ept_map+0x6c>
			cprintf("failed here 1\n");
  800420eac1:	48 bf 49 ec 21 04 80 	movabs $0x800421ec49,%rdi
  800420eac8:	00 00 00 
  800420eacb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ead0:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420ead7:	00 00 00 
  800420eada:	ff d2                	callq  *%rdx
			return -E_BAD_ENV;
  800420eadc:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420eae1:	e9 ed 01 00 00       	jmpq   800420ecd3 <sys_ept_map+0x259>
			}
	
	result = envid2env(guest,&env_store_guest,1);
  800420eae6:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420eaea:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420eaed:	ba 01 00 00 00       	mov    $0x1,%edx
  800420eaf2:	48 89 ce             	mov    %rcx,%rsi
  800420eaf5:	89 c7                	mov    %eax,%edi
  800420eaf7:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800420eafe:	00 00 00 
  800420eb01:	ff d0                	callq  *%rax
  800420eb03:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result != 0){
  800420eb06:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420eb0a:	74 23                	je     800420eb2f <sys_ept_map+0xb5>
		cprintf("failed here 2\n");
  800420eb0c:	48 bf 58 ec 21 04 80 	movabs $0x800421ec58,%rdi
  800420eb13:	00 00 00 
  800420eb16:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eb1b:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420eb22:	00 00 00 
  800420eb25:	ff d2                	callq  *%rdx
		return result;
  800420eb27:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420eb2a:	e9 a4 01 00 00       	jmpq   800420ecd3 <sys_ept_map+0x259>
	}


	if(((uint64_t)guest_pa%PGSIZE !=0 || (uint64_t)guest_pa >= (env_store_guest->env_vmxinfo.phys_sz)) 
  800420eb2f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420eb33:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420eb38:	48 85 c0             	test   %rax,%rax
  800420eb3b:	75 44                	jne    800420eb81 <sys_ept_map+0x107>
  800420eb3d:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420eb41:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eb45:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
  800420eb4c:	48 39 c2             	cmp    %rax,%rdx
  800420eb4f:	73 30                	jae    800420eb81 <sys_ept_map+0x107>
			||((uint64_t)srcva%PGSIZE !=0 || (uint64_t)srcva>= UTOP) || (env_store_guest->env_type != ENV_TYPE_GUEST)){
  800420eb51:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420eb55:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420eb5a:	48 85 c0             	test   %rax,%rax
  800420eb5d:	75 22                	jne    800420eb81 <sys_ept_map+0x107>
  800420eb5f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420eb63:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420eb6a:	00 00 00 
  800420eb6d:	48 39 c2             	cmp    %rax,%rdx
  800420eb70:	77 0f                	ja     800420eb81 <sys_ept_map+0x107>
  800420eb72:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eb76:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800420eb7c:	83 f8 03             	cmp    $0x3,%eax
  800420eb7f:	74 30                	je     800420ebb1 <sys_ept_map+0x137>
		
		cprintf("failed here 3[%x] , env_type[%x]\n",srcva,guest_pa);
  800420eb81:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420eb85:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420eb89:	48 89 c6             	mov    %rax,%rsi
  800420eb8c:	48 bf 68 ec 21 04 80 	movabs $0x800421ec68,%rdi
  800420eb93:	00 00 00 
  800420eb96:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eb9b:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800420eba2:	00 00 00 
  800420eba5:	ff d1                	callq  *%rcx
		return -E_INVAL;
  800420eba7:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ebac:	e9 22 01 00 00       	jmpq   800420ecd3 <sys_ept_map+0x259>
	}

	if((!(perm &__EPTE_FULL))||(!(perm &__EPTE_READ))) {
  800420ebb1:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420ebb4:	83 e0 07             	and    $0x7,%eax
  800420ebb7:	85 c0                	test   %eax,%eax
  800420ebb9:	74 0a                	je     800420ebc5 <sys_ept_map+0x14b>
  800420ebbb:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420ebbe:	83 e0 01             	and    $0x1,%eax
  800420ebc1:	85 c0                	test   %eax,%eax
  800420ebc3:	75 25                	jne    800420ebea <sys_ept_map+0x170>
		
		cprintf("failed here 4\n");
  800420ebc5:	48 bf 8a ec 21 04 80 	movabs $0x800421ec8a,%rdi
  800420ebcc:	00 00 00 
  800420ebcf:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ebd4:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420ebdb:	00 00 00 
  800420ebde:	ff d2                	callq  *%rdx
		return -E_INVAL;
  800420ebe0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ebe5:	e9 e9 00 00 00       	jmpq   800420ecd3 <sys_ept_map+0x259>
	}
		
	pp = page_lookup(env_store_src->env_pml4e, srcva, &pte_store);
  800420ebea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ebee:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ebf5:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420ebf9:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420ebfd:	48 89 ce             	mov    %rcx,%rsi
  800420ec00:	48 89 c7             	mov    %rax,%rdi
  800420ec03:	48 b8 3d 39 20 04 80 	movabs $0x800420393d,%rax
  800420ec0a:	00 00 00 
  800420ec0d:	ff d0                	callq  *%rax
  800420ec0f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(NULL == pp || (((*(pte_store) & PTE_W) == 0) && ((perm & PTE_W) != 0))){
  800420ec13:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420ec18:	74 19                	je     800420ec33 <sys_ept_map+0x1b9>
  800420ec1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec1e:	48 8b 00             	mov    (%rax),%rax
  800420ec21:	83 e0 02             	and    $0x2,%eax
  800420ec24:	48 85 c0             	test   %rax,%rax
  800420ec27:	75 2c                	jne    800420ec55 <sys_ept_map+0x1db>
  800420ec29:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420ec2c:	83 e0 02             	and    $0x2,%eax
  800420ec2f:	85 c0                	test   %eax,%eax
  800420ec31:	74 22                	je     800420ec55 <sys_ept_map+0x1db>
		
		cprintf("failed here 5\n");
  800420ec33:	48 bf 99 ec 21 04 80 	movabs $0x800421ec99,%rdi
  800420ec3a:	00 00 00 
  800420ec3d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ec42:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420ec49:	00 00 00 
  800420ec4c:	ff d2                	callq  *%rdx
		return -E_INVAL;	
  800420ec4e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420ec53:	eb 7e                	jmp    800420ecd3 <sys_ept_map+0x259>
	}

	result = ept_map_hva2gpa(env_store_guest->env_pml4e, page2kva(pp), guest_pa, perm, 0);
  800420ec55:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ec59:	48 89 c7             	mov    %rax,%rdi
  800420ec5c:	48 b8 41 de 20 04 80 	movabs $0x800420de41,%rax
  800420ec63:	00 00 00 
  800420ec66:	ff d0                	callq  *%rax
  800420ec68:	48 89 c6             	mov    %rax,%rsi
  800420ec6b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ec6f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420ec76:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420ec79:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420ec7d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420ec83:	48 89 c7             	mov    %rax,%rdi
  800420ec86:	48 b8 88 94 21 04 80 	movabs $0x8004219488,%rax
  800420ec8d:	00 00 00 
  800420ec90:	ff d0                	callq  *%rax
  800420ec92:	89 45 fc             	mov    %eax,-0x4(%rbp)


	//result = ept_page_insert(env_store_guest->env_pml4e, pp,guest_pa,perm);
	
	if(result != 0){
  800420ec95:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ec99:	74 20                	je     800420ecbb <sys_ept_map+0x241>
		
		cprintf("failed here 6\n");
  800420ec9b:	48 bf a8 ec 21 04 80 	movabs $0x800421eca8,%rdi
  800420eca2:	00 00 00 
  800420eca5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ecaa:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800420ecb1:	00 00 00 
  800420ecb4:	ff d2                	callq  *%rdx
		return result;
  800420ecb6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ecb9:	eb 18                	jmp    800420ecd3 <sys_ept_map+0x259>
	}else{
		pp->pp_ref++;
  800420ecbb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ecbf:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420ecc3:	8d 50 01             	lea    0x1(%rax),%edx
  800420ecc6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ecca:	66 89 50 08          	mov    %dx,0x8(%rax)
	}
	/* Your code here */
	//panic ("sys_ept_map not implemented");
	return 0;
  800420ecce:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420ecd3:	c9                   	leaveq 
  800420ecd4:	c3                   	retq   

000000800420ecd5 <sys_env_mkguest>:

static envid_t
	sys_env_mkguest(uint64_t gphysz, uint64_t gRIP) {
  800420ecd5:	55                   	push   %rbp
  800420ecd6:	48 89 e5             	mov    %rsp,%rbp
  800420ecd9:	48 83 ec 20          	sub    $0x20,%rsp
  800420ecdd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ece1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int r;
	struct Env *e;

	// Check if the processor has VMX support.
	if ( !vmx_check_support() ) {
  800420ece5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ecea:	48 ba c9 9a 21 04 80 	movabs $0x8004219ac9,%rdx
  800420ecf1:	00 00 00 
  800420ecf4:	ff d2                	callq  *%rdx
  800420ecf6:	83 f0 01             	xor    $0x1,%eax
  800420ecf9:	84 c0                	test   %al,%al
  800420ecfb:	74 0a                	je     800420ed07 <sys_env_mkguest+0x32>
		return -E_NO_VMX;
  800420ecfd:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  800420ed02:	e9 b1 00 00 00       	jmpq   800420edb8 <sys_env_mkguest+0xe3>
	} else if ( !vmx_check_ept() ) {
  800420ed07:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ed0c:	48 ba 2b 9b 21 04 80 	movabs $0x8004219b2b,%rdx
  800420ed13:	00 00 00 
  800420ed16:	ff d2                	callq  *%rdx
  800420ed18:	83 f0 01             	xor    $0x1,%eax
  800420ed1b:	84 c0                	test   %al,%al
  800420ed1d:	74 0a                	je     800420ed29 <sys_env_mkguest+0x54>
		return -E_NO_EPT;
  800420ed1f:	b8 ee ff ff ff       	mov    $0xffffffee,%eax
  800420ed24:	e9 8f 00 00 00       	jmpq   800420edb8 <sys_env_mkguest+0xe3>
	} 
	if ((r = env_guest_alloc(&e, curenv->env_id)) < 0)
  800420ed29:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420ed30:	00 00 00 
  800420ed33:	ff d0                	callq  *%rax
  800420ed35:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420ed3c:	00 00 00 
  800420ed3f:	48 98                	cltq   
  800420ed41:	48 c1 e0 03          	shl    $0x3,%rax
  800420ed45:	48 89 c1             	mov    %rax,%rcx
  800420ed48:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ed4c:	48 01 c8             	add    %rcx,%rax
  800420ed4f:	48 01 d0             	add    %rdx,%rax
  800420ed52:	48 83 c0 08          	add    $0x8,%rax
  800420ed56:	48 8b 00             	mov    (%rax),%rax
  800420ed59:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420ed5f:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800420ed63:	89 d6                	mov    %edx,%esi
  800420ed65:	48 89 c7             	mov    %rax,%rdi
  800420ed68:	48 b8 f2 7b 20 04 80 	movabs $0x8004207bf2,%rax
  800420ed6f:	00 00 00 
  800420ed72:	ff d0                	callq  *%rax
  800420ed74:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420ed77:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420ed7b:	79 05                	jns    800420ed82 <sys_env_mkguest+0xad>
		return r;
  800420ed7d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420ed80:	eb 36                	jmp    800420edb8 <sys_env_mkguest+0xe3>
	e->env_status = ENV_NOT_RUNNABLE;
  800420ed82:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed86:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420ed8d:	00 00 00 
	e->env_vmxinfo.phys_sz = gphysz;
  800420ed90:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ed94:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed98:	48 89 90 20 01 00 00 	mov    %rdx,0x120(%rax)
	e->env_tf.tf_rip = gRIP;
  800420ed9f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420eda3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420eda7:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	return e->env_id;
  800420edae:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420edb2:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420edb8:	c9                   	leaveq 
  800420edb9:	c3                   	retq   

000000800420edba <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420edba:	55                   	push   %rbp
  800420edbb:	48 89 e5             	mov    %rsp,%rbp
  800420edbe:	48 83 ec 40          	sub    $0x40,%rsp
  800420edc2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420edc6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420edca:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420edce:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420edd2:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  800420edd6:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.

	//panic("syscall not implemented");
	int64_t result = -E_NO_SYS;
  800420edda:	48 c7 45 f8 f9 ff ff 	movq   $0xfffffffffffffff9,-0x8(%rbp)
  800420ede1:	ff 

	switch (syscallno) {
  800420ede2:	48 83 7d e8 14       	cmpq   $0x14,-0x18(%rbp)
  800420ede7:	0f 87 96 02 00 00    	ja     800420f083 <syscall+0x2c9>
  800420eded:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edf1:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420edf8:	00 
  800420edf9:	48 b8 b8 ec 21 04 80 	movabs $0x800421ecb8,%rax
  800420ee00:	00 00 00 
  800420ee03:	48 01 d0             	add    %rdx,%rax
  800420ee06:	48 8b 00             	mov    (%rax),%rax
  800420ee09:	ff e0                	jmpq   *%rax
#ifndef VMM_GUEST
	case SYS_ept_map:
		return sys_ept_map(a1, (void*) a2, a3, (void*) a4, a5);
  800420ee0b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420ee0f:	89 c7                	mov    %eax,%edi
  800420ee11:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420ee15:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420ee19:	89 c2                	mov    %eax,%edx
  800420ee1b:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420ee1f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ee23:	41 89 f8             	mov    %edi,%r8d
  800420ee26:	89 c7                	mov    %eax,%edi
  800420ee28:	48 b8 7a ea 20 04 80 	movabs $0x800420ea7a,%rax
  800420ee2f:	00 00 00 
  800420ee32:	ff d0                	callq  *%rax
  800420ee34:	48 98                	cltq   
  800420ee36:	e9 55 02 00 00       	jmpq   800420f090 <syscall+0x2d6>
	case SYS_env_mkguest:
		return sys_env_mkguest(a1, a2);
  800420ee3b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420ee3f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ee43:	48 89 d6             	mov    %rdx,%rsi
  800420ee46:	48 89 c7             	mov    %rax,%rdi
  800420ee49:	48 b8 d5 ec 20 04 80 	movabs $0x800420ecd5,%rax
  800420ee50:	00 00 00 
  800420ee53:	ff d0                	callq  *%rax
  800420ee55:	48 98                	cltq   
  800420ee57:	e9 34 02 00 00       	jmpq   800420f090 <syscall+0x2d6>
	case SYS_vmx_list_vms:
		sys_vmx_list_vms();
  800420ee5c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ee61:	48 ba 17 ea 20 04 80 	movabs $0x800420ea17,%rdx
  800420ee68:	00 00 00 
  800420ee6b:	ff d2                	callq  *%rdx
		return 0;
  800420ee6d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ee72:	e9 19 02 00 00       	jmpq   800420f090 <syscall+0x2d6>
	case SYS_vmx_sel_resume:
		return sys_vmx_sel_resume(a1);
  800420ee77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ee7b:	89 c7                	mov    %eax,%edi
  800420ee7d:	48 b8 2e ea 20 04 80 	movabs $0x800420ea2e,%rax
  800420ee84:	00 00 00 
  800420ee87:	ff d0                	callq  *%rax
  800420ee89:	0f b6 c0             	movzbl %al,%eax
  800420ee8c:	e9 ff 01 00 00       	jmpq   800420f090 <syscall+0x2d6>
	case SYS_vmx_get_vmdisk_number:
		return sys_vmx_get_vmdisk_number();
  800420ee91:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ee96:	48 ba 4c ea 20 04 80 	movabs $0x800420ea4c,%rdx
  800420ee9d:	00 00 00 
  800420eea0:	ff d2                	callq  *%rdx
  800420eea2:	48 98                	cltq   
  800420eea4:	e9 e7 01 00 00       	jmpq   800420f090 <syscall+0x2d6>
	case SYS_vmx_incr_vmdisk_number:
		sys_vmx_incr_vmdisk_number();
  800420eea9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eeae:	48 ba 63 ea 20 04 80 	movabs $0x800420ea63,%rdx
  800420eeb5:	00 00 00 
  800420eeb8:	ff d2                	callq  *%rdx
		return 0;
  800420eeba:	b8 00 00 00 00       	mov    $0x0,%eax
  800420eebf:	e9 cc 01 00 00       	jmpq   800420f090 <syscall+0x2d6>
#endif
		
		case SYS_cputs:
			sys_cputs((const char *)a1, a2);
  800420eec4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eec8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420eecc:	48 89 d6             	mov    %rdx,%rsi
  800420eecf:	48 89 c7             	mov    %rax,%rdi
  800420eed2:	48 b8 c9 de 20 04 80 	movabs $0x800420dec9,%rax
  800420eed9:	00 00 00 
  800420eedc:	ff d0                	callq  *%rax
			result = 0;
  800420eede:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420eee5:	00 
			break;
  800420eee6:	e9 a1 01 00 00       	jmpq   800420f08c <syscall+0x2d2>
		case SYS_cgetc:
			result = sys_cgetc();
  800420eeeb:	48 b8 4d df 20 04 80 	movabs $0x800420df4d,%rax
  800420eef2:	00 00 00 
  800420eef5:	ff d0                	callq  *%rax
  800420eef7:	48 98                	cltq   
  800420eef9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420eefd:	e9 8a 01 00 00       	jmpq   800420f08c <syscall+0x2d2>
		case SYS_getenvid:
			result = sys_getenvid();
  800420ef02:	48 b8 5f df 20 04 80 	movabs $0x800420df5f,%rax
  800420ef09:	00 00 00 
  800420ef0c:	ff d0                	callq  *%rax
  800420ef0e:	48 98                	cltq   
  800420ef10:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420ef14:	e9 73 01 00 00       	jmpq   800420f08c <syscall+0x2d2>
		case SYS_env_destroy:
			result = sys_env_destroy(a1);
  800420ef19:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ef1d:	89 c7                	mov    %eax,%edi
  800420ef1f:	48 b8 9b df 20 04 80 	movabs $0x800420df9b,%rax
  800420ef26:	00 00 00 
  800420ef29:	ff d0                	callq  *%rax
  800420ef2b:	48 98                	cltq   
  800420ef2d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420ef31:	e9 56 01 00 00       	jmpq   800420f08c <syscall+0x2d2>
		case SYS_yield:
			sys_yield();
  800420ef36:	48 b8 eb df 20 04 80 	movabs $0x800420dfeb,%rax
  800420ef3d:	00 00 00 
  800420ef40:	ff d0                	callq  *%rax
			result = 0;
  800420ef42:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ef49:	00 
			break;
  800420ef4a:	e9 3d 01 00 00       	jmpq   800420f08c <syscall+0x2d2>
		case SYS_exofork:
			return sys_exofork();
  800420ef4f:	48 b8 fb df 20 04 80 	movabs $0x800420dffb,%rax
  800420ef56:	00 00 00 
  800420ef59:	ff d0                	callq  *%rax
  800420ef5b:	48 98                	cltq   
  800420ef5d:	e9 2e 01 00 00       	jmpq   800420f090 <syscall+0x2d6>
			break;
		case SYS_env_set_status:
			return sys_env_set_status(a1, a2);
  800420ef62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ef66:	89 c2                	mov    %eax,%edx
  800420ef68:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ef6c:	89 d6                	mov    %edx,%esi
  800420ef6e:	89 c7                	mov    %eax,%edi
  800420ef70:	48 b8 d7 e0 20 04 80 	movabs $0x800420e0d7,%rax
  800420ef77:	00 00 00 
  800420ef7a:	ff d0                	callq  *%rax
  800420ef7c:	48 98                	cltq   
  800420ef7e:	e9 0d 01 00 00       	jmpq   800420f090 <syscall+0x2d6>
			break;
		case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall(a1, (void*)a2);
  800420ef83:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420ef87:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ef8b:	48 89 d6             	mov    %rdx,%rsi
  800420ef8e:	89 c7                	mov    %eax,%edi
  800420ef90:	48 b8 d5 e1 20 04 80 	movabs $0x800420e1d5,%rax
  800420ef97:	00 00 00 
  800420ef9a:	ff d0                	callq  *%rax
  800420ef9c:	48 98                	cltq   
  800420ef9e:	e9 ed 00 00 00       	jmpq   800420f090 <syscall+0x2d6>
			break;
		case SYS_ipc_try_send:
			return sys_ipc_try_send(a1, a2, (void*)a3, a4);
  800420efa3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420efa7:	89 c1                	mov    %eax,%ecx
  800420efa9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420efad:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420efb1:	89 c6                	mov    %eax,%esi
  800420efb3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420efb7:	89 c7                	mov    %eax,%edi
  800420efb9:	48 b8 12 e5 20 04 80 	movabs $0x800420e512,%rax
  800420efc0:	00 00 00 
  800420efc3:	ff d0                	callq  *%rax
  800420efc5:	48 98                	cltq   
  800420efc7:	e9 c4 00 00 00       	jmpq   800420f090 <syscall+0x2d6>
			break;
		case SYS_ipc_recv:
			return sys_ipc_recv((void*)a1);
  800420efcc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420efd0:	48 89 c7             	mov    %rax,%rdi
  800420efd3:	48 b8 23 e8 20 04 80 	movabs $0x800420e823,%rax
  800420efda:	00 00 00 
  800420efdd:	ff d0                	callq  *%rax
  800420efdf:	48 98                	cltq   
  800420efe1:	e9 aa 00 00 00       	jmpq   800420f090 <syscall+0x2d6>
			break;
		case SYS_page_alloc:
			return sys_page_alloc(a1, (void*)a2, a3);
  800420efe6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420efea:	89 c2                	mov    %eax,%edx
  800420efec:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420eff0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420eff4:	48 89 ce             	mov    %rcx,%rsi
  800420eff7:	89 c7                	mov    %eax,%edi
  800420eff9:	48 b8 2c e2 20 04 80 	movabs $0x800420e22c,%rax
  800420f000:	00 00 00 
  800420f003:	ff d0                	callq  *%rax
  800420f005:	48 98                	cltq   
  800420f007:	e9 84 00 00 00       	jmpq   800420f090 <syscall+0x2d6>
			break;	
		case SYS_page_map:
			return sys_page_map(a1, (void*)a2, a3, (void*)a4, a5);
  800420f00c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420f010:	89 c7                	mov    %eax,%edi
  800420f012:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420f016:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f01a:	89 c2                	mov    %eax,%edx
  800420f01c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420f020:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f024:	41 89 f8             	mov    %edi,%r8d
  800420f027:	89 c7                	mov    %eax,%edi
  800420f029:	48 b8 17 e3 20 04 80 	movabs $0x800420e317,%rax
  800420f030:	00 00 00 
  800420f033:	ff d0                	callq  *%rax
  800420f035:	48 98                	cltq   
  800420f037:	eb 57                	jmp    800420f090 <syscall+0x2d6>
			break;
		case SYS_page_unmap:
			return sys_page_unmap(a1, (void*)a2);
  800420f039:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f03d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f041:	48 89 d6             	mov    %rdx,%rsi
  800420f044:	89 c7                	mov    %eax,%edi
  800420f046:	48 b8 84 e4 20 04 80 	movabs $0x800420e484,%rax
  800420f04d:	00 00 00 
  800420f050:	ff d0                	callq  *%rax
  800420f052:	48 98                	cltq   
  800420f054:	eb 3a                	jmp    800420f090 <syscall+0x2d6>
			break;
		case SYS_env_set_trapframe:
			return sys_env_set_trapframe(a1, (struct Trapframe *)a2);
  800420f056:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420f05a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f05e:	48 89 d6             	mov    %rdx,%rsi
  800420f061:	89 c7                	mov    %eax,%edi
  800420f063:	48 b8 3c e1 20 04 80 	movabs $0x800420e13c,%rax
  800420f06a:	00 00 00 
  800420f06d:	ff d0                	callq  *%rax
  800420f06f:	48 98                	cltq   
  800420f071:	eb 1d                	jmp    800420f090 <syscall+0x2d6>
		case SYS_time_msec:
			return sys_time_msec();
  800420f073:	48 b8 e9 e9 20 04 80 	movabs $0x800420e9e9,%rax
  800420f07a:	00 00 00 
  800420f07d:	ff d0                	callq  *%rax
  800420f07f:	48 98                	cltq   
  800420f081:	eb 0d                	jmp    800420f090 <syscall+0x2d6>
		default:		
			return -E_NO_SYS;
  800420f083:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
  800420f08a:	eb 04                	jmp    800420f090 <syscall+0x2d6>
	}
	return result;	
  800420f08c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f090:	c9                   	leaveq 
  800420f091:	c3                   	retq   

000000800420f092 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420f092:	55                   	push   %rbp
  800420f093:	48 89 e5             	mov    %rsp,%rbp
  800420f096:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420f09d:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420f0a4:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420f0ab:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420f0b2:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f0b9:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420f0c0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420f0c4:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f0cb:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f0d2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420f0d6:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420f0dd:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f0e4:	48 89 d1             	mov    %rdx,%rcx
  800420f0e7:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420f0ec:	48 89 ce             	mov    %rcx,%rsi
  800420f0ef:	48 89 c7             	mov    %rax,%rdi
  800420f0f2:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  800420f0f9:	00 00 00 
  800420f0fc:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420f0fe:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420f105:	00 
	uint64_t ret_offset=0;
  800420f106:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f10d:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420f10e:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f115:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f119:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420f11d:	74 0a                	je     800420f129 <list_func_die+0x97>
		return 0;
  800420f11f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f124:	e9 cd 06 00 00       	jmpq   800420f7f6 <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420f129:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f130:	ba 38 00 00 00       	mov    $0x38,%edx
  800420f135:	be 00 00 00 00       	mov    $0x0,%esi
  800420f13a:	48 89 c7             	mov    %rax,%rdi
  800420f13d:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  800420f144:	00 00 00 
  800420f147:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420f149:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f150:	be 11 00 00 00       	mov    $0x11,%esi
  800420f155:	48 89 c7             	mov    %rax,%rdi
  800420f158:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  800420f15f:	00 00 00 
  800420f162:	ff d0                	callq  *%rax
  800420f164:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420f168:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f16f:	be 12 00 00 00       	mov    $0x12,%esi
  800420f174:	48 89 c7             	mov    %rax,%rdi
  800420f177:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  800420f17e:	00 00 00 
  800420f181:	ff d0                	callq  *%rax
  800420f183:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420f187:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420f18c:	0f 84 5f 06 00 00    	je     800420f7f1 <list_func_die+0x75f>
  800420f192:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f196:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f19a:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420f1a1:	0f 83 4a 06 00 00    	jae    800420f7f1 <list_func_die+0x75f>
  800420f1a7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f1ac:	0f 84 3f 06 00 00    	je     800420f7f1 <list_func_die+0x75f>
  800420f1b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f1b6:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f1ba:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420f1c1:	0f 86 2a 06 00 00    	jbe    800420f7f1 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420f1c7:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f1ce:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f1d5:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420f1dc:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f1e3:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420f1e6:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f1ed:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420f1f4:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f1fb:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420f1ff:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f206:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420f20d:	48 89 c7             	mov    %rax,%rdi
  800420f210:	48 b8 87 08 21 04 80 	movabs $0x8004210887,%rax
  800420f217:	00 00 00 
  800420f21a:	ff d0                	callq  *%rax
  800420f21c:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420f223:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420f226:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f22a:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420f22e:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f235:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420f239:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f240:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f247:	48 85 c0             	test   %rax,%rax
  800420f24a:	75 35                	jne    800420f281 <list_func_die+0x1ef>
  800420f24c:	48 b9 80 f0 21 04 80 	movabs $0x800421f080,%rcx
  800420f253:	00 00 00 
  800420f256:	48 ba 8c f0 21 04 80 	movabs $0x800421f08c,%rdx
  800420f25d:	00 00 00 
  800420f260:	be 90 00 00 00       	mov    $0x90,%esi
  800420f265:	48 bf a1 f0 21 04 80 	movabs $0x800421f0a1,%rdi
  800420f26c:	00 00 00 
  800420f26f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f274:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420f27b:	00 00 00 
  800420f27e:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420f281:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420f288:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420f28f:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420f296:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420f29d:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420f2a2:	48 89 c7             	mov    %rax,%rdi
  800420f2a5:	48 b8 f7 60 21 04 80 	movabs $0x80042160f7,%rax
  800420f2ac:	00 00 00 
  800420f2af:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420f2b1:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420f2b8:	89 c2                	mov    %eax,%edx
  800420f2ba:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f2c1:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420f2c4:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f2cb:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420f2d2:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420f2d9:	00 00 00 
  800420f2dc:	48 8b 00             	mov    (%rax),%rax
  800420f2df:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420f2e6:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420f2ed:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420f2f1:	48 89 c7             	mov    %rax,%rdi
  800420f2f4:	48 b8 98 2d 21 04 80 	movabs $0x8004212d98,%rax
  800420f2fb:	00 00 00 
  800420f2fe:	ff d0                	callq  *%rax
  800420f300:	83 f8 04             	cmp    $0x4,%eax
  800420f303:	0f 84 e1 04 00 00    	je     800420f7ea <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420f309:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420f310:	48 83 f8 05          	cmp    $0x5,%rax
  800420f314:	74 05                	je     800420f31b <list_func_die+0x289>
				goto last;
  800420f316:	e9 cf 04 00 00       	jmpq   800420f7ea <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420f31b:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420f322:	be 49 00 00 00       	mov    $0x49,%esi
  800420f327:	48 89 c7             	mov    %rax,%rdi
  800420f32a:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  800420f331:	00 00 00 
  800420f334:	ff d0                	callq  *%rax
  800420f336:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420f33a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f33f:	0f 84 d7 00 00 00    	je     800420f41c <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420f345:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f349:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420f34d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f351:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f355:	48 01 d0             	add    %rdx,%rax
  800420f358:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420f35c:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420f363:	00 00 00 
  800420f366:	48 8b 08             	mov    (%rax),%rcx
  800420f369:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420f370:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420f374:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f378:	48 8b 38             	mov    (%rax),%rdi
  800420f37b:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420f37f:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420f383:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420f388:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420f38c:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420f391:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420f395:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420f39a:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420f39e:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420f3a3:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420f3a7:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420f3ac:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420f3b0:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420f3b5:	48 89 cf             	mov    %rcx,%rdi
  800420f3b8:	48 b8 be 29 21 04 80 	movabs $0x80042129be,%rax
  800420f3bf:	00 00 00 
  800420f3c2:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420f3c4:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f3cb:	be 0b 00 00 00       	mov    $0xb,%esi
  800420f3d0:	48 89 c7             	mov    %rax,%rdi
  800420f3d3:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  800420f3da:	00 00 00 
  800420f3dd:	ff d0                	callq  *%rax
  800420f3df:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420f3e3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f3e8:	74 0e                	je     800420f3f8 <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420f3ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f3ee:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f3f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420f3f6:	eb 24                	jmp    800420f41c <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420f3f8:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f3ff:	be 49 00 00 00       	mov    $0x49,%esi
  800420f404:	48 89 c7             	mov    %rax,%rdi
  800420f407:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  800420f40e:	00 00 00 
  800420f411:	ff d0                	callq  *%rax
  800420f413:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420f417:	e9 1e ff ff ff       	jmpq   800420f33a <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420f41c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f423:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420f424:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420f42b:	be 02 00 00 00       	mov    $0x2,%esi
  800420f430:	48 89 c7             	mov    %rax,%rdi
  800420f433:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  800420f43a:	00 00 00 
  800420f43d:	ff d0                	callq  *%rax
  800420f43f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420f443:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f448:	0f 84 a2 00 00 00    	je     800420f4f0 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420f44e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f452:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420f456:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420f45a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f45e:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420f462:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420f466:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f46a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f46e:	48 83 f8 03          	cmp    $0x3,%rax
  800420f472:	72 7c                	jb     800420f4f0 <list_func_die+0x45e>
  800420f474:	48 83 f8 04          	cmp    $0x4,%rax
  800420f478:	76 06                	jbe    800420f480 <list_func_die+0x3ee>
  800420f47a:	48 83 f8 0a          	cmp    $0xa,%rax
  800420f47e:	75 70                	jne    800420f4f0 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420f480:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420f487:	00 
						atom = *(loc_ptr++);
  800420f488:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f48c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f490:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420f494:	0f b6 00             	movzbl (%rax),%eax
  800420f497:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420f49a:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420f49f:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420f4a3:	75 4a                	jne    800420f4ef <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420f4a5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f4a9:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420f4b0:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420f4b7:	48 89 c7             	mov    %rax,%rdi
  800420f4ba:	48 b8 1d 17 21 04 80 	movabs $0x800421171d,%rax
  800420f4c1:	00 00 00 
  800420f4c4:	ff d0                	callq  *%rax
  800420f4c6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420f4ca:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420f4d1:	48 89 c2             	mov    %rax,%rdx
  800420f4d4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420f4d8:	48 29 c2             	sub    %rax,%rdx
  800420f4db:	48 89 d0             	mov    %rdx,%rax
  800420f4de:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420f4e2:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420f4e9:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420f4ed:	eb 00                	jmp    800420f4ef <list_func_die+0x45d>
  800420f4ef:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420f4f0:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f4f7:	8b 48 28             	mov    0x28(%rax),%ecx
  800420f4fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f4fe:	89 c2                	mov    %eax,%edx
  800420f500:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f507:	48 63 c9             	movslq %ecx,%rcx
  800420f50a:	48 83 c1 08          	add    $0x8,%rcx
  800420f50e:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420f512:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f519:	8b 50 28             	mov    0x28(%rax),%edx
  800420f51c:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f523:	48 63 d2             	movslq %edx,%rdx
  800420f526:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420f52a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f52e:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420f533:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f53a:	8b 40 28             	mov    0x28(%rax),%eax
  800420f53d:	8d 50 01             	lea    0x1(%rax),%edx
  800420f540:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f547:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420f54a:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f551:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420f558:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420f55d:	48 89 ce             	mov    %rcx,%rsi
  800420f560:	48 89 c7             	mov    %rax,%rdi
  800420f563:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  800420f56a:	00 00 00 
  800420f56d:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420f56f:	e9 40 02 00 00       	jmpq   800420f7b4 <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420f574:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420f57b:	48 83 f8 05          	cmp    $0x5,%rax
  800420f57f:	74 05                	je     800420f586 <list_func_die+0x4f4>
					break;
  800420f581:	e9 64 02 00 00       	jmpq   800420f7ea <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420f586:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420f58d:	be 49 00 00 00       	mov    $0x49,%esi
  800420f592:	48 89 c7             	mov    %rax,%rdi
  800420f595:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  800420f59c:	00 00 00 
  800420f59f:	ff d0                	callq  *%rax
  800420f5a1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420f5a5:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f5aa:	0f 84 b1 00 00 00    	je     800420f661 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420f5b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f5b4:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420f5b8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f5bc:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f5c0:	48 01 d0             	add    %rdx,%rax
  800420f5c3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420f5c7:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420f5ce:	00 00 00 
  800420f5d1:	48 8b 08             	mov    (%rax),%rcx
  800420f5d4:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420f5db:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420f5df:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f5e3:	48 8b 38             	mov    (%rax),%rdi
  800420f5e6:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420f5ea:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420f5ee:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420f5f3:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420f5f7:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420f5fc:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420f600:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420f605:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420f609:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420f60e:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420f612:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420f617:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420f61b:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420f620:	48 89 cf             	mov    %rcx,%rdi
  800420f623:	48 b8 be 29 21 04 80 	movabs $0x80042129be,%rax
  800420f62a:	00 00 00 
  800420f62d:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420f62f:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f636:	be 0b 00 00 00       	mov    $0xb,%esi
  800420f63b:	48 89 c7             	mov    %rax,%rdi
  800420f63e:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  800420f645:	00 00 00 
  800420f648:	ff d0                	callq  *%rax
  800420f64a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420f64e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f653:	74 0c                	je     800420f661 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420f655:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f659:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420f65d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420f661:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420f668:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420f669:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420f670:	be 02 00 00 00       	mov    $0x2,%esi
  800420f675:	48 89 c7             	mov    %rax,%rdi
  800420f678:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  800420f67f:	00 00 00 
  800420f682:	ff d0                	callq  *%rax
  800420f684:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420f688:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f68d:	0f 84 a2 00 00 00    	je     800420f735 <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420f693:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f697:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420f69b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420f69f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6a3:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420f6a7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420f6ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f6af:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420f6b3:	48 83 f8 03          	cmp    $0x3,%rax
  800420f6b7:	72 7c                	jb     800420f735 <list_func_die+0x6a3>
  800420f6b9:	48 83 f8 04          	cmp    $0x4,%rax
  800420f6bd:	76 06                	jbe    800420f6c5 <list_func_die+0x633>
  800420f6bf:	48 83 f8 0a          	cmp    $0xa,%rax
  800420f6c3:	75 70                	jne    800420f735 <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420f6c5:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420f6cc:	00 
							atom = *(loc_ptr++);
  800420f6cd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f6d1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f6d5:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420f6d9:	0f b6 00             	movzbl (%rax),%eax
  800420f6dc:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420f6df:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420f6e4:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420f6e8:	75 4a                	jne    800420f734 <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420f6ea:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f6ee:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420f6f5:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420f6fc:	48 89 c7             	mov    %rax,%rdi
  800420f6ff:	48 b8 1d 17 21 04 80 	movabs $0x800421171d,%rax
  800420f706:	00 00 00 
  800420f709:	ff d0                	callq  *%rax
  800420f70b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420f70f:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420f716:	48 89 c2             	mov    %rax,%rdx
  800420f719:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f71d:	48 29 c2             	sub    %rax,%rdx
  800420f720:	48 89 d0             	mov    %rdx,%rax
  800420f723:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420f727:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420f72e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420f732:	eb 00                	jmp    800420f734 <list_func_die+0x6a2>
  800420f734:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420f735:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f73c:	8b 48 28             	mov    0x28(%rax),%ecx
  800420f73f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f743:	89 c2                	mov    %eax,%edx
  800420f745:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f74c:	48 63 c9             	movslq %ecx,%rcx
  800420f74f:	48 83 c1 08          	add    $0x8,%rcx
  800420f753:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420f757:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f75e:	8b 50 28             	mov    0x28(%rax),%edx
  800420f761:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f768:	48 63 d2             	movslq %edx,%rdx
  800420f76b:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420f76f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f773:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420f778:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f77f:	8b 40 28             	mov    0x28(%rax),%eax
  800420f782:	8d 50 01             	lea    0x1(%rax),%edx
  800420f785:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420f78c:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420f78f:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420f796:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420f79d:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420f7a2:	48 89 ce             	mov    %rcx,%rsi
  800420f7a5:	48 89 c7             	mov    %rax,%rdi
  800420f7a8:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  800420f7af:	00 00 00 
  800420f7b2:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420f7b4:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420f7bb:	00 00 00 
  800420f7be:	48 8b 00             	mov    (%rax),%rax
  800420f7c1:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420f7c5:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420f7cc:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420f7d3:	48 89 c7             	mov    %rax,%rdi
  800420f7d6:	48 b8 54 2b 21 04 80 	movabs $0x8004212b54,%rax
  800420f7dd:	00 00 00 
  800420f7e0:	ff d0                	callq  *%rax
  800420f7e2:	85 c0                	test   %eax,%eax
  800420f7e4:	0f 84 8a fd ff ff    	je     800420f574 <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420f7ea:	b8 01 00 00 00       	mov    $0x1,%eax
  800420f7ef:	eb 05                	jmp    800420f7f6 <list_func_die+0x764>
	}

	return 0;
  800420f7f1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420f7f6:	c9                   	leaveq 
  800420f7f7:	c3                   	retq   

000000800420f7f8 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420f7f8:	55                   	push   %rbp
  800420f7f9:	48 89 e5             	mov    %rsp,%rbp
  800420f7fc:	53                   	push   %rbx
  800420f7fd:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420f804:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420f80b:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420f812:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420f819:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420f81a:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420f821:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420f825:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f82c:	48 bb af f0 21 04 80 	movabs $0x800421f0af,%rbx
  800420f833:	00 00 00 
  800420f836:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420f839:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f840:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420f847:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f84e:	48 bb af f0 21 04 80 	movabs $0x800421f0af,%rbx
  800420f855:	00 00 00 
  800420f858:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420f85c:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f863:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420f86a:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f871:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420f878:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420f87c:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420f883:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420f88a:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420f891:	00 00 00 
  800420f894:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420f89b:	76 13                	jbe    800420f8b0 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420f89d:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420f8a4:	00 00 00 
  800420f8a7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420f8ab:	e9 04 01 00 00       	jmpq   800420f9b4 <debuginfo_rip+0x1bc>
	} else {
		if(curenv != lastenv) {
  800420f8b0:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420f8b7:	00 00 00 
  800420f8ba:	ff d0                	callq  *%rax
  800420f8bc:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420f8c3:	00 00 00 
  800420f8c6:	48 98                	cltq   
  800420f8c8:	48 c1 e0 03          	shl    $0x3,%rax
  800420f8cc:	48 89 c1             	mov    %rax,%rcx
  800420f8cf:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f8d3:	48 01 c8             	add    %rcx,%rax
  800420f8d6:	48 01 d0             	add    %rdx,%rax
  800420f8d9:	48 83 c0 08          	add    $0x8,%rax
  800420f8dd:	48 8b 10             	mov    (%rax),%rdx
  800420f8e0:	48 b8 a0 e2 3a 04 80 	movabs $0x80043ae2a0,%rax
  800420f8e7:	00 00 00 
  800420f8ea:	48 8b 00             	mov    (%rax),%rax
  800420f8ed:	48 39 c2             	cmp    %rax,%rdx
  800420f8f0:	0f 84 83 00 00 00    	je     800420f979 <debuginfo_rip+0x181>
			find_debug_sections((uintptr_t)curenv->elf);
  800420f8f6:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420f8fd:	00 00 00 
  800420f900:	ff d0                	callq  *%rax
  800420f902:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420f909:	00 00 00 
  800420f90c:	48 98                	cltq   
  800420f90e:	48 c1 e0 03          	shl    $0x3,%rax
  800420f912:	48 89 c1             	mov    %rax,%rcx
  800420f915:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f919:	48 01 c8             	add    %rcx,%rax
  800420f91c:	48 01 d0             	add    %rdx,%rax
  800420f91f:	48 83 c0 08          	add    $0x8,%rax
  800420f923:	48 8b 00             	mov    (%rax),%rax
  800420f926:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420f92d:	48 89 c7             	mov    %rax,%rdi
  800420f930:	48 b8 f2 62 21 04 80 	movabs $0x80042162f2,%rax
  800420f937:	00 00 00 
  800420f93a:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420f93c:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420f943:	00 00 00 
  800420f946:	ff d0                	callq  *%rax
  800420f948:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420f94f:	00 00 00 
  800420f952:	48 98                	cltq   
  800420f954:	48 c1 e0 03          	shl    $0x3,%rax
  800420f958:	48 89 c1             	mov    %rax,%rcx
  800420f95b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f95f:	48 01 c8             	add    %rcx,%rax
  800420f962:	48 01 d0             	add    %rdx,%rax
  800420f965:	48 83 c0 08          	add    $0x8,%rax
  800420f969:	48 8b 10             	mov    (%rax),%rdx
  800420f96c:	48 b8 a0 e2 3a 04 80 	movabs $0x80043ae2a0,%rax
  800420f973:	00 00 00 
  800420f976:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420f979:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800420f980:	00 00 00 
  800420f983:	ff d0                	callq  *%rax
  800420f985:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800420f98c:	00 00 00 
  800420f98f:	48 98                	cltq   
  800420f991:	48 c1 e0 03          	shl    $0x3,%rax
  800420f995:	48 89 c1             	mov    %rax,%rcx
  800420f998:	48 c1 e1 04          	shl    $0x4,%rcx
  800420f99c:	48 01 c8             	add    %rcx,%rax
  800420f99f:	48 01 d0             	add    %rdx,%rax
  800420f9a2:	48 83 c0 08          	add    $0x8,%rax
  800420f9a6:	48 8b 00             	mov    (%rax),%rax
  800420f9a9:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420f9b0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420f9b4:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420f9bb:	00 00 00 
  800420f9be:	48 8b 00             	mov    (%rax),%rax
  800420f9c1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f9c5:	48 89 d6             	mov    %rdx,%rsi
  800420f9c8:	48 89 c7             	mov    %rax,%rdi
  800420f9cb:	48 b8 cc 19 21 04 80 	movabs $0x80042119cc,%rax
  800420f9d2:	00 00 00 
  800420f9d5:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420f9d7:	48 bf b9 f0 21 04 80 	movabs $0x800421f0b9,%rdi
  800420f9de:	00 00 00 
  800420f9e1:	48 b8 72 62 21 04 80 	movabs $0x8004216272,%rax
  800420f9e8:	00 00 00 
  800420f9eb:	ff d0                	callq  *%rax
  800420f9ed:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420f9f1:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420f9f8:	00 00 00 
  800420f9fb:	48 8b 00             	mov    (%rax),%rax
  800420f9fe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420fa02:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420fa06:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420fa0a:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420fa11:	00 00 00 
  800420fa14:	48 8b 00             	mov    (%rax),%rax
  800420fa17:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420fa1b:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420fa1f:	48 89 50 10          	mov    %rdx,0x10(%rax)
    
	assert(dbg->dbg_info_size);
  800420fa23:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420fa2a:	00 00 00 
  800420fa2d:	48 8b 00             	mov    (%rax),%rax
  800420fa30:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420fa34:	48 85 c0             	test   %rax,%rax
  800420fa37:	75 35                	jne    800420fa6e <debuginfo_rip+0x276>
  800420fa39:	48 b9 c5 f0 21 04 80 	movabs $0x800421f0c5,%rcx
  800420fa40:	00 00 00 
  800420fa43:	48 ba 8c f0 21 04 80 	movabs $0x800421f08c,%rdx
  800420fa4a:	00 00 00 
  800420fa4d:	be 36 01 00 00       	mov    $0x136,%esi
  800420fa52:	48 bf a1 f0 21 04 80 	movabs $0x800421f0a1,%rdi
  800420fa59:	00 00 00 
  800420fa5c:	b8 00 00 00 00       	mov    $0x0,%eax
  800420fa61:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800420fa68:	00 00 00 
  800420fa6b:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420fa6e:	e9 6f 01 00 00       	jmpq   800420fbe2 <debuginfo_rip+0x3ea>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420fa73:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420fa7a:	00 00 00 
  800420fa7d:	48 8b 00             	mov    (%rax),%rax
  800420fa80:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420fa84:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420fa8b:	be 00 00 00 00       	mov    $0x0,%esi
  800420fa90:	48 89 c7             	mov    %rax,%rdi
  800420fa93:	48 b8 54 2b 21 04 80 	movabs $0x8004212b54,%rax
  800420fa9a:	00 00 00 
  800420fa9d:	ff d0                	callq  *%rax
  800420fa9f:	83 f8 04             	cmp    $0x4,%eax
  800420faa2:	75 05                	jne    800420faa9 <debuginfo_rip+0x2b1>
		{
			continue;
  800420faa4:	e9 39 01 00 00       	jmpq   800420fbe2 <debuginfo_rip+0x3ea>
		}	
		cudie.cu_header = &cu;
  800420faa9:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420faad:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420fab4:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420fabb:	00 00 00 00 
	    
		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420fabf:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420fac6:	00 00 00 
  800420fac9:	48 8b 00             	mov    (%rax),%rax
  800420facc:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420fad3:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420fada:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420fade:	48 89 c7             	mov    %rax,%rdi
  800420fae1:	48 b8 98 2d 21 04 80 	movabs $0x8004212d98,%rax
  800420fae8:	00 00 00 
  800420faeb:	ff d0                	callq  *%rax
  800420faed:	83 f8 04             	cmp    $0x4,%eax
  800420faf0:	75 05                	jne    800420faf7 <debuginfo_rip+0x2ff>
		{
			continue;
  800420faf2:	e9 eb 00 00 00       	jmpq   800420fbe2 <debuginfo_rip+0x3ea>
		}	
		die.cu_header = &cu;
  800420faf7:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420fafb:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420fb02:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420fb09:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420fb10:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420fb17:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420fb1e:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420fb25:	48 89 ce             	mov    %rcx,%rsi
  800420fb28:	48 89 c7             	mov    %rax,%rdi
  800420fb2b:	48 b8 92 f0 20 04 80 	movabs $0x800420f092,%rax
  800420fb32:	00 00 00 
  800420fb35:	ff d0                	callq  *%rax
  800420fb37:	85 c0                	test   %eax,%eax
  800420fb39:	74 30                	je     800420fb6b <debuginfo_rip+0x373>
				goto find_done;
  800420fb3b:	90                   	nop
    
	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420fb3c:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420fb43:	00 00 00 
  800420fb46:	48 8b 00             	mov    (%rax),%rax
  800420fb49:	be 00 00 00 00       	mov    $0x0,%esi
  800420fb4e:	48 89 c7             	mov    %rax,%rdi
  800420fb51:	48 b8 7f 54 21 04 80 	movabs $0x800421547f,%rax
  800420fb58:	00 00 00 
  800420fb5b:	ff d0                	callq  *%rax
  800420fb5d:	83 f8 01             	cmp    $0x1,%eax
  800420fb60:	0f 85 bb 00 00 00    	jne    800420fc21 <debuginfo_rip+0x429>
  800420fb66:	e9 ac 00 00 00       	jmpq   800420fc17 <debuginfo_rip+0x41f>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420fb6b:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420fb72:	00 00 00 
  800420fb75:	48 8b 00             	mov    (%rax),%rax
  800420fb78:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420fb7c:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420fb83:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420fb8a:	48 89 c7             	mov    %rax,%rdi
  800420fb8d:	48 b8 54 2b 21 04 80 	movabs $0x8004212b54,%rax
  800420fb94:	00 00 00 
  800420fb97:	ff d0                	callq  *%rax
  800420fb99:	85 c0                	test   %eax,%eax
  800420fb9b:	79 02                	jns    800420fb9f <debuginfo_rip+0x3a7>
				break; 
  800420fb9d:	eb 43                	jmp    800420fbe2 <debuginfo_rip+0x3ea>
			die = die2;
  800420fb9f:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420fba6:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420fbad:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420fbb2:	48 89 ce             	mov    %rcx,%rsi
  800420fbb5:	48 89 c7             	mov    %rax,%rdi
  800420fbb8:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  800420fbbf:	00 00 00 
  800420fbc2:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420fbc4:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420fbc8:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420fbcf:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420fbd6:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420fbdd:	e9 2e ff ff ff       	jmpq   800420fb10 <debuginfo_rip+0x318>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;
    
	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420fbe2:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420fbe9:	00 00 00 
  800420fbec:	48 8b 00             	mov    (%rax),%rax
  800420fbef:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420fbf3:	48 89 d6             	mov    %rdx,%rsi
  800420fbf6:	48 89 c7             	mov    %rax,%rdi
  800420fbf9:	48 b8 ae 1a 21 04 80 	movabs $0x8004211aae,%rax
  800420fc00:	00 00 00 
  800420fc03:	ff d0                	callq  *%rax
  800420fc05:	85 c0                	test   %eax,%eax
  800420fc07:	0f 84 66 fe ff ff    	je     800420fa73 <debuginfo_rip+0x27b>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}
    
	return -1;
  800420fc0d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fc12:	e9 a0 00 00 00       	jmpq   800420fcb7 <debuginfo_rip+0x4bf>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420fc17:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420fc1c:	e9 96 00 00 00       	jmpq   800420fcb7 <debuginfo_rip+0x4bf>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420fc21:	48 b8 60 36 23 04 80 	movabs $0x8004233660,%rax
  800420fc28:	00 00 00 
  800420fc2b:	48 8b 08             	mov    (%rax),%rcx
  800420fc2e:	48 b8 58 36 23 04 80 	movabs $0x8004233658,%rax
  800420fc35:	00 00 00 
  800420fc38:	48 8b 10             	mov    (%rax),%rdx
  800420fc3b:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420fc42:	00 00 00 
  800420fc45:	48 8b 00             	mov    (%rax),%rax
  800420fc48:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420fc4f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420fc55:	48 89 c7             	mov    %rax,%rdi
  800420fc58:	48 b8 d9 2f 21 04 80 	movabs $0x8004212fd9,%rax
  800420fc5f:	00 00 00 
  800420fc62:	ff d0                	callq  *%rax
  800420fc64:	85 c0                	test   %eax,%eax
  800420fc66:	75 4a                	jne    800420fcb2 <debuginfo_rip+0x4ba>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr, &info->reg_table,
  800420fc68:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420fc6f:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420fc76:	48 b8 58 36 23 04 80 	movabs $0x8004233658,%rax
  800420fc7d:	00 00 00 
  800420fc80:	48 8b 30             	mov    (%rax),%rsi
  800420fc83:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800420fc8a:	00 00 00 
  800420fc8d:	48 8b 00             	mov    (%rax),%rax
  800420fc90:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420fc97:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420fc9d:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420fca3:	48 89 c7             	mov    %rax,%rdi
  800420fca6:	48 b8 fa 42 21 04 80 	movabs $0x80042142fa,%rax
  800420fcad:	00 00 00 
  800420fcb0:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420fcb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fcb7:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420fcbe:	5b                   	pop    %rbx
  800420fcbf:	5d                   	pop    %rbp
  800420fcc0:	c3                   	retq   

000000800420fcc1 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420fcc1:	55                   	push   %rbp
  800420fcc2:	48 89 e5             	mov    %rsp,%rbp
  800420fcc5:	53                   	push   %rbx
  800420fcc6:	48 83 ec 38          	sub    $0x38,%rsp
  800420fcca:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fcce:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fcd2:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fcd6:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420fcd9:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420fcdd:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420fce1:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420fce4:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420fce8:	77 3b                	ja     800420fd25 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420fcea:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420fced:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420fcf1:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420fcf4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcf8:	ba 00 00 00 00       	mov    $0x0,%edx
  800420fcfd:	48 f7 f3             	div    %rbx
  800420fd00:	48 89 c2             	mov    %rax,%rdx
  800420fd03:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420fd06:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420fd09:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420fd0d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd11:	41 89 f9             	mov    %edi,%r9d
  800420fd14:	48 89 c7             	mov    %rax,%rdi
  800420fd17:	48 b8 c1 fc 20 04 80 	movabs $0x800420fcc1,%rax
  800420fd1e:	00 00 00 
  800420fd21:	ff d0                	callq  *%rax
  800420fd23:	eb 1e                	jmp    800420fd43 <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420fd25:	eb 12                	jmp    800420fd39 <printnum+0x78>
			putch(padc, putdat);
  800420fd27:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420fd2b:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420fd2e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd32:	48 89 ce             	mov    %rcx,%rsi
  800420fd35:	89 d7                	mov    %edx,%edi
  800420fd37:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420fd39:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420fd3d:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420fd41:	7f e4                	jg     800420fd27 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420fd43:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420fd46:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd4a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420fd4f:	48 f7 f1             	div    %rcx
  800420fd52:	48 89 d0             	mov    %rdx,%rax
  800420fd55:	48 ba d0 f2 21 04 80 	movabs $0x800421f2d0,%rdx
  800420fd5c:	00 00 00 
  800420fd5f:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420fd63:	0f be d0             	movsbl %al,%edx
  800420fd66:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420fd6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd6e:	48 89 ce             	mov    %rcx,%rsi
  800420fd71:	89 d7                	mov    %edx,%edi
  800420fd73:	ff d0                	callq  *%rax
}
  800420fd75:	48 83 c4 38          	add    $0x38,%rsp
  800420fd79:	5b                   	pop    %rbx
  800420fd7a:	5d                   	pop    %rbp
  800420fd7b:	c3                   	retq   

000000800420fd7c <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420fd7c:	55                   	push   %rbp
  800420fd7d:	48 89 e5             	mov    %rsp,%rbp
  800420fd80:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420fd84:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fd88:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420fd8b:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420fd8f:	7e 52                	jle    800420fde3 <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420fd91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd95:	8b 00                	mov    (%rax),%eax
  800420fd97:	83 f8 30             	cmp    $0x30,%eax
  800420fd9a:	73 24                	jae    800420fdc0 <getuint+0x44>
  800420fd9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fda0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420fda4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fda8:	8b 00                	mov    (%rax),%eax
  800420fdaa:	89 c0                	mov    %eax,%eax
  800420fdac:	48 01 d0             	add    %rdx,%rax
  800420fdaf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fdb3:	8b 12                	mov    (%rdx),%edx
  800420fdb5:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420fdb8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fdbc:	89 0a                	mov    %ecx,(%rdx)
  800420fdbe:	eb 17                	jmp    800420fdd7 <getuint+0x5b>
  800420fdc0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fdc4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420fdc8:	48 89 d0             	mov    %rdx,%rax
  800420fdcb:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420fdcf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fdd3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420fdd7:	48 8b 00             	mov    (%rax),%rax
  800420fdda:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fdde:	e9 a3 00 00 00       	jmpq   800420fe86 <getuint+0x10a>
	else if (lflag)
  800420fde3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420fde7:	74 4f                	je     800420fe38 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420fde9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fded:	8b 00                	mov    (%rax),%eax
  800420fdef:	83 f8 30             	cmp    $0x30,%eax
  800420fdf2:	73 24                	jae    800420fe18 <getuint+0x9c>
  800420fdf4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fdf8:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420fdfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe00:	8b 00                	mov    (%rax),%eax
  800420fe02:	89 c0                	mov    %eax,%eax
  800420fe04:	48 01 d0             	add    %rdx,%rax
  800420fe07:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe0b:	8b 12                	mov    (%rdx),%edx
  800420fe0d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420fe10:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe14:	89 0a                	mov    %ecx,(%rdx)
  800420fe16:	eb 17                	jmp    800420fe2f <getuint+0xb3>
  800420fe18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe1c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420fe20:	48 89 d0             	mov    %rdx,%rax
  800420fe23:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420fe27:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe2b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420fe2f:	48 8b 00             	mov    (%rax),%rax
  800420fe32:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420fe36:	eb 4e                	jmp    800420fe86 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420fe38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe3c:	8b 00                	mov    (%rax),%eax
  800420fe3e:	83 f8 30             	cmp    $0x30,%eax
  800420fe41:	73 24                	jae    800420fe67 <getuint+0xeb>
  800420fe43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe47:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420fe4b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe4f:	8b 00                	mov    (%rax),%eax
  800420fe51:	89 c0                	mov    %eax,%eax
  800420fe53:	48 01 d0             	add    %rdx,%rax
  800420fe56:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe5a:	8b 12                	mov    (%rdx),%edx
  800420fe5c:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420fe5f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe63:	89 0a                	mov    %ecx,(%rdx)
  800420fe65:	eb 17                	jmp    800420fe7e <getuint+0x102>
  800420fe67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fe6b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420fe6f:	48 89 d0             	mov    %rdx,%rax
  800420fe72:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420fe76:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fe7a:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420fe7e:	8b 00                	mov    (%rax),%eax
  800420fe80:	89 c0                	mov    %eax,%eax
  800420fe82:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420fe86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fe8a:	c9                   	leaveq 
  800420fe8b:	c3                   	retq   

000000800420fe8c <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420fe8c:	55                   	push   %rbp
  800420fe8d:	48 89 e5             	mov    %rsp,%rbp
  800420fe90:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420fe94:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fe98:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420fe9b:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420fe9f:	7e 52                	jle    800420fef3 <getint+0x67>
		x=va_arg(*ap, long long);
  800420fea1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fea5:	8b 00                	mov    (%rax),%eax
  800420fea7:	83 f8 30             	cmp    $0x30,%eax
  800420feaa:	73 24                	jae    800420fed0 <getint+0x44>
  800420feac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420feb0:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420feb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420feb8:	8b 00                	mov    (%rax),%eax
  800420feba:	89 c0                	mov    %eax,%eax
  800420febc:	48 01 d0             	add    %rdx,%rax
  800420febf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fec3:	8b 12                	mov    (%rdx),%edx
  800420fec5:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420fec8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fecc:	89 0a                	mov    %ecx,(%rdx)
  800420fece:	eb 17                	jmp    800420fee7 <getint+0x5b>
  800420fed0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fed4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420fed8:	48 89 d0             	mov    %rdx,%rax
  800420fedb:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420fedf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fee3:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420fee7:	48 8b 00             	mov    (%rax),%rax
  800420feea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420feee:	e9 a3 00 00 00       	jmpq   800420ff96 <getint+0x10a>
	else if (lflag)
  800420fef3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420fef7:	74 4f                	je     800420ff48 <getint+0xbc>
		x=va_arg(*ap, long);
  800420fef9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fefd:	8b 00                	mov    (%rax),%eax
  800420feff:	83 f8 30             	cmp    $0x30,%eax
  800420ff02:	73 24                	jae    800420ff28 <getint+0x9c>
  800420ff04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff08:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ff0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff10:	8b 00                	mov    (%rax),%eax
  800420ff12:	89 c0                	mov    %eax,%eax
  800420ff14:	48 01 d0             	add    %rdx,%rax
  800420ff17:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ff1b:	8b 12                	mov    (%rdx),%edx
  800420ff1d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ff20:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ff24:	89 0a                	mov    %ecx,(%rdx)
  800420ff26:	eb 17                	jmp    800420ff3f <getint+0xb3>
  800420ff28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff2c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ff30:	48 89 d0             	mov    %rdx,%rax
  800420ff33:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ff37:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ff3b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ff3f:	48 8b 00             	mov    (%rax),%rax
  800420ff42:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ff46:	eb 4e                	jmp    800420ff96 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420ff48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff4c:	8b 00                	mov    (%rax),%eax
  800420ff4e:	83 f8 30             	cmp    $0x30,%eax
  800420ff51:	73 24                	jae    800420ff77 <getint+0xeb>
  800420ff53:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff57:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ff5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff5f:	8b 00                	mov    (%rax),%eax
  800420ff61:	89 c0                	mov    %eax,%eax
  800420ff63:	48 01 d0             	add    %rdx,%rax
  800420ff66:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ff6a:	8b 12                	mov    (%rdx),%edx
  800420ff6c:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ff6f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ff73:	89 0a                	mov    %ecx,(%rdx)
  800420ff75:	eb 17                	jmp    800420ff8e <getint+0x102>
  800420ff77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff7b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ff7f:	48 89 d0             	mov    %rdx,%rax
  800420ff82:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ff86:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ff8a:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ff8e:	8b 00                	mov    (%rax),%eax
  800420ff90:	48 98                	cltq   
  800420ff92:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ff96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ff9a:	c9                   	leaveq 
  800420ff9b:	c3                   	retq   

000000800420ff9c <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420ff9c:	55                   	push   %rbp
  800420ff9d:	48 89 e5             	mov    %rsp,%rbp
  800420ffa0:	41 54                	push   %r12
  800420ffa2:	53                   	push   %rbx
  800420ffa3:	48 83 ec 60          	sub    $0x60,%rsp
  800420ffa7:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420ffab:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420ffaf:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420ffb3:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420ffb7:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420ffbb:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420ffbf:	48 8b 0a             	mov    (%rdx),%rcx
  800420ffc2:	48 89 08             	mov    %rcx,(%rax)
  800420ffc5:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420ffc9:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420ffcd:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420ffd1:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420ffd5:	eb 17                	jmp    800420ffee <vprintfmt+0x52>
			if (ch == '\0')
  800420ffd7:	85 db                	test   %ebx,%ebx
  800420ffd9:	0f 84 cc 04 00 00    	je     80042104ab <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  800420ffdf:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420ffe3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420ffe7:	48 89 d6             	mov    %rdx,%rsi
  800420ffea:	89 df                	mov    %ebx,%edi
  800420ffec:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420ffee:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420fff2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fff6:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420fffa:	0f b6 00             	movzbl (%rax),%eax
  800420fffd:	0f b6 d8             	movzbl %al,%ebx
  8004210000:	83 fb 25             	cmp    $0x25,%ebx
  8004210003:	75 d2                	jne    800420ffd7 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  8004210005:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  8004210009:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  8004210010:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  8004210017:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800421001e:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  8004210025:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210029:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421002d:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  8004210031:	0f b6 00             	movzbl (%rax),%eax
  8004210034:	0f b6 d8             	movzbl %al,%ebx
  8004210037:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800421003a:	83 f8 55             	cmp    $0x55,%eax
  800421003d:	0f 87 34 04 00 00    	ja     8004210477 <vprintfmt+0x4db>
  8004210043:	89 c0                	mov    %eax,%eax
  8004210045:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421004c:	00 
  800421004d:	48 b8 f8 f2 21 04 80 	movabs $0x800421f2f8,%rax
  8004210054:	00 00 00 
  8004210057:	48 01 d0             	add    %rdx,%rax
  800421005a:	48 8b 00             	mov    (%rax),%rax
  800421005d:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800421005f:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  8004210063:	eb c0                	jmp    8004210025 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  8004210065:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  8004210069:	eb ba                	jmp    8004210025 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800421006b:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  8004210072:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004210075:	89 d0                	mov    %edx,%eax
  8004210077:	c1 e0 02             	shl    $0x2,%eax
  800421007a:	01 d0                	add    %edx,%eax
  800421007c:	01 c0                	add    %eax,%eax
  800421007e:	01 d8                	add    %ebx,%eax
  8004210080:	83 e8 30             	sub    $0x30,%eax
  8004210083:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  8004210086:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421008a:	0f b6 00             	movzbl (%rax),%eax
  800421008d:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  8004210090:	83 fb 2f             	cmp    $0x2f,%ebx
  8004210093:	7e 0c                	jle    80042100a1 <vprintfmt+0x105>
  8004210095:	83 fb 39             	cmp    $0x39,%ebx
  8004210098:	7f 07                	jg     80042100a1 <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800421009a:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800421009f:	eb d1                	jmp    8004210072 <vprintfmt+0xd6>
			goto process_precision;
  80042100a1:	eb 58                	jmp    80042100fb <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  80042100a3:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80042100a6:	83 f8 30             	cmp    $0x30,%eax
  80042100a9:	73 17                	jae    80042100c2 <vprintfmt+0x126>
  80042100ab:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042100af:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80042100b2:	89 c0                	mov    %eax,%eax
  80042100b4:	48 01 d0             	add    %rdx,%rax
  80042100b7:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042100ba:	83 c2 08             	add    $0x8,%edx
  80042100bd:	89 55 b8             	mov    %edx,-0x48(%rbp)
  80042100c0:	eb 0f                	jmp    80042100d1 <vprintfmt+0x135>
  80042100c2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042100c6:	48 89 d0             	mov    %rdx,%rax
  80042100c9:	48 83 c2 08          	add    $0x8,%rdx
  80042100cd:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  80042100d1:	8b 00                	mov    (%rax),%eax
  80042100d3:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  80042100d6:	eb 23                	jmp    80042100fb <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  80042100d8:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042100dc:	79 0c                	jns    80042100ea <vprintfmt+0x14e>
				width = 0;
  80042100de:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  80042100e5:	e9 3b ff ff ff       	jmpq   8004210025 <vprintfmt+0x89>
  80042100ea:	e9 36 ff ff ff       	jmpq   8004210025 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  80042100ef:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  80042100f6:	e9 2a ff ff ff       	jmpq   8004210025 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  80042100fb:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042100ff:	79 12                	jns    8004210113 <vprintfmt+0x177>
				width = precision, precision = -1;
  8004210101:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8004210104:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004210107:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800421010e:	e9 12 ff ff ff       	jmpq   8004210025 <vprintfmt+0x89>
  8004210113:	e9 0d ff ff ff       	jmpq   8004210025 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  8004210118:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800421011c:	e9 04 ff ff ff       	jmpq   8004210025 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  8004210121:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210124:	83 f8 30             	cmp    $0x30,%eax
  8004210127:	73 17                	jae    8004210140 <vprintfmt+0x1a4>
  8004210129:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421012d:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210130:	89 c0                	mov    %eax,%eax
  8004210132:	48 01 d0             	add    %rdx,%rax
  8004210135:	8b 55 b8             	mov    -0x48(%rbp),%edx
  8004210138:	83 c2 08             	add    $0x8,%edx
  800421013b:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800421013e:	eb 0f                	jmp    800421014f <vprintfmt+0x1b3>
  8004210140:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210144:	48 89 d0             	mov    %rdx,%rax
  8004210147:	48 83 c2 08          	add    $0x8,%rdx
  800421014b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800421014f:	8b 10                	mov    (%rax),%edx
  8004210151:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004210155:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210159:	48 89 ce             	mov    %rcx,%rsi
  800421015c:	89 d7                	mov    %edx,%edi
  800421015e:	ff d0                	callq  *%rax
			break;
  8004210160:	e9 40 03 00 00       	jmpq   80042104a5 <vprintfmt+0x509>

			// error message
		case 'e':
			err = va_arg(aq, int);
  8004210165:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210168:	83 f8 30             	cmp    $0x30,%eax
  800421016b:	73 17                	jae    8004210184 <vprintfmt+0x1e8>
  800421016d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210171:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210174:	89 c0                	mov    %eax,%eax
  8004210176:	48 01 d0             	add    %rdx,%rax
  8004210179:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421017c:	83 c2 08             	add    $0x8,%edx
  800421017f:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8004210182:	eb 0f                	jmp    8004210193 <vprintfmt+0x1f7>
  8004210184:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210188:	48 89 d0             	mov    %rdx,%rax
  800421018b:	48 83 c2 08          	add    $0x8,%rdx
  800421018f:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8004210193:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  8004210195:	85 db                	test   %ebx,%ebx
  8004210197:	79 02                	jns    800421019b <vprintfmt+0x1ff>
				err = -err;
  8004210199:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800421019b:	83 fb 15             	cmp    $0x15,%ebx
  800421019e:	7f 16                	jg     80042101b6 <vprintfmt+0x21a>
  80042101a0:	48 b8 20 f2 21 04 80 	movabs $0x800421f220,%rax
  80042101a7:	00 00 00 
  80042101aa:	48 63 d3             	movslq %ebx,%rdx
  80042101ad:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  80042101b1:	4d 85 e4             	test   %r12,%r12
  80042101b4:	75 2e                	jne    80042101e4 <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  80042101b6:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80042101ba:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042101be:	89 d9                	mov    %ebx,%ecx
  80042101c0:	48 ba e1 f2 21 04 80 	movabs $0x800421f2e1,%rdx
  80042101c7:	00 00 00 
  80042101ca:	48 89 c7             	mov    %rax,%rdi
  80042101cd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042101d2:	49 b8 b4 04 21 04 80 	movabs $0x80042104b4,%r8
  80042101d9:	00 00 00 
  80042101dc:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  80042101df:	e9 c1 02 00 00       	jmpq   80042104a5 <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  80042101e4:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  80042101e8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042101ec:	4c 89 e1             	mov    %r12,%rcx
  80042101ef:	48 ba ea f2 21 04 80 	movabs $0x800421f2ea,%rdx
  80042101f6:	00 00 00 
  80042101f9:	48 89 c7             	mov    %rax,%rdi
  80042101fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210201:	49 b8 b4 04 21 04 80 	movabs $0x80042104b4,%r8
  8004210208:	00 00 00 
  800421020b:	41 ff d0             	callq  *%r8
			break;
  800421020e:	e9 92 02 00 00       	jmpq   80042104a5 <vprintfmt+0x509>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  8004210213:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210216:	83 f8 30             	cmp    $0x30,%eax
  8004210219:	73 17                	jae    8004210232 <vprintfmt+0x296>
  800421021b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421021f:	8b 45 b8             	mov    -0x48(%rbp),%eax
  8004210222:	89 c0                	mov    %eax,%eax
  8004210224:	48 01 d0             	add    %rdx,%rax
  8004210227:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421022a:	83 c2 08             	add    $0x8,%edx
  800421022d:	89 55 b8             	mov    %edx,-0x48(%rbp)
  8004210230:	eb 0f                	jmp    8004210241 <vprintfmt+0x2a5>
  8004210232:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004210236:	48 89 d0             	mov    %rdx,%rax
  8004210239:	48 83 c2 08          	add    $0x8,%rdx
  800421023d:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8004210241:	4c 8b 20             	mov    (%rax),%r12
  8004210244:	4d 85 e4             	test   %r12,%r12
  8004210247:	75 0a                	jne    8004210253 <vprintfmt+0x2b7>
				p = "(null)";
  8004210249:	49 bc ed f2 21 04 80 	movabs $0x800421f2ed,%r12
  8004210250:	00 00 00 
			if (width > 0 && padc != '-')
  8004210253:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210257:	7e 3f                	jle    8004210298 <vprintfmt+0x2fc>
  8004210259:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800421025d:	74 39                	je     8004210298 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800421025f:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8004210262:	48 98                	cltq   
  8004210264:	48 89 c6             	mov    %rax,%rsi
  8004210267:	4c 89 e7             	mov    %r12,%rdi
  800421026a:	48 b8 b5 08 21 04 80 	movabs $0x80042108b5,%rax
  8004210271:	00 00 00 
  8004210274:	ff d0                	callq  *%rax
  8004210276:	29 45 dc             	sub    %eax,-0x24(%rbp)
  8004210279:	eb 17                	jmp    8004210292 <vprintfmt+0x2f6>
					putch(padc, putdat);
  800421027b:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800421027f:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004210283:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210287:	48 89 ce             	mov    %rcx,%rsi
  800421028a:	89 d7                	mov    %edx,%edi
  800421028c:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800421028e:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  8004210292:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004210296:	7f e3                	jg     800421027b <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  8004210298:	eb 37                	jmp    80042102d1 <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800421029a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800421029e:	74 1e                	je     80042102be <vprintfmt+0x322>
  80042102a0:	83 fb 1f             	cmp    $0x1f,%ebx
  80042102a3:	7e 05                	jle    80042102aa <vprintfmt+0x30e>
  80042102a5:	83 fb 7e             	cmp    $0x7e,%ebx
  80042102a8:	7e 14                	jle    80042102be <vprintfmt+0x322>
					putch('?', putdat);
  80042102aa:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042102ae:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042102b2:	48 89 d6             	mov    %rdx,%rsi
  80042102b5:	bf 3f 00 00 00       	mov    $0x3f,%edi
  80042102ba:	ff d0                	callq  *%rax
  80042102bc:	eb 0f                	jmp    80042102cd <vprintfmt+0x331>
				else
					putch(ch, putdat);
  80042102be:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042102c2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042102c6:	48 89 d6             	mov    %rdx,%rsi
  80042102c9:	89 df                	mov    %ebx,%edi
  80042102cb:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80042102cd:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  80042102d1:	4c 89 e0             	mov    %r12,%rax
  80042102d4:	4c 8d 60 01          	lea    0x1(%rax),%r12
  80042102d8:	0f b6 00             	movzbl (%rax),%eax
  80042102db:	0f be d8             	movsbl %al,%ebx
  80042102de:	85 db                	test   %ebx,%ebx
  80042102e0:	74 10                	je     80042102f2 <vprintfmt+0x356>
  80042102e2:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  80042102e6:	78 b2                	js     800421029a <vprintfmt+0x2fe>
  80042102e8:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  80042102ec:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  80042102f0:	79 a8                	jns    800421029a <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80042102f2:	eb 16                	jmp    800421030a <vprintfmt+0x36e>
				putch(' ', putdat);
  80042102f4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042102f8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042102fc:	48 89 d6             	mov    %rdx,%rsi
  80042102ff:	bf 20 00 00 00       	mov    $0x20,%edi
  8004210304:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  8004210306:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800421030a:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800421030e:	7f e4                	jg     80042102f4 <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  8004210310:	e9 90 01 00 00       	jmpq   80042104a5 <vprintfmt+0x509>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  8004210315:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210319:	be 03 00 00 00       	mov    $0x3,%esi
  800421031e:	48 89 c7             	mov    %rax,%rdi
  8004210321:	48 b8 8c fe 20 04 80 	movabs $0x800420fe8c,%rax
  8004210328:	00 00 00 
  800421032b:	ff d0                	callq  *%rax
  800421032d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  8004210331:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210335:	48 85 c0             	test   %rax,%rax
  8004210338:	79 1d                	jns    8004210357 <vprintfmt+0x3bb>
				putch('-', putdat);
  800421033a:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421033e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210342:	48 89 d6             	mov    %rdx,%rsi
  8004210345:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800421034a:	ff d0                	callq  *%rax
				num = -(long long) num;
  800421034c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210350:	48 f7 d8             	neg    %rax
  8004210353:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  8004210357:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800421035e:	e9 d5 00 00 00       	jmpq   8004210438 <vprintfmt+0x49c>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  8004210363:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210367:	be 03 00 00 00       	mov    $0x3,%esi
  800421036c:	48 89 c7             	mov    %rax,%rdi
  800421036f:	48 b8 7c fd 20 04 80 	movabs $0x800420fd7c,%rax
  8004210376:	00 00 00 
  8004210379:	ff d0                	callq  *%rax
  800421037b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800421037f:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  8004210386:	e9 ad 00 00 00       	jmpq   8004210438 <vprintfmt+0x49c>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getint(&aq, lflag);
  800421038b:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800421038e:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210392:	89 d6                	mov    %edx,%esi
  8004210394:	48 89 c7             	mov    %rax,%rdi
  8004210397:	48 b8 8c fe 20 04 80 	movabs $0x800420fe8c,%rax
  800421039e:	00 00 00 
  80042103a1:	ff d0                	callq  *%rax
  80042103a3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  80042103a7:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  80042103ae:	e9 85 00 00 00       	jmpq   8004210438 <vprintfmt+0x49c>


			// pointer
		case 'p':
			putch('0', putdat);
  80042103b3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042103b7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042103bb:	48 89 d6             	mov    %rdx,%rsi
  80042103be:	bf 30 00 00 00       	mov    $0x30,%edi
  80042103c3:	ff d0                	callq  *%rax
			putch('x', putdat);
  80042103c5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042103c9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042103cd:	48 89 d6             	mov    %rdx,%rsi
  80042103d0:	bf 78 00 00 00       	mov    $0x78,%edi
  80042103d5:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  80042103d7:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80042103da:	83 f8 30             	cmp    $0x30,%eax
  80042103dd:	73 17                	jae    80042103f6 <vprintfmt+0x45a>
  80042103df:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042103e3:	8b 45 b8             	mov    -0x48(%rbp),%eax
  80042103e6:	89 c0                	mov    %eax,%eax
  80042103e8:	48 01 d0             	add    %rdx,%rax
  80042103eb:	8b 55 b8             	mov    -0x48(%rbp),%edx
  80042103ee:	83 c2 08             	add    $0x8,%edx
  80042103f1:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80042103f4:	eb 0f                	jmp    8004210405 <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  80042103f6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042103fa:	48 89 d0             	mov    %rdx,%rax
  80042103fd:	48 83 c2 08          	add    $0x8,%rdx
  8004210401:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  8004210405:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  8004210408:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800421040c:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  8004210413:	eb 23                	jmp    8004210438 <vprintfmt+0x49c>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  8004210415:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  8004210419:	be 03 00 00 00       	mov    $0x3,%esi
  800421041e:	48 89 c7             	mov    %rax,%rdi
  8004210421:	48 b8 7c fd 20 04 80 	movabs $0x800420fd7c,%rax
  8004210428:	00 00 00 
  800421042b:	ff d0                	callq  *%rax
  800421042d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  8004210431:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  8004210438:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800421043d:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  8004210440:	8b 7d dc             	mov    -0x24(%rbp),%edi
  8004210443:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210447:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800421044b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421044f:	45 89 c1             	mov    %r8d,%r9d
  8004210452:	41 89 f8             	mov    %edi,%r8d
  8004210455:	48 89 c7             	mov    %rax,%rdi
  8004210458:	48 b8 c1 fc 20 04 80 	movabs $0x800420fcc1,%rax
  800421045f:	00 00 00 
  8004210462:	ff d0                	callq  *%rax
			break;
  8004210464:	eb 3f                	jmp    80042104a5 <vprintfmt+0x509>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  8004210466:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421046a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421046e:	48 89 d6             	mov    %rdx,%rsi
  8004210471:	89 df                	mov    %ebx,%edi
  8004210473:	ff d0                	callq  *%rax
			break;
  8004210475:	eb 2e                	jmp    80042104a5 <vprintfmt+0x509>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  8004210477:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421047b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421047f:	48 89 d6             	mov    %rdx,%rsi
  8004210482:	bf 25 00 00 00       	mov    $0x25,%edi
  8004210487:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  8004210489:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800421048e:	eb 05                	jmp    8004210495 <vprintfmt+0x4f9>
  8004210490:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  8004210495:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004210499:	48 83 e8 01          	sub    $0x1,%rax
  800421049d:	0f b6 00             	movzbl (%rax),%eax
  80042104a0:	3c 25                	cmp    $0x25,%al
  80042104a2:	75 ec                	jne    8004210490 <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  80042104a4:	90                   	nop
		}
	}
  80042104a5:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80042104a6:	e9 43 fb ff ff       	jmpq   800420ffee <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  80042104ab:	48 83 c4 60          	add    $0x60,%rsp
  80042104af:	5b                   	pop    %rbx
  80042104b0:	41 5c                	pop    %r12
  80042104b2:	5d                   	pop    %rbp
  80042104b3:	c3                   	retq   

00000080042104b4 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80042104b4:	55                   	push   %rbp
  80042104b5:	48 89 e5             	mov    %rsp,%rbp
  80042104b8:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  80042104bf:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042104c6:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  80042104cd:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042104d4:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042104db:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042104e2:	84 c0                	test   %al,%al
  80042104e4:	74 20                	je     8004210506 <printfmt+0x52>
  80042104e6:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042104ea:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042104ee:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042104f2:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042104f6:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042104fa:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042104fe:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004210502:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004210506:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800421050d:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  8004210514:	00 00 00 
  8004210517:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800421051e:	00 00 00 
  8004210521:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004210525:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800421052c:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004210533:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800421053a:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  8004210541:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  8004210548:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800421054f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004210556:	48 89 c7             	mov    %rax,%rdi
  8004210559:	48 b8 9c ff 20 04 80 	movabs $0x800420ff9c,%rax
  8004210560:	00 00 00 
  8004210563:	ff d0                	callq  *%rax
	va_end(ap);
}
  8004210565:	c9                   	leaveq 
  8004210566:	c3                   	retq   

0000008004210567 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  8004210567:	55                   	push   %rbp
  8004210568:	48 89 e5             	mov    %rsp,%rbp
  800421056b:	48 83 ec 10          	sub    $0x10,%rsp
  800421056f:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004210572:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  8004210576:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421057a:	8b 40 10             	mov    0x10(%rax),%eax
  800421057d:	8d 50 01             	lea    0x1(%rax),%edx
  8004210580:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210584:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  8004210587:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421058b:	48 8b 10             	mov    (%rax),%rdx
  800421058e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210592:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210596:	48 39 c2             	cmp    %rax,%rdx
  8004210599:	73 17                	jae    80042105b2 <sprintputch+0x4b>
		*b->buf++ = ch;
  800421059b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421059f:	48 8b 00             	mov    (%rax),%rax
  80042105a2:	48 8d 48 01          	lea    0x1(%rax),%rcx
  80042105a6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042105aa:	48 89 0a             	mov    %rcx,(%rdx)
  80042105ad:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042105b0:	88 10                	mov    %dl,(%rax)
}
  80042105b2:	c9                   	leaveq 
  80042105b3:	c3                   	retq   

00000080042105b4 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80042105b4:	55                   	push   %rbp
  80042105b5:	48 89 e5             	mov    %rsp,%rbp
  80042105b8:	48 83 ec 50          	sub    $0x50,%rsp
  80042105bc:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042105c0:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  80042105c3:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  80042105c7:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  80042105cb:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  80042105cf:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042105d3:	48 8b 0a             	mov    (%rdx),%rcx
  80042105d6:	48 89 08             	mov    %rcx,(%rax)
  80042105d9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042105dd:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042105e1:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042105e5:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  80042105e9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042105ed:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  80042105f1:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042105f4:	48 98                	cltq   
  80042105f6:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  80042105fa:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042105fe:	48 01 d0             	add    %rdx,%rax
  8004210601:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004210605:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800421060c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210611:	74 06                	je     8004210619 <vsnprintf+0x65>
  8004210613:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004210617:	7f 07                	jg     8004210620 <vsnprintf+0x6c>
		return -E_INVAL;
  8004210619:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800421061e:	eb 2f                	jmp    800421064f <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  8004210620:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  8004210624:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004210628:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800421062c:	48 89 c6             	mov    %rax,%rsi
  800421062f:	48 bf 67 05 21 04 80 	movabs $0x8004210567,%rdi
  8004210636:	00 00 00 
  8004210639:	48 b8 9c ff 20 04 80 	movabs $0x800420ff9c,%rax
  8004210640:	00 00 00 
  8004210643:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  8004210645:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210649:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800421064c:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800421064f:	c9                   	leaveq 
  8004210650:	c3                   	retq   

0000008004210651 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  8004210651:	55                   	push   %rbp
  8004210652:	48 89 e5             	mov    %rsp,%rbp
  8004210655:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800421065c:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  8004210663:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  8004210669:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004210670:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004210677:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800421067e:	84 c0                	test   %al,%al
  8004210680:	74 20                	je     80042106a2 <snprintf+0x51>
  8004210682:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004210686:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800421068a:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800421068e:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004210692:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004210696:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800421069a:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800421069e:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042106a2:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  80042106a9:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  80042106b0:	00 00 00 
  80042106b3:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  80042106ba:	00 00 00 
  80042106bd:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042106c1:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042106c8:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042106cf:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  80042106d6:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  80042106dd:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  80042106e4:	48 8b 0a             	mov    (%rdx),%rcx
  80042106e7:	48 89 08             	mov    %rcx,(%rax)
  80042106ea:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  80042106ee:	48 89 48 08          	mov    %rcx,0x8(%rax)
  80042106f2:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  80042106f6:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  80042106fa:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  8004210701:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004210708:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800421070e:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004210715:	48 89 c7             	mov    %rax,%rdi
  8004210718:	48 b8 b4 05 21 04 80 	movabs $0x80042105b4,%rax
  800421071f:	00 00 00 
  8004210722:	ff d0                	callq  *%rax
  8004210724:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800421072a:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004210730:	c9                   	leaveq 
  8004210731:	c3                   	retq   

0000008004210732 <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  8004210732:	55                   	push   %rbp
  8004210733:	48 89 e5             	mov    %rsp,%rbp
  8004210736:	48 83 ec 20          	sub    $0x20,%rsp
  800421073a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800421073e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210743:	74 22                	je     8004210767 <readline+0x35>
		cprintf("%s", prompt);
  8004210745:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210749:	48 89 c6             	mov    %rax,%rsi
  800421074c:	48 bf a8 f5 21 04 80 	movabs $0x800421f5a8,%rdi
  8004210753:	00 00 00 
  8004210756:	b8 00 00 00 00       	mov    $0x0,%eax
  800421075b:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004210762:	00 00 00 
  8004210765:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  8004210767:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800421076e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004210773:	48 b8 ab 12 20 04 80 	movabs $0x80042012ab,%rax
  800421077a:	00 00 00 
  800421077d:	ff d0                	callq  *%rax
  800421077f:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  8004210782:	48 b8 89 12 20 04 80 	movabs $0x8004201289,%rax
  8004210789:	00 00 00 
  800421078c:	ff d0                	callq  *%rax
  800421078e:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  8004210791:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004210795:	79 30                	jns    80042107c7 <readline+0x95>
			if (c != -E_EOF)
  8004210797:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800421079b:	74 20                	je     80042107bd <readline+0x8b>
				cprintf("read error: %e\n", c);
  800421079d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042107a0:	89 c6                	mov    %eax,%esi
  80042107a2:	48 bf ab f5 21 04 80 	movabs $0x800421f5ab,%rdi
  80042107a9:	00 00 00 
  80042107ac:	b8 00 00 00 00       	mov    $0x0,%eax
  80042107b1:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042107b8:	00 00 00 
  80042107bb:	ff d2                	callq  *%rdx
			return NULL;
  80042107bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042107c2:	e9 be 00 00 00       	jmpq   8004210885 <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  80042107c7:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  80042107cb:	74 06                	je     80042107d3 <readline+0xa1>
  80042107cd:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  80042107d1:	75 26                	jne    80042107f9 <readline+0xc7>
  80042107d3:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042107d7:	7e 20                	jle    80042107f9 <readline+0xc7>
			if (echoing)
  80042107d9:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042107dd:	74 11                	je     80042107f0 <readline+0xbe>
				cputchar('\b');
  80042107df:	bf 08 00 00 00       	mov    $0x8,%edi
  80042107e4:	48 b8 6b 12 20 04 80 	movabs $0x800420126b,%rax
  80042107eb:	00 00 00 
  80042107ee:	ff d0                	callq  *%rax
			i--;
  80042107f0:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  80042107f4:	e9 87 00 00 00       	jmpq   8004210880 <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  80042107f9:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  80042107fd:	7e 3f                	jle    800421083e <readline+0x10c>
  80042107ff:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  8004210806:	7f 36                	jg     800421083e <readline+0x10c>
			if (echoing)
  8004210808:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800421080c:	74 11                	je     800421081f <readline+0xed>
				cputchar(c);
  800421080e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210811:	89 c7                	mov    %eax,%edi
  8004210813:	48 b8 6b 12 20 04 80 	movabs $0x800420126b,%rax
  800421081a:	00 00 00 
  800421081d:	ff d0                	callq  *%rax
			buf[i++] = c;
  800421081f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004210822:	8d 50 01             	lea    0x1(%rax),%edx
  8004210825:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004210828:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421082b:	89 d1                	mov    %edx,%ecx
  800421082d:	48 ba c0 e2 3a 04 80 	movabs $0x80043ae2c0,%rdx
  8004210834:	00 00 00 
  8004210837:	48 98                	cltq   
  8004210839:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800421083c:	eb 42                	jmp    8004210880 <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800421083e:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  8004210842:	74 06                	je     800421084a <readline+0x118>
  8004210844:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  8004210848:	75 36                	jne    8004210880 <readline+0x14e>
			if (echoing)
  800421084a:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800421084e:	74 11                	je     8004210861 <readline+0x12f>
				cputchar('\n');
  8004210850:	bf 0a 00 00 00       	mov    $0xa,%edi
  8004210855:	48 b8 6b 12 20 04 80 	movabs $0x800420126b,%rax
  800421085c:	00 00 00 
  800421085f:	ff d0                	callq  *%rax
			buf[i] = 0;
  8004210861:	48 ba c0 e2 3a 04 80 	movabs $0x80043ae2c0,%rdx
  8004210868:	00 00 00 
  800421086b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421086e:	48 98                	cltq   
  8004210870:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  8004210874:	48 b8 c0 e2 3a 04 80 	movabs $0x80043ae2c0,%rax
  800421087b:	00 00 00 
  800421087e:	eb 05                	jmp    8004210885 <readline+0x153>
		}
	}
  8004210880:	e9 fd fe ff ff       	jmpq   8004210782 <readline+0x50>
}
  8004210885:	c9                   	leaveq 
  8004210886:	c3                   	retq   

0000008004210887 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  8004210887:	55                   	push   %rbp
  8004210888:	48 89 e5             	mov    %rsp,%rbp
  800421088b:	48 83 ec 18          	sub    $0x18,%rsp
  800421088f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  8004210893:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421089a:	eb 09                	jmp    80042108a5 <strlen+0x1e>
		n++;
  800421089c:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80042108a0:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042108a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108a9:	0f b6 00             	movzbl (%rax),%eax
  80042108ac:	84 c0                	test   %al,%al
  80042108ae:	75 ec                	jne    800421089c <strlen+0x15>
		n++;
	return n;
  80042108b0:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042108b3:	c9                   	leaveq 
  80042108b4:	c3                   	retq   

00000080042108b5 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80042108b5:	55                   	push   %rbp
  80042108b6:	48 89 e5             	mov    %rsp,%rbp
  80042108b9:	48 83 ec 20          	sub    $0x20,%rsp
  80042108bd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042108c1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80042108c5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042108cc:	eb 0e                	jmp    80042108dc <strnlen+0x27>
		n++;
  80042108ce:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80042108d2:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  80042108d7:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  80042108dc:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042108e1:	74 0b                	je     80042108ee <strnlen+0x39>
  80042108e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108e7:	0f b6 00             	movzbl (%rax),%eax
  80042108ea:	84 c0                	test   %al,%al
  80042108ec:	75 e0                	jne    80042108ce <strnlen+0x19>
		n++;
	return n;
  80042108ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042108f1:	c9                   	leaveq 
  80042108f2:	c3                   	retq   

00000080042108f3 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80042108f3:	55                   	push   %rbp
  80042108f4:	48 89 e5             	mov    %rsp,%rbp
  80042108f7:	48 83 ec 20          	sub    $0x20,%rsp
  80042108fb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042108ff:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  8004210903:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210907:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800421090b:	90                   	nop
  800421090c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210910:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210914:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210918:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421091c:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  8004210920:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  8004210924:	0f b6 12             	movzbl (%rdx),%edx
  8004210927:	88 10                	mov    %dl,(%rax)
  8004210929:	0f b6 00             	movzbl (%rax),%eax
  800421092c:	84 c0                	test   %al,%al
  800421092e:	75 dc                	jne    800421090c <strcpy+0x19>
		/* do nothing */;
	return ret;
  8004210930:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210934:	c9                   	leaveq 
  8004210935:	c3                   	retq   

0000008004210936 <strcat>:

char *
strcat(char *dst, const char *src)
{
  8004210936:	55                   	push   %rbp
  8004210937:	48 89 e5             	mov    %rsp,%rbp
  800421093a:	48 83 ec 20          	sub    $0x20,%rsp
  800421093e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210942:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  8004210946:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421094a:	48 89 c7             	mov    %rax,%rdi
  800421094d:	48 b8 87 08 21 04 80 	movabs $0x8004210887,%rax
  8004210954:	00 00 00 
  8004210957:	ff d0                	callq  *%rax
  8004210959:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800421095c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421095f:	48 63 d0             	movslq %eax,%rdx
  8004210962:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210966:	48 01 c2             	add    %rax,%rdx
  8004210969:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421096d:	48 89 c6             	mov    %rax,%rsi
  8004210970:	48 89 d7             	mov    %rdx,%rdi
  8004210973:	48 b8 f3 08 21 04 80 	movabs $0x80042108f3,%rax
  800421097a:	00 00 00 
  800421097d:	ff d0                	callq  *%rax
	return dst;
  800421097f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004210983:	c9                   	leaveq 
  8004210984:	c3                   	retq   

0000008004210985 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  8004210985:	55                   	push   %rbp
  8004210986:	48 89 e5             	mov    %rsp,%rbp
  8004210989:	48 83 ec 28          	sub    $0x28,%rsp
  800421098d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210991:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210995:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  8004210999:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421099d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  80042109a1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042109a8:	00 
  80042109a9:	eb 2a                	jmp    80042109d5 <strncpy+0x50>
		*dst++ = *src;
  80042109ab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109af:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042109b3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042109b7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042109bb:	0f b6 12             	movzbl (%rdx),%edx
  80042109be:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  80042109c0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042109c4:	0f b6 00             	movzbl (%rax),%eax
  80042109c7:	84 c0                	test   %al,%al
  80042109c9:	74 05                	je     80042109d0 <strncpy+0x4b>
			src++;
  80042109cb:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80042109d0:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  80042109d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042109d9:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042109dd:	72 cc                	jb     80042109ab <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  80042109df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042109e3:	c9                   	leaveq 
  80042109e4:	c3                   	retq   

00000080042109e5 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80042109e5:	55                   	push   %rbp
  80042109e6:	48 89 e5             	mov    %rsp,%rbp
  80042109e9:	48 83 ec 28          	sub    $0x28,%rsp
  80042109ed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042109f1:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042109f5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  80042109f9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109fd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  8004210a01:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210a06:	74 3d                	je     8004210a45 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  8004210a08:	eb 1d                	jmp    8004210a27 <strlcpy+0x42>
			*dst++ = *src++;
  8004210a0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a0e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210a12:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210a16:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210a1a:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  8004210a1e:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  8004210a22:	0f b6 12             	movzbl (%rdx),%edx
  8004210a25:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  8004210a27:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  8004210a2c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004210a31:	74 0b                	je     8004210a3e <strlcpy+0x59>
  8004210a33:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a37:	0f b6 00             	movzbl (%rax),%eax
  8004210a3a:	84 c0                	test   %al,%al
  8004210a3c:	75 cc                	jne    8004210a0a <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  8004210a3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a42:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  8004210a45:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210a49:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a4d:	48 29 c2             	sub    %rax,%rdx
  8004210a50:	48 89 d0             	mov    %rdx,%rax
}
  8004210a53:	c9                   	leaveq 
  8004210a54:	c3                   	retq   

0000008004210a55 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  8004210a55:	55                   	push   %rbp
  8004210a56:	48 89 e5             	mov    %rsp,%rbp
  8004210a59:	48 83 ec 10          	sub    $0x10,%rsp
  8004210a5d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210a61:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  8004210a65:	eb 0a                	jmp    8004210a71 <strcmp+0x1c>
		p++, q++;
  8004210a67:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210a6c:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  8004210a71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a75:	0f b6 00             	movzbl (%rax),%eax
  8004210a78:	84 c0                	test   %al,%al
  8004210a7a:	74 12                	je     8004210a8e <strcmp+0x39>
  8004210a7c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a80:	0f b6 10             	movzbl (%rax),%edx
  8004210a83:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a87:	0f b6 00             	movzbl (%rax),%eax
  8004210a8a:	38 c2                	cmp    %al,%dl
  8004210a8c:	74 d9                	je     8004210a67 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  8004210a8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210a92:	0f b6 00             	movzbl (%rax),%eax
  8004210a95:	0f b6 d0             	movzbl %al,%edx
  8004210a98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a9c:	0f b6 00             	movzbl (%rax),%eax
  8004210a9f:	0f b6 c0             	movzbl %al,%eax
  8004210aa2:	29 c2                	sub    %eax,%edx
  8004210aa4:	89 d0                	mov    %edx,%eax
}
  8004210aa6:	c9                   	leaveq 
  8004210aa7:	c3                   	retq   

0000008004210aa8 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  8004210aa8:	55                   	push   %rbp
  8004210aa9:	48 89 e5             	mov    %rsp,%rbp
  8004210aac:	48 83 ec 18          	sub    $0x18,%rsp
  8004210ab0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210ab4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004210ab8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  8004210abc:	eb 0f                	jmp    8004210acd <strncmp+0x25>
		n--, p++, q++;
  8004210abe:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  8004210ac3:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210ac8:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  8004210acd:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210ad2:	74 1d                	je     8004210af1 <strncmp+0x49>
  8004210ad4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ad8:	0f b6 00             	movzbl (%rax),%eax
  8004210adb:	84 c0                	test   %al,%al
  8004210add:	74 12                	je     8004210af1 <strncmp+0x49>
  8004210adf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210ae3:	0f b6 10             	movzbl (%rax),%edx
  8004210ae6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210aea:	0f b6 00             	movzbl (%rax),%eax
  8004210aed:	38 c2                	cmp    %al,%dl
  8004210aef:	74 cd                	je     8004210abe <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  8004210af1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210af6:	75 07                	jne    8004210aff <strncmp+0x57>
		return 0;
  8004210af8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210afd:	eb 18                	jmp    8004210b17 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  8004210aff:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210b03:	0f b6 00             	movzbl (%rax),%eax
  8004210b06:	0f b6 d0             	movzbl %al,%edx
  8004210b09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210b0d:	0f b6 00             	movzbl (%rax),%eax
  8004210b10:	0f b6 c0             	movzbl %al,%eax
  8004210b13:	29 c2                	sub    %eax,%edx
  8004210b15:	89 d0                	mov    %edx,%eax
}
  8004210b17:	c9                   	leaveq 
  8004210b18:	c3                   	retq   

0000008004210b19 <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8004210b19:	55                   	push   %rbp
  8004210b1a:	48 89 e5             	mov    %rsp,%rbp
  8004210b1d:	48 83 ec 0c          	sub    $0xc,%rsp
  8004210b21:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210b25:	89 f0                	mov    %esi,%eax
  8004210b27:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8004210b2a:	eb 17                	jmp    8004210b43 <strchr+0x2a>
		if (*s == c)
  8004210b2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210b30:	0f b6 00             	movzbl (%rax),%eax
  8004210b33:	3a 45 f4             	cmp    -0xc(%rbp),%al
  8004210b36:	75 06                	jne    8004210b3e <strchr+0x25>
			return (char *) s;
  8004210b38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210b3c:	eb 15                	jmp    8004210b53 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  8004210b3e:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210b43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210b47:	0f b6 00             	movzbl (%rax),%eax
  8004210b4a:	84 c0                	test   %al,%al
  8004210b4c:	75 de                	jne    8004210b2c <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  8004210b4e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210b53:	c9                   	leaveq 
  8004210b54:	c3                   	retq   

0000008004210b55 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  8004210b55:	55                   	push   %rbp
  8004210b56:	48 89 e5             	mov    %rsp,%rbp
  8004210b59:	48 83 ec 0c          	sub    $0xc,%rsp
  8004210b5d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210b61:	89 f0                	mov    %esi,%eax
  8004210b63:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  8004210b66:	eb 13                	jmp    8004210b7b <strfind+0x26>
		if (*s == c)
  8004210b68:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210b6c:	0f b6 00             	movzbl (%rax),%eax
  8004210b6f:	3a 45 f4             	cmp    -0xc(%rbp),%al
  8004210b72:	75 02                	jne    8004210b76 <strfind+0x21>
			break;
  8004210b74:	eb 10                	jmp    8004210b86 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  8004210b76:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210b7b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210b7f:	0f b6 00             	movzbl (%rax),%eax
  8004210b82:	84 c0                	test   %al,%al
  8004210b84:	75 e2                	jne    8004210b68 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  8004210b86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210b8a:	c9                   	leaveq 
  8004210b8b:	c3                   	retq   

0000008004210b8c <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  8004210b8c:	55                   	push   %rbp
  8004210b8d:	48 89 e5             	mov    %rsp,%rbp
  8004210b90:	48 83 ec 18          	sub    $0x18,%rsp
  8004210b94:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210b98:	89 75 f4             	mov    %esi,-0xc(%rbp)
  8004210b9b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  8004210b9f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210ba4:	75 06                	jne    8004210bac <memset+0x20>
		return v;
  8004210ba6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210baa:	eb 69                	jmp    8004210c15 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  8004210bac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210bb0:	83 e0 03             	and    $0x3,%eax
  8004210bb3:	48 85 c0             	test   %rax,%rax
  8004210bb6:	75 48                	jne    8004210c00 <memset+0x74>
  8004210bb8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210bbc:	83 e0 03             	and    $0x3,%eax
  8004210bbf:	48 85 c0             	test   %rax,%rax
  8004210bc2:	75 3c                	jne    8004210c00 <memset+0x74>
		c &= 0xFF;
  8004210bc4:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  8004210bcb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210bce:	c1 e0 18             	shl    $0x18,%eax
  8004210bd1:	89 c2                	mov    %eax,%edx
  8004210bd3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210bd6:	c1 e0 10             	shl    $0x10,%eax
  8004210bd9:	09 c2                	or     %eax,%edx
  8004210bdb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210bde:	c1 e0 08             	shl    $0x8,%eax
  8004210be1:	09 d0                	or     %edx,%eax
  8004210be3:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  8004210be6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210bea:	48 c1 e8 02          	shr    $0x2,%rax
  8004210bee:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  8004210bf1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210bf5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210bf8:	48 89 d7             	mov    %rdx,%rdi
  8004210bfb:	fc                   	cld    
  8004210bfc:	f3 ab                	rep stos %eax,%es:(%rdi)
  8004210bfe:	eb 11                	jmp    8004210c11 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  8004210c00:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210c04:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210c07:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210c0b:	48 89 d7             	mov    %rdx,%rdi
  8004210c0e:	fc                   	cld    
  8004210c0f:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  8004210c11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004210c15:	c9                   	leaveq 
  8004210c16:	c3                   	retq   

0000008004210c17 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  8004210c17:	55                   	push   %rbp
  8004210c18:	48 89 e5             	mov    %rsp,%rbp
  8004210c1b:	48 83 ec 28          	sub    $0x28,%rsp
  8004210c1f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210c23:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210c27:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  8004210c2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210c2f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  8004210c33:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210c37:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  8004210c3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210c3f:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004210c43:	0f 83 88 00 00 00    	jae    8004210cd1 <memmove+0xba>
  8004210c49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210c4d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210c51:	48 01 d0             	add    %rdx,%rax
  8004210c54:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004210c58:	76 77                	jbe    8004210cd1 <memmove+0xba>
		s += n;
  8004210c5a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210c5e:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  8004210c62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210c66:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8004210c6a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210c6e:	83 e0 03             	and    $0x3,%eax
  8004210c71:	48 85 c0             	test   %rax,%rax
  8004210c74:	75 3b                	jne    8004210cb1 <memmove+0x9a>
  8004210c76:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c7a:	83 e0 03             	and    $0x3,%eax
  8004210c7d:	48 85 c0             	test   %rax,%rax
  8004210c80:	75 2f                	jne    8004210cb1 <memmove+0x9a>
  8004210c82:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210c86:	83 e0 03             	and    $0x3,%eax
  8004210c89:	48 85 c0             	test   %rax,%rax
  8004210c8c:	75 23                	jne    8004210cb1 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  8004210c8e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c92:	48 83 e8 04          	sub    $0x4,%rax
  8004210c96:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210c9a:	48 83 ea 04          	sub    $0x4,%rdx
  8004210c9e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210ca2:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  8004210ca6:	48 89 c7             	mov    %rax,%rdi
  8004210ca9:	48 89 d6             	mov    %rdx,%rsi
  8004210cac:	fd                   	std    
  8004210cad:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8004210caf:	eb 1d                	jmp    8004210cce <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  8004210cb1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210cb5:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004210cb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210cbd:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  8004210cc1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210cc5:	48 89 d7             	mov    %rdx,%rdi
  8004210cc8:	48 89 c1             	mov    %rax,%rcx
  8004210ccb:	fd                   	std    
  8004210ccc:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  8004210cce:	fc                   	cld    
  8004210ccf:	eb 57                	jmp    8004210d28 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  8004210cd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210cd5:	83 e0 03             	and    $0x3,%eax
  8004210cd8:	48 85 c0             	test   %rax,%rax
  8004210cdb:	75 36                	jne    8004210d13 <memmove+0xfc>
  8004210cdd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210ce1:	83 e0 03             	and    $0x3,%eax
  8004210ce4:	48 85 c0             	test   %rax,%rax
  8004210ce7:	75 2a                	jne    8004210d13 <memmove+0xfc>
  8004210ce9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210ced:	83 e0 03             	and    $0x3,%eax
  8004210cf0:	48 85 c0             	test   %rax,%rax
  8004210cf3:	75 1e                	jne    8004210d13 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  8004210cf5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210cf9:	48 c1 e8 02          	shr    $0x2,%rax
  8004210cfd:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  8004210d00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d04:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210d08:	48 89 c7             	mov    %rax,%rdi
  8004210d0b:	48 89 d6             	mov    %rdx,%rsi
  8004210d0e:	fc                   	cld    
  8004210d0f:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  8004210d11:	eb 15                	jmp    8004210d28 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  8004210d13:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d17:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210d1b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004210d1f:	48 89 c7             	mov    %rax,%rdi
  8004210d22:	48 89 d6             	mov    %rdx,%rsi
  8004210d25:	fc                   	cld    
  8004210d26:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  8004210d28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004210d2c:	c9                   	leaveq 
  8004210d2d:	c3                   	retq   

0000008004210d2e <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  8004210d2e:	55                   	push   %rbp
  8004210d2f:	48 89 e5             	mov    %rsp,%rbp
  8004210d32:	48 83 ec 18          	sub    $0x18,%rsp
  8004210d36:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004210d3a:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004210d3e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  8004210d42:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210d46:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004210d4a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d4e:	48 89 ce             	mov    %rcx,%rsi
  8004210d51:	48 89 c7             	mov    %rax,%rdi
  8004210d54:	48 b8 17 0c 21 04 80 	movabs $0x8004210c17,%rax
  8004210d5b:	00 00 00 
  8004210d5e:	ff d0                	callq  *%rax
}
  8004210d60:	c9                   	leaveq 
  8004210d61:	c3                   	retq   

0000008004210d62 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  8004210d62:	55                   	push   %rbp
  8004210d63:	48 89 e5             	mov    %rsp,%rbp
  8004210d66:	48 83 ec 28          	sub    $0x28,%rsp
  8004210d6a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210d6e:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004210d72:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  8004210d76:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210d7a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  8004210d7e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210d82:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  8004210d86:	eb 36                	jmp    8004210dbe <memcmp+0x5c>
		if (*s1 != *s2)
  8004210d88:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d8c:	0f b6 10             	movzbl (%rax),%edx
  8004210d8f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d93:	0f b6 00             	movzbl (%rax),%eax
  8004210d96:	38 c2                	cmp    %al,%dl
  8004210d98:	74 1a                	je     8004210db4 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  8004210d9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210d9e:	0f b6 00             	movzbl (%rax),%eax
  8004210da1:	0f b6 d0             	movzbl %al,%edx
  8004210da4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210da8:	0f b6 00             	movzbl (%rax),%eax
  8004210dab:	0f b6 c0             	movzbl %al,%eax
  8004210dae:	29 c2                	sub    %eax,%edx
  8004210db0:	89 d0                	mov    %edx,%eax
  8004210db2:	eb 20                	jmp    8004210dd4 <memcmp+0x72>
		s1++, s2++;
  8004210db4:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004210db9:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8004210dbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210dc2:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  8004210dc6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004210dca:	48 85 c0             	test   %rax,%rax
  8004210dcd:	75 b9                	jne    8004210d88 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  8004210dcf:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210dd4:	c9                   	leaveq 
  8004210dd5:	c3                   	retq   

0000008004210dd6 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  8004210dd6:	55                   	push   %rbp
  8004210dd7:	48 89 e5             	mov    %rsp,%rbp
  8004210dda:	48 83 ec 28          	sub    $0x28,%rsp
  8004210dde:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210de2:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8004210de5:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  8004210de9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210ded:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210df1:	48 01 d0             	add    %rdx,%rax
  8004210df4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  8004210df8:	eb 15                	jmp    8004210e0f <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  8004210dfa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210dfe:	0f b6 10             	movzbl (%rax),%edx
  8004210e01:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210e04:	38 c2                	cmp    %al,%dl
  8004210e06:	75 02                	jne    8004210e0a <memfind+0x34>
			break;
  8004210e08:	eb 0f                	jmp    8004210e19 <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  8004210e0a:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004210e0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210e13:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004210e17:	72 e1                	jb     8004210dfa <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  8004210e19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004210e1d:	c9                   	leaveq 
  8004210e1e:	c3                   	retq   

0000008004210e1f <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  8004210e1f:	55                   	push   %rbp
  8004210e20:	48 89 e5             	mov    %rsp,%rbp
  8004210e23:	48 83 ec 34          	sub    $0x34,%rsp
  8004210e27:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210e2b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210e2f:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  8004210e32:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  8004210e39:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004210e40:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8004210e41:	eb 05                	jmp    8004210e48 <strtol+0x29>
		s++;
  8004210e43:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8004210e48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210e4c:	0f b6 00             	movzbl (%rax),%eax
  8004210e4f:	3c 20                	cmp    $0x20,%al
  8004210e51:	74 f0                	je     8004210e43 <strtol+0x24>
  8004210e53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210e57:	0f b6 00             	movzbl (%rax),%eax
  8004210e5a:	3c 09                	cmp    $0x9,%al
  8004210e5c:	74 e5                	je     8004210e43 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  8004210e5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210e62:	0f b6 00             	movzbl (%rax),%eax
  8004210e65:	3c 2b                	cmp    $0x2b,%al
  8004210e67:	75 07                	jne    8004210e70 <strtol+0x51>
		s++;
  8004210e69:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004210e6e:	eb 17                	jmp    8004210e87 <strtol+0x68>
	else if (*s == '-')
  8004210e70:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210e74:	0f b6 00             	movzbl (%rax),%eax
  8004210e77:	3c 2d                	cmp    $0x2d,%al
  8004210e79:	75 0c                	jne    8004210e87 <strtol+0x68>
		s++, neg = 1;
  8004210e7b:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004210e80:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  8004210e87:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004210e8b:	74 06                	je     8004210e93 <strtol+0x74>
  8004210e8d:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  8004210e91:	75 28                	jne    8004210ebb <strtol+0x9c>
  8004210e93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210e97:	0f b6 00             	movzbl (%rax),%eax
  8004210e9a:	3c 30                	cmp    $0x30,%al
  8004210e9c:	75 1d                	jne    8004210ebb <strtol+0x9c>
  8004210e9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210ea2:	48 83 c0 01          	add    $0x1,%rax
  8004210ea6:	0f b6 00             	movzbl (%rax),%eax
  8004210ea9:	3c 78                	cmp    $0x78,%al
  8004210eab:	75 0e                	jne    8004210ebb <strtol+0x9c>
		s += 2, base = 16;
  8004210ead:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  8004210eb2:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  8004210eb9:	eb 2c                	jmp    8004210ee7 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  8004210ebb:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004210ebf:	75 19                	jne    8004210eda <strtol+0xbb>
  8004210ec1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210ec5:	0f b6 00             	movzbl (%rax),%eax
  8004210ec8:	3c 30                	cmp    $0x30,%al
  8004210eca:	75 0e                	jne    8004210eda <strtol+0xbb>
		s++, base = 8;
  8004210ecc:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004210ed1:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  8004210ed8:	eb 0d                	jmp    8004210ee7 <strtol+0xc8>
	else if (base == 0)
  8004210eda:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004210ede:	75 07                	jne    8004210ee7 <strtol+0xc8>
		base = 10;
  8004210ee0:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  8004210ee7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210eeb:	0f b6 00             	movzbl (%rax),%eax
  8004210eee:	3c 2f                	cmp    $0x2f,%al
  8004210ef0:	7e 1d                	jle    8004210f0f <strtol+0xf0>
  8004210ef2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210ef6:	0f b6 00             	movzbl (%rax),%eax
  8004210ef9:	3c 39                	cmp    $0x39,%al
  8004210efb:	7f 12                	jg     8004210f0f <strtol+0xf0>
			dig = *s - '0';
  8004210efd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f01:	0f b6 00             	movzbl (%rax),%eax
  8004210f04:	0f be c0             	movsbl %al,%eax
  8004210f07:	83 e8 30             	sub    $0x30,%eax
  8004210f0a:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004210f0d:	eb 4e                	jmp    8004210f5d <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  8004210f0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f13:	0f b6 00             	movzbl (%rax),%eax
  8004210f16:	3c 60                	cmp    $0x60,%al
  8004210f18:	7e 1d                	jle    8004210f37 <strtol+0x118>
  8004210f1a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f1e:	0f b6 00             	movzbl (%rax),%eax
  8004210f21:	3c 7a                	cmp    $0x7a,%al
  8004210f23:	7f 12                	jg     8004210f37 <strtol+0x118>
			dig = *s - 'a' + 10;
  8004210f25:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f29:	0f b6 00             	movzbl (%rax),%eax
  8004210f2c:	0f be c0             	movsbl %al,%eax
  8004210f2f:	83 e8 57             	sub    $0x57,%eax
  8004210f32:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004210f35:	eb 26                	jmp    8004210f5d <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  8004210f37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f3b:	0f b6 00             	movzbl (%rax),%eax
  8004210f3e:	3c 40                	cmp    $0x40,%al
  8004210f40:	7e 48                	jle    8004210f8a <strtol+0x16b>
  8004210f42:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f46:	0f b6 00             	movzbl (%rax),%eax
  8004210f49:	3c 5a                	cmp    $0x5a,%al
  8004210f4b:	7f 3d                	jg     8004210f8a <strtol+0x16b>
			dig = *s - 'A' + 10;
  8004210f4d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210f51:	0f b6 00             	movzbl (%rax),%eax
  8004210f54:	0f be c0             	movsbl %al,%eax
  8004210f57:	83 e8 37             	sub    $0x37,%eax
  8004210f5a:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  8004210f5d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210f60:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  8004210f63:	7c 02                	jl     8004210f67 <strtol+0x148>
			break;
  8004210f65:	eb 23                	jmp    8004210f8a <strtol+0x16b>
		s++, val = (val * base) + dig;
  8004210f67:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  8004210f6c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004210f6f:	48 98                	cltq   
  8004210f71:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  8004210f76:	48 89 c2             	mov    %rax,%rdx
  8004210f79:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004210f7c:	48 98                	cltq   
  8004210f7e:	48 01 d0             	add    %rdx,%rax
  8004210f81:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  8004210f85:	e9 5d ff ff ff       	jmpq   8004210ee7 <strtol+0xc8>

	if (endptr)
  8004210f8a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210f8f:	74 0b                	je     8004210f9c <strtol+0x17d>
		*endptr = (char *) s;
  8004210f91:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210f95:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004210f99:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  8004210f9c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004210fa0:	74 09                	je     8004210fab <strtol+0x18c>
  8004210fa2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210fa6:	48 f7 d8             	neg    %rax
  8004210fa9:	eb 04                	jmp    8004210faf <strtol+0x190>
  8004210fab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  8004210faf:	c9                   	leaveq 
  8004210fb0:	c3                   	retq   

0000008004210fb1 <strstr>:

char * strstr(const char *in, const char *str)
{
  8004210fb1:	55                   	push   %rbp
  8004210fb2:	48 89 e5             	mov    %rsp,%rbp
  8004210fb5:	48 83 ec 30          	sub    $0x30,%rsp
  8004210fb9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210fbd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  8004210fc1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210fc5:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210fc9:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004210fcd:	0f b6 00             	movzbl (%rax),%eax
  8004210fd0:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  8004210fd3:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  8004210fd7:	75 06                	jne    8004210fdf <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  8004210fd9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210fdd:	eb 6b                	jmp    800421104a <strstr+0x99>

	len = strlen(str);
  8004210fdf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210fe3:	48 89 c7             	mov    %rax,%rdi
  8004210fe6:	48 b8 87 08 21 04 80 	movabs $0x8004210887,%rax
  8004210fed:	00 00 00 
  8004210ff0:	ff d0                	callq  *%rax
  8004210ff2:	48 98                	cltq   
  8004210ff4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  8004210ff8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210ffc:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211000:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211004:	0f b6 00             	movzbl (%rax),%eax
  8004211007:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800421100a:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800421100e:	75 07                	jne    8004211017 <strstr+0x66>
				return (char *) 0;
  8004211010:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211015:	eb 33                	jmp    800421104a <strstr+0x99>
		} while (sc != c);
  8004211017:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800421101b:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800421101e:	75 d8                	jne    8004210ff8 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  8004211020:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211024:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  8004211028:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421102c:	48 89 ce             	mov    %rcx,%rsi
  800421102f:	48 89 c7             	mov    %rax,%rdi
  8004211032:	48 b8 a8 0a 21 04 80 	movabs $0x8004210aa8,%rax
  8004211039:	00 00 00 
  800421103c:	ff d0                	callq  *%rax
  800421103e:	85 c0                	test   %eax,%eax
  8004211040:	75 b6                	jne    8004210ff8 <strstr+0x47>

	return (char *) (in - 1);
  8004211042:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211046:	48 83 e8 01          	sub    $0x1,%rax
}
  800421104a:	c9                   	leaveq 
  800421104b:	c3                   	retq   

000000800421104c <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800421104c:	55                   	push   %rbp
  800421104d:	48 89 e5             	mov    %rsp,%rbp
  8004211050:	48 83 ec 24          	sub    $0x24,%rsp
  8004211054:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211058:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421105c:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800421105f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211063:	48 8b 10             	mov    (%rax),%rdx
  8004211066:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421106a:	48 01 d0             	add    %rdx,%rax
  800421106d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004211071:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211078:	00 
	switch (bytes_to_read) {
  8004211079:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421107c:	83 f8 02             	cmp    $0x2,%eax
  800421107f:	0f 84 ab 00 00 00    	je     8004211130 <_dwarf_read_lsb+0xe4>
  8004211085:	83 f8 02             	cmp    $0x2,%eax
  8004211088:	7f 0e                	jg     8004211098 <_dwarf_read_lsb+0x4c>
  800421108a:	83 f8 01             	cmp    $0x1,%eax
  800421108d:	0f 84 b3 00 00 00    	je     8004211146 <_dwarf_read_lsb+0xfa>
  8004211093:	e9 d9 00 00 00       	jmpq   8004211171 <_dwarf_read_lsb+0x125>
  8004211098:	83 f8 04             	cmp    $0x4,%eax
  800421109b:	74 65                	je     8004211102 <_dwarf_read_lsb+0xb6>
  800421109d:	83 f8 08             	cmp    $0x8,%eax
  80042110a0:	0f 85 cb 00 00 00    	jne    8004211171 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042110a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110aa:	48 83 c0 04          	add    $0x4,%rax
  80042110ae:	0f b6 00             	movzbl (%rax),%eax
  80042110b1:	0f b6 c0             	movzbl %al,%eax
  80042110b4:	48 c1 e0 20          	shl    $0x20,%rax
  80042110b8:	48 89 c2             	mov    %rax,%rdx
  80042110bb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110bf:	48 83 c0 05          	add    $0x5,%rax
  80042110c3:	0f b6 00             	movzbl (%rax),%eax
  80042110c6:	0f b6 c0             	movzbl %al,%eax
  80042110c9:	48 c1 e0 28          	shl    $0x28,%rax
  80042110cd:	48 09 d0             	or     %rdx,%rax
  80042110d0:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  80042110d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110d8:	48 83 c0 06          	add    $0x6,%rax
  80042110dc:	0f b6 00             	movzbl (%rax),%eax
  80042110df:	0f b6 c0             	movzbl %al,%eax
  80042110e2:	48 c1 e0 30          	shl    $0x30,%rax
  80042110e6:	48 89 c2             	mov    %rax,%rdx
  80042110e9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042110ed:	48 83 c0 07          	add    $0x7,%rax
  80042110f1:	0f b6 00             	movzbl (%rax),%eax
  80042110f4:	0f b6 c0             	movzbl %al,%eax
  80042110f7:	48 c1 e0 38          	shl    $0x38,%rax
  80042110fb:	48 09 d0             	or     %rdx,%rax
  80042110fe:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  8004211102:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211106:	48 83 c0 02          	add    $0x2,%rax
  800421110a:	0f b6 00             	movzbl (%rax),%eax
  800421110d:	0f b6 c0             	movzbl %al,%eax
  8004211110:	48 c1 e0 10          	shl    $0x10,%rax
  8004211114:	48 89 c2             	mov    %rax,%rdx
  8004211117:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421111b:	48 83 c0 03          	add    $0x3,%rax
  800421111f:	0f b6 00             	movzbl (%rax),%eax
  8004211122:	0f b6 c0             	movzbl %al,%eax
  8004211125:	48 c1 e0 18          	shl    $0x18,%rax
  8004211129:	48 09 d0             	or     %rdx,%rax
  800421112c:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004211130:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211134:	48 83 c0 01          	add    $0x1,%rax
  8004211138:	0f b6 00             	movzbl (%rax),%eax
  800421113b:	0f b6 c0             	movzbl %al,%eax
  800421113e:	48 c1 e0 08          	shl    $0x8,%rax
  8004211142:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  8004211146:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421114a:	0f b6 00             	movzbl (%rax),%eax
  800421114d:	0f b6 c0             	movzbl %al,%eax
  8004211150:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211154:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  8004211155:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211159:	48 8b 10             	mov    (%rax),%rdx
  800421115c:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421115f:	48 98                	cltq   
  8004211161:	48 01 c2             	add    %rax,%rdx
  8004211164:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211168:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421116b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421116f:	eb 05                	jmp    8004211176 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004211171:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  8004211176:	c9                   	leaveq 
  8004211177:	c3                   	retq   

0000008004211178 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  8004211178:	55                   	push   %rbp
  8004211179:	48 89 e5             	mov    %rsp,%rbp
  800421117c:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004211180:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211184:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004211187:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421118b:	48 8b 00             	mov    (%rax),%rax
  800421118e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004211192:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211199:	00 
	switch (bytes_to_read) {
  800421119a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421119d:	83 f8 02             	cmp    $0x2,%eax
  80042111a0:	0f 84 ab 00 00 00    	je     8004211251 <_dwarf_decode_lsb+0xd9>
  80042111a6:	83 f8 02             	cmp    $0x2,%eax
  80042111a9:	7f 0e                	jg     80042111b9 <_dwarf_decode_lsb+0x41>
  80042111ab:	83 f8 01             	cmp    $0x1,%eax
  80042111ae:	0f 84 b3 00 00 00    	je     8004211267 <_dwarf_decode_lsb+0xef>
  80042111b4:	e9 d9 00 00 00       	jmpq   8004211292 <_dwarf_decode_lsb+0x11a>
  80042111b9:	83 f8 04             	cmp    $0x4,%eax
  80042111bc:	74 65                	je     8004211223 <_dwarf_decode_lsb+0xab>
  80042111be:	83 f8 08             	cmp    $0x8,%eax
  80042111c1:	0f 85 cb 00 00 00    	jne    8004211292 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042111c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042111cb:	48 83 c0 04          	add    $0x4,%rax
  80042111cf:	0f b6 00             	movzbl (%rax),%eax
  80042111d2:	0f b6 c0             	movzbl %al,%eax
  80042111d5:	48 c1 e0 20          	shl    $0x20,%rax
  80042111d9:	48 89 c2             	mov    %rax,%rdx
  80042111dc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042111e0:	48 83 c0 05          	add    $0x5,%rax
  80042111e4:	0f b6 00             	movzbl (%rax),%eax
  80042111e7:	0f b6 c0             	movzbl %al,%eax
  80042111ea:	48 c1 e0 28          	shl    $0x28,%rax
  80042111ee:	48 09 d0             	or     %rdx,%rax
  80042111f1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  80042111f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042111f9:	48 83 c0 06          	add    $0x6,%rax
  80042111fd:	0f b6 00             	movzbl (%rax),%eax
  8004211200:	0f b6 c0             	movzbl %al,%eax
  8004211203:	48 c1 e0 30          	shl    $0x30,%rax
  8004211207:	48 89 c2             	mov    %rax,%rdx
  800421120a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421120e:	48 83 c0 07          	add    $0x7,%rax
  8004211212:	0f b6 00             	movzbl (%rax),%eax
  8004211215:	0f b6 c0             	movzbl %al,%eax
  8004211218:	48 c1 e0 38          	shl    $0x38,%rax
  800421121c:	48 09 d0             	or     %rdx,%rax
  800421121f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  8004211223:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211227:	48 83 c0 02          	add    $0x2,%rax
  800421122b:	0f b6 00             	movzbl (%rax),%eax
  800421122e:	0f b6 c0             	movzbl %al,%eax
  8004211231:	48 c1 e0 10          	shl    $0x10,%rax
  8004211235:	48 89 c2             	mov    %rax,%rdx
  8004211238:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421123c:	48 83 c0 03          	add    $0x3,%rax
  8004211240:	0f b6 00             	movzbl (%rax),%eax
  8004211243:	0f b6 c0             	movzbl %al,%eax
  8004211246:	48 c1 e0 18          	shl    $0x18,%rax
  800421124a:	48 09 d0             	or     %rdx,%rax
  800421124d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004211251:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211255:	48 83 c0 01          	add    $0x1,%rax
  8004211259:	0f b6 00             	movzbl (%rax),%eax
  800421125c:	0f b6 c0             	movzbl %al,%eax
  800421125f:	48 c1 e0 08          	shl    $0x8,%rax
  8004211263:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  8004211267:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421126b:	0f b6 00             	movzbl (%rax),%eax
  800421126e:	0f b6 c0             	movzbl %al,%eax
  8004211271:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211275:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  8004211276:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421127a:	48 8b 10             	mov    (%rax),%rdx
  800421127d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211280:	48 98                	cltq   
  8004211282:	48 01 c2             	add    %rax,%rdx
  8004211285:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211289:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421128c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211290:	eb 05                	jmp    8004211297 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004211292:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  8004211297:	c9                   	leaveq 
  8004211298:	c3                   	retq   

0000008004211299 <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  8004211299:	55                   	push   %rbp
  800421129a:	48 89 e5             	mov    %rsp,%rbp
  800421129d:	48 83 ec 24          	sub    $0x24,%rsp
  80042112a1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042112a5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042112a9:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  80042112ac:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042112b0:	48 8b 10             	mov    (%rax),%rdx
  80042112b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042112b7:	48 01 d0             	add    %rdx,%rax
  80042112ba:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  80042112be:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042112c1:	83 f8 02             	cmp    $0x2,%eax
  80042112c4:	74 35                	je     80042112fb <_dwarf_read_msb+0x62>
  80042112c6:	83 f8 02             	cmp    $0x2,%eax
  80042112c9:	7f 0a                	jg     80042112d5 <_dwarf_read_msb+0x3c>
  80042112cb:	83 f8 01             	cmp    $0x1,%eax
  80042112ce:	74 18                	je     80042112e8 <_dwarf_read_msb+0x4f>
  80042112d0:	e9 53 01 00 00       	jmpq   8004211428 <_dwarf_read_msb+0x18f>
  80042112d5:	83 f8 04             	cmp    $0x4,%eax
  80042112d8:	74 49                	je     8004211323 <_dwarf_read_msb+0x8a>
  80042112da:	83 f8 08             	cmp    $0x8,%eax
  80042112dd:	0f 84 96 00 00 00    	je     8004211379 <_dwarf_read_msb+0xe0>
  80042112e3:	e9 40 01 00 00       	jmpq   8004211428 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  80042112e8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042112ec:	0f b6 00             	movzbl (%rax),%eax
  80042112ef:	0f b6 c0             	movzbl %al,%eax
  80042112f2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042112f6:	e9 34 01 00 00       	jmpq   800421142f <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  80042112fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042112ff:	48 83 c0 01          	add    $0x1,%rax
  8004211303:	0f b6 00             	movzbl (%rax),%eax
  8004211306:	0f b6 d0             	movzbl %al,%edx
  8004211309:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421130d:	0f b6 00             	movzbl (%rax),%eax
  8004211310:	0f b6 c0             	movzbl %al,%eax
  8004211313:	48 c1 e0 08          	shl    $0x8,%rax
  8004211317:	48 09 d0             	or     %rdx,%rax
  800421131a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800421131e:	e9 0c 01 00 00       	jmpq   800421142f <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  8004211323:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211327:	48 83 c0 03          	add    $0x3,%rax
  800421132b:	0f b6 00             	movzbl (%rax),%eax
  800421132e:	0f b6 c0             	movzbl %al,%eax
  8004211331:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211335:	48 83 c2 02          	add    $0x2,%rdx
  8004211339:	0f b6 12             	movzbl (%rdx),%edx
  800421133c:	0f b6 d2             	movzbl %dl,%edx
  800421133f:	48 c1 e2 08          	shl    $0x8,%rdx
  8004211343:	48 09 d0             	or     %rdx,%rax
  8004211346:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800421134a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421134e:	48 83 c0 01          	add    $0x1,%rax
  8004211352:	0f b6 00             	movzbl (%rax),%eax
  8004211355:	0f b6 c0             	movzbl %al,%eax
  8004211358:	48 c1 e0 10          	shl    $0x10,%rax
  800421135c:	48 89 c2             	mov    %rax,%rdx
  800421135f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211363:	0f b6 00             	movzbl (%rax),%eax
  8004211366:	0f b6 c0             	movzbl %al,%eax
  8004211369:	48 c1 e0 18          	shl    $0x18,%rax
  800421136d:	48 09 d0             	or     %rdx,%rax
  8004211370:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211374:	e9 b6 00 00 00       	jmpq   800421142f <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004211379:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421137d:	48 83 c0 07          	add    $0x7,%rax
  8004211381:	0f b6 00             	movzbl (%rax),%eax
  8004211384:	0f b6 c0             	movzbl %al,%eax
  8004211387:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421138b:	48 83 c2 06          	add    $0x6,%rdx
  800421138f:	0f b6 12             	movzbl (%rdx),%edx
  8004211392:	0f b6 d2             	movzbl %dl,%edx
  8004211395:	48 c1 e2 08          	shl    $0x8,%rdx
  8004211399:	48 09 d0             	or     %rdx,%rax
  800421139c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  80042113a0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113a4:	48 83 c0 05          	add    $0x5,%rax
  80042113a8:	0f b6 00             	movzbl (%rax),%eax
  80042113ab:	0f b6 c0             	movzbl %al,%eax
  80042113ae:	48 c1 e0 10          	shl    $0x10,%rax
  80042113b2:	48 89 c2             	mov    %rax,%rdx
  80042113b5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113b9:	48 83 c0 04          	add    $0x4,%rax
  80042113bd:	0f b6 00             	movzbl (%rax),%eax
  80042113c0:	0f b6 c0             	movzbl %al,%eax
  80042113c3:	48 c1 e0 18          	shl    $0x18,%rax
  80042113c7:	48 09 d0             	or     %rdx,%rax
  80042113ca:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  80042113ce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113d2:	48 83 c0 03          	add    $0x3,%rax
  80042113d6:	0f b6 00             	movzbl (%rax),%eax
  80042113d9:	0f b6 c0             	movzbl %al,%eax
  80042113dc:	48 c1 e0 20          	shl    $0x20,%rax
  80042113e0:	48 89 c2             	mov    %rax,%rdx
  80042113e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042113e7:	48 83 c0 02          	add    $0x2,%rax
  80042113eb:	0f b6 00             	movzbl (%rax),%eax
  80042113ee:	0f b6 c0             	movzbl %al,%eax
  80042113f1:	48 c1 e0 28          	shl    $0x28,%rax
  80042113f5:	48 09 d0             	or     %rdx,%rax
  80042113f8:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  80042113fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211400:	48 83 c0 01          	add    $0x1,%rax
  8004211404:	0f b6 00             	movzbl (%rax),%eax
  8004211407:	0f b6 c0             	movzbl %al,%eax
  800421140a:	48 c1 e0 30          	shl    $0x30,%rax
  800421140e:	48 89 c2             	mov    %rax,%rdx
  8004211411:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211415:	0f b6 00             	movzbl (%rax),%eax
  8004211418:	0f b6 c0             	movzbl %al,%eax
  800421141b:	48 c1 e0 38          	shl    $0x38,%rax
  800421141f:	48 09 d0             	or     %rdx,%rax
  8004211422:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211426:	eb 07                	jmp    800421142f <_dwarf_read_msb+0x196>
	default:
		return (0);
  8004211428:	b8 00 00 00 00       	mov    $0x0,%eax
  800421142d:	eb 1a                	jmp    8004211449 <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  800421142f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211433:	48 8b 10             	mov    (%rax),%rdx
  8004211436:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004211439:	48 98                	cltq   
  800421143b:	48 01 c2             	add    %rax,%rdx
  800421143e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211442:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211445:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211449:	c9                   	leaveq 
  800421144a:	c3                   	retq   

000000800421144b <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800421144b:	55                   	push   %rbp
  800421144c:	48 89 e5             	mov    %rsp,%rbp
  800421144f:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004211453:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211457:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800421145a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421145e:	48 8b 00             	mov    (%rax),%rax
  8004211461:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004211465:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421146c:	00 
	switch (bytes_to_read) {
  800421146d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211470:	83 f8 02             	cmp    $0x2,%eax
  8004211473:	74 35                	je     80042114aa <_dwarf_decode_msb+0x5f>
  8004211475:	83 f8 02             	cmp    $0x2,%eax
  8004211478:	7f 0a                	jg     8004211484 <_dwarf_decode_msb+0x39>
  800421147a:	83 f8 01             	cmp    $0x1,%eax
  800421147d:	74 18                	je     8004211497 <_dwarf_decode_msb+0x4c>
  800421147f:	e9 53 01 00 00       	jmpq   80042115d7 <_dwarf_decode_msb+0x18c>
  8004211484:	83 f8 04             	cmp    $0x4,%eax
  8004211487:	74 49                	je     80042114d2 <_dwarf_decode_msb+0x87>
  8004211489:	83 f8 08             	cmp    $0x8,%eax
  800421148c:	0f 84 96 00 00 00    	je     8004211528 <_dwarf_decode_msb+0xdd>
  8004211492:	e9 40 01 00 00       	jmpq   80042115d7 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  8004211497:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421149b:	0f b6 00             	movzbl (%rax),%eax
  800421149e:	0f b6 c0             	movzbl %al,%eax
  80042114a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042114a5:	e9 34 01 00 00       	jmpq   80042115de <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  80042114aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114ae:	48 83 c0 01          	add    $0x1,%rax
  80042114b2:	0f b6 00             	movzbl (%rax),%eax
  80042114b5:	0f b6 d0             	movzbl %al,%edx
  80042114b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114bc:	0f b6 00             	movzbl (%rax),%eax
  80042114bf:	0f b6 c0             	movzbl %al,%eax
  80042114c2:	48 c1 e0 08          	shl    $0x8,%rax
  80042114c6:	48 09 d0             	or     %rdx,%rax
  80042114c9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042114cd:	e9 0c 01 00 00       	jmpq   80042115de <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  80042114d2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114d6:	48 83 c0 03          	add    $0x3,%rax
  80042114da:	0f b6 00             	movzbl (%rax),%eax
  80042114dd:	0f b6 c0             	movzbl %al,%eax
  80042114e0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042114e4:	48 83 c2 02          	add    $0x2,%rdx
  80042114e8:	0f b6 12             	movzbl (%rdx),%edx
  80042114eb:	0f b6 d2             	movzbl %dl,%edx
  80042114ee:	48 c1 e2 08          	shl    $0x8,%rdx
  80042114f2:	48 09 d0             	or     %rdx,%rax
  80042114f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  80042114f9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042114fd:	48 83 c0 01          	add    $0x1,%rax
  8004211501:	0f b6 00             	movzbl (%rax),%eax
  8004211504:	0f b6 c0             	movzbl %al,%eax
  8004211507:	48 c1 e0 10          	shl    $0x10,%rax
  800421150b:	48 89 c2             	mov    %rax,%rdx
  800421150e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211512:	0f b6 00             	movzbl (%rax),%eax
  8004211515:	0f b6 c0             	movzbl %al,%eax
  8004211518:	48 c1 e0 18          	shl    $0x18,%rax
  800421151c:	48 09 d0             	or     %rdx,%rax
  800421151f:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004211523:	e9 b6 00 00 00       	jmpq   80042115de <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004211528:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421152c:	48 83 c0 07          	add    $0x7,%rax
  8004211530:	0f b6 00             	movzbl (%rax),%eax
  8004211533:	0f b6 c0             	movzbl %al,%eax
  8004211536:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421153a:	48 83 c2 06          	add    $0x6,%rdx
  800421153e:	0f b6 12             	movzbl (%rdx),%edx
  8004211541:	0f b6 d2             	movzbl %dl,%edx
  8004211544:	48 c1 e2 08          	shl    $0x8,%rdx
  8004211548:	48 09 d0             	or     %rdx,%rax
  800421154b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  800421154f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211553:	48 83 c0 05          	add    $0x5,%rax
  8004211557:	0f b6 00             	movzbl (%rax),%eax
  800421155a:	0f b6 c0             	movzbl %al,%eax
  800421155d:	48 c1 e0 10          	shl    $0x10,%rax
  8004211561:	48 89 c2             	mov    %rax,%rdx
  8004211564:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211568:	48 83 c0 04          	add    $0x4,%rax
  800421156c:	0f b6 00             	movzbl (%rax),%eax
  800421156f:	0f b6 c0             	movzbl %al,%eax
  8004211572:	48 c1 e0 18          	shl    $0x18,%rax
  8004211576:	48 09 d0             	or     %rdx,%rax
  8004211579:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800421157d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211581:	48 83 c0 03          	add    $0x3,%rax
  8004211585:	0f b6 00             	movzbl (%rax),%eax
  8004211588:	0f b6 c0             	movzbl %al,%eax
  800421158b:	48 c1 e0 20          	shl    $0x20,%rax
  800421158f:	48 89 c2             	mov    %rax,%rdx
  8004211592:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211596:	48 83 c0 02          	add    $0x2,%rax
  800421159a:	0f b6 00             	movzbl (%rax),%eax
  800421159d:	0f b6 c0             	movzbl %al,%eax
  80042115a0:	48 c1 e0 28          	shl    $0x28,%rax
  80042115a4:	48 09 d0             	or     %rdx,%rax
  80042115a7:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  80042115ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042115af:	48 83 c0 01          	add    $0x1,%rax
  80042115b3:	0f b6 00             	movzbl (%rax),%eax
  80042115b6:	0f b6 c0             	movzbl %al,%eax
  80042115b9:	48 c1 e0 30          	shl    $0x30,%rax
  80042115bd:	48 89 c2             	mov    %rax,%rdx
  80042115c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042115c4:	0f b6 00             	movzbl (%rax),%eax
  80042115c7:	0f b6 c0             	movzbl %al,%eax
  80042115ca:	48 c1 e0 38          	shl    $0x38,%rax
  80042115ce:	48 09 d0             	or     %rdx,%rax
  80042115d1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042115d5:	eb 07                	jmp    80042115de <_dwarf_decode_msb+0x193>
	default:
		return (0);
  80042115d7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042115dc:	eb 1a                	jmp    80042115f8 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  80042115de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042115e2:	48 8b 10             	mov    (%rax),%rdx
  80042115e5:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042115e8:	48 98                	cltq   
  80042115ea:	48 01 c2             	add    %rax,%rdx
  80042115ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042115f1:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042115f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042115f8:	c9                   	leaveq 
  80042115f9:	c3                   	retq   

00000080042115fa <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  80042115fa:	55                   	push   %rbp
  80042115fb:	48 89 e5             	mov    %rsp,%rbp
  80042115fe:	48 83 ec 30          	sub    $0x30,%rsp
  8004211602:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211606:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  800421160a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211611:	00 
	uint8_t b;
	int shift = 0;
  8004211612:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  8004211619:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421161d:	48 8b 10             	mov    (%rax),%rdx
  8004211620:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211624:	48 01 d0             	add    %rdx,%rax
  8004211627:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800421162b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421162f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211633:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004211637:	0f b6 00             	movzbl (%rax),%eax
  800421163a:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800421163d:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211641:	83 e0 7f             	and    $0x7f,%eax
  8004211644:	89 c2                	mov    %eax,%edx
  8004211646:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211649:	89 c1                	mov    %eax,%ecx
  800421164b:	d3 e2                	shl    %cl,%edx
  800421164d:	89 d0                	mov    %edx,%eax
  800421164f:	48 98                	cltq   
  8004211651:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004211655:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211659:	48 8b 00             	mov    (%rax),%rax
  800421165c:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211660:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211664:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004211667:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421166b:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421166f:	84 c0                	test   %al,%al
  8004211671:	78 b8                	js     800421162b <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  8004211673:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004211677:	7f 1f                	jg     8004211698 <_dwarf_read_sleb128+0x9e>
  8004211679:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421167d:	83 e0 40             	and    $0x40,%eax
  8004211680:	85 c0                	test   %eax,%eax
  8004211682:	74 14                	je     8004211698 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  8004211684:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211687:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800421168c:	89 c1                	mov    %eax,%ecx
  800421168e:	d3 e2                	shl    %cl,%edx
  8004211690:	89 d0                	mov    %edx,%eax
  8004211692:	48 98                	cltq   
  8004211694:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  8004211698:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421169c:	c9                   	leaveq 
  800421169d:	c3                   	retq   

000000800421169e <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800421169e:	55                   	push   %rbp
  800421169f:	48 89 e5             	mov    %rsp,%rbp
  80042116a2:	48 83 ec 30          	sub    $0x30,%rsp
  80042116a6:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042116aa:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  80042116ae:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042116b5:	00 
	uint8_t b;
	int shift = 0;
  80042116b6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  80042116bd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042116c1:	48 8b 10             	mov    (%rax),%rdx
  80042116c4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042116c8:	48 01 d0             	add    %rdx,%rax
  80042116cb:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042116cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042116d3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042116d7:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042116db:	0f b6 00             	movzbl (%rax),%eax
  80042116de:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  80042116e1:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042116e5:	83 e0 7f             	and    $0x7f,%eax
  80042116e8:	89 c2                	mov    %eax,%edx
  80042116ea:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042116ed:	89 c1                	mov    %eax,%ecx
  80042116ef:	d3 e2                	shl    %cl,%edx
  80042116f1:	89 d0                	mov    %edx,%eax
  80042116f3:	48 98                	cltq   
  80042116f5:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  80042116f9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042116fd:	48 8b 00             	mov    (%rax),%rax
  8004211700:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211704:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211708:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  800421170b:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421170f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211713:	84 c0                	test   %al,%al
  8004211715:	78 b8                	js     80042116cf <_dwarf_read_uleb128+0x31>

	return (ret);
  8004211717:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421171b:	c9                   	leaveq 
  800421171c:	c3                   	retq   

000000800421171d <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800421171d:	55                   	push   %rbp
  800421171e:	48 89 e5             	mov    %rsp,%rbp
  8004211721:	48 83 ec 28          	sub    $0x28,%rsp
  8004211725:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  8004211729:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004211730:	00 
	uint8_t b;
	int shift = 0;
  8004211731:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004211738:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421173c:	48 8b 00             	mov    (%rax),%rax
  800421173f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004211743:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211747:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421174b:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800421174f:	0f b6 00             	movzbl (%rax),%eax
  8004211752:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004211755:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211759:	83 e0 7f             	and    $0x7f,%eax
  800421175c:	89 c2                	mov    %eax,%edx
  800421175e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211761:	89 c1                	mov    %eax,%ecx
  8004211763:	d3 e2                	shl    %cl,%edx
  8004211765:	89 d0                	mov    %edx,%eax
  8004211767:	48 98                	cltq   
  8004211769:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800421176d:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211771:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211775:	84 c0                	test   %al,%al
  8004211777:	78 ca                	js     8004211743 <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  8004211779:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800421177d:	7f 1f                	jg     800421179e <_dwarf_decode_sleb128+0x81>
  800421177f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211783:	83 e0 40             	and    $0x40,%eax
  8004211786:	85 c0                	test   %eax,%eax
  8004211788:	74 14                	je     800421179e <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800421178a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421178d:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004211792:	89 c1                	mov    %eax,%ecx
  8004211794:	d3 e2                	shl    %cl,%edx
  8004211796:	89 d0                	mov    %edx,%eax
  8004211798:	48 98                	cltq   
  800421179a:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800421179e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042117a2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042117a6:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042117a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042117ad:	c9                   	leaveq 
  80042117ae:	c3                   	retq   

00000080042117af <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  80042117af:	55                   	push   %rbp
  80042117b0:	48 89 e5             	mov    %rsp,%rbp
  80042117b3:	48 83 ec 28          	sub    $0x28,%rsp
  80042117b7:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  80042117bb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042117c2:	00 
	uint8_t b;
	int shift = 0;
  80042117c3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  80042117ca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042117ce:	48 8b 00             	mov    (%rax),%rax
  80042117d1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042117d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042117d9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042117dd:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042117e1:	0f b6 00             	movzbl (%rax),%eax
  80042117e4:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  80042117e7:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042117eb:	83 e0 7f             	and    $0x7f,%eax
  80042117ee:	89 c2                	mov    %eax,%edx
  80042117f0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042117f3:	89 c1                	mov    %eax,%ecx
  80042117f5:	d3 e2                	shl    %cl,%edx
  80042117f7:	89 d0                	mov    %edx,%eax
  80042117f9:	48 98                	cltq   
  80042117fb:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  80042117ff:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004211803:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004211807:	84 c0                	test   %al,%al
  8004211809:	78 ca                	js     80042117d5 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  800421180b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421180f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211813:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004211816:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421181a:	c9                   	leaveq 
  800421181b:	c3                   	retq   

000000800421181c <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800421181c:	55                   	push   %rbp
  800421181d:	48 89 e5             	mov    %rsp,%rbp
  8004211820:	48 83 ec 28          	sub    $0x28,%rsp
  8004211824:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211828:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421182c:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  8004211830:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211834:	48 8b 10             	mov    (%rax),%rdx
  8004211837:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421183b:	48 01 d0             	add    %rdx,%rax
  800421183e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211842:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211846:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800421184a:	eb 17                	jmp    8004211863 <_dwarf_read_string+0x47>
		src++;
  800421184c:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  8004211851:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211855:	48 8b 00             	mov    (%rax),%rax
  8004211858:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421185c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211860:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  8004211863:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211867:	0f b6 00             	movzbl (%rax),%eax
  800421186a:	84 c0                	test   %al,%al
  800421186c:	74 0d                	je     800421187b <_dwarf_read_string+0x5f>
  800421186e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211872:	48 8b 00             	mov    (%rax),%rax
  8004211875:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211879:	72 d1                	jb     800421184c <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800421187b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421187f:	0f b6 00             	movzbl (%rax),%eax
  8004211882:	84 c0                	test   %al,%al
  8004211884:	75 1f                	jne    80042118a5 <_dwarf_read_string+0x89>
  8004211886:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421188a:	48 8b 00             	mov    (%rax),%rax
  800421188d:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211891:	73 12                	jae    80042118a5 <_dwarf_read_string+0x89>
		(*offsetp)++;
  8004211893:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211897:	48 8b 00             	mov    (%rax),%rax
  800421189a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421189e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042118a2:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042118a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042118a9:	c9                   	leaveq 
  80042118aa:	c3                   	retq   

00000080042118ab <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  80042118ab:	55                   	push   %rbp
  80042118ac:	48 89 e5             	mov    %rsp,%rbp
  80042118af:	48 83 ec 28          	sub    $0x28,%rsp
  80042118b3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042118b7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042118bb:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  80042118bf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042118c3:	48 8b 10             	mov    (%rax),%rdx
  80042118c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042118ca:	48 01 d0             	add    %rdx,%rax
  80042118cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042118d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042118d5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  80042118d9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042118dd:	48 8b 10             	mov    (%rax),%rdx
  80042118e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042118e4:	48 01 c2             	add    %rax,%rdx
  80042118e7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042118eb:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042118ee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042118f2:	c9                   	leaveq 
  80042118f3:	c3                   	retq   

00000080042118f4 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  80042118f4:	55                   	push   %rbp
  80042118f5:	48 89 e5             	mov    %rsp,%rbp
  80042118f8:	48 83 ec 20          	sub    $0x20,%rsp
  80042118fc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  8004211900:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211904:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004211908:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421190d:	75 35                	jne    8004211944 <_dwarf_elf_get_byte_order+0x50>
  800421190f:	48 b9 c0 f5 21 04 80 	movabs $0x800421f5c0,%rcx
  8004211916:	00 00 00 
  8004211919:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004211920:	00 00 00 
  8004211923:	be 29 01 00 00       	mov    $0x129,%esi
  8004211928:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  800421192f:	00 00 00 
  8004211932:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211937:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421193e:	00 00 00 
  8004211941:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  8004211944:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211948:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800421194c:	0f b6 c0             	movzbl %al,%eax
  800421194f:	83 f8 02             	cmp    $0x2,%eax
  8004211952:	75 07                	jne    800421195b <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  8004211954:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211959:	eb 05                	jmp    8004211960 <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  800421195b:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  8004211960:	c9                   	leaveq 
  8004211961:	c3                   	retq   

0000008004211962 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  8004211962:	55                   	push   %rbp
  8004211963:	48 89 e5             	mov    %rsp,%rbp
  8004211966:	48 83 ec 20          	sub    $0x20,%rsp
  800421196a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800421196e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211972:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004211976:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421197b:	75 35                	jne    80042119b2 <_dwarf_elf_get_pointer_size+0x50>
  800421197d:	48 b9 c0 f5 21 04 80 	movabs $0x800421f5c0,%rcx
  8004211984:	00 00 00 
  8004211987:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  800421198e:	00 00 00 
  8004211991:	be 3f 01 00 00       	mov    $0x13f,%esi
  8004211996:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  800421199d:	00 00 00 
  80042119a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042119a5:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042119ac:	00 00 00 
  80042119af:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  80042119b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042119b6:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  80042119ba:	3c 01                	cmp    $0x1,%al
  80042119bc:	75 07                	jne    80042119c5 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  80042119be:	b8 04 00 00 00       	mov    $0x4,%eax
  80042119c3:	eb 05                	jmp    80042119ca <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  80042119c5:	b8 08 00 00 00       	mov    $0x8,%eax
}
  80042119ca:	c9                   	leaveq 
  80042119cb:	c3                   	retq   

00000080042119cc <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  80042119cc:	55                   	push   %rbp
  80042119cd:	48 89 e5             	mov    %rsp,%rbp
  80042119d0:	53                   	push   %rbx
  80042119d1:	48 83 ec 18          	sub    $0x18,%rsp
  80042119d5:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042119d9:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  80042119dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119e1:	ba 60 00 00 00       	mov    $0x60,%edx
  80042119e6:	be 00 00 00 00       	mov    $0x0,%esi
  80042119eb:	48 89 c7             	mov    %rax,%rdi
  80042119ee:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  80042119f5:	00 00 00 
  80042119f8:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  80042119fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042119fe:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  8004211a05:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a09:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004211a10:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  8004211a11:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211a15:	48 89 c7             	mov    %rax,%rdi
  8004211a18:	48 b8 62 19 21 04 80 	movabs $0x8004211962,%rax
  8004211a1f:	00 00 00 
  8004211a22:	ff d0                	callq  *%rax
  8004211a24:	0f b6 d0             	movzbl %al,%edx
  8004211a27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a2b:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  8004211a2e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211a32:	48 89 c7             	mov    %rax,%rdi
  8004211a35:	48 b8 f4 18 21 04 80 	movabs $0x80042118f4,%rax
  8004211a3c:	00 00 00 
  8004211a3f:	ff d0                	callq  *%rax
  8004211a41:	85 c0                	test   %eax,%eax
  8004211a43:	75 26                	jne    8004211a6b <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  8004211a45:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a49:	48 b9 99 12 21 04 80 	movabs $0x8004211299,%rcx
  8004211a50:	00 00 00 
  8004211a53:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  8004211a57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a5b:	48 bb 4b 14 21 04 80 	movabs $0x800421144b,%rbx
  8004211a62:	00 00 00 
  8004211a65:	48 89 58 20          	mov    %rbx,0x20(%rax)
  8004211a69:	eb 24                	jmp    8004211a8f <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  8004211a6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a6f:	48 b9 4c 10 21 04 80 	movabs $0x800421104c,%rcx
  8004211a76:	00 00 00 
  8004211a79:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  8004211a7d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a81:	48 be 78 11 21 04 80 	movabs $0x8004211178,%rsi
  8004211a88:	00 00 00 
  8004211a8b:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  8004211a8f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a93:	48 89 c7             	mov    %rax,%rdi
  8004211a96:	48 b8 99 2f 21 04 80 	movabs $0x8004212f99,%rax
  8004211a9d:	00 00 00 
  8004211aa0:	ff d0                	callq  *%rax
	return 0;
  8004211aa2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211aa7:	48 83 c4 18          	add    $0x18,%rsp
  8004211aab:	5b                   	pop    %rbx
  8004211aac:	5d                   	pop    %rbp
  8004211aad:	c3                   	retq   

0000008004211aae <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  8004211aae:	55                   	push   %rbp
  8004211aaf:	48 89 e5             	mov    %rsp,%rbp
  8004211ab2:	48 83 ec 20          	sub    $0x20,%rsp
  8004211ab6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211aba:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  8004211abe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ac2:	48 8b 10             	mov    (%rax),%rdx
  8004211ac5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ac9:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004211acd:	48 39 c2             	cmp    %rax,%rdx
  8004211ad0:	76 0a                	jbe    8004211adc <_get_next_cu+0x2e>
		return -1;
  8004211ad2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211ad7:	e9 6b 01 00 00       	jmpq   8004211c47 <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  8004211adc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211ae0:	48 8b 00             	mov    (%rax),%rax
  8004211ae3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  8004211ae7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211aeb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211aef:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  8004211af3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211af7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211afb:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211aff:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211b03:	48 89 d1             	mov    %rdx,%rcx
  8004211b06:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004211b0a:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211b0f:	48 89 cf             	mov    %rcx,%rdi
  8004211b12:	ff d0                	callq  *%rax
  8004211b14:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  8004211b17:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004211b1b:	75 2a                	jne    8004211b47 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  8004211b1d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b21:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211b25:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211b29:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211b2d:	48 89 d1             	mov    %rdx,%rcx
  8004211b30:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004211b34:	ba 08 00 00 00       	mov    $0x8,%edx
  8004211b39:	48 89 cf             	mov    %rcx,%rdi
  8004211b3c:	ff d0                	callq  *%rax
  8004211b3e:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  8004211b41:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  8004211b45:	eb 04                	jmp    8004211b4b <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  8004211b47:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  8004211b4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211b4f:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004211b53:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  8004211b56:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004211b59:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211b5d:	48 01 c2             	add    %rax,%rdx
  8004211b60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b64:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  8004211b67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b6b:	48 8b 10             	mov    (%rax),%rdx
  8004211b6e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211b72:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  8004211b76:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004211b79:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211b7d:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  8004211b80:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  8004211b84:	75 07                	jne    8004211b8d <_get_next_cu+0xdf>
  8004211b86:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211b8b:	eb 05                	jmp    8004211b92 <_get_next_cu+0xe4>
  8004211b8d:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004211b92:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211b96:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  8004211b99:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211b9d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211ba1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211ba5:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211ba9:	48 89 d1             	mov    %rdx,%rcx
  8004211bac:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004211bb0:	ba 02 00 00 00       	mov    $0x2,%edx
  8004211bb5:	48 89 cf             	mov    %rcx,%rdi
  8004211bb8:	ff d0                	callq  *%rax
  8004211bba:	89 c2                	mov    %eax,%edx
  8004211bbc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211bc0:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  8004211bc4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211bc8:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211bcc:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004211bd0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211bd4:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004211bd8:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004211bdc:	48 89 cf             	mov    %rcx,%rdi
  8004211bdf:	ff d0                	callq  *%rax
  8004211be1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211be5:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  8004211be9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211bed:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211bf1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211bf5:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004211bf9:	48 89 d1             	mov    %rdx,%rcx
  8004211bfc:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004211c00:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211c05:	48 89 cf             	mov    %rcx,%rdi
  8004211c08:	ff d0                	callq  *%rax
  8004211c0a:	89 c2                	mov    %eax,%edx
  8004211c0c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211c10:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  8004211c13:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211c17:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004211c1b:	66 83 f8 01          	cmp    $0x1,%ax
  8004211c1f:	76 0e                	jbe    8004211c2f <_get_next_cu+0x181>
  8004211c21:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211c25:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004211c29:	66 83 f8 04          	cmp    $0x4,%ax
  8004211c2d:	76 07                	jbe    8004211c36 <_get_next_cu+0x188>
		return -1;
  8004211c2f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211c34:	eb 11                	jmp    8004211c47 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  8004211c36:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211c3a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211c3e:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  8004211c42:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211c47:	c9                   	leaveq 
  8004211c48:	c3                   	retq   

0000008004211c49 <print_cu>:

void print_cu(Dwarf_CU cu)
{
  8004211c49:	55                   	push   %rbp
  8004211c4a:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  8004211c4d:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  8004211c51:	0f b6 c8             	movzbl %al,%ecx
  8004211c54:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  8004211c58:	0f b7 d0             	movzwl %ax,%edx
  8004211c5b:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8004211c5f:	48 89 c6             	mov    %rax,%rsi
  8004211c62:	48 bf f2 f5 21 04 80 	movabs $0x800421f5f2,%rdi
  8004211c69:	00 00 00 
  8004211c6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211c71:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  8004211c78:	00 00 00 
  8004211c7b:	41 ff d0             	callq  *%r8
}
  8004211c7e:	5d                   	pop    %rbp
  8004211c7f:	c3                   	retq   

0000008004211c80 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  8004211c80:	55                   	push   %rbp
  8004211c81:	48 89 e5             	mov    %rsp,%rbp
  8004211c84:	48 83 ec 60          	sub    $0x60,%rsp
  8004211c88:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004211c8c:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004211c90:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004211c94:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  8004211c98:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004211c9d:	75 35                	jne    8004211cd4 <_dwarf_abbrev_parse+0x54>
  8004211c9f:	48 b9 01 f6 21 04 80 	movabs $0x800421f601,%rcx
  8004211ca6:	00 00 00 
  8004211ca9:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004211cb0:	00 00 00 
  8004211cb3:	be a4 01 00 00       	mov    $0x1a4,%esi
  8004211cb8:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004211cbf:	00 00 00 
  8004211cc2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211cc7:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004211cce:	00 00 00 
  8004211cd1:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  8004211cd4:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8004211cd9:	75 35                	jne    8004211d10 <_dwarf_abbrev_parse+0x90>
  8004211cdb:	48 b9 0d f6 21 04 80 	movabs $0x800421f60d,%rcx
  8004211ce2:	00 00 00 
  8004211ce5:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004211cec:	00 00 00 
  8004211cef:	be a5 01 00 00       	mov    $0x1a5,%esi
  8004211cf4:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004211cfb:	00 00 00 
  8004211cfe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d03:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004211d0a:	00 00 00 
  8004211d0d:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  8004211d10:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211d14:	48 8b 10             	mov    (%rax),%rdx
  8004211d17:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211d1b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211d1f:	48 39 c2             	cmp    %rax,%rdx
  8004211d22:	72 0a                	jb     8004211d2e <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  8004211d24:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211d29:	e9 d3 01 00 00       	jmpq   8004211f01 <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  8004211d2e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211d32:	48 8b 00             	mov    (%rax),%rax
  8004211d35:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  8004211d39:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004211d3d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211d41:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004211d45:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211d49:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004211d4d:	48 89 d6             	mov    %rdx,%rsi
  8004211d50:	48 89 c7             	mov    %rax,%rdi
  8004211d53:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  8004211d5a:	00 00 00 
  8004211d5d:	ff d0                	callq  *%rax
  8004211d5f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  8004211d63:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211d68:	75 15                	jne    8004211d7f <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  8004211d6a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211d6e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  8004211d75:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d7a:	e9 82 01 00 00       	jmpq   8004211f01 <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004211d7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211d83:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004211d87:	48 89 d6             	mov    %rdx,%rsi
  8004211d8a:	48 89 c7             	mov    %rax,%rdi
  8004211d8d:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  8004211d94:	00 00 00 
  8004211d97:	ff d0                	callq  *%rax
  8004211d99:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  8004211d9d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004211da1:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211da5:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004211da9:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004211dad:	ba 01 00 00 00       	mov    $0x1,%edx
  8004211db2:	48 89 cf             	mov    %rcx,%rdi
  8004211db5:	ff d0                	callq  *%rax
  8004211db7:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  8004211dba:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211dbe:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004211dc2:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  8004211dc5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211dc9:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004211dcd:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  8004211dd1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211dd5:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  8004211dd9:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  8004211ddc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211de0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211de4:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  8004211de8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211dec:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  8004211df3:	00 
	abp->ab_atnum    = 0;
  8004211df4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211df8:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004211dff:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  8004211e00:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211e04:	48 8b 00             	mov    (%rax),%rax
  8004211e07:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004211e0b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211e0f:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004211e13:	48 89 d6             	mov    %rdx,%rsi
  8004211e16:	48 89 c7             	mov    %rax,%rdi
  8004211e19:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  8004211e20:	00 00 00 
  8004211e23:	ff d0                	callq  *%rax
  8004211e25:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004211e29:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004211e2d:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004211e31:	48 89 d6             	mov    %rdx,%rsi
  8004211e34:	48 89 c7             	mov    %rax,%rdi
  8004211e37:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  8004211e3e:	00 00 00 
  8004211e41:	ff d0                	callq  *%rax
  8004211e43:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  8004211e47:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211e4c:	0f 84 89 00 00 00    	je     8004211edb <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004211e52:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211e56:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211e5a:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004211e5e:	48 89 d0             	mov    %rdx,%rax
  8004211e61:	48 01 c0             	add    %rax,%rax
  8004211e64:	48 01 d0             	add    %rdx,%rax
  8004211e67:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e6b:	48 01 c8             	add    %rcx,%rax
  8004211e6e:	48 8d 50 30          	lea    0x30(%rax),%rdx
  8004211e72:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211e76:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  8004211e79:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211e7d:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211e81:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004211e85:	48 89 d0             	mov    %rdx,%rax
  8004211e88:	48 01 c0             	add    %rax,%rax
  8004211e8b:	48 01 d0             	add    %rdx,%rax
  8004211e8e:	48 c1 e0 03          	shl    $0x3,%rax
  8004211e92:	48 01 c8             	add    %rcx,%rax
  8004211e95:	48 8d 50 38          	lea    0x38(%rax),%rdx
  8004211e99:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211e9d:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  8004211ea0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211ea4:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211ea8:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004211eac:	48 89 d0             	mov    %rdx,%rax
  8004211eaf:	48 01 c0             	add    %rax,%rax
  8004211eb2:	48 01 d0             	add    %rdx,%rax
  8004211eb5:	48 c1 e0 03          	shl    $0x3,%rax
  8004211eb9:	48 01 c8             	add    %rcx,%rax
  8004211ebc:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004211ec0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211ec4:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  8004211ec7:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211ecb:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211ecf:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004211ed3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211ed7:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  8004211edb:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211ee0:	0f 85 1a ff ff ff    	jne    8004211e00 <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  8004211ee6:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004211eea:	48 8b 00             	mov    (%rax),%rax
  8004211eed:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004211ef1:	48 89 c2             	mov    %rax,%rdx
  8004211ef4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004211ef8:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  8004211efc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211f01:	c9                   	leaveq 
  8004211f02:	c3                   	retq   

0000008004211f03 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  8004211f03:	55                   	push   %rbp
  8004211f04:	48 89 e5             	mov    %rsp,%rbp
  8004211f07:	48 83 ec 70          	sub    $0x70,%rsp
  8004211f0b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211f0f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211f13:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  8004211f17:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211f1c:	75 0a                	jne    8004211f28 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  8004211f1e:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211f23:	e9 0a 01 00 00       	jmpq   8004212032 <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  8004211f28:	48 bf 18 f6 21 04 80 	movabs $0x800421f618,%rdi
  8004211f2f:	00 00 00 
  8004211f32:	48 b8 72 62 21 04 80 	movabs $0x8004216272,%rax
  8004211f39:	00 00 00 
  8004211f3c:	ff d0                	callq  *%rax
  8004211f3e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004211f42:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004211f47:	75 35                	jne    8004211f7e <_dwarf_abbrev_find+0x7b>
  8004211f49:	48 b9 0d f6 21 04 80 	movabs $0x800421f60d,%rcx
  8004211f50:	00 00 00 
  8004211f53:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004211f5a:	00 00 00 
  8004211f5d:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004211f62:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004211f69:	00 00 00 
  8004211f6c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f71:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004211f78:	00 00 00 
  8004211f7b:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004211f7e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004211f82:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  8004211f86:	e9 8d 00 00 00       	jmpq   8004212018 <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  8004211f8b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004211f8f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211f93:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  8004211f97:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211f9b:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004211f9f:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211fa3:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  8004211fa7:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004211fac:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  8004211fb0:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004211fb5:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  8004211fb9:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211fbe:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004211fc2:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004211fc7:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  8004211fcb:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004211fd0:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004211fd4:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  8004211fd9:	48 89 c7             	mov    %rax,%rdi
  8004211fdc:	48 b8 80 1c 21 04 80 	movabs $0x8004211c80,%rax
  8004211fe3:	00 00 00 
  8004211fe6:	ff d0                	callq  *%rax
  8004211fe8:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  8004211feb:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004211fef:	74 05                	je     8004211ff6 <_dwarf_abbrev_find+0xf3>
			return (ret);
  8004211ff1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211ff4:	eb 3c                	jmp    8004212032 <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  8004211ff6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211ffa:	48 8b 00             	mov    (%rax),%rax
  8004211ffd:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212001:	75 07                	jne    800421200a <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  8004212003:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212008:	eb 28                	jmp    8004212032 <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  800421200a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421200e:	48 8b 00             	mov    (%rax),%rax
  8004212011:	48 85 c0             	test   %rax,%rax
  8004212014:	75 02                	jne    8004212018 <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  8004212016:	eb 15                	jmp    800421202d <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  8004212018:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421201c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212020:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212024:	48 39 c2             	cmp    %rax,%rdx
  8004212027:	0f 87 5e ff ff ff    	ja     8004211f8b <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  800421202d:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004212032:	c9                   	leaveq 
  8004212033:	c3                   	retq   

0000008004212034 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  8004212034:	55                   	push   %rbp
  8004212035:	48 89 e5             	mov    %rsp,%rbp
  8004212038:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  800421203f:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004212046:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  800421204d:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004212054:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  800421205b:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004212062:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004212069:	48 bf 26 f6 21 04 80 	movabs $0x800421f626,%rdi
  8004212070:	00 00 00 
  8004212073:	48 b8 72 62 21 04 80 	movabs $0x8004216272,%rax
  800421207a:	00 00 00 
  800421207d:	ff d0                	callq  *%rax
  800421207f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004212083:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004212087:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421208b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  800421208f:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004212096:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421209a:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  800421209d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  80042120a4:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042120ab:	ba 60 00 00 00       	mov    $0x60,%edx
  80042120b0:	be 00 00 00 00       	mov    $0x0,%esi
  80042120b5:	48 89 c7             	mov    %rax,%rdi
  80042120b8:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  80042120bf:	00 00 00 
  80042120c2:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  80042120c4:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042120cb:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  80042120d2:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042120d9:	48 8b 00             	mov    (%rax),%rax
  80042120dc:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  80042120e0:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  80042120e7:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042120eb:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  80042120ef:	8b 45 10             	mov    0x10(%rbp),%eax
  80042120f2:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  80042120f5:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  80042120fc:	00 

	switch (form) {
  80042120fd:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  8004212104:	20 
  8004212105:	0f 87 82 04 00 00    	ja     800421258d <_dwarf_attr_init+0x559>
  800421210b:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004212112:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004212119:	00 
  800421211a:	48 b8 50 f6 21 04 80 	movabs $0x800421f650,%rax
  8004212121:	00 00 00 
  8004212124:	48 01 d0             	add    %rdx,%rax
  8004212127:	48 8b 00             	mov    (%rax),%rax
  800421212a:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800421212c:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212133:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212137:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421213e:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004212142:	0f b6 d2             	movzbl %dl,%edx
  8004212145:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421214c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212150:	48 89 cf             	mov    %rcx,%rdi
  8004212153:	ff d0                	callq  *%rax
  8004212155:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212159:	e9 37 04 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800421215e:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004212165:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212169:	48 89 d6             	mov    %rdx,%rsi
  800421216c:	48 89 c7             	mov    %rax,%rdi
  800421216f:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  8004212176:	00 00 00 
  8004212179:	ff d0                	callq  *%rax
  800421217b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421217f:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212183:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421218a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421218e:	48 89 ce             	mov    %rcx,%rsi
  8004212191:	48 89 c7             	mov    %rax,%rdi
  8004212194:	48 b8 ab 18 21 04 80 	movabs $0x80042118ab,%rax
  800421219b:	00 00 00 
  800421219e:	ff d0                	callq  *%rax
  80042121a0:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042121a4:	e9 ec 03 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  80042121a9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042121b0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042121b4:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042121bb:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042121bf:	ba 01 00 00 00       	mov    $0x1,%edx
  80042121c4:	48 89 cf             	mov    %rcx,%rdi
  80042121c7:	ff d0                	callq  *%rax
  80042121c9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042121cd:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042121d1:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042121d8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042121dc:	48 89 ce             	mov    %rcx,%rsi
  80042121df:	48 89 c7             	mov    %rax,%rdi
  80042121e2:	48 b8 ab 18 21 04 80 	movabs $0x80042118ab,%rax
  80042121e9:	00 00 00 
  80042121ec:	ff d0                	callq  *%rax
  80042121ee:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042121f2:	e9 9e 03 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042121f7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042121fe:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212202:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212209:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421220d:	ba 02 00 00 00       	mov    $0x2,%edx
  8004212212:	48 89 cf             	mov    %rcx,%rdi
  8004212215:	ff d0                	callq  *%rax
  8004212217:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421221b:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421221f:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212226:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421222a:	48 89 ce             	mov    %rcx,%rsi
  800421222d:	48 89 c7             	mov    %rax,%rdi
  8004212230:	48 b8 ab 18 21 04 80 	movabs $0x80042118ab,%rax
  8004212237:	00 00 00 
  800421223a:	ff d0                	callq  *%rax
  800421223c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004212240:	e9 50 03 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004212245:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421224c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212250:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212257:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421225b:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212260:	48 89 cf             	mov    %rcx,%rdi
  8004212263:	ff d0                	callq  *%rax
  8004212265:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004212269:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421226d:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212274:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212278:	48 89 ce             	mov    %rcx,%rsi
  800421227b:	48 89 c7             	mov    %rax,%rdi
  800421227e:	48 b8 ab 18 21 04 80 	movabs $0x80042118ab,%rax
  8004212285:	00 00 00 
  8004212288:	ff d0                	callq  *%rax
  800421228a:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421228e:	e9 02 03 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004212293:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421229a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421229e:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042122a5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042122a9:	ba 01 00 00 00       	mov    $0x1,%edx
  80042122ae:	48 89 cf             	mov    %rcx,%rdi
  80042122b1:	ff d0                	callq  *%rax
  80042122b3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042122b7:	e9 d9 02 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042122bc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042122c3:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042122c7:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042122ce:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042122d2:	ba 02 00 00 00       	mov    $0x2,%edx
  80042122d7:	48 89 cf             	mov    %rcx,%rdi
  80042122da:	ff d0                	callq  *%rax
  80042122dc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042122e0:	e9 b0 02 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  80042122e5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042122ec:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042122f0:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042122f7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042122fb:	ba 04 00 00 00       	mov    $0x4,%edx
  8004212300:	48 89 cf             	mov    %rcx,%rdi
  8004212303:	ff d0                	callq  *%rax
  8004212305:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212309:	e9 87 02 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  800421230e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212315:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212319:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212320:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212324:	ba 08 00 00 00       	mov    $0x8,%edx
  8004212329:	48 89 cf             	mov    %rcx,%rdi
  800421232c:	ff d0                	callq  *%rax
  800421232e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212332:	e9 5e 02 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004212337:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421233e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212342:	48 89 d6             	mov    %rdx,%rsi
  8004212345:	48 89 c7             	mov    %rax,%rdi
  8004212348:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  800421234f:	00 00 00 
  8004212352:	ff d0                	callq  *%rax
  8004212354:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  800421235b:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  8004212362:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  8004212369:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004212370:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004212377:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421237e:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212385:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  800421238c:	4d 89 c1             	mov    %r8,%r9
  800421238f:	49 89 f8             	mov    %rdi,%r8
  8004212392:	48 89 c7             	mov    %rax,%rdi
  8004212395:	48 b8 34 20 21 04 80 	movabs $0x8004212034,%rax
  800421239c:	00 00 00 
  800421239f:	ff d0                	callq  *%rax
  80042123a1:	e9 1d 03 00 00       	jmpq   80042126c3 <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  80042123a6:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042123ad:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042123b1:	66 83 f8 02          	cmp    $0x2,%ax
  80042123b5:	75 2f                	jne    80042123e6 <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042123b7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042123be:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042123c2:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042123c9:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042123cd:	0f b6 d2             	movzbl %dl,%edx
  80042123d0:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042123d7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042123db:	48 89 cf             	mov    %rcx,%rdi
  80042123de:	ff d0                	callq  *%rax
  80042123e0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042123e4:	eb 39                	jmp    800421241f <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  80042123e6:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042123ed:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042123f1:	66 83 f8 03          	cmp    $0x3,%ax
  80042123f5:	75 28                	jne    800421241f <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042123f7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042123fe:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212402:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004212406:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421240d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212411:	48 89 cf             	mov    %rcx,%rdi
  8004212414:	ff d0                	callq  *%rax
  8004212416:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421241a:	e9 76 01 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
  800421241f:	e9 71 01 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004212424:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421242b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421242f:	48 89 d6             	mov    %rdx,%rsi
  8004212432:	48 89 c7             	mov    %rax,%rdi
  8004212435:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  800421243c:	00 00 00 
  800421243f:	ff d0                	callq  *%rax
  8004212441:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212445:	e9 4b 01 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800421244a:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004212451:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212455:	48 89 d6             	mov    %rdx,%rsi
  8004212458:	48 89 c7             	mov    %rax,%rdi
  800421245b:	48 b8 fa 15 21 04 80 	movabs $0x80042115fa,%rax
  8004212462:	00 00 00 
  8004212465:	ff d0                	callq  *%rax
  8004212467:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421246b:	e9 25 01 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004212470:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004212477:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421247b:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  800421247f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004212486:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421248a:	48 89 cf             	mov    %rcx,%rdi
  800421248d:	ff d0                	callq  *%rax
  800421248f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004212493:	e9 fd 00 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  8004212498:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421249c:	48 8b 48 18          	mov    0x18(%rax),%rcx
  80042124a0:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042124a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042124ab:	48 89 ce             	mov    %rcx,%rsi
  80042124ae:	48 89 c7             	mov    %rax,%rdi
  80042124b1:	48 b8 1c 18 21 04 80 	movabs $0x800421181c,%rax
  80042124b8:	00 00 00 
  80042124bb:	ff d0                	callq  *%rax
  80042124bd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042124c1:	e9 cf 00 00 00       	jmpq   8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042124c6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042124cd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042124d1:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042124d5:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042124dc:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042124e0:	48 89 cf             	mov    %rcx,%rdi
  80042124e3:	ff d0                	callq  *%rax
  80042124e5:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  80042124e9:	48 bf 32 f6 21 04 80 	movabs $0x800421f632,%rdi
  80042124f0:	00 00 00 
  80042124f3:	48 b8 72 62 21 04 80 	movabs $0x8004216272,%rax
  80042124fa:	00 00 00 
  80042124fd:	ff d0                	callq  *%rax
  80042124ff:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  8004212503:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212508:	75 35                	jne    800421253f <_dwarf_attr_init+0x50b>
  800421250a:	48 b9 3d f6 21 04 80 	movabs $0x800421f63d,%rcx
  8004212511:	00 00 00 
  8004212514:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  800421251b:	00 00 00 
  800421251e:	be 51 02 00 00       	mov    $0x251,%esi
  8004212523:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  800421252a:	00 00 00 
  800421252d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212532:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212539:	00 00 00 
  800421253c:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  800421253f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212543:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212547:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421254b:	48 01 d0             	add    %rdx,%rax
  800421254e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004212552:	eb 41                	jmp    8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004212554:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800421255b:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  800421255c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004212560:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004212567:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421256b:	48 89 ce             	mov    %rcx,%rsi
  800421256e:	48 89 c7             	mov    %rax,%rdi
  8004212571:	48 b8 ab 18 21 04 80 	movabs $0x80042118ab,%rax
  8004212578:	00 00 00 
  800421257b:	ff d0                	callq  *%rax
  800421257d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004212581:	eb 12                	jmp    8004212595 <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  8004212583:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  800421258a:	00 
		break;
  800421258b:	eb 08                	jmp    8004212595 <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  800421258d:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004212594:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  8004212595:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212599:	0f 85 21 01 00 00    	jne    80042126c0 <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  800421259f:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  80042125a6:	09 
  80042125a7:	74 1e                	je     80042125c7 <_dwarf_attr_init+0x593>
  80042125a9:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  80042125b0:	0a 
  80042125b1:	74 14                	je     80042125c7 <_dwarf_attr_init+0x593>
  80042125b3:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  80042125ba:	03 
  80042125bb:	74 0a                	je     80042125c7 <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  80042125bd:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  80042125c4:	04 
  80042125c5:	75 10                	jne    80042125d7 <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  80042125c7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042125cb:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  80042125cf:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042125d3:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  80042125d7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042125db:	48 83 f8 03          	cmp    $0x3,%rax
  80042125df:	75 39                	jne    800421261a <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  80042125e1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042125e5:	48 83 f8 08          	cmp    $0x8,%rax
  80042125e9:	74 1c                	je     8004212607 <_dwarf_attr_init+0x5d3>
  80042125eb:	48 83 f8 0e          	cmp    $0xe,%rax
  80042125ef:	74 02                	je     80042125f3 <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  80042125f1:	eb 27                	jmp    800421261a <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  80042125f3:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042125f7:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042125fe:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004212605:	eb 13                	jmp    800421261a <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  8004212607:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421260b:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004212612:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  8004212619:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  800421261a:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004212621:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004212628:	8d 48 01             	lea    0x1(%rax),%ecx
  800421262b:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004212632:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004212638:	0f b6 c0             	movzbl %al,%eax
  800421263b:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004212642:	48 63 d0             	movslq %eax,%rdx
  8004212645:	48 89 d0             	mov    %rdx,%rax
  8004212648:	48 01 c0             	add    %rax,%rax
  800421264b:	48 01 d0             	add    %rdx,%rax
  800421264e:	48 c1 e0 05          	shl    $0x5,%rax
  8004212652:	48 01 c8             	add    %rcx,%rax
  8004212655:	48 05 70 03 00 00    	add    $0x370,%rax
  800421265b:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212662:	48 89 10             	mov    %rdx,(%rax)
  8004212665:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800421266c:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004212670:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004212674:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004212678:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800421267c:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004212680:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004212684:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004212688:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421268c:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004212690:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212694:	48 89 50 30          	mov    %rdx,0x30(%rax)
  8004212698:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800421269c:	48 89 50 38          	mov    %rdx,0x38(%rax)
  80042126a0:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042126a4:	48 89 50 40          	mov    %rdx,0x40(%rax)
  80042126a8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  80042126ac:	48 89 50 48          	mov    %rdx,0x48(%rax)
  80042126b0:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042126b4:	48 89 50 50          	mov    %rdx,0x50(%rax)
  80042126b8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042126bc:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  80042126c0:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042126c3:	c9                   	leaveq 
  80042126c4:	c3                   	retq   

00000080042126c5 <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  80042126c5:	55                   	push   %rbp
  80042126c6:	48 89 e5             	mov    %rsp,%rbp
  80042126c9:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  80042126d0:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  80042126d7:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  80042126de:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  80042126e5:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  80042126eb:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  80042126f2:	00 
  80042126f3:	75 35                	jne    800421272a <dwarf_search_die_within_cu+0x65>
  80042126f5:	48 b9 58 f7 21 04 80 	movabs $0x800421f758,%rcx
  80042126fc:	00 00 00 
  80042126ff:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212706:	00 00 00 
  8004212709:	be 86 02 00 00       	mov    $0x286,%esi
  800421270e:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212715:	00 00 00 
  8004212718:	b8 00 00 00 00       	mov    $0x0,%eax
  800421271d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212724:	00 00 00 
  8004212727:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  800421272a:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004212731:	00 
  8004212732:	75 35                	jne    8004212769 <dwarf_search_die_within_cu+0xa4>
  8004212734:	48 b9 5c f7 21 04 80 	movabs $0x800421f75c,%rcx
  800421273b:	00 00 00 
  800421273e:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212745:	00 00 00 
  8004212748:	be 88 02 00 00       	mov    $0x288,%esi
  800421274d:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212754:	00 00 00 
  8004212757:	b8 00 00 00 00       	mov    $0x0,%eax
  800421275c:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212763:	00 00 00 
  8004212766:	41 ff d0             	callq  *%r8

	level = 1;
  8004212769:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004212770:	e9 17 02 00 00       	jmpq   800421298c <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  8004212775:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800421277c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004212780:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212787:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421278b:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  8004212792:	48 89 d6             	mov    %rdx,%rsi
  8004212795:	48 89 c7             	mov    %rax,%rdi
  8004212798:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  800421279f:	00 00 00 
  80042127a2:	ff d0                	callq  *%rax
  80042127a4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  80042127a8:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042127ad:	75 22                	jne    80042127d1 <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  80042127af:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042127b3:	74 09                	je     80042127be <dwarf_search_die_within_cu+0xf9>
  80042127b5:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  80042127bc:	75 0a                	jne    80042127c8 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  80042127be:	b8 04 00 00 00       	mov    $0x4,%eax
  80042127c3:	e9 f4 01 00 00       	jmpq   80042129bc <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  80042127c8:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  80042127cc:	e9 bb 01 00 00       	jmpq   800421298c <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  80042127d1:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042127d8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042127dc:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042127e3:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  80042127e7:	48 89 34 24          	mov    %rsi,(%rsp)
  80042127eb:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  80042127ef:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  80042127f4:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  80042127f8:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  80042127fd:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  8004212801:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  8004212806:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  800421280a:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  800421280f:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  8004212813:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  8004212818:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  800421281c:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  8004212821:	48 89 ce             	mov    %rcx,%rsi
  8004212824:	48 89 c7             	mov    %rax,%rdi
  8004212827:	48 b8 03 1f 21 04 80 	movabs $0x8004211f03,%rax
  800421282e:	00 00 00 
  8004212831:	ff d0                	callq  *%rax
  8004212833:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004212836:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421283a:	74 08                	je     8004212844 <dwarf_search_die_within_cu+0x17f>
			return (ret);
  800421283c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421283f:	e9 78 01 00 00       	jmpq   80042129bc <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  8004212844:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421284b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421284f:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  8004212852:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212859:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421285d:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  8004212861:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212868:	48 8d 78 20          	lea    0x20(%rax),%rdi
  800421286c:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004212873:	b8 66 00 00 00       	mov    $0x66,%eax
  8004212878:	48 89 d6             	mov    %rdx,%rsi
  800421287b:	48 89 c1             	mov    %rax,%rcx
  800421287e:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  8004212881:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004212888:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  800421288f:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  8004212896:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421289d:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  80042128a1:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  80042128a8:	e9 8e 00 00 00       	jmpq   800421293b <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  80042128ad:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042128b0:	48 63 d0             	movslq %eax,%rdx
  80042128b3:	48 89 d0             	mov    %rdx,%rax
  80042128b6:	48 01 c0             	add    %rax,%rax
  80042128b9:	48 01 d0             	add    %rdx,%rax
  80042128bc:	48 c1 e0 03          	shl    $0x3,%rax
  80042128c0:	48 01 e8             	add    %rbp,%rax
  80042128c3:	48 2d 18 03 00 00    	sub    $0x318,%rax
  80042128c9:	48 8b 08             	mov    (%rax),%rcx
  80042128cc:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  80042128d3:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042128d6:	48 63 d0             	movslq %eax,%rdx
  80042128d9:	48 89 d0             	mov    %rdx,%rax
  80042128dc:	48 01 c0             	add    %rax,%rax
  80042128df:	48 01 d0             	add    %rdx,%rax
  80042128e2:	48 c1 e0 03          	shl    $0x3,%rax
  80042128e6:	48 83 c0 30          	add    $0x30,%rax
  80042128ea:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  80042128ee:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  80042128f5:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  80042128fc:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004212903:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  800421290a:	49 89 c9             	mov    %rcx,%r9
  800421290d:	49 89 f8             	mov    %rdi,%r8
  8004212910:	48 89 d1             	mov    %rdx,%rcx
  8004212913:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004212917:	48 89 c7             	mov    %rax,%rdi
  800421291a:	48 b8 34 20 21 04 80 	movabs $0x8004212034,%rax
  8004212921:	00 00 00 
  8004212924:	ff d0                	callq  *%rax
  8004212926:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004212929:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421292d:	74 08                	je     8004212937 <dwarf_search_die_within_cu+0x272>
				return (ret);
  800421292f:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004212932:	e9 85 00 00 00       	jmpq   80042129bc <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004212937:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800421293b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421293e:	48 63 d0             	movslq %eax,%rdx
  8004212941:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004212948:	48 39 c2             	cmp    %rax,%rdx
  800421294b:	0f 82 5c ff ff ff    	jb     80042128ad <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  8004212951:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004212958:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421295f:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  8004212963:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800421296a:	74 19                	je     8004212985 <dwarf_search_die_within_cu+0x2c0>
  800421296c:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212970:	7e 13                	jle    8004212985 <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004212972:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  8004212979:	3c 01                	cmp    $0x1,%al
  800421297b:	75 06                	jne    8004212983 <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  800421297d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004212981:	eb 09                	jmp    800421298c <dwarf_search_die_within_cu+0x2c7>
  8004212983:	eb 07                	jmp    800421298c <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  8004212985:	b8 00 00 00 00       	mov    $0x0,%eax
  800421298a:	eb 30                	jmp    80042129bc <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800421298c:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004212990:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004212997:	48 39 c2             	cmp    %rax,%rdx
  800421299a:	76 1b                	jbe    80042129b7 <dwarf_search_die_within_cu+0x2f2>
  800421299c:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042129a3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042129a7:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  80042129ae:	48 39 c2             	cmp    %rax,%rdx
  80042129b1:	0f 87 be fd ff ff    	ja     8004212775 <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  80042129b7:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042129bc:	c9                   	leaveq 
  80042129bd:	c3                   	retq   

00000080042129be <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  80042129be:	55                   	push   %rbp
  80042129bf:	48 89 e5             	mov    %rsp,%rbp
  80042129c2:	48 83 ec 60          	sub    $0x60,%rsp
  80042129c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042129ca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042129ce:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  80042129d2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042129d7:	75 35                	jne    8004212a0e <dwarf_offdie+0x50>
  80042129d9:	48 b9 58 f7 21 04 80 	movabs $0x800421f758,%rcx
  80042129e0:	00 00 00 
  80042129e3:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  80042129ea:	00 00 00 
  80042129ed:	be c4 02 00 00       	mov    $0x2c4,%esi
  80042129f2:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  80042129f9:	00 00 00 
  80042129fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212a01:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212a08:	00 00 00 
  8004212a0b:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004212a0e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212a13:	75 35                	jne    8004212a4a <dwarf_offdie+0x8c>
  8004212a15:	48 b9 5c f7 21 04 80 	movabs $0x800421f75c,%rcx
  8004212a1c:	00 00 00 
  8004212a1f:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212a26:	00 00 00 
  8004212a29:	be c5 02 00 00       	mov    $0x2c5,%esi
  8004212a2e:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212a35:	00 00 00 
  8004212a38:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212a3d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212a44:	00 00 00 
  8004212a47:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  8004212a4a:	48 8b 45 30          	mov    0x30(%rbp),%rax
  8004212a4e:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212a52:	76 66                	jbe    8004212aba <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004212a54:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004212a58:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004212a5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212a60:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  8004212a64:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004212a68:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  8004212a6c:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004212a71:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  8004212a75:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004212a7a:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004212a7e:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004212a83:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  8004212a87:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004212a8c:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  8004212a90:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004212a95:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  8004212a99:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  8004212a9e:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004212aa3:	48 89 c7             	mov    %rax,%rdi
  8004212aa6:	48 b8 c5 26 21 04 80 	movabs $0x80042126c5,%rax
  8004212aad:	00 00 00 
  8004212ab0:	ff d0                	callq  *%rax
  8004212ab2:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  8004212ab5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004212ab8:	eb 05                	jmp    8004212abf <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  8004212aba:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212abf:	c9                   	leaveq 
  8004212ac0:	c3                   	retq   

0000008004212ac1 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  8004212ac1:	55                   	push   %rbp
  8004212ac2:	48 89 e5             	mov    %rsp,%rbp
  8004212ac5:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004212ac9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212acd:	89 f0                	mov    %esi,%eax
  8004212acf:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  8004212ad3:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004212ada:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004212adb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004212ae2:	eb 57                	jmp    8004212b3b <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  8004212ae4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004212ae8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212aeb:	48 63 d0             	movslq %eax,%rdx
  8004212aee:	48 89 d0             	mov    %rdx,%rax
  8004212af1:	48 01 c0             	add    %rax,%rax
  8004212af4:	48 01 d0             	add    %rdx,%rax
  8004212af7:	48 c1 e0 05          	shl    $0x5,%rax
  8004212afb:	48 01 c8             	add    %rcx,%rax
  8004212afe:	48 05 80 03 00 00    	add    $0x380,%rax
  8004212b04:	48 8b 10             	mov    (%rax),%rdx
  8004212b07:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  8004212b0b:	48 39 c2             	cmp    %rax,%rdx
  8004212b0e:	75 27                	jne    8004212b37 <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  8004212b10:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004212b13:	48 63 d0             	movslq %eax,%rdx
  8004212b16:	48 89 d0             	mov    %rdx,%rax
  8004212b19:	48 01 c0             	add    %rax,%rax
  8004212b1c:	48 01 d0             	add    %rdx,%rax
  8004212b1f:	48 c1 e0 05          	shl    $0x5,%rax
  8004212b23:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004212b2a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b2e:	48 01 d0             	add    %rdx,%rax
  8004212b31:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004212b35:	eb 17                	jmp    8004212b4e <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004212b37:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004212b3b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212b3f:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004212b46:	0f b6 c0             	movzbl %al,%eax
  8004212b49:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004212b4c:	7f 96                	jg     8004212ae4 <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004212b4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004212b52:	c9                   	leaveq 
  8004212b53:	c3                   	retq   

0000008004212b54 <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  8004212b54:	55                   	push   %rbp
  8004212b55:	48 89 e5             	mov    %rsp,%rbp
  8004212b58:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004212b5c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004212b60:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004212b64:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004212b68:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004212b6c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212b71:	75 35                	jne    8004212ba8 <dwarf_siblingof+0x54>
  8004212b73:	48 b9 58 f7 21 04 80 	movabs $0x800421f758,%rcx
  8004212b7a:	00 00 00 
  8004212b7d:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212b84:	00 00 00 
  8004212b87:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004212b8c:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212b93:	00 00 00 
  8004212b96:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212b9b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212ba2:	00 00 00 
  8004212ba5:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004212ba8:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212bad:	75 35                	jne    8004212be4 <dwarf_siblingof+0x90>
  8004212baf:	48 b9 5c f7 21 04 80 	movabs $0x800421f75c,%rcx
  8004212bb6:	00 00 00 
  8004212bb9:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212bc0:	00 00 00 
  8004212bc3:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004212bc8:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212bcf:	00 00 00 
  8004212bd2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212bd7:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212bde:	00 00 00 
  8004212be1:	41 ff d0             	callq  *%r8
	assert(cu);
  8004212be4:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004212be9:	75 35                	jne    8004212c20 <dwarf_siblingof+0xcc>
  8004212beb:	48 b9 64 f7 21 04 80 	movabs $0x800421f764,%rcx
  8004212bf2:	00 00 00 
  8004212bf5:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212bfc:	00 00 00 
  8004212bff:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004212c04:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212c0b:	00 00 00 
  8004212c0e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212c13:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212c1a:	00 00 00 
  8004212c1d:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004212c20:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212c25:	75 65                	jne    8004212c8c <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004212c27:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212c2b:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004212c2f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212c33:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004212c37:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212c3b:	48 8b 38             	mov    (%rax),%rdi
  8004212c3e:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004212c42:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004212c46:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004212c4b:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004212c4f:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004212c54:	48 8b 78 18          	mov    0x18(%rax),%rdi
  8004212c58:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004212c5d:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004212c61:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004212c66:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004212c6a:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004212c6f:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212c73:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004212c78:	48 89 cf             	mov    %rcx,%rdi
  8004212c7b:	48 b8 be 29 21 04 80 	movabs $0x80042129be,%rax
  8004212c82:	00 00 00 
  8004212c85:	ff d0                	callq  *%rax
  8004212c87:	e9 0a 01 00 00       	jmpq   8004212d96 <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004212c8c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004212c93:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212c97:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004212c9b:	84 c0                	test   %al,%al
  8004212c9d:	75 0e                	jne    8004212cad <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  8004212c9f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212ca3:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212ca7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212cab:	eb 6b                	jmp    8004212d18 <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004212cad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212cb1:	be 01 00 00 00       	mov    $0x1,%esi
  8004212cb6:	48 89 c7             	mov    %rax,%rdi
  8004212cb9:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  8004212cc0:	00 00 00 
  8004212cc3:	ff d0                	callq  *%rax
  8004212cc5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004212cc9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212cce:	74 35                	je     8004212d05 <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  8004212cd0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cd4:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004212cd8:	48 83 f8 10          	cmp    $0x10,%rax
  8004212cdc:	74 19                	je     8004212cf7 <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  8004212cde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212ce2:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004212ce6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212cea:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212cee:	48 01 d0             	add    %rdx,%rax
  8004212cf1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212cf5:	eb 21                	jmp    8004212d18 <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  8004212cf7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212cfb:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004212cff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004212d03:	eb 13                	jmp    8004212d18 <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  8004212d05:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212d09:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212d0d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004212d11:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004212d18:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004212d1b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212d1f:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004212d23:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004212d27:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212d2b:	4c 8b 00             	mov    (%rax),%r8
  8004212d2e:	4c 89 04 24          	mov    %r8,(%rsp)
  8004212d32:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004212d36:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004212d3b:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004212d3f:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004212d44:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004212d48:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004212d4d:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004212d51:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004212d56:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004212d5a:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004212d5f:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212d63:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004212d68:	48 b8 c5 26 21 04 80 	movabs $0x80042126c5,%rax
  8004212d6f:	00 00 00 
  8004212d72:	ff d0                	callq  *%rax
  8004212d74:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  8004212d77:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004212d7b:	75 07                	jne    8004212d84 <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  8004212d7d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212d82:	eb 12                	jmp    8004212d96 <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  8004212d84:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004212d88:	74 07                	je     8004212d91 <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  8004212d8a:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212d8f:	eb 05                	jmp    8004212d96 <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  8004212d91:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212d96:	c9                   	leaveq 
  8004212d97:	c3                   	retq   

0000008004212d98 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004212d98:	55                   	push   %rbp
  8004212d99:	48 89 e5             	mov    %rsp,%rbp
  8004212d9c:	48 83 ec 70          	sub    $0x70,%rsp
  8004212da0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212da4:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004212da8:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004212dac:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004212db0:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004212db5:	75 35                	jne    8004212dec <dwarf_child+0x54>
  8004212db7:	48 b9 67 f7 21 04 80 	movabs $0x800421f767,%rcx
  8004212dbe:	00 00 00 
  8004212dc1:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212dc8:	00 00 00 
  8004212dcb:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004212dd0:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212dd7:	00 00 00 
  8004212dda:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212ddf:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212de6:	00 00 00 
  8004212de9:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004212dec:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004212df1:	75 35                	jne    8004212e28 <dwarf_child+0x90>
  8004212df3:	48 b9 5c f7 21 04 80 	movabs $0x800421f75c,%rcx
  8004212dfa:	00 00 00 
  8004212dfd:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212e04:	00 00 00 
  8004212e07:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004212e0c:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212e13:	00 00 00 
  8004212e16:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212e1b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212e22:	00 00 00 
  8004212e25:	41 ff d0             	callq  *%r8
	assert(dbg);
  8004212e28:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004212e2d:	75 35                	jne    8004212e64 <dwarf_child+0xcc>
  8004212e2f:	48 b9 58 f7 21 04 80 	movabs $0x800421f758,%rcx
  8004212e36:	00 00 00 
  8004212e39:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212e40:	00 00 00 
  8004212e43:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004212e48:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212e4f:	00 00 00 
  8004212e52:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212e57:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212e5e:	00 00 00 
  8004212e61:	41 ff d0             	callq  *%r8
	assert(cu);
  8004212e64:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004212e69:	75 35                	jne    8004212ea0 <dwarf_child+0x108>
  8004212e6b:	48 b9 64 f7 21 04 80 	movabs $0x800421f764,%rcx
  8004212e72:	00 00 00 
  8004212e75:	48 ba ca f5 21 04 80 	movabs $0x800421f5ca,%rdx
  8004212e7c:	00 00 00 
  8004212e7f:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004212e84:	48 bf df f5 21 04 80 	movabs $0x800421f5df,%rdi
  8004212e8b:	00 00 00 
  8004212e8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212e93:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004212e9a:	00 00 00 
  8004212e9d:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004212ea0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212ea4:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004212ea8:	84 c0                	test   %al,%al
  8004212eaa:	75 0a                	jne    8004212eb6 <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  8004212eac:	b8 04 00 00 00       	mov    $0x4,%eax
  8004212eb1:	e9 84 00 00 00       	jmpq   8004212f3a <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004212eb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212eba:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004212ebe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ec2:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004212ec6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004212eca:	48 8b 08             	mov    (%rax),%rcx
  8004212ecd:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004212ed1:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004212ed5:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004212eda:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004212ede:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004212ee3:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004212ee7:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004212eec:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ef0:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004212ef5:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8004212ef9:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004212efe:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004212f02:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004212f07:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004212f0c:	48 b8 c5 26 21 04 80 	movabs $0x80042126c5,%rax
  8004212f13:	00 00 00 
  8004212f16:	ff d0                	callq  *%rax
  8004212f18:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  8004212f1b:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004212f1f:	75 07                	jne    8004212f28 <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004212f21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004212f26:	eb 12                	jmp    8004212f3a <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  8004212f28:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004212f2c:	74 07                	je     8004212f35 <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  8004212f2e:	b8 01 00 00 00       	mov    $0x1,%eax
  8004212f33:	eb 05                	jmp    8004212f3a <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  8004212f35:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212f3a:	c9                   	leaveq 
  8004212f3b:	c3                   	retq   

0000008004212f3c <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004212f3c:	55                   	push   %rbp
  8004212f3d:	48 89 e5             	mov    %rsp,%rbp
  8004212f40:	48 83 ec 20          	sub    $0x20,%rsp
  8004212f44:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004212f48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f4c:	48 8b 00             	mov    (%rax),%rax
  8004212f4f:	48 89 c7             	mov    %rax,%rdi
  8004212f52:	48 b8 72 62 21 04 80 	movabs $0x8004216272,%rax
  8004212f59:	00 00 00 
  8004212f5c:	ff d0                	callq  *%rax
  8004212f5e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004212f62:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212f66:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004212f6a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f6e:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  8004212f72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212f76:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004212f7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f7e:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  8004212f82:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212f86:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004212f8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004212f8e:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  8004212f92:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004212f97:	c9                   	leaveq 
  8004212f98:	c3                   	retq   

0000008004212f99 <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004212f99:	55                   	push   %rbp
  8004212f9a:	48 89 e5             	mov    %rsp,%rbp
  8004212f9d:	48 83 ec 08          	sub    $0x8,%rsp
  8004212fa1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        /* Initialise call frame related parameters. */
        dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004212fa5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212fa9:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
        dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004212faf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212fb3:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
        dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004212fb9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212fbd:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
        dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004212fc3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212fc7:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
        dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004212fcd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004212fd1:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004212fd7:	c9                   	leaveq 
  8004212fd8:	c3                   	retq   

0000008004212fd9 <dwarf_get_fde_at_pc>:


int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    Dwarf_Addr *lopc, Dwarf_Addr *hipc, struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004212fd9:	55                   	push   %rbp
  8004212fda:	48 89 e5             	mov    %rsp,%rbp
  8004212fdd:	48 83 ec 40          	sub    $0x40,%rsp
  8004212fe1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004212fe5:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004212fe9:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004212fed:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004212ff1:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  8004212ff5:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	Dwarf_Fde fde = ret_fde;
  8004212ff9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ffd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004213001:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213005:	ba 80 00 00 00       	mov    $0x80,%edx
  800421300a:	be 00 00 00 00       	mov    $0x0,%esi
  800421300f:	48 89 c7             	mov    %rax,%rdi
  8004213012:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004213019:	00 00 00 
  800421301c:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  800421301e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213022:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213026:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) 
  800421302a:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421302f:	74 0e                	je     800421303f <dwarf_get_fde_at_pc+0x66>
  8004213031:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004213036:	74 07                	je     800421303f <dwarf_get_fde_at_pc+0x66>
  8004213038:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421303d:	75 07                	jne    8004213046 <dwarf_get_fde_at_pc+0x6d>
                return (DW_DLV_ERROR);
  800421303f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004213044:	eb 78                	jmp    80042130be <dwarf_get_fde_at_pc+0xe5>

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  8004213046:	eb 5c                	jmp    80042130a4 <dwarf_get_fde_at_pc+0xcb>
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  8004213048:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421304c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213050:	48 89 d1             	mov    %rdx,%rcx
  8004213053:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213057:	be 01 00 00 00       	mov    $0x1,%esi
  800421305c:	48 89 c7             	mov    %rax,%rdi
  800421305f:	48 b8 fd 51 21 04 80 	movabs $0x80042151fd,%rax
  8004213066:	00 00 00 
  8004213069:	ff d0                	callq  *%rax
  800421306b:	85 c0                	test   %eax,%eax
  800421306d:	79 07                	jns    8004213076 <dwarf_get_fde_at_pc+0x9d>
		{
			return DW_DLV_NO_ENTRY;
  800421306f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213074:	eb 48                	jmp    80042130be <dwarf_get_fde_at_pc+0xe5>
		}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004213076:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421307a:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421307e:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004213082:	77 20                	ja     80042130a4 <dwarf_get_fde_at_pc+0xcb>
  8004213084:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213088:	48 8b 50 30          	mov    0x30(%rax),%rdx
                    fde->fde_adrange)
  800421308c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213090:	48 8b 40 38          	mov    0x38(%rax),%rax
        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004213094:	48 01 d0             	add    %rdx,%rax
  8004213097:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421309b:	76 07                	jbe    80042130a4 <dwarf_get_fde_at_pc+0xcb>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
  800421309d:	b8 00 00 00 00       	mov    $0x0,%eax
  80042130a2:	eb 1a                	jmp    80042130be <dwarf_get_fde_at_pc+0xe5>
	fde->fde_cie = cie;
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) 
                return (DW_DLV_ERROR);

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  80042130a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130a8:	48 8b 50 38          	mov    0x38(%rax),%rdx
  80042130ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130b0:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042130b4:	48 39 c2             	cmp    %rax,%rdx
  80042130b7:	72 8f                	jb     8004213048 <dwarf_get_fde_at_pc+0x6f>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
        }

        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  80042130b9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80042130be:	c9                   	leaveq 
  80042130bf:	c3                   	retq   

00000080042130c0 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  80042130c0:	55                   	push   %rbp
  80042130c1:	48 89 e5             	mov    %rsp,%rbp
  80042130c4:	53                   	push   %rbx
  80042130c5:	48 83 ec 38          	sub    $0x38,%rsp
  80042130c9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042130cd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042130d1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042130d5:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
        int i;

        assert(dest != NULL);
  80042130d9:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042130de:	75 35                	jne    8004213115 <_dwarf_frame_regtable_copy+0x55>
  80042130e0:	48 b9 7a f7 21 04 80 	movabs $0x800421f77a,%rcx
  80042130e7:	00 00 00 
  80042130ea:	48 ba 87 f7 21 04 80 	movabs $0x800421f787,%rdx
  80042130f1:	00 00 00 
  80042130f4:	be 57 00 00 00       	mov    $0x57,%esi
  80042130f9:	48 bf 9c f7 21 04 80 	movabs $0x800421f79c,%rdi
  8004213100:	00 00 00 
  8004213103:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213108:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421310f:	00 00 00 
  8004213112:	41 ff d0             	callq  *%r8
        assert(src != NULL);
  8004213115:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421311a:	75 35                	jne    8004213151 <_dwarf_frame_regtable_copy+0x91>
  800421311c:	48 b9 b2 f7 21 04 80 	movabs $0x800421f7b2,%rcx
  8004213123:	00 00 00 
  8004213126:	48 ba 87 f7 21 04 80 	movabs $0x800421f787,%rdx
  800421312d:	00 00 00 
  8004213130:	be 58 00 00 00       	mov    $0x58,%esi
  8004213135:	48 bf 9c f7 21 04 80 	movabs $0x800421f79c,%rdi
  800421313c:	00 00 00 
  800421313f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213144:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421314b:	00 00 00 
  800421314e:	41 ff d0             	callq  *%r8

        if (*dest == NULL) {
  8004213151:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213155:	48 8b 00             	mov    (%rax),%rax
  8004213158:	48 85 c0             	test   %rax,%rax
  800421315b:	75 39                	jne    8004213196 <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  800421315d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213161:	48 bb 00 e7 3a 04 80 	movabs $0x80043ae700,%rbx
  8004213168:	00 00 00 
  800421316b:	48 89 18             	mov    %rbx,(%rax)
                (*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  800421316e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213172:	48 8b 00             	mov    (%rax),%rax
  8004213175:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213179:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  800421317d:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  8004213181:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213185:	48 8b 00             	mov    (%rax),%rax
  8004213188:	48 bb a0 e9 3a 04 80 	movabs $0x80043ae9a0,%rbx
  800421318f:	00 00 00 
  8004213192:	48 89 58 20          	mov    %rbx,0x20(%rax)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  8004213196:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421319a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421319e:	48 8b 00             	mov    (%rax),%rax
  80042131a1:	ba 18 00 00 00       	mov    $0x18,%edx
  80042131a6:	48 89 ce             	mov    %rcx,%rsi
  80042131a9:	48 89 c7             	mov    %rax,%rdi
  80042131ac:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  80042131b3:	00 00 00 
  80042131b6:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042131b8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042131bf:	eb 5a                	jmp    800421321b <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  80042131c1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042131c5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042131c9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042131cc:	48 63 d0             	movslq %eax,%rdx
  80042131cf:	48 89 d0             	mov    %rdx,%rax
  80042131d2:	48 01 c0             	add    %rax,%rax
  80042131d5:	48 01 d0             	add    %rdx,%rax
  80042131d8:	48 c1 e0 03          	shl    $0x3,%rax
  80042131dc:	48 01 c1             	add    %rax,%rcx
  80042131df:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042131e3:	48 8b 00             	mov    (%rax),%rax
  80042131e6:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042131ea:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042131ed:	48 63 d0             	movslq %eax,%rdx
  80042131f0:	48 89 d0             	mov    %rdx,%rax
  80042131f3:	48 01 c0             	add    %rax,%rax
  80042131f6:	48 01 d0             	add    %rdx,%rax
  80042131f9:	48 c1 e0 03          	shl    $0x3,%rax
  80042131fd:	48 01 f0             	add    %rsi,%rax
  8004213200:	ba 18 00 00 00       	mov    $0x18,%edx
  8004213205:	48 89 ce             	mov    %rcx,%rsi
  8004213208:	48 89 c7             	mov    %rax,%rdi
  800421320b:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  8004213212:	00 00 00 
  8004213215:	ff d0                	callq  *%rax

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  8004213217:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800421321b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421321f:	48 8b 00             	mov    (%rax),%rax
  8004213222:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213226:	0f b7 c0             	movzwl %ax,%eax
  8004213229:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421322c:	7e 10                	jle    800421323e <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  800421322e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213232:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213236:	0f b7 c0             	movzwl %ax,%eax
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  8004213239:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421323c:	7f 83                	jg     80042131c1 <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  800421323e:	eb 32                	jmp    8004213272 <_dwarf_frame_regtable_copy+0x1b2>
                (*dest)->rt3_rules[i].dw_regnum =
  8004213240:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213244:	48 8b 00             	mov    (%rax),%rax
  8004213247:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421324b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421324e:	48 63 d0             	movslq %eax,%rdx
  8004213251:	48 89 d0             	mov    %rdx,%rax
  8004213254:	48 01 c0             	add    %rax,%rax
  8004213257:	48 01 d0             	add    %rdx,%rax
  800421325a:	48 c1 e0 03          	shl    $0x3,%rax
  800421325e:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  8004213262:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213266:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
                (*dest)->rt3_rules[i].dw_regnum =
  800421326a:	66 89 42 02          	mov    %ax,0x2(%rdx)
        for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  800421326e:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004213272:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213276:	48 8b 00             	mov    (%rax),%rax
  8004213279:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421327d:	0f b7 c0             	movzwl %ax,%eax
  8004213280:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004213283:	7f bb                	jg     8004213240 <_dwarf_frame_regtable_copy+0x180>
                (*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

        return (DW_DLE_NONE);
  8004213285:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421328a:	48 83 c4 38          	add    $0x38,%rsp
  800421328e:	5b                   	pop    %rbx
  800421328f:	5d                   	pop    %rbp
  8004213290:	c3                   	retq   

0000008004213291 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004213291:	55                   	push   %rbp
  8004213292:	48 89 e5             	mov    %rsp,%rbp
  8004213295:	53                   	push   %rbx
  8004213296:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  800421329d:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  80042132a1:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  80042132a5:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  80042132a9:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  80042132ad:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  80042132b4:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
                        ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
                        goto program_done;                              \
                }                                                       \
        } while(0)

        ret = DW_DLE_NONE;
  80042132bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
        init_rt = saved_rt = NULL;
  80042132c2:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80042132c9:	00 
  80042132ca:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042132ce:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        *row_pc = pc;
  80042132d2:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042132d6:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042132da:	48 89 10             	mov    %rdx,(%rax)

        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  80042132dd:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042132e1:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042132e5:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  80042132e9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042132ed:	48 89 c7             	mov    %rax,%rdi
  80042132f0:	48 b8 c0 30 21 04 80 	movabs $0x80042130c0,%rax
  80042132f7:	00 00 00 
  80042132fa:	ff d0                	callq  *%rax
        p = insts;
  80042132fc:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004213300:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        pe = p + len;
  8004213304:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213308:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421330c:	48 01 d0             	add    %rdx,%rax
  800421330f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

        while (p < pe) {
  8004213313:	e9 3a 0d 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                if (*p == DW_CFA_nop) {
  8004213318:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421331c:	0f b6 00             	movzbl (%rax),%eax
  800421331f:	84 c0                	test   %al,%al
  8004213321:	75 11                	jne    8004213334 <_dwarf_frame_run_inst+0xa3>
                        p++;
  8004213323:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213327:	48 83 c0 01          	add    $0x1,%rax
  800421332b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        continue;
  800421332f:	e9 1e 0d 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                }

                high2 = *p & 0xc0;
  8004213334:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213338:	0f b6 00             	movzbl (%rax),%eax
  800421333b:	83 e0 c0             	and    $0xffffffc0,%eax
  800421333e:	88 45 df             	mov    %al,-0x21(%rbp)
                low6 = *p & 0x3f;
  8004213341:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213345:	0f b6 00             	movzbl (%rax),%eax
  8004213348:	83 e0 3f             	and    $0x3f,%eax
  800421334b:	88 45 de             	mov    %al,-0x22(%rbp)
                p++;
  800421334e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213352:	48 83 c0 01          	add    $0x1,%rax
  8004213356:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

                if (high2 > 0) {
  800421335a:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  800421335e:	0f 84 a1 01 00 00    	je     8004213505 <_dwarf_frame_run_inst+0x274>
                        switch (high2) {
  8004213364:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004213368:	3d 80 00 00 00       	cmp    $0x80,%eax
  800421336d:	74 38                	je     80042133a7 <_dwarf_frame_run_inst+0x116>
  800421336f:	3d c0 00 00 00       	cmp    $0xc0,%eax
  8004213374:	0f 84 01 01 00 00    	je     800421347b <_dwarf_frame_run_inst+0x1ea>
  800421337a:	83 f8 40             	cmp    $0x40,%eax
  800421337d:	0f 85 71 01 00 00    	jne    80042134f4 <_dwarf_frame_run_inst+0x263>
                        case DW_CFA_advance_loc:
                                pc += low6 * caf;
  8004213383:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004213387:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421338e:	ff 
  800421338f:	48 01 45 10          	add    %rax,0x10(%rbp)
                                if (pc_req < pc)
  8004213393:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004213397:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421339b:	73 05                	jae    80042133a2 <_dwarf_frame_run_inst+0x111>
                                        goto program_done;
  800421339d:	e9 be 0c 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                                break;
  80042133a2:	e9 59 01 00 00       	jmpq   8004213500 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_offset:
                                *row_pc = pc;
  80042133a7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042133ab:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042133af:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  80042133b2:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042133b6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042133ba:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042133be:	66 39 c2             	cmp    %ax,%dx
  80042133c1:	72 0c                	jb     80042133cf <_dwarf_frame_run_inst+0x13e>
  80042133c3:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042133ca:	e9 91 0c 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                                RL[low6].dw_offset_relevant = 1;
  80042133cf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042133d3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042133d7:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042133db:	48 89 d0             	mov    %rdx,%rax
  80042133de:	48 01 c0             	add    %rax,%rax
  80042133e1:	48 01 d0             	add    %rdx,%rax
  80042133e4:	48 c1 e0 03          	shl    $0x3,%rax
  80042133e8:	48 01 c8             	add    %rcx,%rax
  80042133eb:	c6 00 01             	movb   $0x1,(%rax)
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
  80042133ee:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042133f2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042133f6:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042133fa:	48 89 d0             	mov    %rdx,%rax
  80042133fd:	48 01 c0             	add    %rax,%rax
  8004213400:	48 01 d0             	add    %rdx,%rax
  8004213403:	48 c1 e0 03          	shl    $0x3,%rax
  8004213407:	48 01 c8             	add    %rcx,%rax
  800421340a:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  800421340e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213412:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213416:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421341a:	48 89 d0             	mov    %rdx,%rax
  800421341d:	48 01 c0             	add    %rax,%rax
  8004213420:	48 01 d0             	add    %rdx,%rax
  8004213423:	48 c1 e0 03          	shl    $0x3,%rax
  8004213427:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421342b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421342f:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213433:	66 89 42 02          	mov    %ax,0x2(%rdx)
                                RL[low6].dw_offset_or_block_len =
  8004213437:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421343b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421343f:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004213443:	48 89 d0             	mov    %rdx,%rax
  8004213446:	48 01 c0             	add    %rax,%rax
  8004213449:	48 01 d0             	add    %rdx,%rax
  800421344c:	48 c1 e0 03          	shl    $0x3,%rax
  8004213450:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  8004213454:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213458:	48 89 c7             	mov    %rax,%rdi
  800421345b:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213462:	00 00 00 
  8004213465:	ff d0                	callq  *%rax
  8004213467:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421346e:	48 0f af c2          	imul   %rdx,%rax
                                *row_pc = pc;
                                CHECK_TABLE_SIZE(low6);
                                RL[low6].dw_offset_relevant = 1;
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
                                RL[low6].dw_offset_or_block_len =
  8004213472:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
                                break;
  8004213476:	e9 85 00 00 00       	jmpq   8004213500 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_restore:
                                *row_pc = pc;
  800421347b:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421347f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213483:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  8004213486:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421348a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421348e:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213492:	66 39 c2             	cmp    %ax,%dx
  8004213495:	72 0c                	jb     80042134a3 <_dwarf_frame_run_inst+0x212>
  8004213497:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421349e:	e9 bd 0b 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                                memcpy(&RL[low6], &INITRL[low6],
  80042134a3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042134a7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042134ab:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042134af:	48 89 d0             	mov    %rdx,%rax
  80042134b2:	48 01 c0             	add    %rax,%rax
  80042134b5:	48 01 d0             	add    %rdx,%rax
  80042134b8:	48 c1 e0 03          	shl    $0x3,%rax
  80042134bc:	48 01 c1             	add    %rax,%rcx
  80042134bf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042134c3:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042134c7:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042134cb:	48 89 d0             	mov    %rdx,%rax
  80042134ce:	48 01 c0             	add    %rax,%rax
  80042134d1:	48 01 d0             	add    %rdx,%rax
  80042134d4:	48 c1 e0 03          	shl    $0x3,%rax
  80042134d8:	48 01 f0             	add    %rsi,%rax
  80042134db:	ba 18 00 00 00       	mov    $0x18,%edx
  80042134e0:	48 89 ce             	mov    %rcx,%rsi
  80042134e3:	48 89 c7             	mov    %rax,%rdi
  80042134e6:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  80042134ed:	00 00 00 
  80042134f0:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
                                break;
  80042134f2:	eb 0c                	jmp    8004213500 <_dwarf_frame_run_inst+0x26f>
                        default:
                                DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  80042134f4:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                                goto program_done;
  80042134fb:	e9 60 0b 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        }

                        continue;
  8004213500:	e9 4d 0b 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                }

                switch (low6) {
  8004213505:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004213509:	83 f8 16             	cmp    $0x16,%eax
  800421350c:	0f 87 37 0b 00 00    	ja     8004214049 <_dwarf_frame_run_inst+0xdb8>
  8004213512:	89 c0                	mov    %eax,%eax
  8004213514:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421351b:	00 
  800421351c:	48 b8 c0 f7 21 04 80 	movabs $0x800421f7c0,%rax
  8004213523:	00 00 00 
  8004213526:	48 01 d0             	add    %rdx,%rax
  8004213529:	48 8b 00             	mov    (%rax),%rax
  800421352c:	ff e0                	jmpq   *%rax
                case DW_CFA_set_loc:
                        pc = dbg->decode(&p, dbg->dbg_pointer_size);
  800421352e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213532:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213536:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421353a:	8b 4a 28             	mov    0x28(%rdx),%ecx
  800421353d:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004213541:	89 ce                	mov    %ecx,%esi
  8004213543:	48 89 d7             	mov    %rdx,%rdi
  8004213546:	ff d0                	callq  *%rax
  8004213548:	48 89 45 10          	mov    %rax,0x10(%rbp)
                        if (pc_req < pc)
  800421354c:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004213550:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004213554:	73 05                	jae    800421355b <_dwarf_frame_run_inst+0x2ca>
                                goto program_done;
  8004213556:	e9 05 0b 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        break;
  800421355b:	e9 f2 0a 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc1:
                        pc += dbg->decode(&p, 1) * caf;
  8004213560:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213564:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213568:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421356c:	be 01 00 00 00       	mov    $0x1,%esi
  8004213571:	48 89 d7             	mov    %rdx,%rdi
  8004213574:	ff d0                	callq  *%rax
  8004213576:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421357d:	ff 
  800421357e:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  8004213582:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004213586:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421358a:	73 05                	jae    8004213591 <_dwarf_frame_run_inst+0x300>
                                goto program_done;
  800421358c:	e9 cf 0a 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        break;
  8004213591:	e9 bc 0a 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc2:
                        pc += dbg->decode(&p, 2) * caf;
  8004213596:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421359a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421359e:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042135a2:	be 02 00 00 00       	mov    $0x2,%esi
  80042135a7:	48 89 d7             	mov    %rdx,%rdi
  80042135aa:	ff d0                	callq  *%rax
  80042135ac:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042135b3:	ff 
  80042135b4:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  80042135b8:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042135bc:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042135c0:	73 05                	jae    80042135c7 <_dwarf_frame_run_inst+0x336>
                                goto program_done;
  80042135c2:	e9 99 0a 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        break;
  80042135c7:	e9 86 0a 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc4:
                        pc += dbg->decode(&p, 4) * caf;
  80042135cc:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042135d0:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042135d4:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042135d8:	be 04 00 00 00       	mov    $0x4,%esi
  80042135dd:	48 89 d7             	mov    %rdx,%rdi
  80042135e0:	ff d0                	callq  *%rax
  80042135e2:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042135e9:	ff 
  80042135ea:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  80042135ee:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042135f2:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042135f6:	73 05                	jae    80042135fd <_dwarf_frame_run_inst+0x36c>
                                goto program_done;
  80042135f8:	e9 63 0a 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        break;
  80042135fd:	e9 50 0a 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended:
                        *row_pc = pc;
  8004213602:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213606:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421360a:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421360d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213611:	48 89 c7             	mov    %rax,%rdi
  8004213614:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  800421361b:	00 00 00 
  800421361e:	ff d0                	callq  *%rax
  8004213620:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004213624:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213628:	48 89 c7             	mov    %rax,%rdi
  800421362b:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213632:	00 00 00 
  8004213635:	ff d0                	callq  *%rax
  8004213637:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421363b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421363f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213643:	0f b7 c0             	movzwl %ax,%eax
  8004213646:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421364a:	77 0c                	ja     8004213658 <_dwarf_frame_run_inst+0x3c7>
  800421364c:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213653:	e9 08 0a 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004213658:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421365c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213660:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213664:	48 89 d0             	mov    %rdx,%rax
  8004213667:	48 01 c0             	add    %rax,%rax
  800421366a:	48 01 d0             	add    %rdx,%rax
  800421366d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213671:	48 01 c8             	add    %rcx,%rax
  8004213674:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004213677:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421367b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421367f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213683:	48 89 d0             	mov    %rdx,%rax
  8004213686:	48 01 c0             	add    %rax,%rax
  8004213689:	48 01 d0             	add    %rdx,%rax
  800421368c:	48 c1 e0 03          	shl    $0x3,%rax
  8004213690:	48 01 c8             	add    %rcx,%rax
  8004213693:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004213697:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421369b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421369f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042136a3:	48 89 d0             	mov    %rdx,%rax
  80042136a6:	48 01 c0             	add    %rax,%rax
  80042136a9:	48 01 d0             	add    %rdx,%rax
  80042136ac:	48 c1 e0 03          	shl    $0x3,%rax
  80042136b0:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042136b4:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042136b8:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042136bc:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  80042136c0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042136c4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042136c8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042136cc:	48 89 d0             	mov    %rdx,%rax
  80042136cf:	48 01 c0             	add    %rax,%rax
  80042136d2:	48 01 d0             	add    %rdx,%rax
  80042136d5:	48 c1 e0 03          	shl    $0x3,%rax
  80042136d9:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042136dd:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042136e4:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042136e9:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  80042136ed:	e9 60 09 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_extended:
                        *row_pc = pc;
  80042136f2:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042136f6:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042136fa:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042136fd:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213701:	48 89 c7             	mov    %rax,%rdi
  8004213704:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  800421370b:	00 00 00 
  800421370e:	ff d0                	callq  *%rax
  8004213710:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213714:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213718:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421371c:	0f b7 c0             	movzwl %ax,%eax
  800421371f:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213723:	77 0c                	ja     8004213731 <_dwarf_frame_run_inst+0x4a0>
  8004213725:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421372c:	e9 2f 09 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        memcpy(&RL[reg], &INITRL[reg],
  8004213731:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213735:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213739:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421373d:	48 89 d0             	mov    %rdx,%rax
  8004213740:	48 01 c0             	add    %rax,%rax
  8004213743:	48 01 d0             	add    %rdx,%rax
  8004213746:	48 c1 e0 03          	shl    $0x3,%rax
  800421374a:	48 01 c1             	add    %rax,%rcx
  800421374d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213751:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004213755:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213759:	48 89 d0             	mov    %rdx,%rax
  800421375c:	48 01 c0             	add    %rax,%rax
  800421375f:	48 01 d0             	add    %rdx,%rax
  8004213762:	48 c1 e0 03          	shl    $0x3,%rax
  8004213766:	48 01 f0             	add    %rsi,%rax
  8004213769:	ba 18 00 00 00       	mov    $0x18,%edx
  800421376e:	48 89 ce             	mov    %rcx,%rsi
  8004213771:	48 89 c7             	mov    %rax,%rdi
  8004213774:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  800421377b:	00 00 00 
  800421377e:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
                        break;
  8004213780:	e9 cd 08 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_undefined:
                        *row_pc = pc;
  8004213785:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213789:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421378d:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213790:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213794:	48 89 c7             	mov    %rax,%rdi
  8004213797:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  800421379e:	00 00 00 
  80042137a1:	ff d0                	callq  *%rax
  80042137a3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042137a7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137ab:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042137af:	0f b7 c0             	movzwl %ax,%eax
  80042137b2:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042137b6:	77 0c                	ja     80042137c4 <_dwarf_frame_run_inst+0x533>
  80042137b8:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042137bf:	e9 9c 08 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  80042137c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137c8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042137cc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042137d0:	48 89 d0             	mov    %rdx,%rax
  80042137d3:	48 01 c0             	add    %rax,%rax
  80042137d6:	48 01 d0             	add    %rdx,%rax
  80042137d9:	48 c1 e0 03          	shl    $0x3,%rax
  80042137dd:	48 01 c8             	add    %rcx,%rax
  80042137e0:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  80042137e3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042137e7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042137eb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042137ef:	48 89 d0             	mov    %rdx,%rax
  80042137f2:	48 01 c0             	add    %rax,%rax
  80042137f5:	48 01 d0             	add    %rdx,%rax
  80042137f8:	48 c1 e0 03          	shl    $0x3,%rax
  80042137fc:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213800:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213804:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  8004213808:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  800421380c:	e9 41 08 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_same_value:
                        reg = _dwarf_decode_uleb128(&p);
  8004213811:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213815:	48 89 c7             	mov    %rax,%rdi
  8004213818:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  800421381f:	00 00 00 
  8004213822:	ff d0                	callq  *%rax
  8004213824:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213828:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421382c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213830:	0f b7 c0             	movzwl %ax,%eax
  8004213833:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213837:	77 0c                	ja     8004213845 <_dwarf_frame_run_inst+0x5b4>
  8004213839:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213840:	e9 1b 08 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004213845:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213849:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421384d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213851:	48 89 d0             	mov    %rdx,%rax
  8004213854:	48 01 c0             	add    %rax,%rax
  8004213857:	48 01 d0             	add    %rdx,%rax
  800421385a:	48 c1 e0 03          	shl    $0x3,%rax
  800421385e:	48 01 c8             	add    %rcx,%rax
  8004213861:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004213864:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213868:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421386c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213870:	48 89 d0             	mov    %rdx,%rax
  8004213873:	48 01 c0             	add    %rax,%rax
  8004213876:	48 01 d0             	add    %rdx,%rax
  8004213879:	48 c1 e0 03          	shl    $0x3,%rax
  800421387d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213881:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213885:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  8004213889:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  800421388d:	e9 c0 07 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_register:
                        *row_pc = pc;
  8004213892:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213896:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421389a:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421389d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042138a1:	48 89 c7             	mov    %rax,%rdi
  80042138a4:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  80042138ab:	00 00 00 
  80042138ae:	ff d0                	callq  *%rax
  80042138b0:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        reg2 = _dwarf_decode_uleb128(&p);
  80042138b4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042138b8:	48 89 c7             	mov    %rax,%rdi
  80042138bb:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  80042138c2:	00 00 00 
  80042138c5:	ff d0                	callq  *%rax
  80042138c7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042138cb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042138cf:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042138d3:	0f b7 c0             	movzwl %ax,%eax
  80042138d6:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042138da:	77 0c                	ja     80042138e8 <_dwarf_frame_run_inst+0x657>
  80042138dc:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042138e3:	e9 78 07 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  80042138e8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042138ec:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042138f0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042138f4:	48 89 d0             	mov    %rdx,%rax
  80042138f7:	48 01 c0             	add    %rax,%rax
  80042138fa:	48 01 d0             	add    %rdx,%rax
  80042138fd:	48 c1 e0 03          	shl    $0x3,%rax
  8004213901:	48 01 c8             	add    %rcx,%rax
  8004213904:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = reg2;
  8004213907:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421390b:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421390f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213913:	48 89 d0             	mov    %rdx,%rax
  8004213916:	48 01 c0             	add    %rax,%rax
  8004213919:	48 01 d0             	add    %rdx,%rax
  800421391c:	48 c1 e0 03          	shl    $0x3,%rax
  8004213920:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213924:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213928:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  800421392c:	e9 21 07 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_remember_state:
                        _dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004213931:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004213935:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004213939:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  800421393d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213941:	48 89 c7             	mov    %rax,%rdi
  8004213944:	48 b8 c0 30 21 04 80 	movabs $0x80042130c0,%rax
  800421394b:	00 00 00 
  800421394e:	ff d0                	callq  *%rax
                        break;
  8004213950:	e9 fd 06 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_state:
                        *row_pc = pc;
  8004213955:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213959:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421395d:	48 89 10             	mov    %rdx,(%rax)
                        _dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004213960:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004213964:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004213968:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800421396c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213970:	48 89 c7             	mov    %rax,%rdi
  8004213973:	48 b8 c0 30 21 04 80 	movabs $0x80042130c0,%rax
  800421397a:	00 00 00 
  800421397d:	ff d0                	callq  *%rax
                        break;
  800421397f:	e9 ce 06 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa:
                        *row_pc = pc;
  8004213984:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213988:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421398c:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421398f:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213993:	48 89 c7             	mov    %rax,%rdi
  8004213996:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  800421399d:	00 00 00 
  80042139a0:	ff d0                	callq  *%rax
  80042139a2:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  80042139a6:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042139aa:	48 89 c7             	mov    %rax,%rdi
  80042139ad:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  80042139b4:	00 00 00 
  80042139b7:	ff d0                	callq  *%rax
  80042139b9:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  80042139bd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139c1:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  80042139c4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139c8:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  80042139cc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139d0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042139d4:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  80042139d8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042139dc:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042139e0:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  80042139e4:	e9 69 06 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_register:
                        *row_pc = pc;
  80042139e9:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042139ed:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042139f1:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042139f4:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042139f8:	48 89 c7             	mov    %rax,%rdi
  80042139fb:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213a02:	00 00 00 
  8004213a05:	ff d0                	callq  *%rax
  8004213a07:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CFA.dw_regnum = reg;
  8004213a0b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a0f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213a13:	66 89 50 02          	mov    %dx,0x2(%rax)
                         * Note that DW_CFA_def_cfa_register change the CFA
                         * rule register while keep the old offset. So we
                         * should not touch the CFA.dw_offset_relevant flag
                         * here.
                         */
                        break;
  8004213a17:	e9 36 06 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset:
                        *row_pc = pc;
  8004213a1c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213a20:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213a24:	48 89 10             	mov    %rdx,(%rax)
                        uoff = _dwarf_decode_uleb128(&p);
  8004213a27:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213a2b:	48 89 c7             	mov    %rax,%rdi
  8004213a2e:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213a35:	00 00 00 
  8004213a38:	ff d0                	callq  *%rax
  8004213a3a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004213a3e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a42:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213a45:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a49:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  8004213a4d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a51:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213a55:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004213a59:	e9 f4 05 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_expression:
                        *row_pc = pc;
  8004213a5e:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213a62:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213a66:	48 89 10             	mov    %rdx,(%rax)
                        CFA.dw_offset_relevant = 0;
  8004213a69:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a6d:	c6 00 00             	movb   $0x0,(%rax)
                        CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004213a70:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a74:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004213a78:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  8004213a7c:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213a80:	48 89 c7             	mov    %rax,%rdi
  8004213a83:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213a8a:	00 00 00 
  8004213a8d:	ff d0                	callq  *%rax
  8004213a8f:	48 89 43 08          	mov    %rax,0x8(%rbx)
                        CFA.dw_block_ptr = p;
  8004213a93:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213a97:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213a9b:	48 89 50 10          	mov    %rdx,0x10(%rax)
                        p += CFA.dw_offset_or_block_len;
  8004213a9f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004213aa3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213aa7:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213aab:	48 01 d0             	add    %rdx,%rax
  8004213aae:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  8004213ab2:	e9 9b 05 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_expression:
                        *row_pc = pc;
  8004213ab7:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213abb:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213abf:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213ac2:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213ac6:	48 89 c7             	mov    %rax,%rdi
  8004213ac9:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213ad0:	00 00 00 
  8004213ad3:	ff d0                	callq  *%rax
  8004213ad5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213ad9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213add:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213ae1:	0f b7 c0             	movzwl %ax,%eax
  8004213ae4:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213ae8:	77 0c                	ja     8004213af6 <_dwarf_frame_run_inst+0x865>
  8004213aea:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213af1:	e9 6a 05 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004213af6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213afa:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213afe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b02:	48 89 d0             	mov    %rdx,%rax
  8004213b05:	48 01 c0             	add    %rax,%rax
  8004213b08:	48 01 d0             	add    %rdx,%rax
  8004213b0b:	48 c1 e0 03          	shl    $0x3,%rax
  8004213b0f:	48 01 c8             	add    %rcx,%rax
  8004213b12:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004213b15:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213b19:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213b1d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b21:	48 89 d0             	mov    %rdx,%rax
  8004213b24:	48 01 c0             	add    %rax,%rax
  8004213b27:	48 01 d0             	add    %rdx,%rax
  8004213b2a:	48 c1 e0 03          	shl    $0x3,%rax
  8004213b2e:	48 01 c8             	add    %rcx,%rax
  8004213b31:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004213b35:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213b39:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213b3d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b41:	48 89 d0             	mov    %rdx,%rax
  8004213b44:	48 01 c0             	add    %rax,%rax
  8004213b47:	48 01 d0             	add    %rdx,%rax
  8004213b4a:	48 c1 e0 03          	shl    $0x3,%rax
  8004213b4e:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004213b52:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213b56:	48 89 c7             	mov    %rax,%rdi
  8004213b59:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213b60:	00 00 00 
  8004213b63:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004213b65:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  8004213b69:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213b6d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213b71:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b75:	48 89 d0             	mov    %rdx,%rax
  8004213b78:	48 01 c0             	add    %rax,%rax
  8004213b7b:	48 01 d0             	add    %rdx,%rax
  8004213b7e:	48 c1 e0 03          	shl    $0x3,%rax
  8004213b82:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213b86:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213b8a:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004213b8e:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004213b92:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213b96:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004213b9a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213b9e:	48 89 d0             	mov    %rdx,%rax
  8004213ba1:	48 01 c0             	add    %rax,%rax
  8004213ba4:	48 01 d0             	add    %rdx,%rax
  8004213ba7:	48 c1 e0 03          	shl    $0x3,%rax
  8004213bab:	48 01 f0             	add    %rsi,%rax
  8004213bae:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213bb2:	48 01 c8             	add    %rcx,%rax
  8004213bb5:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  8004213bb9:	e9 94 04 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended_sf:
                        *row_pc = pc;
  8004213bbe:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213bc2:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213bc6:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213bc9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213bcd:	48 89 c7             	mov    %rax,%rdi
  8004213bd0:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213bd7:	00 00 00 
  8004213bda:	ff d0                	callq  *%rax
  8004213bdc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004213be0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213be4:	48 89 c7             	mov    %rax,%rdi
  8004213be7:	48 b8 1d 17 21 04 80 	movabs $0x800421171d,%rax
  8004213bee:	00 00 00 
  8004213bf1:	ff d0                	callq  *%rax
  8004213bf3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213bf7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213bfb:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213bff:	0f b7 c0             	movzwl %ax,%eax
  8004213c02:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213c06:	77 0c                	ja     8004213c14 <_dwarf_frame_run_inst+0x983>
  8004213c08:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213c0f:	e9 4c 04 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004213c14:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213c18:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213c1c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c20:	48 89 d0             	mov    %rdx,%rax
  8004213c23:	48 01 c0             	add    %rax,%rax
  8004213c26:	48 01 d0             	add    %rdx,%rax
  8004213c29:	48 c1 e0 03          	shl    $0x3,%rax
  8004213c2d:	48 01 c8             	add    %rcx,%rax
  8004213c30:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004213c33:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213c37:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213c3b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c3f:	48 89 d0             	mov    %rdx,%rax
  8004213c42:	48 01 c0             	add    %rax,%rax
  8004213c45:	48 01 d0             	add    %rdx,%rax
  8004213c48:	48 c1 e0 03          	shl    $0x3,%rax
  8004213c4c:	48 01 c8             	add    %rcx,%rax
  8004213c4f:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004213c53:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213c57:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213c5b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c5f:	48 89 d0             	mov    %rdx,%rax
  8004213c62:	48 01 c0             	add    %rax,%rax
  8004213c65:	48 01 d0             	add    %rdx,%rax
  8004213c68:	48 c1 e0 03          	shl    $0x3,%rax
  8004213c6c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213c70:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213c74:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213c78:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004213c7c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213c80:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213c84:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213c88:	48 89 d0             	mov    %rdx,%rax
  8004213c8b:	48 01 c0             	add    %rax,%rax
  8004213c8e:	48 01 d0             	add    %rdx,%rax
  8004213c91:	48 c1 e0 03          	shl    $0x3,%rax
  8004213c95:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213c99:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004213ca0:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004213ca5:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004213ca9:	e9 a4 03 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_sf:
                        *row_pc = pc;
  8004213cae:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213cb2:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213cb6:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213cb9:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213cbd:	48 89 c7             	mov    %rax,%rdi
  8004213cc0:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213cc7:	00 00 00 
  8004213cca:	ff d0                	callq  *%rax
  8004213ccc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004213cd0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213cd4:	48 89 c7             	mov    %rax,%rdi
  8004213cd7:	48 b8 1d 17 21 04 80 	movabs $0x800421171d,%rax
  8004213cde:	00 00 00 
  8004213ce1:	ff d0                	callq  *%rax
  8004213ce3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004213ce7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213ceb:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213cee:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213cf2:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004213cf6:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213cfa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213cfe:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004213d02:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d06:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004213d0d:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004213d12:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004213d16:	e9 37 03 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset_sf:
                        *row_pc = pc;
  8004213d1b:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213d1f:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213d23:	48 89 10             	mov    %rdx,(%rax)
                        soff = _dwarf_decode_sleb128(&p);
  8004213d26:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213d2a:	48 89 c7             	mov    %rax,%rdi
  8004213d2d:	48 b8 1d 17 21 04 80 	movabs $0x800421171d,%rax
  8004213d34:	00 00 00 
  8004213d37:	ff d0                	callq  *%rax
  8004213d39:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004213d3d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d41:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004213d44:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d48:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004213d4c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213d50:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004213d57:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004213d5c:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004213d60:	e9 ed 02 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset:
                        *row_pc = pc;
  8004213d65:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213d69:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213d6d:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213d70:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213d74:	48 89 c7             	mov    %rax,%rdi
  8004213d77:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213d7e:	00 00 00 
  8004213d81:	ff d0                	callq  *%rax
  8004213d83:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004213d87:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213d8b:	48 89 c7             	mov    %rax,%rdi
  8004213d8e:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213d95:	00 00 00 
  8004213d98:	ff d0                	callq  *%rax
  8004213d9a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213d9e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213da2:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213da6:	0f b7 c0             	movzwl %ax,%eax
  8004213da9:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213dad:	77 0c                	ja     8004213dbb <_dwarf_frame_run_inst+0xb2a>
  8004213daf:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213db6:	e9 a5 02 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004213dbb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213dbf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213dc3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213dc7:	48 89 d0             	mov    %rdx,%rax
  8004213dca:	48 01 c0             	add    %rax,%rax
  8004213dcd:	48 01 d0             	add    %rdx,%rax
  8004213dd0:	48 c1 e0 03          	shl    $0x3,%rax
  8004213dd4:	48 01 c8             	add    %rcx,%rax
  8004213dd7:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004213dda:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213dde:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213de2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213de6:	48 89 d0             	mov    %rdx,%rax
  8004213de9:	48 01 c0             	add    %rax,%rax
  8004213dec:	48 01 d0             	add    %rdx,%rax
  8004213def:	48 c1 e0 03          	shl    $0x3,%rax
  8004213df3:	48 01 c8             	add    %rcx,%rax
  8004213df6:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004213dfa:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213dfe:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213e02:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e06:	48 89 d0             	mov    %rdx,%rax
  8004213e09:	48 01 c0             	add    %rax,%rax
  8004213e0c:	48 01 d0             	add    %rdx,%rax
  8004213e0f:	48 c1 e0 03          	shl    $0x3,%rax
  8004213e13:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213e17:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213e1b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213e1f:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  8004213e23:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e27:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213e2b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213e2f:	48 89 d0             	mov    %rdx,%rax
  8004213e32:	48 01 c0             	add    %rax,%rax
  8004213e35:	48 01 d0             	add    %rdx,%rax
  8004213e38:	48 c1 e0 03          	shl    $0x3,%rax
  8004213e3c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213e40:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004213e47:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004213e4c:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004213e50:	e9 fd 01 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset_sf:
                        *row_pc = pc;
  8004213e55:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213e59:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213e5d:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213e60:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213e64:	48 89 c7             	mov    %rax,%rdi
  8004213e67:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213e6e:	00 00 00 
  8004213e71:	ff d0                	callq  *%rax
  8004213e73:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004213e77:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213e7b:	48 89 c7             	mov    %rax,%rdi
  8004213e7e:	48 b8 1d 17 21 04 80 	movabs $0x800421171d,%rax
  8004213e85:	00 00 00 
  8004213e88:	ff d0                	callq  *%rax
  8004213e8a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213e8e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213e92:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213e96:	0f b7 c0             	movzwl %ax,%eax
  8004213e99:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213e9d:	77 0c                	ja     8004213eab <_dwarf_frame_run_inst+0xc1a>
  8004213e9f:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213ea6:	e9 b5 01 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004213eab:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213eaf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213eb3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213eb7:	48 89 d0             	mov    %rdx,%rax
  8004213eba:	48 01 c0             	add    %rax,%rax
  8004213ebd:	48 01 d0             	add    %rdx,%rax
  8004213ec0:	48 c1 e0 03          	shl    $0x3,%rax
  8004213ec4:	48 01 c8             	add    %rcx,%rax
  8004213ec7:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004213eca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213ece:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213ed2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ed6:	48 89 d0             	mov    %rdx,%rax
  8004213ed9:	48 01 c0             	add    %rax,%rax
  8004213edc:	48 01 d0             	add    %rdx,%rax
  8004213edf:	48 c1 e0 03          	shl    $0x3,%rax
  8004213ee3:	48 01 c8             	add    %rcx,%rax
  8004213ee6:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004213eea:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213eee:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213ef2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ef6:	48 89 d0             	mov    %rdx,%rax
  8004213ef9:	48 01 c0             	add    %rax,%rax
  8004213efc:	48 01 d0             	add    %rdx,%rax
  8004213eff:	48 c1 e0 03          	shl    $0x3,%rax
  8004213f03:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213f07:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004213f0b:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004213f0f:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004213f13:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f17:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213f1b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f1f:	48 89 d0             	mov    %rdx,%rax
  8004213f22:	48 01 c0             	add    %rax,%rax
  8004213f25:	48 01 d0             	add    %rdx,%rax
  8004213f28:	48 c1 e0 03          	shl    $0x3,%rax
  8004213f2c:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004213f30:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004213f37:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004213f3c:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004213f40:	e9 0d 01 00 00       	jmpq   8004214052 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_expression:
                        *row_pc = pc;
  8004213f45:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004213f49:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004213f4d:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004213f50:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213f54:	48 89 c7             	mov    %rax,%rdi
  8004213f57:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213f5e:	00 00 00 
  8004213f61:	ff d0                	callq  *%rax
  8004213f63:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004213f67:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f6b:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213f6f:	0f b7 c0             	movzwl %ax,%eax
  8004213f72:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004213f76:	77 0c                	ja     8004213f84 <_dwarf_frame_run_inst+0xcf3>
  8004213f78:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004213f7f:	e9 dc 00 00 00       	jmpq   8004214060 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004213f84:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213f88:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213f8c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f90:	48 89 d0             	mov    %rdx,%rax
  8004213f93:	48 01 c0             	add    %rax,%rax
  8004213f96:	48 01 d0             	add    %rdx,%rax
  8004213f99:	48 c1 e0 03          	shl    $0x3,%rax
  8004213f9d:	48 01 c8             	add    %rcx,%rax
  8004213fa0:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004213fa3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213fa7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213fab:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213faf:	48 89 d0             	mov    %rdx,%rax
  8004213fb2:	48 01 c0             	add    %rax,%rax
  8004213fb5:	48 01 d0             	add    %rdx,%rax
  8004213fb8:	48 c1 e0 03          	shl    $0x3,%rax
  8004213fbc:	48 01 c8             	add    %rcx,%rax
  8004213fbf:	c6 40 01 03          	movb   $0x3,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004213fc3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213fc7:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213fcb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213fcf:	48 89 d0             	mov    %rdx,%rax
  8004213fd2:	48 01 c0             	add    %rax,%rax
  8004213fd5:	48 01 d0             	add    %rdx,%rax
  8004213fd8:	48 c1 e0 03          	shl    $0x3,%rax
  8004213fdc:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004213fe0:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004213fe4:	48 89 c7             	mov    %rax,%rdi
  8004213fe7:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004213fee:	00 00 00 
  8004213ff1:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004213ff3:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  8004213ff7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004213ffb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213fff:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214003:	48 89 d0             	mov    %rdx,%rax
  8004214006:	48 01 c0             	add    %rax,%rax
  8004214009:	48 01 d0             	add    %rdx,%rax
  800421400c:	48 c1 e0 03          	shl    $0x3,%rax
  8004214010:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004214014:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214018:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  800421401c:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004214020:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004214024:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004214028:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421402c:	48 89 d0             	mov    %rdx,%rax
  800421402f:	48 01 c0             	add    %rax,%rax
  8004214032:	48 01 d0             	add    %rdx,%rax
  8004214035:	48 c1 e0 03          	shl    $0x3,%rax
  8004214039:	48 01 f0             	add    %rsi,%rax
  800421403c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214040:	48 01 c8             	add    %rcx,%rax
  8004214043:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  8004214047:	eb 09                	jmp    8004214052 <_dwarf_frame_run_inst+0xdc1>
                default:
                        DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
                        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004214049:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                        goto program_done;
  8004214050:	eb 0e                	jmp    8004214060 <_dwarf_frame_run_inst+0xdcf>
        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
        p = insts;
        pe = p + len;

        while (p < pe) {
  8004214052:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214056:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421405a:	0f 82 b8 f2 ff ff    	jb     8004213318 <_dwarf_frame_run_inst+0x87>
                        goto program_done;
                }
        }

program_done:
        return (ret);
  8004214060:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004214063:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  800421406a:	5b                   	pop    %rbx
  800421406b:	5d                   	pop    %rbp
  800421406c:	c3                   	retq   

000000800421406d <_dwarf_frame_get_internal_table>:

int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt, Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  800421406d:	55                   	push   %rbp
  800421406e:	48 89 e5             	mov    %rsp,%rbp
  8004214071:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004214075:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214079:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421407d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004214081:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004214085:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004214089:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
        Dwarf_Cie cie;
        Dwarf_Regtable3 *rt;
        Dwarf_Addr row_pc;
        int i, ret;

        assert(ret_rt != NULL);
  800421408d:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004214092:	75 35                	jne    80042140c9 <_dwarf_frame_get_internal_table+0x5c>
  8004214094:	48 b9 78 f8 21 04 80 	movabs $0x800421f878,%rcx
  800421409b:	00 00 00 
  800421409e:	48 ba 87 f7 21 04 80 	movabs $0x800421f787,%rdx
  80042140a5:	00 00 00 
  80042140a8:	be 82 01 00 00       	mov    $0x182,%esi
  80042140ad:	48 bf 9c f7 21 04 80 	movabs $0x800421f79c,%rdi
  80042140b4:	00 00 00 
  80042140b7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042140bc:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042140c3:	00 00 00 
  80042140c6:	41 ff d0             	callq  *%r8

        //dbg = fde->fde_dbg;
        assert(dbg != NULL);
  80042140c9:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042140ce:	75 35                	jne    8004214105 <_dwarf_frame_get_internal_table+0x98>
  80042140d0:	48 b9 87 f8 21 04 80 	movabs $0x800421f887,%rcx
  80042140d7:	00 00 00 
  80042140da:	48 ba 87 f7 21 04 80 	movabs $0x800421f787,%rdx
  80042140e1:	00 00 00 
  80042140e4:	be 85 01 00 00       	mov    $0x185,%esi
  80042140e9:	48 bf 9c f7 21 04 80 	movabs $0x800421f79c,%rdi
  80042140f0:	00 00 00 
  80042140f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042140f8:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042140ff:	00 00 00 
  8004214102:	41 ff d0             	callq  *%r8

        rt = dbg->dbg_internal_reg_table;
  8004214105:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214109:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421410d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        /* Clear the content of regtable from previous run. */
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004214111:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214115:	ba 18 00 00 00       	mov    $0x18,%edx
  800421411a:	be 00 00 00 00       	mov    $0x0,%esi
  800421411f:	48 89 c7             	mov    %rax,%rdi
  8004214122:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004214129:	00 00 00 
  800421412c:	ff d0                	callq  *%rax
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  800421412e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214132:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004214136:	0f b7 d0             	movzwl %ax,%edx
  8004214139:	48 89 d0             	mov    %rdx,%rax
  800421413c:	48 01 c0             	add    %rax,%rax
  800421413f:	48 01 d0             	add    %rdx,%rax
  8004214142:	48 c1 e0 03          	shl    $0x3,%rax
  8004214146:	48 89 c2             	mov    %rax,%rdx
  8004214149:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421414d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214151:	be 00 00 00 00       	mov    $0x0,%esi
  8004214156:	48 89 c7             	mov    %rax,%rdi
  8004214159:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004214160:	00 00 00 
  8004214163:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004214165:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421416c:	eb 2f                	jmp    800421419d <_dwarf_frame_get_internal_table+0x130>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  800421416e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004214172:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214176:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214179:	48 63 d0             	movslq %eax,%rdx
  800421417c:	48 89 d0             	mov    %rdx,%rax
  800421417f:	48 01 c0             	add    %rax,%rax
  8004214182:	48 01 d0             	add    %rdx,%rax
  8004214185:	48 c1 e0 03          	shl    $0x3,%rax
  8004214189:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421418d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214191:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  8004214195:	66 89 42 02          	mov    %ax,0x2(%rdx)
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004214199:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421419d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042141a1:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042141a5:	0f b7 c0             	movzwl %ax,%eax
  80042141a8:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042141ab:	7f c1                	jg     800421416e <_dwarf_frame_get_internal_table+0x101>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
  80042141ad:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042141b1:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042141b5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        assert(cie != NULL);
  80042141b9:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042141be:	75 35                	jne    80042141f5 <_dwarf_frame_get_internal_table+0x188>
  80042141c0:	48 b9 93 f8 21 04 80 	movabs $0x800421f893,%rcx
  80042141c7:	00 00 00 
  80042141ca:	48 ba 87 f7 21 04 80 	movabs $0x800421f787,%rdx
  80042141d1:	00 00 00 
  80042141d4:	be 94 01 00 00       	mov    $0x194,%esi
  80042141d9:	48 bf 9c f7 21 04 80 	movabs $0x800421f79c,%rdi
  80042141e0:	00 00 00 
  80042141e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042141e8:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042141ef:	00 00 00 
  80042141f2:	41 ff d0             	callq  *%r8
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  80042141f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042141f9:	4c 8b 48 40          	mov    0x40(%rax),%r9
  80042141fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214201:	4c 8b 40 38          	mov    0x38(%rax),%r8
  8004214205:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214209:	48 8b 48 70          	mov    0x70(%rax),%rcx
  800421420d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214211:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004214215:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004214219:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421421d:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004214221:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004214226:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  800421422a:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800421422f:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  8004214236:	ff ff 
  8004214238:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  800421423f:	00 
  8004214240:	48 89 c7             	mov    %rax,%rdi
  8004214243:	48 b8 91 32 21 04 80 	movabs $0x8004213291,%rax
  800421424a:	00 00 00 
  800421424d:	ff d0                	callq  *%rax
  800421424f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
        if (ret != DW_DLE_NONE)
  8004214252:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004214256:	74 08                	je     8004214260 <_dwarf_frame_get_internal_table+0x1f3>
                return (ret);
  8004214258:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421425b:	e9 98 00 00 00       	jmpq   80042142f8 <_dwarf_frame_get_internal_table+0x28b>
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
  8004214260:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214264:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004214268:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800421426c:	77 6f                	ja     80042142dd <_dwarf_frame_get_internal_table+0x270>
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  800421426e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214272:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8004214276:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421427a:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800421427e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214282:	4c 8b 50 38          	mov    0x38(%rax),%r10
  8004214286:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421428a:	48 8b 48 58          	mov    0x58(%rax),%rcx
  800421428e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214292:	48 8b 50 50          	mov    0x50(%rax),%rdx
  8004214296:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800421429a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421429e:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  80042142a2:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  80042142a7:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  80042142ab:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  80042142b0:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  80042142b4:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  80042142b9:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042142bd:	4d 89 d0             	mov    %r10,%r8
  80042142c0:	48 89 c7             	mov    %rax,%rdi
  80042142c3:	48 b8 91 32 21 04 80 	movabs $0x8004213291,%rax
  80042142ca:	00 00 00 
  80042142cd:	ff d0                	callq  *%rax
  80042142cf:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
					    fde->fde_initloc, pc_req, &row_pc, error);
                if (ret != DW_DLE_NONE)
  80042142d2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042142d6:	74 05                	je     80042142dd <_dwarf_frame_get_internal_table+0x270>
                        return (ret);
  80042142d8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042142db:	eb 1b                	jmp    80042142f8 <_dwarf_frame_get_internal_table+0x28b>
        }

        *ret_rt = rt;
  80042142dd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042142e1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042142e5:	48 89 10             	mov    %rdx,(%rax)
        *ret_row_pc = row_pc;
  80042142e8:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042142ec:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042142f0:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLE_NONE);
  80042142f3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042142f8:	c9                   	leaveq 
  80042142f9:	c3                   	retq   

00000080042142fa <dwarf_get_fde_info_for_all_regs>:

int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested, Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  80042142fa:	55                   	push   %rbp
  80042142fb:	48 89 e5             	mov    %rsp,%rbp
  80042142fe:	48 83 ec 50          	sub    $0x50,%rsp
  8004214302:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004214306:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421430a:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421430e:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004214312:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8004214316:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
        Dwarf_Regtable3 *rt;
        Dwarf_Addr pc;
        Dwarf_Half cfa;
        int i, ret;

        if (fde == NULL || reg_table == NULL) {
  800421431a:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421431f:	74 07                	je     8004214328 <dwarf_get_fde_info_for_all_regs+0x2e>
  8004214321:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004214326:	75 0a                	jne    8004214332 <dwarf_get_fde_info_for_all_regs+0x38>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
                return (DW_DLV_ERROR);
  8004214328:	b8 01 00 00 00       	mov    $0x1,%eax
  800421432d:	e9 eb 02 00 00       	jmpq   800421461d <dwarf_get_fde_info_for_all_regs+0x323>
        }

        assert(dbg != NULL);
  8004214332:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004214337:	75 35                	jne    800421436e <dwarf_get_fde_info_for_all_regs+0x74>
  8004214339:	48 b9 87 f8 21 04 80 	movabs $0x800421f887,%rcx
  8004214340:	00 00 00 
  8004214343:	48 ba 87 f7 21 04 80 	movabs $0x800421f787,%rdx
  800421434a:	00 00 00 
  800421434d:	be ba 01 00 00       	mov    $0x1ba,%esi
  8004214352:	48 bf 9c f7 21 04 80 	movabs $0x800421f79c,%rdi
  8004214359:	00 00 00 
  800421435c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214361:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004214368:	00 00 00 
  800421436b:	41 ff d0             	callq  *%r8

        if (pc_requested < fde->fde_initloc ||
  800421436e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214372:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004214376:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800421437a:	77 19                	ja     8004214395 <dwarf_get_fde_info_for_all_regs+0x9b>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  800421437c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214380:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004214384:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214388:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421438c:	48 01 d0             	add    %rdx,%rax
                return (DW_DLV_ERROR);
        }

        assert(dbg != NULL);

        if (pc_requested < fde->fde_initloc ||
  800421438f:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004214393:	77 0a                	ja     800421439f <dwarf_get_fde_info_for_all_regs+0xa5>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
                return (DW_DLV_ERROR);
  8004214395:	b8 01 00 00 00       	mov    $0x1,%eax
  800421439a:	e9 7e 02 00 00       	jmpq   800421461d <dwarf_get_fde_info_for_all_regs+0x323>
        }

        ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  800421439f:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  80042143a3:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  80042143a7:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  80042143ab:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042143af:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042143b3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042143b7:	4d 89 c1             	mov    %r8,%r9
  80042143ba:	49 89 f8             	mov    %rdi,%r8
  80042143bd:	48 89 c7             	mov    %rax,%rdi
  80042143c0:	48 b8 6d 40 21 04 80 	movabs $0x800421406d,%rax
  80042143c7:	00 00 00 
  80042143ca:	ff d0                	callq  *%rax
  80042143cc:	89 45 f8             	mov    %eax,-0x8(%rbp)
                                              error);
        if (ret != DW_DLE_NONE)
  80042143cf:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042143d3:	74 0a                	je     80042143df <dwarf_get_fde_info_for_all_regs+0xe5>
                return (DW_DLV_ERROR);
  80042143d5:	b8 01 00 00 00       	mov    $0x1,%eax
  80042143da:	e9 3e 02 00 00       	jmpq   800421461d <dwarf_get_fde_info_for_all_regs+0x323>
        /*
         * Copy the CFA rule to the column intended for holding the CFA,
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
  80042143df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042143e3:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042143e7:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
        if (cfa < DW_REG_TABLE_SIZE) {
  80042143eb:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  80042143f0:	0f 87 b1 00 00 00    	ja     80042144a7 <dwarf_get_fde_info_for_all_regs+0x1ad>
                reg_table->rules[cfa].dw_offset_relevant =
  80042143f6:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  80042143fa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042143fe:	0f b6 00             	movzbl (%rax),%eax
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
        if (cfa < DW_REG_TABLE_SIZE) {
                reg_table->rules[cfa].dw_offset_relevant =
  8004214401:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214405:	48 63 c9             	movslq %ecx,%rcx
  8004214408:	48 83 c1 01          	add    $0x1,%rcx
  800421440c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214410:	48 01 ca             	add    %rcx,%rdx
  8004214413:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  8004214415:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  8004214419:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421441d:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004214421:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214425:	48 63 c9             	movslq %ecx,%rcx
  8004214428:	48 83 c1 01          	add    $0x1,%rcx
  800421442c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214430:	48 01 ca             	add    %rcx,%rdx
  8004214433:	88 42 01             	mov    %al,0x1(%rdx)
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004214436:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421443a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421443e:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004214442:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214446:	48 63 c9             	movslq %ecx,%rcx
  8004214449:	48 83 c1 01          	add    $0x1,%rcx
  800421444d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214451:	48 01 ca             	add    %rcx,%rdx
  8004214454:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004214458:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421445c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214460:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214464:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214468:	48 63 c9             	movslq %ecx,%rcx
  800421446b:	48 83 c1 01          	add    $0x1,%rcx
  800421446f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214473:	48 01 ca             	add    %rcx,%rdx
  8004214476:	48 83 c2 08          	add    $0x8,%rdx
  800421447a:	48 89 02             	mov    %rax,(%rdx)
                reg_table->cfa_rule = reg_table->rules[cfa];
  800421447d:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004214481:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004214485:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214489:	48 63 d2             	movslq %edx,%rdx
  800421448c:	48 83 c2 01          	add    $0x1,%rdx
  8004214490:	48 c1 e2 04          	shl    $0x4,%rdx
  8004214494:	48 01 d0             	add    %rdx,%rax
  8004214497:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421449b:	48 8b 00             	mov    (%rax),%rax
  800421449e:	48 89 01             	mov    %rax,(%rcx)
  80042144a1:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  80042144a5:	eb 3c                	jmp    80042144e3 <dwarf_get_fde_info_for_all_regs+0x1e9>
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
                    CFA.dw_offset_relevant;
  80042144a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042144ab:	0f b6 10             	movzbl (%rax),%edx
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
                reg_table->cfa_rule = reg_table->rules[cfa];
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
  80042144ae:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042144b2:	88 10                	mov    %dl,(%rax)
                    CFA.dw_offset_relevant;
                reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  80042144b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042144b8:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  80042144bc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042144c0:	88 50 01             	mov    %dl,0x1(%rax)
                reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  80042144c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042144c7:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  80042144cb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042144cf:	66 89 50 02          	mov    %dx,0x2(%rax)
                reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  80042144d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042144d7:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042144db:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042144df:	48 89 50 08          	mov    %rdx,0x8(%rax)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042144e3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042144ea:	e9 fd 00 00 00       	jmpq   80042145ec <dwarf_get_fde_info_for_all_regs+0x2f2>
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
  80042144ef:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80042144f3:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042144f6:	75 05                	jne    80042144fd <dwarf_get_fde_info_for_all_regs+0x203>
                        continue;
  80042144f8:	e9 eb 00 00 00       	jmpq   80042145e8 <dwarf_get_fde_info_for_all_regs+0x2ee>

                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  80042144fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214501:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214505:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214508:	48 63 d0             	movslq %eax,%rdx
  800421450b:	48 89 d0             	mov    %rdx,%rax
  800421450e:	48 01 c0             	add    %rax,%rax
  8004214511:	48 01 d0             	add    %rdx,%rax
  8004214514:	48 c1 e0 03          	shl    $0x3,%rax
  8004214518:	48 01 c8             	add    %rcx,%rax
  800421451b:	0f b6 00             	movzbl (%rax),%eax

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
  800421451e:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214522:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004214525:	48 63 c9             	movslq %ecx,%rcx
  8004214528:	48 83 c1 01          	add    $0x1,%rcx
  800421452c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214530:	48 01 ca             	add    %rcx,%rdx
  8004214533:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  8004214535:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214539:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421453d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004214540:	48 63 d0             	movslq %eax,%rdx
  8004214543:	48 89 d0             	mov    %rdx,%rax
  8004214546:	48 01 c0             	add    %rax,%rax
  8004214549:	48 01 d0             	add    %rdx,%rax
  800421454c:	48 c1 e0 03          	shl    $0x3,%rax
  8004214550:	48 01 c8             	add    %rcx,%rax
  8004214553:	0f b6 40 01          	movzbl 0x1(%rax),%eax
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
  8004214557:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421455b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421455e:	48 63 c9             	movslq %ecx,%rcx
  8004214561:	48 83 c1 01          	add    $0x1,%rcx
  8004214565:	48 c1 e1 04          	shl    $0x4,%rcx
  8004214569:	48 01 ca             	add    %rcx,%rdx
  800421456c:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  800421456f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214573:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004214577:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421457a:	48 63 d0             	movslq %eax,%rdx
  800421457d:	48 89 d0             	mov    %rdx,%rax
  8004214580:	48 01 c0             	add    %rax,%rax
  8004214583:	48 01 d0             	add    %rdx,%rax
  8004214586:	48 c1 e0 03          	shl    $0x3,%rax
  800421458a:	48 01 c8             	add    %rcx,%rax
  800421458d:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004214591:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214595:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004214598:	48 63 c9             	movslq %ecx,%rcx
  800421459b:	48 83 c1 01          	add    $0x1,%rcx
  800421459f:	48 c1 e1 04          	shl    $0x4,%rcx
  80042145a3:	48 01 ca             	add    %rcx,%rdx
  80042145a6:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  80042145aa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042145ae:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042145b2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042145b5:	48 63 d0             	movslq %eax,%rdx
  80042145b8:	48 89 d0             	mov    %rdx,%rax
  80042145bb:	48 01 c0             	add    %rax,%rax
  80042145be:	48 01 d0             	add    %rdx,%rax
  80042145c1:	48 c1 e0 03          	shl    $0x3,%rax
  80042145c5:	48 01 c8             	add    %rcx,%rax
  80042145c8:	48 8b 40 08          	mov    0x8(%rax),%rax
                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
  80042145cc:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042145d0:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042145d3:	48 63 c9             	movslq %ecx,%rcx
  80042145d6:	48 83 c1 01          	add    $0x1,%rcx
  80042145da:	48 c1 e1 04          	shl    $0x4,%rcx
  80042145de:	48 01 ca             	add    %rcx,%rdx
  80042145e1:	48 83 c2 08          	add    $0x8,%rdx
  80042145e5:	48 89 02             	mov    %rax,(%rdx)

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {
  80042145e8:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042145ec:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  80042145f0:	7f 14                	jg     8004214606 <dwarf_get_fde_info_for_all_regs+0x30c>
  80042145f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042145f6:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  80042145fa:	0f b7 c0             	movzwl %ax,%eax
  80042145fd:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  8004214600:	0f 8f e9 fe ff ff    	jg     80042144ef <dwarf_get_fde_info_for_all_regs+0x1f5>
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
        }

        if (row_pc) *row_pc = pc;
  8004214606:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  800421460b:	74 0b                	je     8004214618 <dwarf_get_fde_info_for_all_regs+0x31e>
  800421460d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214611:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214615:	48 89 10             	mov    %rdx,(%rax)
        return (DW_DLV_OK);
  8004214618:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421461d:	c9                   	leaveq 
  800421461e:	c3                   	retq   

000000800421461f <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  800421461f:	55                   	push   %rbp
  8004214620:	48 89 e5             	mov    %rsp,%rbp
  8004214623:	48 83 ec 40          	sub    $0x40,%rsp
  8004214627:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421462b:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421462f:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004214633:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004214637:	44 89 c0             	mov    %r8d,%eax
  800421463a:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  800421463e:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004214641:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004214645:	75 0a                	jne    8004214651 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004214647:	b8 00 00 00 00       	mov    $0x0,%eax
  800421464c:	e9 e6 01 00 00       	jmpq   8004214837 <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  8004214651:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214655:	83 e0 f0             	and    $0xfffffff0,%eax
  8004214658:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  800421465b:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  800421465f:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004214663:	83 f8 0c             	cmp    $0xc,%eax
  8004214666:	0f 87 72 01 00 00    	ja     80042147de <_dwarf_frame_read_lsb_encoded+0x1bf>
  800421466c:	89 c0                	mov    %eax,%eax
  800421466e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004214675:	00 
  8004214676:	48 b8 a0 f8 21 04 80 	movabs $0x800421f8a0,%rax
  800421467d:	00 00 00 
  8004214680:	48 01 d0             	add    %rdx,%rax
  8004214683:	48 8b 00             	mov    (%rax),%rax
  8004214686:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  8004214688:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421468c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214690:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214694:	8b 52 28             	mov    0x28(%rdx),%edx
  8004214697:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421469b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421469f:	48 89 cf             	mov    %rcx,%rdi
  80042146a2:	ff d0                	callq  *%rax
  80042146a4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042146a8:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042146ab:	e9 35 01 00 00       	jmpq   80042147e5 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  80042146b0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042146b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042146b8:	48 89 d6             	mov    %rdx,%rsi
  80042146bb:	48 89 c7             	mov    %rax,%rdi
  80042146be:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  80042146c5:	00 00 00 
  80042146c8:	ff d0                	callq  *%rax
  80042146ca:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042146ce:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042146d1:	e9 0f 01 00 00       	jmpq   80042147e5 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  80042146d6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042146da:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042146de:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042146e2:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042146e6:	ba 02 00 00 00       	mov    $0x2,%edx
  80042146eb:	48 89 cf             	mov    %rcx,%rdi
  80042146ee:	ff d0                	callq  *%rax
  80042146f0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042146f4:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042146f7:	e9 e9 00 00 00       	jmpq   80042147e5 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  80042146fc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214700:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214704:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004214708:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421470c:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214711:	48 89 cf             	mov    %rcx,%rdi
  8004214714:	ff d0                	callq  *%rax
  8004214716:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421471a:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421471d:	e9 c3 00 00 00       	jmpq   80042147e5 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004214722:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214726:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421472a:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421472e:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004214732:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214737:	48 89 cf             	mov    %rcx,%rdi
  800421473a:	ff d0                	callq  *%rax
  800421473c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214740:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004214743:	e9 9d 00 00 00       	jmpq   80042147e5 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004214748:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421474c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214750:	48 89 d6             	mov    %rdx,%rsi
  8004214753:	48 89 c7             	mov    %rax,%rdi
  8004214756:	48 b8 fa 15 21 04 80 	movabs $0x80042115fa,%rax
  800421475d:	00 00 00 
  8004214760:	ff d0                	callq  *%rax
  8004214762:	48 89 c2             	mov    %rax,%rdx
  8004214765:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214769:	48 89 10             	mov    %rdx,(%rax)
		break;
  800421476c:	eb 77                	jmp    80042147e5 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  800421476e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214772:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214776:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421477a:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421477e:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214783:	48 89 cf             	mov    %rcx,%rdi
  8004214786:	ff d0                	callq  *%rax
  8004214788:	48 0f bf d0          	movswq %ax,%rdx
  800421478c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214790:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004214793:	eb 50                	jmp    80042147e5 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  8004214795:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214799:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421479d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042147a1:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042147a5:	ba 04 00 00 00       	mov    $0x4,%edx
  80042147aa:	48 89 cf             	mov    %rcx,%rdi
  80042147ad:	ff d0                	callq  *%rax
  80042147af:	48 63 d0             	movslq %eax,%rdx
  80042147b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042147b6:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042147b9:	eb 2a                	jmp    80042147e5 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  80042147bb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042147bf:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042147c3:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042147c7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042147cb:	ba 08 00 00 00       	mov    $0x8,%edx
  80042147d0:	48 89 cf             	mov    %rcx,%rdi
  80042147d3:	ff d0                	callq  *%rax
  80042147d5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042147d9:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042147dc:	eb 07                	jmp    80042147e5 <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  80042147de:	b8 14 00 00 00       	mov    $0x14,%eax
  80042147e3:	eb 52                	jmp    8004214837 <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  80042147e5:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  80042147e9:	75 47                	jne    8004214832 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  80042147eb:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042147ef:	83 f8 01             	cmp    $0x1,%eax
  80042147f2:	7c 3d                	jl     8004214831 <_dwarf_frame_read_lsb_encoded+0x212>
  80042147f4:	83 f8 04             	cmp    $0x4,%eax
  80042147f7:	7e 0a                	jle    8004214803 <_dwarf_frame_read_lsb_encoded+0x1e4>
  80042147f9:	83 e8 09             	sub    $0x9,%eax
  80042147fc:	83 f8 03             	cmp    $0x3,%eax
  80042147ff:	77 30                	ja     8004214831 <_dwarf_frame_read_lsb_encoded+0x212>
  8004214801:	eb 17                	jmp    800421481a <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  8004214803:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214807:	48 8b 10             	mov    (%rax),%rdx
  800421480a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421480e:	48 01 c2             	add    %rax,%rdx
  8004214811:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004214815:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004214818:	eb 18                	jmp    8004214832 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  800421481a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421481e:	48 8b 10             	mov    (%rax),%rdx
  8004214821:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214825:	48 01 c2             	add    %rax,%rdx
  8004214828:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421482c:	48 89 10             	mov    %rdx,(%rax)
			break;
  800421482f:	eb 01                	jmp    8004214832 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004214831:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004214832:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214837:	c9                   	leaveq 
  8004214838:	c3                   	retq   

0000008004214839 <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  8004214839:	55                   	push   %rbp
  800421483a:	48 89 e5             	mov    %rsp,%rbp
  800421483d:	48 83 ec 50          	sub    $0x50,%rsp
  8004214841:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214845:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004214849:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  800421484d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214851:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214855:	48 85 c0             	test   %rax,%rax
  8004214858:	74 0f                	je     8004214869 <_dwarf_frame_parse_lsb_cie_augment+0x30>
  800421485a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421485e:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214862:	0f b6 00             	movzbl (%rax),%eax
  8004214865:	3c 7a                	cmp    $0x7a,%al
  8004214867:	74 35                	je     800421489e <_dwarf_frame_parse_lsb_cie_augment+0x65>
  8004214869:	48 b9 08 f9 21 04 80 	movabs $0x800421f908,%rcx
  8004214870:	00 00 00 
  8004214873:	48 ba 87 f7 21 04 80 	movabs $0x800421f787,%rdx
  800421487a:	00 00 00 
  800421487d:	be 45 02 00 00       	mov    $0x245,%esi
  8004214882:	48 bf 9c f7 21 04 80 	movabs $0x800421f79c,%rdi
  8004214889:	00 00 00 
  800421488c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214891:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004214898:	00 00 00 
  800421489b:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  800421489e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042148a2:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042148a6:	48 83 c0 01          	add    $0x1,%rax
  80042148aa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  80042148ae:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042148b2:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042148b6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042148ba:	e9 af 00 00 00       	jmpq   800421496e <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  80042148bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042148c3:	0f b6 00             	movzbl (%rax),%eax
  80042148c6:	0f b6 c0             	movzbl %al,%eax
  80042148c9:	83 f8 50             	cmp    $0x50,%eax
  80042148cc:	74 18                	je     80042148e6 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  80042148ce:	83 f8 52             	cmp    $0x52,%eax
  80042148d1:	74 77                	je     800421494a <_dwarf_frame_parse_lsb_cie_augment+0x111>
  80042148d3:	83 f8 4c             	cmp    $0x4c,%eax
  80042148d6:	0f 85 86 00 00 00    	jne    8004214962 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  80042148dc:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  80042148e1:	e9 83 00 00 00       	jmpq   8004214969 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  80042148e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042148ea:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042148ee:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  80042148f2:	0f b6 00             	movzbl (%rax),%eax
  80042148f5:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  80042148f8:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80042148ff:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  8004214900:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  8004214905:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  8004214909:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421490d:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004214911:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214915:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004214919:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421491d:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004214923:	48 89 c7             	mov    %rax,%rdi
  8004214926:	48 b8 1f 46 21 04 80 	movabs $0x800421461f,%rax
  800421492d:	00 00 00 
  8004214930:	ff d0                	callq  *%rax
  8004214932:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004214935:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004214939:	74 05                	je     8004214940 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  800421493b:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421493e:	eb 42                	jmp    8004214982 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  8004214940:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214944:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  8004214948:	eb 1f                	jmp    8004214969 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  800421494a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421494e:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214952:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004214956:	0f b6 10             	movzbl (%rax),%edx
  8004214959:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421495d:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004214960:	eb 07                	jmp    8004214969 <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004214962:	b8 14 00 00 00       	mov    $0x14,%eax
  8004214967:	eb 19                	jmp    8004214982 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  8004214969:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  800421496e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214972:	0f b6 00             	movzbl (%rax),%eax
  8004214975:	84 c0                	test   %al,%al
  8004214977:	0f 85 42 ff ff ff    	jne    80042148bf <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  800421497d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214982:	c9                   	leaveq 
  8004214983:	c3                   	retq   

0000008004214984 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  8004214984:	55                   	push   %rbp
  8004214985:	48 89 e5             	mov    %rsp,%rbp
  8004214988:	48 83 ec 60          	sub    $0x60,%rsp
  800421498c:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214990:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004214994:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004214998:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800421499c:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  80042149a0:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  80042149a5:	75 35                	jne    80042149dc <_dwarf_frame_set_cie+0x58>
  80042149a7:	48 b9 3d f9 21 04 80 	movabs $0x800421f93d,%rcx
  80042149ae:	00 00 00 
  80042149b1:	48 ba 87 f7 21 04 80 	movabs $0x800421f787,%rdx
  80042149b8:	00 00 00 
  80042149bb:	be 76 02 00 00       	mov    $0x276,%esi
  80042149c0:	48 bf 9c f7 21 04 80 	movabs $0x800421f79c,%rdi
  80042149c7:	00 00 00 
  80042149ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042149cf:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042149d6:	00 00 00 
  80042149d9:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  80042149dc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042149e0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  80042149e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149e8:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042149ec:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  80042149ef:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042149f3:	48 8b 10             	mov    (%rax),%rdx
  80042149f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042149fa:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  80042149fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214a02:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a06:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214a0a:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214a0e:	48 89 d1             	mov    %rdx,%rcx
  8004214a11:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004214a15:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214a1a:	48 89 cf             	mov    %rcx,%rdi
  8004214a1d:	ff d0                	callq  *%rax
  8004214a1f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004214a23:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214a28:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214a2c:	75 2e                	jne    8004214a5c <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  8004214a2e:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004214a35:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214a39:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a3d:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214a41:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214a45:	48 89 d1             	mov    %rdx,%rcx
  8004214a48:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004214a4c:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214a51:	48 89 cf             	mov    %rcx,%rdi
  8004214a54:	ff d0                	callq  *%rax
  8004214a56:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214a5a:	eb 07                	jmp    8004214a63 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  8004214a5c:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004214a63:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214a67:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004214a6b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214a6f:	48 8b 00             	mov    (%rax),%rax
  8004214a72:	48 29 c2             	sub    %rax,%rdx
  8004214a75:	48 89 d0             	mov    %rdx,%rax
  8004214a78:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004214a7c:	73 0a                	jae    8004214a88 <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004214a7e:	b8 12 00 00 00       	mov    $0x12,%eax
  8004214a83:	e9 5d 03 00 00       	jmpq   8004214de5 <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  8004214a88:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214a8c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214a90:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214a94:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214a98:	48 89 d1             	mov    %rdx,%rcx
  8004214a9b:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214a9e:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004214aa2:	48 89 cf             	mov    %rcx,%rdi
  8004214aa5:	ff d0                	callq  *%rax
	cie->cie_length = length;
  8004214aa7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214aab:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214aaf:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004214ab3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214ab7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214abb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214abf:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214ac3:	48 89 d1             	mov    %rdx,%rcx
  8004214ac6:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004214aca:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214acf:	48 89 cf             	mov    %rcx,%rdi
  8004214ad2:	ff d0                	callq  *%rax
  8004214ad4:	89 c2                	mov    %eax,%edx
  8004214ad6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ada:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004214ade:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ae2:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214ae6:	66 83 f8 01          	cmp    $0x1,%ax
  8004214aea:	74 26                	je     8004214b12 <_dwarf_frame_set_cie+0x18e>
  8004214aec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214af0:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214af4:	66 83 f8 03          	cmp    $0x3,%ax
  8004214af8:	74 18                	je     8004214b12 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  8004214afa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214afe:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  8004214b02:	66 83 f8 04          	cmp    $0x4,%ax
  8004214b06:	74 0a                	je     8004214b12 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  8004214b08:	b8 16 00 00 00       	mov    $0x16,%eax
  8004214b0d:	e9 d3 02 00 00       	jmpq   8004214de5 <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004214b12:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214b16:	48 8b 10             	mov    (%rax),%rdx
  8004214b19:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214b1d:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214b21:	48 01 d0             	add    %rdx,%rax
  8004214b24:	48 89 c2             	mov    %rax,%rdx
  8004214b27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214b2b:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004214b2f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214b33:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214b37:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004214b3b:	90                   	nop
  8004214b3c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214b40:	48 8b 00             	mov    (%rax),%rax
  8004214b43:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004214b47:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214b4b:	48 89 0a             	mov    %rcx,(%rdx)
  8004214b4e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214b52:	48 01 d0             	add    %rdx,%rax
  8004214b55:	0f b6 00             	movzbl (%rax),%eax
  8004214b58:	84 c0                	test   %al,%al
  8004214b5a:	75 e0                	jne    8004214b3c <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004214b5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214b60:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214b64:	0f b6 00             	movzbl (%rax),%eax
  8004214b67:	84 c0                	test   %al,%al
  8004214b69:	74 48                	je     8004214bb3 <_dwarf_frame_set_cie+0x22f>
  8004214b6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214b6f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214b73:	0f b6 00             	movzbl (%rax),%eax
  8004214b76:	3c 7a                	cmp    $0x7a,%al
  8004214b78:	74 39                	je     8004214bb3 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004214b7a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214b7e:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004214b82:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214b86:	75 07                	jne    8004214b8f <_dwarf_frame_set_cie+0x20b>
  8004214b88:	b8 04 00 00 00       	mov    $0x4,%eax
  8004214b8d:	eb 05                	jmp    8004214b94 <_dwarf_frame_set_cie+0x210>
  8004214b8f:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004214b94:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004214b97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214b9b:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004214b9f:	48 01 c2             	add    %rax,%rdx
  8004214ba2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214ba6:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004214ba9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214bae:	e9 32 02 00 00       	jmpq   8004214de5 <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004214bb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214bb7:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214bbb:	48 be 45 f9 21 04 80 	movabs $0x800421f945,%rsi
  8004214bc2:	00 00 00 
  8004214bc5:	48 89 c7             	mov    %rax,%rdi
  8004214bc8:	48 b8 b1 0f 21 04 80 	movabs $0x8004210fb1,%rax
  8004214bcf:	00 00 00 
  8004214bd2:	ff d0                	callq  *%rax
  8004214bd4:	48 85 c0             	test   %rax,%rax
  8004214bd7:	74 28                	je     8004214c01 <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read(ds->ds_data, off,
  8004214bd9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214bdd:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214be1:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214be5:	8b 52 28             	mov    0x28(%rdx),%edx
  8004214be8:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004214bec:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004214bf0:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004214bf4:	48 89 cf             	mov    %rcx,%rdi
  8004214bf7:	ff d0                	callq  *%rax
  8004214bf9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214bfd:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004214c01:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c05:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214c09:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214c0d:	48 89 d6             	mov    %rdx,%rsi
  8004214c10:	48 89 c7             	mov    %rax,%rdi
  8004214c13:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  8004214c1a:	00 00 00 
  8004214c1d:	ff d0                	callq  *%rax
  8004214c1f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214c23:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004214c27:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c2b:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214c2f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214c33:	48 89 d6             	mov    %rdx,%rsi
  8004214c36:	48 89 c7             	mov    %rax,%rdi
  8004214c39:	48 b8 fa 15 21 04 80 	movabs $0x80042115fa,%rax
  8004214c40:	00 00 00 
  8004214c43:	ff d0                	callq  *%rax
  8004214c45:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214c49:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004214c4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214c51:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004214c55:	66 83 f8 01          	cmp    $0x1,%ax
  8004214c59:	75 2b                	jne    8004214c86 <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004214c5b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c5f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c63:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214c67:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214c6b:	48 89 d1             	mov    %rdx,%rcx
  8004214c6e:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004214c72:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214c77:	48 89 cf             	mov    %rcx,%rdi
  8004214c7a:	ff d0                	callq  *%rax
  8004214c7c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214c80:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004214c84:	eb 26                	jmp    8004214cac <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004214c86:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214c8a:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214c8e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214c92:	48 89 d6             	mov    %rdx,%rsi
  8004214c95:	48 89 c7             	mov    %rax,%rdi
  8004214c98:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  8004214c9f:	00 00 00 
  8004214ca2:	ff d0                	callq  *%rax
  8004214ca4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214ca8:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004214cac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214cb0:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214cb4:	0f b6 00             	movzbl (%rax),%eax
  8004214cb7:	3c 7a                	cmp    $0x7a,%al
  8004214cb9:	0f 85 93 00 00 00    	jne    8004214d52 <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004214cbf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214cc3:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214cc7:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004214ccb:	48 89 d6             	mov    %rdx,%rsi
  8004214cce:	48 89 c7             	mov    %rax,%rdi
  8004214cd1:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  8004214cd8:	00 00 00 
  8004214cdb:	ff d0                	callq  *%rax
  8004214cdd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214ce1:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004214ce5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214ce9:	48 8b 10             	mov    (%rax),%rdx
  8004214cec:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214cf0:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214cf4:	48 01 d0             	add    %rdx,%rax
  8004214cf7:	48 89 c2             	mov    %rax,%rdx
  8004214cfa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214cfe:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004214d02:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214d06:	48 8b 10             	mov    (%rax),%rdx
  8004214d09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d0d:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004214d11:	48 01 c2             	add    %rax,%rdx
  8004214d14:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214d18:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004214d1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d1f:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004214d23:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004214d27:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004214d2b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214d2f:	48 89 ce             	mov    %rcx,%rsi
  8004214d32:	48 89 c7             	mov    %rax,%rdi
  8004214d35:	48 b8 39 48 21 04 80 	movabs $0x8004214839,%rax
  8004214d3c:	00 00 00 
  8004214d3f:	ff d0                	callq  *%rax
  8004214d41:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004214d44:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214d48:	74 08                	je     8004214d52 <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  8004214d4a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004214d4d:	e9 93 00 00 00       	jmpq   8004214de5 <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004214d52:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214d56:	48 8b 10             	mov    (%rax),%rdx
  8004214d59:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214d5d:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214d61:	48 01 d0             	add    %rdx,%rax
  8004214d64:	48 89 c2             	mov    %rax,%rdx
  8004214d67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d6b:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004214d6f:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214d73:	75 2a                	jne    8004214d9f <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004214d75:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d79:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004214d7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214d81:	48 01 c2             	add    %rax,%rdx
  8004214d84:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214d88:	48 8b 00             	mov    (%rax),%rax
  8004214d8b:	48 29 c2             	sub    %rax,%rdx
  8004214d8e:	48 89 d0             	mov    %rdx,%rax
  8004214d91:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004214d95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214d99:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004214d9d:	eb 28                	jmp    8004214dc7 <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004214d9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214da3:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004214da7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214dab:	48 01 c2             	add    %rax,%rdx
  8004214dae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214db2:	48 8b 00             	mov    (%rax),%rax
  8004214db5:	48 29 c2             	sub    %rax,%rdx
  8004214db8:	48 89 d0             	mov    %rdx,%rax
  8004214dbb:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004214dbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214dc3:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004214dc7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214dcb:	48 8b 10             	mov    (%rax),%rdx
  8004214dce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214dd2:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004214dd6:	48 01 c2             	add    %rax,%rdx
  8004214dd9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214ddd:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004214de0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214de5:	c9                   	leaveq 
  8004214de6:	c3                   	retq   

0000008004214de7 <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004214de7:	55                   	push   %rbp
  8004214de8:	48 89 e5             	mov    %rsp,%rbp
  8004214deb:	48 83 ec 70          	sub    $0x70,%rsp
  8004214def:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004214df3:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004214df7:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004214dfb:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004214dff:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004214e03:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004214e07:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e0b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004214e0f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e13:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214e17:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004214e1a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214e1e:	48 8b 10             	mov    (%rax),%rdx
  8004214e21:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214e25:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214e29:	48 01 d0             	add    %rdx,%rax
  8004214e2c:	48 89 c2             	mov    %rax,%rdx
  8004214e2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e33:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004214e37:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214e3b:	48 8b 10             	mov    (%rax),%rdx
  8004214e3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214e42:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004214e46:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214e4a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214e4e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214e52:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214e56:	48 89 d1             	mov    %rdx,%rcx
  8004214e59:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214e5d:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214e62:	48 89 cf             	mov    %rcx,%rdi
  8004214e65:	ff d0                	callq  *%rax
  8004214e67:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004214e6b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214e70:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214e74:	75 2e                	jne    8004214ea4 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  8004214e76:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004214e7d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214e81:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214e85:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214e89:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214e8d:	48 89 d1             	mov    %rdx,%rcx
  8004214e90:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214e94:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214e99:	48 89 cf             	mov    %rcx,%rdi
  8004214e9c:	ff d0                	callq  *%rax
  8004214e9e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004214ea2:	eb 07                	jmp    8004214eab <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  8004214ea4:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004214eab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214eaf:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004214eb3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214eb7:	48 8b 00             	mov    (%rax),%rax
  8004214eba:	48 29 c2             	sub    %rax,%rdx
  8004214ebd:	48 89 d0             	mov    %rdx,%rax
  8004214ec0:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004214ec4:	73 0a                	jae    8004214ed0 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004214ec6:	b8 12 00 00 00       	mov    $0x12,%eax
  8004214ecb:	e9 c4 02 00 00       	jmpq   8004215194 <_dwarf_frame_set_fde+0x3ad>
	}

	fde->fde_length = length;
  8004214ed0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214ed4:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004214ed8:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004214edc:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004214ee0:	74 5e                	je     8004214f40 <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004214ee2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214ee6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214eea:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214eee:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214ef2:	48 89 d1             	mov    %rdx,%rcx
  8004214ef5:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214ef9:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214efe:	48 89 cf             	mov    %rcx,%rdi
  8004214f01:	ff d0                	callq  *%rax
  8004214f03:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214f07:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004214f0b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214f0f:	48 8b 10             	mov    (%rax),%rdx
  8004214f12:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f16:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214f1a:	48 29 c2             	sub    %rax,%rdx
  8004214f1d:	48 89 d0             	mov    %rdx,%rax
  8004214f20:	48 83 e8 04          	sub    $0x4,%rax
  8004214f24:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004214f28:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f2c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214f30:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004214f34:	75 3d                	jne    8004214f73 <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004214f36:	b8 13 00 00 00       	mov    $0x13,%eax
  8004214f3b:	e9 54 02 00 00       	jmpq   8004215194 <_dwarf_frame_set_fde+0x3ad>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004214f40:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214f44:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214f48:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214f4c:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214f50:	48 89 d1             	mov    %rdx,%rcx
  8004214f53:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214f56:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214f5a:	48 89 cf             	mov    %rcx,%rdi
  8004214f5d:	ff d0                	callq  *%rax
  8004214f5f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214f63:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004214f67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214f6b:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004214f6f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004214f73:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004214f77:	0f 84 c3 00 00 00    	je     8004215040 <_dwarf_frame_set_fde+0x259>
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004214f7d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214f81:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004214f85:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214f89:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004214f8c:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004214f90:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214f94:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004214f98:	44 0f b6 c0          	movzbl %al,%r8d
  8004214f9c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214fa0:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214fa4:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004214fa8:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004214fac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214fb0:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004214fb4:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214fb8:	48 89 c7             	mov    %rax,%rdi
  8004214fbb:	48 b8 1f 46 21 04 80 	movabs $0x800421461f,%rax
  8004214fc2:	00 00 00 
  8004214fc5:	ff d0                	callq  *%rax
  8004214fc7:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004214fca:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214fce:	74 08                	je     8004214fd8 <_dwarf_frame_set_fde+0x1f1>
			return (ret);
  8004214fd0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004214fd3:	e9 bc 01 00 00       	jmpq   8004215194 <_dwarf_frame_set_fde+0x3ad>
		fde->fde_initloc = val;
  8004214fd8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214fdc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214fe0:	48 89 50 30          	mov    %rdx,0x30(%rax)
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
						    off, cie->cie_fde_encode, 0, error);
  8004214fe4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004214fe8:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004214fec:	44 0f b6 c0          	movzbl %al,%r8d
  8004214ff0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214ff4:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214ff8:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004214ffc:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004215000:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215004:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004215008:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421500c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004215012:	48 89 c7             	mov    %rax,%rdi
  8004215015:	48 b8 1f 46 21 04 80 	movabs $0x800421461f,%rax
  800421501c:	00 00 00 
  800421501f:	ff d0                	callq  *%rax
  8004215021:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  8004215024:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004215028:	74 08                	je     8004215032 <_dwarf_frame_set_fde+0x24b>
			return (ret);
  800421502a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421502d:	e9 62 01 00 00       	jmpq   8004215194 <_dwarf_frame_set_fde+0x3ad>
		fde->fde_adrange = val;
  8004215032:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215036:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421503a:	48 89 50 38          	mov    %rdx,0x38(%rax)
  800421503e:	eb 50                	jmp    8004215090 <_dwarf_frame_set_fde+0x2a9>
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
  8004215040:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215044:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215048:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421504c:	8b 52 28             	mov    0x28(%rdx),%edx
  800421504f:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004215053:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004215057:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  800421505b:	48 89 cf             	mov    %rcx,%rdi
  800421505e:	ff d0                	callq  *%rax
  8004215060:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215064:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read(ds->ds_data, off,
  8004215068:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421506c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215070:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215074:	8b 52 28             	mov    0x28(%rdx),%edx
  8004215077:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421507b:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  800421507f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004215083:	48 89 cf             	mov    %rcx,%rdi
  8004215086:	ff d0                	callq  *%rax
  8004215088:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421508c:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004215090:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004215094:	74 6b                	je     8004215101 <_dwarf_frame_set_fde+0x31a>
  8004215096:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421509a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800421509e:	0f b6 00             	movzbl (%rax),%eax
  80042150a1:	3c 7a                	cmp    $0x7a,%al
  80042150a3:	75 5c                	jne    8004215101 <_dwarf_frame_set_fde+0x31a>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  80042150a5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042150a9:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042150ad:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  80042150b1:	48 89 d6             	mov    %rdx,%rsi
  80042150b4:	48 89 c7             	mov    %rax,%rdi
  80042150b7:	48 b8 9e 16 21 04 80 	movabs $0x800421169e,%rax
  80042150be:	00 00 00 
  80042150c1:	ff d0                	callq  *%rax
  80042150c3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042150c7:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  80042150cb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042150cf:	48 8b 10             	mov    (%rax),%rdx
  80042150d2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042150d6:	48 8b 40 38          	mov    0x38(%rax),%rax
  80042150da:	48 01 d0             	add    %rdx,%rax
  80042150dd:	48 89 c2             	mov    %rax,%rdx
  80042150e0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150e4:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  80042150e8:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042150ec:	48 8b 10             	mov    (%rax),%rdx
  80042150ef:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042150f3:	48 8b 40 40          	mov    0x40(%rax),%rax
  80042150f7:	48 01 c2             	add    %rax,%rdx
  80042150fa:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042150fe:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004215101:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215105:	48 8b 10             	mov    (%rax),%rdx
  8004215108:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421510c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004215110:	48 01 d0             	add    %rdx,%rax
  8004215113:	48 89 c2             	mov    %rax,%rdx
  8004215116:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421511a:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  800421511e:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004215122:	75 2a                	jne    800421514e <_dwarf_frame_set_fde+0x367>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  8004215124:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215128:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421512c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215130:	48 01 c2             	add    %rax,%rdx
  8004215133:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215137:	48 8b 00             	mov    (%rax),%rax
  800421513a:	48 29 c2             	sub    %rax,%rdx
  800421513d:	48 89 d0             	mov    %rdx,%rax
  8004215140:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004215144:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215148:	48 89 50 58          	mov    %rdx,0x58(%rax)
  800421514c:	eb 28                	jmp    8004215176 <_dwarf_frame_set_fde+0x38f>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  800421514e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215152:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215156:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421515a:	48 01 c2             	add    %rax,%rdx
  800421515d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215161:	48 8b 00             	mov    (%rax),%rax
  8004215164:	48 29 c2             	sub    %rax,%rdx
  8004215167:	48 89 d0             	mov    %rdx,%rax
  800421516a:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  800421516e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215172:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004215176:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421517a:	48 8b 10             	mov    (%rax),%rdx
  800421517d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215181:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004215185:	48 01 c2             	add    %rax,%rdx
  8004215188:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421518c:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  800421518f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215194:	c9                   	leaveq 
  8004215195:	c3                   	retq   

0000008004215196 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004215196:	55                   	push   %rbp
  8004215197:	48 89 e5             	mov    %rsp,%rbp
  800421519a:	48 83 ec 20          	sub    $0x20,%rsp
  800421519e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042151a2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
        Dwarf_Regtable3 *rt = &global_rt_table;
  80042151a6:	48 b8 c0 e6 3a 04 80 	movabs $0x80043ae6c0,%rax
  80042151ad:	00 00 00 
  80042151b0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

        if (dbg->dbg_internal_reg_table != NULL)
  80042151b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151b8:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042151bc:	48 85 c0             	test   %rax,%rax
  80042151bf:	74 07                	je     80042151c8 <_dwarf_frame_interal_table_init+0x32>
                return (DW_DLE_NONE);
  80042151c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042151c6:	eb 33                	jmp    80042151fb <_dwarf_frame_interal_table_init+0x65>

        rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  80042151c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151cc:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  80042151d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042151d4:	66 89 50 18          	mov    %dx,0x18(%rax)
        rt->rt3_rules = global_rules;
  80042151d8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042151dc:	48 b9 e0 ef 3a 04 80 	movabs $0x80043aefe0,%rcx
  80042151e3:	00 00 00 
  80042151e6:	48 89 48 20          	mov    %rcx,0x20(%rax)

        dbg->dbg_internal_reg_table = rt;
  80042151ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042151ee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042151f2:	48 89 50 58          	mov    %rdx,0x58(%rax)

        return (DW_DLE_NONE);
  80042151f6:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042151fb:	c9                   	leaveq 
  80042151fc:	c3                   	retq   

00000080042151fd <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
                    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  80042151fd:	55                   	push   %rbp
  80042151fe:	48 89 e5             	mov    %rsp,%rbp
  8004215201:	48 83 ec 60          	sub    $0x60,%rsp
  8004215205:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215209:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800421520c:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004215210:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  8004215214:	48 b8 80 36 23 04 80 	movabs $0x8004233680,%rax
  800421521b:	00 00 00 
  800421521e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004215222:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  8004215229:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421522d:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004215231:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004215235:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215239:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421523d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215241:	48 39 c2             	cmp    %rax,%rdx
  8004215244:	0f 86 fe 01 00 00    	jbe    8004215448 <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  800421524a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421524e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  8004215252:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215256:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421525a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421525e:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004215262:	48 89 d1             	mov    %rdx,%rcx
  8004215265:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004215269:	ba 04 00 00 00       	mov    $0x4,%edx
  800421526e:	48 89 cf             	mov    %rcx,%rdi
  8004215271:	ff d0                	callq  *%rax
  8004215273:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004215277:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421527c:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004215280:	75 2e                	jne    80042152b0 <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  8004215282:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  8004215289:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421528d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215291:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215295:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004215299:	48 89 d1             	mov    %rdx,%rcx
  800421529c:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  80042152a0:	ba 08 00 00 00       	mov    $0x8,%edx
  80042152a5:	48 89 cf             	mov    %rcx,%rdi
  80042152a8:	ff d0                	callq  *%rax
  80042152aa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042152ae:	eb 07                	jmp    80042152b7 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  80042152b0:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  80042152b7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042152bb:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042152bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042152c3:	48 29 c2             	sub    %rax,%rdx
  80042152c6:	48 89 d0             	mov    %rdx,%rax
  80042152c9:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042152cd:	72 0d                	jb     80042152dc <_dwarf_get_next_fde+0xdf>
  80042152cf:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042152d4:	75 10                	jne    80042152e6 <_dwarf_get_next_fde+0xe9>
  80042152d6:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042152da:	75 0a                	jne    80042152e6 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042152dc:	b8 12 00 00 00       	mov    $0x12,%eax
  80042152e1:	e9 67 01 00 00       	jmpq   800421544d <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  80042152e6:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042152ea:	74 11                	je     80042152fd <_dwarf_get_next_fde+0x100>
  80042152ec:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042152f1:	75 0a                	jne    80042152fd <_dwarf_get_next_fde+0x100>
			return(-1);
  80042152f3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042152f8:	e9 50 01 00 00       	jmpq   800421544d <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  80042152fd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215301:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215305:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215309:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421530d:	48 89 d1             	mov    %rdx,%rcx
  8004215310:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215313:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004215317:	48 89 cf             	mov    %rcx,%rdi
  800421531a:	ff d0                	callq  *%rax
  800421531c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  8004215320:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004215324:	74 79                	je     800421539f <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004215326:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421532b:	75 32                	jne    800421535f <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  800421532d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215331:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004215335:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004215339:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800421533d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004215341:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215345:	49 89 f8             	mov    %rdi,%r8
  8004215348:	48 89 c7             	mov    %rax,%rdi
  800421534b:	48 b8 84 49 21 04 80 	movabs $0x8004214984,%rax
  8004215352:	00 00 00 
  8004215355:	ff d0                	callq  *%rax
  8004215357:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421535a:	e9 c8 00 00 00       	jmpq   8004215427 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  800421535f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004215363:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004215367:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800421536b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421536f:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004215373:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215377:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421537b:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421537f:	4d 89 c1             	mov    %r8,%r9
  8004215382:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004215388:	48 89 c7             	mov    %rax,%rdi
  800421538b:	48 b8 e7 4d 21 04 80 	movabs $0x8004214de7,%rax
  8004215392:	00 00 00 
  8004215395:	ff d0                	callq  *%rax
  8004215397:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421539a:	e9 88 00 00 00       	jmpq   8004215427 <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  800421539f:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042153a3:	75 0b                	jne    80042153b0 <_dwarf_get_next_fde+0x1b3>
  80042153a5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042153aa:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  80042153ae:	74 0d                	je     80042153bd <_dwarf_get_next_fde+0x1c0>
  80042153b0:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  80042153b4:	75 36                	jne    80042153ec <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  80042153b6:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  80042153bb:	75 2f                	jne    80042153ec <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042153bd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042153c1:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042153c5:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042153c9:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042153cd:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042153d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042153d5:	49 89 f8             	mov    %rdi,%r8
  80042153d8:	48 89 c7             	mov    %rax,%rdi
  80042153db:	48 b8 84 49 21 04 80 	movabs $0x8004214984,%rax
  80042153e2:	00 00 00 
  80042153e5:	ff d0                	callq  *%rax
  80042153e7:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042153ea:	eb 3b                	jmp    8004215427 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  80042153ec:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042153f0:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042153f4:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042153f8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042153fc:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004215400:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215404:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004215408:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421540c:	4d 89 c1             	mov    %r8,%r9
  800421540f:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004215415:	48 89 c7             	mov    %rax,%rdi
  8004215418:	48 b8 e7 4d 21 04 80 	movabs $0x8004214de7,%rax
  800421541f:	00 00 00 
  8004215422:	ff d0                	callq  *%rax
  8004215424:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004215427:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  800421542b:	74 07                	je     8004215434 <_dwarf_get_next_fde+0x237>
			return(-1);
  800421542d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215432:	eb 19                	jmp    800421544d <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  8004215434:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215438:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  800421543c:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215440:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215444:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004215448:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421544d:	c9                   	leaveq 
  800421544e:	c3                   	retq   

000000800421544f <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  800421544f:	55                   	push   %rbp
  8004215450:	48 89 e5             	mov    %rsp,%rbp
  8004215453:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004215457:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421545b:	89 f0                	mov    %esi,%eax
  800421545d:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
        Dwarf_Half old_value;

        old_value = dbg->dbg_frame_cfa_value;
  8004215461:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215465:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004215469:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
        dbg->dbg_frame_cfa_value = value;
  800421546d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215471:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004215475:	66 89 50 4c          	mov    %dx,0x4c(%rax)

        return (old_value);
  8004215479:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  800421547d:	c9                   	leaveq 
  800421547e:	c3                   	retq   

000000800421547f <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  800421547f:	55                   	push   %rbp
  8004215480:	48 89 e5             	mov    %rsp,%rbp
  8004215483:	48 83 ec 10          	sub    $0x10,%rsp
  8004215487:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421548b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  800421548f:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004215494:	75 0a                	jne    80042154a0 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004215496:	b8 01 00 00 00       	mov    $0x1,%eax
  800421549b:	e9 85 00 00 00       	jmpq   8004215525 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  80042154a0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154a4:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042154a8:	48 85 c0             	test   %rax,%rax
  80042154ab:	75 25                	jne    80042154d2 <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  80042154ad:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042154b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154b5:	48 89 d6             	mov    %rdx,%rsi
  80042154b8:	48 89 c7             	mov    %rax,%rdi
  80042154bb:	48 b8 96 51 21 04 80 	movabs $0x8004215196,%rax
  80042154c2:	00 00 00 
  80042154c5:	ff d0                	callq  *%rax
  80042154c7:	85 c0                	test   %eax,%eax
  80042154c9:	74 07                	je     80042154d2 <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  80042154cb:	b8 01 00 00 00       	mov    $0x1,%eax
  80042154d0:	eb 53                	jmp    8004215525 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  80042154d2:	48 bf 80 36 23 04 80 	movabs $0x8004233680,%rdi
  80042154d9:	00 00 00 
  80042154dc:	48 b8 3c 2f 21 04 80 	movabs $0x8004212f3c,%rax
  80042154e3:	00 00 00 
  80042154e6:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  80042154e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042154ec:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80042154f3:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  80042154f4:	48 b8 80 36 23 04 80 	movabs $0x8004233680,%rax
  80042154fb:	00 00 00 
  80042154fe:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004215502:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215506:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  800421550a:	48 b8 80 36 23 04 80 	movabs $0x8004233680,%rax
  8004215511:	00 00 00 
  8004215514:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215518:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421551c:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  8004215520:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215525:	c9                   	leaveq 
  8004215526:	c3                   	retq   

0000008004215527 <_dwarf_lineno_run_program>:


static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004215527:	55                   	push   %rbp
  8004215528:	48 89 e5             	mov    %rsp,%rbp
  800421552b:	53                   	push   %rbx
  800421552c:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004215533:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004215537:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  800421553b:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004215542:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  8004215549:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  8004215550:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004215557:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421555b:	48 83 c0 48          	add    $0x48,%rax
  800421555f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  8004215563:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421556a:	00 
  800421556b:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004215572:	00 
  8004215573:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  800421557a:	00 
  800421557b:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004215582:	00 
  8004215583:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215587:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421558b:	0f b6 c0             	movzbl %al,%eax
  800421558e:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004215591:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004215598:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  800421559f:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  80042155a6:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  80042155ad:	e9 0a 05 00 00       	jmpq   8004215abc <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  80042155b2:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042155b9:	0f b6 00             	movzbl (%rax),%eax
  80042155bc:	84 c0                	test   %al,%al
  80042155be:	0f 85 78 01 00 00    	jne    800421573c <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  80042155c4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042155cb:	48 83 c0 01          	add    $0x1,%rax
  80042155cf:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  80042155d6:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042155dd:	48 89 c7             	mov    %rax,%rdi
  80042155e0:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  80042155e7:	00 00 00 
  80042155ea:	ff d0                	callq  *%rax
  80042155ec:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  80042155f0:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042155f7:	0f b6 00             	movzbl (%rax),%eax
  80042155fa:	0f b6 c0             	movzbl %al,%eax
  80042155fd:	83 f8 02             	cmp    $0x2,%eax
  8004215600:	74 7a                	je     800421567c <_dwarf_lineno_run_program+0x155>
  8004215602:	83 f8 03             	cmp    $0x3,%eax
  8004215605:	0f 84 b3 00 00 00    	je     80042156be <_dwarf_lineno_run_program+0x197>
  800421560b:	83 f8 01             	cmp    $0x1,%eax
  800421560e:	0f 85 09 01 00 00    	jne    800421571d <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  8004215614:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421561b:	48 83 c0 01          	add    $0x1,%rax
  800421561f:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  8004215626:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  800421562d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004215634:	00 
  8004215635:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  800421563c:	00 
  800421563d:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004215644:	00 
  8004215645:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421564c:	00 
  800421564d:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215651:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004215655:	0f b6 c0             	movzbl %al,%eax
  8004215658:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421565b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004215662:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004215669:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004215670:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004215677:	e9 bb 00 00 00       	jmpq   8004215737 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  800421567c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215683:	48 83 c0 01          	add    $0x1,%rax
  8004215687:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  800421568e:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215695:	00 00 00 
  8004215698:	48 8b 00             	mov    (%rax),%rax
  800421569b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421569f:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  80042156a3:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042156a7:	0f b6 ca             	movzbl %dl,%ecx
  80042156aa:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  80042156b1:	89 ce                	mov    %ecx,%esi
  80042156b3:	48 89 d7             	mov    %rdx,%rdi
  80042156b6:	ff d0                	callq  *%rax
  80042156b8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  80042156bc:	eb 79                	jmp    8004215737 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  80042156be:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042156c5:	48 83 c0 01          	add    $0x1,%rax
  80042156c9:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  80042156d0:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  80042156d7:	00 00 00 
  80042156da:	48 8b 08             	mov    (%rax),%rcx
  80042156dd:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042156e4:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  80042156eb:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042156ef:	49 89 c8             	mov    %rcx,%r8
  80042156f2:	48 89 d1             	mov    %rdx,%rcx
  80042156f5:	ba 00 00 00 00       	mov    $0x0,%edx
  80042156fa:	48 89 c7             	mov    %rax,%rdi
  80042156fd:	48 b8 df 5a 21 04 80 	movabs $0x8004215adf,%rax
  8004215704:	00 00 00 
  8004215707:	ff d0                	callq  *%rax
  8004215709:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  800421570c:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  8004215710:	74 09                	je     800421571b <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  8004215712:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  8004215713:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004215716:	e9 ba 03 00 00       	jmpq   8004215ad5 <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  800421571b:	eb 1a                	jmp    8004215737 <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  800421571d:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004215724:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215728:	48 01 d0             	add    %rdx,%rax
  800421572b:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004215732:	e9 85 03 00 00       	jmpq   8004215abc <_dwarf_lineno_run_program+0x595>
  8004215737:	e9 80 03 00 00       	jmpq   8004215abc <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  800421573c:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215743:	0f b6 00             	movzbl (%rax),%eax
  8004215746:	84 c0                	test   %al,%al
  8004215748:	0f 84 3c 02 00 00    	je     800421598a <_dwarf_lineno_run_program+0x463>
  800421574e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215755:	0f b6 10             	movzbl (%rax),%edx
  8004215758:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421575c:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215760:	38 c2                	cmp    %al,%dl
  8004215762:	0f 83 22 02 00 00    	jae    800421598a <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004215768:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421576f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215773:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  800421577a:	0f b6 00             	movzbl (%rax),%eax
  800421577d:	0f b6 c0             	movzbl %al,%eax
  8004215780:	83 f8 0c             	cmp    $0xc,%eax
  8004215783:	0f 87 fb 01 00 00    	ja     8004215984 <_dwarf_lineno_run_program+0x45d>
  8004215789:	89 c0                	mov    %eax,%eax
  800421578b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004215792:	00 
  8004215793:	48 b8 48 f9 21 04 80 	movabs $0x800421f948,%rax
  800421579a:	00 00 00 
  800421579d:	48 01 d0             	add    %rdx,%rax
  80042157a0:	48 8b 00             	mov    (%rax),%rax
  80042157a3:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  80042157a5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042157ac:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042157b0:	73 0a                	jae    80042157bc <_dwarf_lineno_run_program+0x295>
  80042157b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042157b7:	e9 19 03 00 00       	jmpq   8004215ad5 <_dwarf_lineno_run_program+0x5ae>
  80042157bc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042157c0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042157c4:	48 89 10             	mov    %rdx,(%rax)
  80042157c7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042157cb:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80042157d2:	00 
  80042157d3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042157d7:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042157db:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042157df:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042157e3:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042157e7:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042157eb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042157ef:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042157f3:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042157f7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042157fb:	8b 55 c8             	mov    -0x38(%rbp),%edx
  80042157fe:	89 50 28             	mov    %edx,0x28(%rax)
  8004215801:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215805:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215808:	89 50 2c             	mov    %edx,0x2c(%rax)
  800421580b:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421580f:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004215812:	89 50 30             	mov    %edx,0x30(%rax)
  8004215815:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215819:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004215820:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215824:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215828:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  800421582f:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  8004215836:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  800421583d:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004215844:	e9 3c 01 00 00       	jmpq   8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004215849:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004215850:	48 89 c7             	mov    %rax,%rdi
  8004215853:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  800421585a:	00 00 00 
  800421585d:	ff d0                	callq  *%rax
					li->li_minlen;
  800421585f:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004215863:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004215867:	0f b6 d2             	movzbl %dl,%edx
  800421586a:	48 0f af c2          	imul   %rdx,%rax
  800421586e:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  8004215872:	e9 0e 01 00 00       	jmpq   8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004215877:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421587e:	48 89 c7             	mov    %rax,%rdi
  8004215881:	48 b8 1d 17 21 04 80 	movabs $0x800421171d,%rax
  8004215888:	00 00 00 
  800421588b:	ff d0                	callq  *%rax
  800421588d:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  8004215891:	e9 ef 00 00 00       	jmpq   8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004215896:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421589d:	48 89 c7             	mov    %rax,%rdi
  80042158a0:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  80042158a7:	00 00 00 
  80042158aa:	ff d0                	callq  *%rax
  80042158ac:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  80042158b0:	e9 d0 00 00 00       	jmpq   8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  80042158b5:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042158bc:	48 89 c7             	mov    %rax,%rdi
  80042158bf:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  80042158c6:	00 00 00 
  80042158c9:	ff d0                	callq  *%rax
  80042158cb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  80042158cf:	e9 b1 00 00 00       	jmpq   8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  80042158d4:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042158d8:	0f 94 c0             	sete   %al
  80042158db:	0f b6 c0             	movzbl %al,%eax
  80042158de:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  80042158e1:	e9 9f 00 00 00       	jmpq   8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  80042158e6:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  80042158ed:	e9 93 00 00 00       	jmpq   8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  80042158f2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042158f6:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042158fa:	0f b6 c0             	movzbl %al,%eax
  80042158fd:	ba ff 00 00 00       	mov    $0xff,%edx
  8004215902:	89 d1                	mov    %edx,%ecx
  8004215904:	29 c1                	sub    %eax,%ecx
  8004215906:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421590a:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  800421590e:	0f b6 d8             	movzbl %al,%ebx
  8004215911:	89 c8                	mov    %ecx,%eax
  8004215913:	99                   	cltd   
  8004215914:	f7 fb                	idiv   %ebx
  8004215916:	89 c2                	mov    %eax,%edx
  8004215918:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421591c:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004215920:	0f b6 c0             	movzbl %al,%eax
  8004215923:	0f af c2             	imul   %edx,%eax
  8004215926:	48 98                	cltq   
  8004215928:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  800421592c:	eb 57                	jmp    8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  800421592e:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215935:	00 00 00 
  8004215938:	48 8b 00             	mov    (%rax),%rax
  800421593b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421593f:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004215946:	be 02 00 00 00       	mov    $0x2,%esi
  800421594b:	48 89 d7             	mov    %rdx,%rdi
  800421594e:	ff d0                	callq  *%rax
  8004215950:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004215954:	eb 2f                	jmp    8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004215956:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  800421595d:	eb 26                	jmp    8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  800421595f:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  8004215966:	eb 1d                	jmp    8004215985 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004215968:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421596f:	48 89 c7             	mov    %rax,%rdi
  8004215972:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004215979:	00 00 00 
  800421597c:	ff d0                	callq  *%rax
  800421597e:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  8004215982:	eb 01                	jmp    8004215985 <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  8004215984:	90                   	nop
			}

		} else {
  8004215985:	e9 32 01 00 00       	jmpq   8004215abc <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  800421598a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421598e:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  8004215992:	0f be c8             	movsbl %al,%ecx
  8004215995:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421599c:	0f b6 00             	movzbl (%rax),%eax
  800421599f:	0f b6 d0             	movzbl %al,%edx
  80042159a2:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042159a6:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042159aa:	0f b6 c0             	movzbl %al,%eax
  80042159ad:	29 c2                	sub    %eax,%edx
  80042159af:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042159b3:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042159b7:	0f b6 f0             	movzbl %al,%esi
  80042159ba:	89 d0                	mov    %edx,%eax
  80042159bc:	99                   	cltd   
  80042159bd:	f7 fe                	idiv   %esi
  80042159bf:	89 d0                	mov    %edx,%eax
  80042159c1:	01 c8                	add    %ecx,%eax
  80042159c3:	48 98                	cltq   
  80042159c5:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  80042159c9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042159d0:	0f b6 00             	movzbl (%rax),%eax
  80042159d3:	0f b6 d0             	movzbl %al,%edx
  80042159d6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042159da:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042159de:	0f b6 c0             	movzbl %al,%eax
  80042159e1:	89 d1                	mov    %edx,%ecx
  80042159e3:	29 c1                	sub    %eax,%ecx
  80042159e5:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042159e9:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042159ed:	0f b6 d8             	movzbl %al,%ebx
  80042159f0:	89 c8                	mov    %ecx,%eax
  80042159f2:	99                   	cltd   
  80042159f3:	f7 fb                	idiv   %ebx
  80042159f5:	89 c2                	mov    %eax,%edx
  80042159f7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042159fb:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80042159ff:	0f b6 c0             	movzbl %al,%eax
  8004215a02:	0f af c2             	imul   %edx,%eax
  8004215a05:	48 98                	cltq   
  8004215a07:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  8004215a0b:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215a12:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004215a16:	73 0a                	jae    8004215a22 <_dwarf_lineno_run_program+0x4fb>
  8004215a18:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215a1d:	e9 b3 00 00 00       	jmpq   8004215ad5 <_dwarf_lineno_run_program+0x5ae>
  8004215a22:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215a26:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215a2a:	48 89 10             	mov    %rdx,(%rax)
  8004215a2d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215a31:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004215a38:	00 
  8004215a39:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215a3d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215a41:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004215a45:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215a49:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215a4d:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215a51:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215a55:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215a59:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004215a5d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215a61:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004215a64:	89 50 28             	mov    %edx,0x28(%rax)
  8004215a67:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215a6b:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215a6e:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004215a71:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215a75:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004215a78:	89 50 30             	mov    %edx,0x30(%rax)
  8004215a7b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215a7f:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004215a86:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215a8a:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004215a8e:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004215a95:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  8004215a9c:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  8004215aa3:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  8004215aaa:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215ab1:	48 83 c0 01          	add    $0x1,%rax
  8004215ab5:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  8004215abc:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004215ac3:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  8004215aca:	0f 82 e2 fa ff ff    	jb     80042155b2 <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  8004215ad0:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  8004215ad5:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  8004215adc:	5b                   	pop    %rbx
  8004215add:	5d                   	pop    %rbp
  8004215ade:	c3                   	retq   

0000008004215adf <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  8004215adf:	55                   	push   %rbp
  8004215ae0:	48 89 e5             	mov    %rsp,%rbp
  8004215ae3:	53                   	push   %rbx
  8004215ae4:	48 83 ec 48          	sub    $0x48,%rsp
  8004215ae8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004215aec:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004215af0:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004215af4:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004215af8:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  8004215afc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215b00:	48 8b 00             	mov    (%rax),%rax
  8004215b03:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  8004215b07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215b0b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  8004215b0f:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004215b13:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215b17:	48 89 c7             	mov    %rax,%rdi
  8004215b1a:	48 b8 87 08 21 04 80 	movabs $0x8004210887,%rax
  8004215b21:	00 00 00 
  8004215b24:	ff d0                	callq  *%rax
  8004215b26:	48 98                	cltq   
  8004215b28:	48 83 c0 01          	add    $0x1,%rax
  8004215b2c:	48 01 d8             	add    %rbx,%rax
  8004215b2f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  8004215b33:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004215b37:	48 89 c7             	mov    %rax,%rdi
  8004215b3a:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004215b41:	00 00 00 
  8004215b44:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004215b46:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004215b4a:	48 89 c7             	mov    %rax,%rdi
  8004215b4d:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004215b54:	00 00 00 
  8004215b57:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004215b59:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004215b5d:	48 89 c7             	mov    %rax,%rdi
  8004215b60:	48 b8 af 17 21 04 80 	movabs $0x80042117af,%rax
  8004215b67:	00 00 00 
  8004215b6a:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004215b6c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215b70:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215b74:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004215b77:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215b7c:	48 83 c4 48          	add    $0x48,%rsp
  8004215b80:	5b                   	pop    %rbx
  8004215b81:	5d                   	pop    %rbp
  8004215b82:	c3                   	retq   

0000008004215b83 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004215b83:	55                   	push   %rbp
  8004215b84:	48 89 e5             	mov    %rsp,%rbp
  8004215b87:	53                   	push   %rbx
  8004215b88:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004215b8f:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004215b96:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004215b9d:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004215ba4:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004215bab:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004215bb2:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004215bb9:	00 
  8004215bba:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004215bc1:	00 
  8004215bc2:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004215bc9:	00 
  8004215bca:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004215bd1:	00 
  8004215bd2:	48 b8 b0 f9 21 04 80 	movabs $0x800421f9b0,%rax
  8004215bd9:	00 00 00 
  8004215bdc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004215be0:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004215be4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004215be8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004215bef:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004215bf6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004215bfa:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004215bff:	75 35                	jne    8004215c36 <_dwarf_lineno_init+0xb3>
  8004215c01:	48 b9 bc f9 21 04 80 	movabs $0x800421f9bc,%rcx
  8004215c08:	00 00 00 
  8004215c0b:	48 ba c7 f9 21 04 80 	movabs $0x800421f9c7,%rdx
  8004215c12:	00 00 00 
  8004215c15:	be 17 01 00 00       	mov    $0x117,%esi
  8004215c1a:	48 bf dc f9 21 04 80 	movabs $0x800421f9dc,%rdi
  8004215c21:	00 00 00 
  8004215c24:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215c29:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004215c30:	00 00 00 
  8004215c33:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004215c36:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215c3d:	00 00 00 
  8004215c40:	48 8b 00             	mov    (%rax),%rax
  8004215c43:	48 85 c0             	test   %rax,%rax
  8004215c46:	75 35                	jne    8004215c7d <_dwarf_lineno_init+0xfa>
  8004215c48:	48 b9 f3 f9 21 04 80 	movabs $0x800421f9f3,%rcx
  8004215c4f:	00 00 00 
  8004215c52:	48 ba c7 f9 21 04 80 	movabs $0x800421f9c7,%rdx
  8004215c59:	00 00 00 
  8004215c5c:	be 18 01 00 00       	mov    $0x118,%esi
  8004215c61:	48 bf dc f9 21 04 80 	movabs $0x800421f9dc,%rdi
  8004215c68:	00 00 00 
  8004215c6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215c70:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004215c77:	00 00 00 
  8004215c7a:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004215c7d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215c81:	48 89 c7             	mov    %rax,%rdi
  8004215c84:	48 b8 3c 2f 21 04 80 	movabs $0x8004212f3c,%rax
  8004215c8b:	00 00 00 
  8004215c8e:	ff d0                	callq  *%rax
  8004215c90:	85 c0                	test   %eax,%eax
  8004215c92:	74 0a                	je     8004215c9e <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004215c94:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215c99:	e9 4f 04 00 00       	jmpq   80042160ed <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004215c9e:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004215ca5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004215ca9:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215cb0:	00 00 00 
  8004215cb3:	48 8b 00             	mov    (%rax),%rax
  8004215cb6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215cba:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215cbe:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215cc2:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215cc9:	ba 04 00 00 00       	mov    $0x4,%edx
  8004215cce:	48 89 cf             	mov    %rcx,%rdi
  8004215cd1:	ff d0                	callq  *%rax
  8004215cd3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004215cd7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004215cdc:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004215ce0:	75 37                	jne    8004215d19 <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004215ce2:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004215ce9:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215cf0:	00 00 00 
  8004215cf3:	48 8b 00             	mov    (%rax),%rax
  8004215cf6:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215cfa:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215cfe:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215d02:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215d09:	ba 08 00 00 00       	mov    $0x8,%edx
  8004215d0e:	48 89 cf             	mov    %rcx,%rdi
  8004215d11:	ff d0                	callq  *%rax
  8004215d13:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004215d17:	eb 07                	jmp    8004215d20 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004215d19:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004215d20:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215d24:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215d28:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004215d2f:	48 29 c2             	sub    %rax,%rdx
  8004215d32:	48 89 d0             	mov    %rdx,%rax
  8004215d35:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004215d39:	73 0a                	jae    8004215d45 <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004215d3b:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004215d40:	e9 a8 03 00 00       	jmpq   80042160ed <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004215d45:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215d49:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215d4d:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004215d50:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004215d57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215d5b:	48 01 d0             	add    %rdx,%rax
  8004215d5e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004215d62:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215d69:	00 00 00 
  8004215d6c:	48 8b 00             	mov    (%rax),%rax
  8004215d6f:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215d73:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215d77:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215d7b:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215d82:	ba 02 00 00 00       	mov    $0x2,%edx
  8004215d87:	48 89 cf             	mov    %rcx,%rdi
  8004215d8a:	ff d0                	callq  *%rax
  8004215d8c:	89 c2                	mov    %eax,%edx
  8004215d8e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215d92:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004215d96:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215d9d:	00 00 00 
  8004215da0:	48 8b 00             	mov    (%rax),%rax
  8004215da3:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215da7:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215dab:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215daf:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004215db2:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215db9:	48 89 cf             	mov    %rcx,%rdi
  8004215dbc:	ff d0                	callq  *%rax
  8004215dbe:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004215dc2:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  8004215dc6:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004215dcd:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004215dd1:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215dd8:	00 00 00 
  8004215ddb:	48 8b 00             	mov    (%rax),%rax
  8004215dde:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215de2:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215de6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215dea:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215df1:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215df6:	48 89 cf             	mov    %rcx,%rdi
  8004215df9:	ff d0                	callq  *%rax
  8004215dfb:	89 c2                	mov    %eax,%edx
  8004215dfd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215e01:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004215e04:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215e0b:	00 00 00 
  8004215e0e:	48 8b 00             	mov    (%rax),%rax
  8004215e11:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215e15:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215e19:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215e1d:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215e24:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215e29:	48 89 cf             	mov    %rcx,%rdi
  8004215e2c:	ff d0                	callq  *%rax
  8004215e2e:	89 c2                	mov    %eax,%edx
  8004215e30:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215e34:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004215e37:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215e3e:	00 00 00 
  8004215e41:	48 8b 00             	mov    (%rax),%rax
  8004215e44:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215e48:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215e4c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215e50:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215e57:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215e5c:	48 89 cf             	mov    %rcx,%rdi
  8004215e5f:	ff d0                	callq  *%rax
  8004215e61:	89 c2                	mov    %eax,%edx
  8004215e63:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215e67:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004215e6a:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215e71:	00 00 00 
  8004215e74:	48 8b 00             	mov    (%rax),%rax
  8004215e77:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215e7b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215e7f:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215e83:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215e8a:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215e8f:	48 89 cf             	mov    %rcx,%rdi
  8004215e92:	ff d0                	callq  *%rax
  8004215e94:	89 c2                	mov    %eax,%edx
  8004215e96:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215e9a:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004215e9d:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215ea4:	00 00 00 
  8004215ea7:	48 8b 00             	mov    (%rax),%rax
  8004215eaa:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215eae:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215eb2:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215eb6:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215ebd:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215ec2:	48 89 cf             	mov    %rcx,%rdi
  8004215ec5:	ff d0                	callq  *%rax
  8004215ec7:	89 c2                	mov    %eax,%edx
  8004215ec9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215ecd:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004215ed0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215ed4:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215ed8:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004215edb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215edf:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215ee3:	0f b6 c0             	movzbl %al,%eax
  8004215ee6:	83 e8 01             	sub    $0x1,%eax
  8004215ee9:	39 c2                	cmp    %eax,%edx
  8004215eeb:	7d 0c                	jge    8004215ef9 <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004215eed:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004215ef4:	e9 f1 01 00 00       	jmpq   80042160ea <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  8004215ef9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215efd:	48 bb 20 f6 3a 04 80 	movabs $0x80043af620,%rbx
  8004215f04:	00 00 00 
  8004215f07:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004215f0b:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004215f12:	eb 41                	jmp    8004215f55 <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004215f14:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215f18:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215f1c:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004215f1f:	48 98                	cltq   
  8004215f21:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004215f25:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  8004215f2c:	00 00 00 
  8004215f2f:	48 8b 00             	mov    (%rax),%rax
  8004215f32:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215f36:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215f3a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004215f3e:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004215f45:	ba 01 00 00 00       	mov    $0x1,%edx
  8004215f4a:	48 89 cf             	mov    %rcx,%rdi
  8004215f4d:	ff d0                	callq  *%rax
  8004215f4f:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004215f51:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004215f55:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215f59:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004215f5d:	0f b6 c0             	movzbl %al,%eax
  8004215f60:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004215f63:	7f af                	jg     8004215f14 <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004215f65:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004215f6c:	00 
	p = ds->ds_data + offset;
  8004215f6d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215f71:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004215f75:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004215f7c:	48 01 d0             	add    %rdx,%rax
  8004215f7f:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  8004215f86:	eb 1f                	jmp    8004215fa7 <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  8004215f88:	90                   	nop
  8004215f89:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215f90:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004215f94:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004215f9b:	0f b6 00             	movzbl (%rax),%eax
  8004215f9e:	84 c0                	test   %al,%al
  8004215fa0:	75 e7                	jne    8004215f89 <_dwarf_lineno_init+0x406>
			;
		length++;
  8004215fa2:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004215fa7:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215fae:	0f b6 00             	movzbl (%rax),%eax
  8004215fb1:	84 c0                	test   %al,%al
  8004215fb3:	75 d3                	jne    8004215f88 <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004215fb5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004215fb9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215fbd:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004215fc1:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215fc8:	48 89 c2             	mov    %rax,%rdx
  8004215fcb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215fcf:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215fd3:	48 29 c2             	sub    %rax,%rdx
  8004215fd6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215fda:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215fde:	48 98                	cltq   
  8004215fe0:	48 39 c2             	cmp    %rax,%rdx
  8004215fe3:	7e 0c                	jle    8004215ff1 <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004215fe5:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004215fec:	e9 f9 00 00 00       	jmpq   80042160ea <_dwarf_lineno_init+0x567>
  li->li_incdirs[i++] = (char *) p;
  while (*p++ != '\0')
  ;
  }
*/
	p++;
  8004215ff1:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004215ff8:	48 83 c0 01          	add    $0x1,%rax
  8004215ffc:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004216003:	eb 3c                	jmp    8004216041 <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004216005:	48 b8 68 36 23 04 80 	movabs $0x8004233668,%rax
  800421600c:	00 00 00 
  800421600f:	48 8b 08             	mov    (%rax),%rcx
  8004216012:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004216019:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004216020:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216024:	49 89 c8             	mov    %rcx,%r8
  8004216027:	48 89 d1             	mov    %rdx,%rcx
  800421602a:	ba 00 00 00 00       	mov    $0x0,%edx
  800421602f:	48 89 c7             	mov    %rax,%rdi
  8004216032:	48 b8 df 5a 21 04 80 	movabs $0x8004215adf,%rax
  8004216039:	00 00 00 
  800421603c:	ff d0                	callq  *%rax
  800421603e:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004216041:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216048:	0f b6 00             	movzbl (%rax),%eax
  800421604b:	84 c0                	test   %al,%al
  800421604d:	75 b6                	jne    8004216005 <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  800421604f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216056:	48 83 c0 01          	add    $0x1,%rax
  800421605a:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004216061:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004216068:	48 89 c2             	mov    %rax,%rdx
  800421606b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421606f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216073:	48 29 c2             	sub    %rax,%rdx
  8004216076:	48 89 d0             	mov    %rdx,%rax
  8004216079:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  800421607d:	48 89 c2             	mov    %rax,%rdx
  8004216080:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004216084:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216088:	48 39 c2             	cmp    %rax,%rdx
  800421608b:	74 09                	je     8004216096 <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  800421608d:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004216094:	eb 54                	jmp    80042160ea <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004216096:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421609a:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421609e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042160a2:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042160a6:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  80042160ad:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  80042160b4:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  80042160bb:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  80042160bf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042160c3:	4d 89 c1             	mov    %r8,%r9
  80042160c6:	49 89 f8             	mov    %rdi,%r8
  80042160c9:	48 89 c7             	mov    %rax,%rdi
  80042160cc:	48 b8 27 55 21 04 80 	movabs $0x8004215527,%rax
  80042160d3:	00 00 00 
  80042160d6:	ff d0                	callq  *%rax
  80042160d8:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  80042160db:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042160df:	74 02                	je     80042160e3 <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  80042160e1:	eb 07                	jmp    80042160ea <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  80042160e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042160e8:	eb 03                	jmp    80042160ed <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  80042160ea:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  80042160ed:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  80042160f4:	5b                   	pop    %rbx
  80042160f5:	5d                   	pop    %rbp
  80042160f6:	c3                   	retq   

00000080042160f7 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  80042160f7:	55                   	push   %rbp
  80042160f8:	48 89 e5             	mov    %rsp,%rbp
  80042160fb:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004216102:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004216109:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004216110:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004216117:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  800421611e:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004216125:	00 
  8004216126:	75 35                	jne    800421615d <dwarf_srclines+0x66>
  8004216128:	48 b9 ff f9 21 04 80 	movabs $0x800421f9ff,%rcx
  800421612f:	00 00 00 
  8004216132:	48 ba c7 f9 21 04 80 	movabs $0x800421f9c7,%rdx
  8004216139:	00 00 00 
  800421613c:	be ae 01 00 00       	mov    $0x1ae,%esi
  8004216141:	48 bf dc f9 21 04 80 	movabs $0x800421f9dc,%rdi
  8004216148:	00 00 00 
  800421614b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216150:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004216157:	00 00 00 
  800421615a:	41 ff d0             	callq  *%r8
	assert(linebuf);
  800421615d:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004216164:	00 
  8004216165:	75 35                	jne    800421619c <dwarf_srclines+0xa5>
  8004216167:	48 b9 03 fa 21 04 80 	movabs $0x800421fa03,%rcx
  800421616e:	00 00 00 
  8004216171:	48 ba c7 f9 21 04 80 	movabs $0x800421f9c7,%rdx
  8004216178:	00 00 00 
  800421617b:	be af 01 00 00       	mov    $0x1af,%esi
  8004216180:	48 bf dc f9 21 04 80 	movabs $0x800421f9dc,%rdi
  8004216187:	00 00 00 
  800421618a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421618f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004216196:	00 00 00 
  8004216199:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  800421619c:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  80042161a3:	ba 88 00 00 00       	mov    $0x88,%edx
  80042161a8:	be 00 00 00 00       	mov    $0x0,%esi
  80042161ad:	48 89 c7             	mov    %rax,%rdi
  80042161b0:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  80042161b7:	00 00 00 
  80042161ba:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  80042161bc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042161c3:	be 10 00 00 00       	mov    $0x10,%esi
  80042161c8:	48 89 c7             	mov    %rax,%rdi
  80042161cb:	48 b8 c1 2a 21 04 80 	movabs $0x8004212ac1,%rax
  80042161d2:	00 00 00 
  80042161d5:	ff d0                	callq  *%rax
  80042161d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042161db:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042161e0:	75 0a                	jne    80042161ec <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  80042161e2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042161e7:	e9 84 00 00 00       	jmpq   8004216270 <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  80042161ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042161f0:	48 8b 70 28          	mov    0x28(%rax),%rsi
  80042161f4:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  80042161fb:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  8004216202:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  8004216209:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004216210:	49 89 f8             	mov    %rdi,%r8
  8004216213:	48 89 c7             	mov    %rax,%rdi
  8004216216:	48 b8 83 5b 21 04 80 	movabs $0x8004215b83,%rax
  800421621d:	00 00 00 
  8004216220:	ff d0                	callq  *%rax
  8004216222:	85 c0                	test   %eax,%eax
  8004216224:	74 07                	je     800421622d <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004216226:	b8 01 00 00 00       	mov    $0x1,%eax
  800421622b:	eb 43                	jmp    8004216270 <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  800421622d:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004216234:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004216238:	48 89 10             	mov    %rdx,(%rax)
  800421623b:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421623f:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004216243:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004216247:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421624b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421624f:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004216253:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004216257:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421625b:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421625f:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004216263:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216267:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  800421626b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216270:	c9                   	leaveq 
  8004216271:	c3                   	retq   

0000008004216272 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004216272:	55                   	push   %rbp
  8004216273:	48 89 e5             	mov    %rsp,%rbp
  8004216276:	48 83 ec 20          	sub    $0x20,%rsp
  800421627a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  800421627e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004216285:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004216286:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421628d:	eb 57                	jmp    80042162e6 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  800421628f:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216296:	00 00 00 
  8004216299:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421629c:	48 63 d2             	movslq %edx,%rdx
  800421629f:	48 c1 e2 05          	shl    $0x5,%rdx
  80042162a3:	48 01 d0             	add    %rdx,%rax
  80042162a6:	48 8b 00             	mov    (%rax),%rax
  80042162a9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042162ad:	48 89 d6             	mov    %rdx,%rsi
  80042162b0:	48 89 c7             	mov    %rax,%rdi
  80042162b3:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  80042162ba:	00 00 00 
  80042162bd:	ff d0                	callq  *%rax
  80042162bf:	85 c0                	test   %eax,%eax
  80042162c1:	75 1f                	jne    80042162e2 <_dwarf_find_section+0x70>
			ret = (section_info + i);
  80042162c3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042162c6:	48 98                	cltq   
  80042162c8:	48 c1 e0 05          	shl    $0x5,%rax
  80042162cc:	48 89 c2             	mov    %rax,%rdx
  80042162cf:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042162d6:	00 00 00 
  80042162d9:	48 01 d0             	add    %rdx,%rax
  80042162dc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  80042162e0:	eb 0a                	jmp    80042162ec <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042162e2:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042162e6:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042162ea:	7e a3                	jle    800421628f <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  80042162ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042162f0:	c9                   	leaveq 
  80042162f1:	c3                   	retq   

00000080042162f2 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  80042162f2:	55                   	push   %rbp
  80042162f3:	48 89 e5             	mov    %rsp,%rbp
  80042162f6:	48 83 ec 40          	sub    $0x40,%rsp
  80042162fa:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  80042162fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216302:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  8004216306:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  800421630d:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  800421630e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216312:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004216316:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421631a:	48 01 d0             	add    %rdx,%rax
  800421631d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004216321:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216325:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  8004216329:	0f b7 c0             	movzwl %ax,%eax
  800421632c:	48 c1 e0 06          	shl    $0x6,%rax
  8004216330:	48 89 c2             	mov    %rax,%rdx
  8004216333:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216337:	48 01 d0             	add    %rdx,%rax
  800421633a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  800421633e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216342:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004216346:	0f b7 c0             	movzwl %ax,%eax
  8004216349:	48 c1 e0 06          	shl    $0x6,%rax
  800421634d:	48 89 c2             	mov    %rax,%rdx
  8004216350:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216354:	48 01 d0             	add    %rdx,%rax
  8004216357:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  800421635b:	e9 4b 02 00 00       	jmpq   80042165ab <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004216360:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216364:	8b 00                	mov    (%rax),%eax
  8004216366:	89 c2                	mov    %eax,%edx
  8004216368:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421636c:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004216370:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216374:	48 01 c8             	add    %rcx,%rax
  8004216377:	48 01 d0             	add    %rdx,%rax
  800421637a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  800421637e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216382:	48 be 0b fa 21 04 80 	movabs $0x800421fa0b,%rsi
  8004216389:	00 00 00 
  800421638c:	48 89 c7             	mov    %rax,%rdi
  800421638f:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  8004216396:	00 00 00 
  8004216399:	ff d0                	callq  *%rax
  800421639b:	85 c0                	test   %eax,%eax
  800421639d:	75 4b                	jne    80042163ea <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  800421639f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042163a3:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042163aa:	00 00 00 
  80042163ad:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  80042163b1:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042163b8:	00 00 00 
  80042163bb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042163bf:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  80042163c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042163c7:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042163cb:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042163d2:	00 00 00 
  80042163d5:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  80042163d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042163dd:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042163e1:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042163e5:	e9 bc 01 00 00       	jmpq   80042165a6 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  80042163ea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042163ee:	48 be 17 fa 21 04 80 	movabs $0x800421fa17,%rsi
  80042163f5:	00 00 00 
  80042163f8:	48 89 c7             	mov    %rax,%rdi
  80042163fb:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  8004216402:	00 00 00 
  8004216405:	ff d0                	callq  *%rax
  8004216407:	85 c0                	test   %eax,%eax
  8004216409:	75 4b                	jne    8004216456 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  800421640b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421640f:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216416:	00 00 00 
  8004216419:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  800421641d:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216424:	00 00 00 
  8004216427:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421642b:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  800421642f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216433:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216437:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  800421643e:	00 00 00 
  8004216441:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  8004216445:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216449:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421644d:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004216451:	e9 50 01 00 00       	jmpq   80042165a6 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004216456:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421645a:	48 be 2f fa 21 04 80 	movabs $0x800421fa2f,%rsi
  8004216461:	00 00 00 
  8004216464:	48 89 c7             	mov    %rax,%rdi
  8004216467:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  800421646e:	00 00 00 
  8004216471:	ff d0                	callq  *%rax
  8004216473:	85 c0                	test   %eax,%eax
  8004216475:	75 4b                	jne    80042164c2 <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004216477:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421647b:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216482:	00 00 00 
  8004216485:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  8004216489:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216490:	00 00 00 
  8004216493:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004216497:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  800421649b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421649f:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042164a3:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042164aa:	00 00 00 
  80042164ad:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  80042164b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042164b5:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042164b9:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042164bd:	e9 e4 00 00 00       	jmpq   80042165a6 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  80042164c2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042164c6:	48 be 25 fa 21 04 80 	movabs $0x800421fa25,%rsi
  80042164cd:	00 00 00 
  80042164d0:	48 89 c7             	mov    %rax,%rdi
  80042164d3:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  80042164da:	00 00 00 
  80042164dd:	ff d0                	callq  *%rax
  80042164df:	85 c0                	test   %eax,%eax
  80042164e1:	75 53                	jne    8004216536 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  80042164e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042164e7:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042164eb:	48 89 c2             	mov    %rax,%rdx
  80042164ee:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042164f5:	00 00 00 
  80042164f8:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  80042164fc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216500:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004216504:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  800421650b:	00 00 00 
  800421650e:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004216512:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216516:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421651a:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216521:	00 00 00 
  8004216524:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004216528:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421652c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004216530:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004216534:	eb 70                	jmp    80042165a6 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004216536:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421653a:	48 be 3b fa 21 04 80 	movabs $0x800421fa3b,%rsi
  8004216541:	00 00 00 
  8004216544:	48 89 c7             	mov    %rax,%rdi
  8004216547:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  800421654e:	00 00 00 
  8004216551:	ff d0                	callq  *%rax
  8004216553:	85 c0                	test   %eax,%eax
  8004216555:	75 4f                	jne    80042165a6 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004216557:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421655b:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216562:	00 00 00 
  8004216565:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  800421656c:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216573:	00 00 00 
  8004216576:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421657a:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004216581:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216585:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216589:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216590:	00 00 00 
  8004216593:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  800421659a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421659e:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042165a2:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  80042165a6:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  80042165ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042165af:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042165b3:	0f 82 a7 fd ff ff    	jb     8004216360 <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  80042165b9:	c9                   	leaveq 
  80042165ba:	c3                   	retq   

00000080042165bb <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  80042165bb:	55                   	push   %rbp
  80042165bc:	48 89 e5             	mov    %rsp,%rbp
  80042165bf:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  80042165c6:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  80042165cd:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  80042165d4:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  80042165db:	b8 00 00 00 00       	mov    $0x0,%eax
  80042165e0:	ba 14 00 00 00       	mov    $0x14,%edx
  80042165e5:	48 89 f7             	mov    %rsi,%rdi
  80042165e8:	48 89 d1             	mov    %rdx,%rcx
  80042165eb:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  80042165ee:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  80042165f5:	00 
  80042165f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042165fa:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  8004216601:	48 01 d0             	add    %rdx,%rax
  8004216604:	48 83 e8 01          	sub    $0x1,%rax
  8004216608:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421660c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216610:	ba 00 00 00 00       	mov    $0x0,%edx
  8004216615:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004216619:	48 89 d0             	mov    %rdx,%rax
  800421661c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004216620:	48 29 c2             	sub    %rax,%rdx
  8004216623:	48 89 d0             	mov    %rdx,%rax
  8004216626:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  800421662a:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004216631:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004216635:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216639:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  800421663d:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004216644:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004216645:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800421664c:	00 00 00 
  800421664f:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004216656:	75 11                	jne    8004216669 <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004216658:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421665f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004216663:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216667:	eb 26                	jmp    800421668f <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  8004216669:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216670:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004216674:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421667b:	48 01 c2             	add    %rax,%rdx
  800421667e:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004216685:	ff ff ff 
  8004216688:	48 01 d0             	add    %rdx,%rax
  800421668b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  800421668f:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004216696:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  800421669a:	0f b7 c0             	movzwl %ax,%eax
  800421669d:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  80042166a0:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042166a7:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  80042166ab:	0f b7 c0             	movzwl %ax,%eax
  80042166ae:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  80042166b1:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042166b8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  80042166bc:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042166bf:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  80042166c3:	48 63 f0             	movslq %eax,%rsi
  80042166c6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042166ca:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042166d1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042166d5:	48 89 c7             	mov    %rax,%rdi
  80042166d8:	48 b8 fa 6c 21 04 80 	movabs $0x8004216cfa,%rax
  80042166df:	00 00 00 
  80042166e2:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  80042166e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042166e8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042166ec:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042166f0:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042166f6:	48 89 c2             	mov    %rax,%rdx
  80042166f9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042166fd:	48 29 d0             	sub    %rdx,%rax
  8004216700:	48 89 c2             	mov    %rax,%rdx
  8004216703:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216707:	48 01 d0             	add    %rdx,%rax
  800421670a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  800421670e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004216715:	eb 24                	jmp    800421673b <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004216717:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421671a:	48 98                	cltq   
  800421671c:	48 c1 e0 06          	shl    $0x6,%rax
  8004216720:	48 89 c2             	mov    %rax,%rdx
  8004216723:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004216727:	48 01 c2             	add    %rax,%rdx
  800421672a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421672d:	48 98                	cltq   
  800421672f:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004216736:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004216737:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421673b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421673e:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004216741:	7c d4                	jl     8004216717 <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004216743:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004216747:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  800421674b:	0f b7 c0             	movzwl %ax,%eax
  800421674e:	48 98                	cltq   
  8004216750:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216757:	ff 
  8004216758:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  800421675c:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216763:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004216767:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421676b:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421676f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216773:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004216777:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421677e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216782:	48 01 c8             	add    %rcx,%rax
  8004216785:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421678c:	48 89 c7             	mov    %rax,%rdi
  800421678f:	48 b8 fa 6c 21 04 80 	movabs $0x8004216cfa,%rax
  8004216796:	00 00 00 
  8004216799:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  800421679b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421679f:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042167a3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042167a7:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042167ab:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042167af:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042167b3:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042167b9:	48 29 c2             	sub    %rax,%rdx
  80042167bc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042167c0:	48 01 c2             	add    %rax,%rdx
  80042167c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042167c7:	48 01 d0             	add    %rdx,%rax
  80042167ca:	48 89 45 90          	mov    %rax,-0x70(%rbp)

    
	for (i = 0; i < numSectionHeaders; i++)
  80042167ce:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042167d5:	e9 04 05 00 00       	jmpq   8004216cde <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  80042167da:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042167dd:	48 98                	cltq   
  80042167df:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042167e6:	ff 
  80042167e7:	8b 00                	mov    (%rax),%eax
  80042167e9:	89 c2                	mov    %eax,%edx
  80042167eb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042167ef:	48 01 d0             	add    %rdx,%rax
  80042167f2:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  80042167f6:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042167fd:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004216802:	48 85 c0             	test   %rax,%rax
  8004216805:	74 35                	je     800421683c <read_section_headers+0x281>
  8004216807:	48 b9 46 fa 21 04 80 	movabs $0x800421fa46,%rcx
  800421680e:	00 00 00 
  8004216811:	48 ba 5f fa 21 04 80 	movabs $0x800421fa5f,%rdx
  8004216818:	00 00 00 
  800421681b:	be 87 00 00 00       	mov    $0x87,%esi
  8004216820:	48 bf 74 fa 21 04 80 	movabs $0x800421fa74,%rdi
  8004216827:	00 00 00 
  800421682a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421682f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004216836:	00 00 00 
  8004216839:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  800421683c:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216843:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004216847:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421684b:	48 be 0b fa 21 04 80 	movabs $0x800421fa0b,%rsi
  8004216852:	00 00 00 
  8004216855:	48 89 c7             	mov    %rax,%rdi
  8004216858:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  800421685f:	00 00 00 
  8004216862:	ff d0                	callq  *%rax
  8004216864:	85 c0                	test   %eax,%eax
  8004216866:	0f 85 d8 00 00 00    	jne    8004216944 <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421686c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421686f:	48 98                	cltq   
  8004216871:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216878:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216879:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421687d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216880:	48 98                	cltq   
  8004216882:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216889:	ff 
  800421688a:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421688e:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004216895:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216899:	48 01 c8             	add    %rcx,%rax
  800421689c:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042168a3:	48 89 c7             	mov    %rax,%rdi
  80042168a6:	48 b8 fa 6c 21 04 80 	movabs $0x8004216cfa,%rax
  80042168ad:	00 00 00 
  80042168b0:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042168b2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042168b5:	48 98                	cltq   
  80042168b7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042168be:	ff 
  80042168bf:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042168c3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042168c6:	48 98                	cltq   
  80042168c8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042168cf:	ff 
  80042168d0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042168d4:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042168d8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042168dc:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042168e2:	48 29 c2             	sub    %rax,%rdx
  80042168e5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042168e9:	48 01 c2             	add    %rax,%rdx
  80042168ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042168f0:	48 01 c2             	add    %rax,%rdx
  80042168f3:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042168fa:	00 00 00 
  80042168fd:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  8004216901:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216908:	00 00 00 
  800421690b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421690f:	48 89 c2             	mov    %rax,%rdx
  8004216912:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216919:	00 00 00 
  800421691c:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004216920:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216923:	48 98                	cltq   
  8004216925:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421692c:	ff 
  800421692d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216931:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216938:	00 00 00 
  800421693b:	48 89 50 18          	mov    %rdx,0x18(%rax)
  800421693f:	e9 96 03 00 00       	jmpq   8004216cda <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004216944:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216948:	48 be 17 fa 21 04 80 	movabs $0x800421fa17,%rsi
  800421694f:	00 00 00 
  8004216952:	48 89 c7             	mov    %rax,%rdi
  8004216955:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  800421695c:	00 00 00 
  800421695f:	ff d0                	callq  *%rax
  8004216961:	85 c0                	test   %eax,%eax
  8004216963:	0f 85 de 00 00 00    	jne    8004216a47 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216969:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421696c:	48 98                	cltq   
  800421696e:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216975:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216976:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421697a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421697d:	48 98                	cltq   
  800421697f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216986:	ff 
  8004216987:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421698b:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004216992:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216996:	48 01 c8             	add    %rcx,%rax
  8004216999:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042169a0:	48 89 c7             	mov    %rax,%rdi
  80042169a3:	48 b8 fa 6c 21 04 80 	movabs $0x8004216cfa,%rax
  80042169aa:	00 00 00 
  80042169ad:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042169af:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042169b2:	48 98                	cltq   
  80042169b4:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042169bb:	ff 
  80042169bc:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042169c0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042169c3:	48 98                	cltq   
  80042169c5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042169cc:	ff 
  80042169cd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042169d1:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042169d8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042169df:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042169e5:	48 29 c2             	sub    %rax,%rdx
  80042169e8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042169ec:	48 01 c2             	add    %rax,%rdx
  80042169ef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042169f3:	48 01 c2             	add    %rax,%rdx
  80042169f6:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  80042169fd:	00 00 00 
  8004216a00:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  8004216a04:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216a0b:	00 00 00 
  8004216a0e:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004216a12:	48 89 c2             	mov    %rax,%rdx
  8004216a15:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216a1c:	00 00 00 
  8004216a1f:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004216a23:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216a26:	48 98                	cltq   
  8004216a28:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216a2f:	ff 
  8004216a30:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216a34:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216a3b:	00 00 00 
  8004216a3e:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004216a42:	e9 93 02 00 00       	jmpq   8004216cda <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004216a47:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216a4b:	48 be 2f fa 21 04 80 	movabs $0x800421fa2f,%rsi
  8004216a52:	00 00 00 
  8004216a55:	48 89 c7             	mov    %rax,%rdi
  8004216a58:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  8004216a5f:	00 00 00 
  8004216a62:	ff d0                	callq  *%rax
  8004216a64:	85 c0                	test   %eax,%eax
  8004216a66:	0f 85 de 00 00 00    	jne    8004216b4a <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216a6c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216a6f:	48 98                	cltq   
  8004216a71:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216a78:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216a79:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216a7d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216a80:	48 98                	cltq   
  8004216a82:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216a89:	ff 
  8004216a8a:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004216a8e:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004216a95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216a99:	48 01 c8             	add    %rcx,%rax
  8004216a9c:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216aa3:	48 89 c7             	mov    %rax,%rdi
  8004216aa6:	48 b8 fa 6c 21 04 80 	movabs $0x8004216cfa,%rax
  8004216aad:	00 00 00 
  8004216ab0:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004216ab2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216ab5:	48 98                	cltq   
  8004216ab7:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216abe:	ff 
  8004216abf:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216ac3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216ac6:	48 98                	cltq   
  8004216ac8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216acf:	ff 
  8004216ad0:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216ad4:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004216adb:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004216ae2:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216ae8:	48 29 c2             	sub    %rax,%rdx
  8004216aeb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216aef:	48 01 c2             	add    %rax,%rdx
  8004216af2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216af6:	48 01 c2             	add    %rax,%rdx
  8004216af9:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216b00:	00 00 00 
  8004216b03:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  8004216b07:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216b0e:	00 00 00 
  8004216b11:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004216b15:	48 89 c2             	mov    %rax,%rdx
  8004216b18:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216b1f:	00 00 00 
  8004216b22:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004216b26:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216b29:	48 98                	cltq   
  8004216b2b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216b32:	ff 
  8004216b33:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216b37:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216b3e:	00 00 00 
  8004216b41:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004216b45:	e9 90 01 00 00       	jmpq   8004216cda <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004216b4a:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216b4e:	48 be 25 fa 21 04 80 	movabs $0x800421fa25,%rsi
  8004216b55:	00 00 00 
  8004216b58:	48 89 c7             	mov    %rax,%rdi
  8004216b5b:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  8004216b62:	00 00 00 
  8004216b65:	ff d0                	callq  *%rax
  8004216b67:	85 c0                	test   %eax,%eax
  8004216b69:	75 65                	jne    8004216bd0 <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004216b6b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216b6e:	48 98                	cltq   
  8004216b70:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216b77:	ff 
  8004216b78:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216b7c:	48 89 c2             	mov    %rax,%rdx
  8004216b7f:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216b86:	00 00 00 
  8004216b89:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004216b8d:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216b94:	00 00 00 
  8004216b97:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004216b9b:	48 89 c2             	mov    %rax,%rdx
  8004216b9e:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216ba5:	00 00 00 
  8004216ba8:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004216bac:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216baf:	48 98                	cltq   
  8004216bb1:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216bb8:	ff 
  8004216bb9:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216bbd:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216bc4:	00 00 00 
  8004216bc7:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004216bcb:	e9 0a 01 00 00       	jmpq   8004216cda <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004216bd0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004216bd4:	48 be 3b fa 21 04 80 	movabs $0x800421fa3b,%rsi
  8004216bdb:	00 00 00 
  8004216bde:	48 89 c7             	mov    %rax,%rdi
  8004216be1:	48 b8 55 0a 21 04 80 	movabs $0x8004210a55,%rax
  8004216be8:	00 00 00 
  8004216beb:	ff d0                	callq  *%rax
  8004216bed:	85 c0                	test   %eax,%eax
  8004216bef:	0f 85 e5 00 00 00    	jne    8004216cda <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004216bf5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216bf8:	48 98                	cltq   
  8004216bfa:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216c01:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004216c02:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216c06:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216c09:	48 98                	cltq   
  8004216c0b:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216c12:	ff 
  8004216c13:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004216c17:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004216c1e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c22:	48 01 c8             	add    %rcx,%rax
  8004216c25:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004216c2c:	48 89 c7             	mov    %rax,%rdi
  8004216c2f:	48 b8 fa 6c 21 04 80 	movabs $0x8004216cfa,%rax
  8004216c36:	00 00 00 
  8004216c39:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004216c3b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216c3e:	48 98                	cltq   
  8004216c40:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216c47:	ff 
  8004216c48:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004216c4c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216c4f:	48 98                	cltq   
  8004216c51:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216c58:	ff 
  8004216c59:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004216c5d:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004216c64:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004216c6b:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004216c71:	48 29 c2             	sub    %rax,%rdx
  8004216c74:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216c78:	48 01 c2             	add    %rax,%rdx
  8004216c7b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216c7f:	48 01 c2             	add    %rax,%rdx
  8004216c82:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216c89:	00 00 00 
  8004216c8c:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004216c93:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216c9a:	00 00 00 
  8004216c9d:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004216ca4:	48 89 c2             	mov    %rax,%rdx
  8004216ca7:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216cae:	00 00 00 
  8004216cb1:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004216cb8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216cbb:	48 98                	cltq   
  8004216cbd:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004216cc4:	ff 
  8004216cc5:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004216cc9:	48 b8 a0 36 23 04 80 	movabs $0x80042336a0,%rax
  8004216cd0:	00 00 00 
  8004216cd3:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

    
	for (i = 0; i < numSectionHeaders; i++)
  8004216cda:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216cde:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216ce1:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004216ce4:	0f 8c f0 fa ff ff    	jl     80042167da <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004216cea:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004216cee:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004216cf5:	48 01 d0             	add    %rdx,%rax
}
  8004216cf8:	c9                   	leaveq 
  8004216cf9:	c3                   	retq   

0000008004216cfa <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004216cfa:	55                   	push   %rbp
  8004216cfb:	48 89 e5             	mov    %rsp,%rbp
  8004216cfe:	48 83 ec 30          	sub    $0x30,%rsp
  8004216d02:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004216d06:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004216d0a:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004216d0e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004216d12:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d16:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004216d1a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216d1e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216d22:	48 01 d0             	add    %rdx,%rax
  8004216d25:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004216d29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216d2d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004216d32:	48 85 c0             	test   %rax,%rax
  8004216d35:	74 35                	je     8004216d6c <readseg+0x72>
  8004216d37:	48 b9 82 fa 21 04 80 	movabs $0x800421fa82,%rcx
  8004216d3e:	00 00 00 
  8004216d41:	48 ba 5f fa 21 04 80 	movabs $0x800421fa5f,%rdx
  8004216d48:	00 00 00 
  8004216d4b:	be c1 00 00 00       	mov    $0xc1,%esi
  8004216d50:	48 bf 74 fa 21 04 80 	movabs $0x800421fa74,%rdi
  8004216d57:	00 00 00 
  8004216d5a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216d5f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004216d66:	00 00 00 
  8004216d69:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004216d6c:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004216d73:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004216d74:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d78:	48 c1 e8 09          	shr    $0x9,%rax
  8004216d7c:	48 83 c0 01          	add    $0x1,%rax
  8004216d80:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004216d84:	eb 3c                	jmp    8004216dc2 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004216d86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216d8a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004216d8e:	48 89 d6             	mov    %rdx,%rsi
  8004216d91:	48 89 c7             	mov    %rax,%rdi
  8004216d94:	48 b8 8a 6e 21 04 80 	movabs $0x8004216e8a,%rax
  8004216d9b:	00 00 00 
  8004216d9e:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004216da0:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004216da7:	00 
		*kvoffset += SECTSIZE;
  8004216da8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216dac:	48 8b 00             	mov    (%rax),%rax
  8004216daf:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004216db6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216dba:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004216dbd:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004216dc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216dc6:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004216dca:	72 ba                	jb     8004216d86 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004216dcc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216dd0:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004216dd5:	48 89 c2             	mov    %rax,%rdx
  8004216dd8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216ddc:	48 01 d0             	add    %rdx,%rax
  8004216ddf:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004216de5:	76 2f                	jbe    8004216e16 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004216de7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216deb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004216def:	48 89 d6             	mov    %rdx,%rsi
  8004216df2:	48 89 c7             	mov    %rax,%rdi
  8004216df5:	48 b8 8a 6e 21 04 80 	movabs $0x8004216e8a,%rax
  8004216dfc:	00 00 00 
  8004216dff:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004216e01:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216e05:	48 8b 00             	mov    (%rax),%rax
  8004216e08:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004216e0f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216e13:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004216e16:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216e1a:	48 8b 00             	mov    (%rax),%rax
  8004216e1d:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004216e22:	48 85 c0             	test   %rax,%rax
  8004216e25:	74 35                	je     8004216e5c <readseg+0x162>
  8004216e27:	48 b9 95 fa 21 04 80 	movabs $0x800421fa95,%rcx
  8004216e2e:	00 00 00 
  8004216e31:	48 ba 5f fa 21 04 80 	movabs $0x800421fa5f,%rdx
  8004216e38:	00 00 00 
  8004216e3b:	be d7 00 00 00       	mov    $0xd7,%esi
  8004216e40:	48 bf 74 fa 21 04 80 	movabs $0x800421fa74,%rdi
  8004216e47:	00 00 00 
  8004216e4a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216e4f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004216e56:	00 00 00 
  8004216e59:	41 ff d0             	callq  *%r8
}
  8004216e5c:	c9                   	leaveq 
  8004216e5d:	c3                   	retq   

0000008004216e5e <waitdisk>:

void
waitdisk(void)
{
  8004216e5e:	55                   	push   %rbp
  8004216e5f:	48 89 e5             	mov    %rsp,%rbp
  8004216e62:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004216e66:	90                   	nop
  8004216e67:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004216e6e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216e71:	89 c2                	mov    %eax,%edx
  8004216e73:	ec                   	in     (%dx),%al
  8004216e74:	88 45 fb             	mov    %al,-0x5(%rbp)
    return data;
  8004216e77:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004216e7b:	0f b6 c0             	movzbl %al,%eax
  8004216e7e:	25 c0 00 00 00       	and    $0xc0,%eax
  8004216e83:	83 f8 40             	cmp    $0x40,%eax
  8004216e86:	75 df                	jne    8004216e67 <waitdisk+0x9>
		/* do nothing */;
}
  8004216e88:	c9                   	leaveq 
  8004216e89:	c3                   	retq   

0000008004216e8a <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004216e8a:	55                   	push   %rbp
  8004216e8b:	48 89 e5             	mov    %rsp,%rbp
  8004216e8e:	48 83 ec 60          	sub    $0x60,%rsp
  8004216e92:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004216e96:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004216e9a:	48 b8 5e 6e 21 04 80 	movabs $0x8004216e5e,%rax
  8004216ea1:	00 00 00 
  8004216ea4:	ff d0                	callq  *%rax
  8004216ea6:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004216ead:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004216eb1:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004216eb5:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004216eb8:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004216eb9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216ebd:	0f b6 c0             	movzbl %al,%eax
  8004216ec0:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004216ec7:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004216eca:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004216ece:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004216ed1:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004216ed2:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216ed6:	48 c1 e8 08          	shr    $0x8,%rax
  8004216eda:	0f b6 c0             	movzbl %al,%eax
  8004216edd:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004216ee4:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004216ee7:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004216eeb:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216eee:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004216eef:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216ef3:	48 c1 e8 10          	shr    $0x10,%rax
  8004216ef7:	0f b6 c0             	movzbl %al,%eax
  8004216efa:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004216f01:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004216f04:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004216f08:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004216f0b:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004216f0c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004216f10:	48 c1 e8 18          	shr    $0x18,%rax
  8004216f14:	83 c8 e0             	or     $0xffffffe0,%eax
  8004216f17:	0f b6 c0             	movzbl %al,%eax
  8004216f1a:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004216f21:	88 45 db             	mov    %al,-0x25(%rbp)
  8004216f24:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004216f28:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004216f2b:	ee                   	out    %al,(%dx)
  8004216f2c:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004216f33:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004216f37:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004216f3b:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004216f3e:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004216f3f:	48 b8 5e 6e 21 04 80 	movabs $0x8004216e5e,%rax
  8004216f46:	00 00 00 
  8004216f49:	ff d0                	callq  *%rax
  8004216f4b:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004216f52:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004216f56:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004216f5a:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

    static __inline void
insl(int port, void *addr, int cnt)
{
    __asm __volatile("cld\n\trepne\n\tinsl"			:
  8004216f61:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004216f64:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004216f68:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004216f6b:	48 89 ce             	mov    %rcx,%rsi
  8004216f6e:	48 89 f7             	mov    %rsi,%rdi
  8004216f71:	89 c1                	mov    %eax,%ecx
  8004216f73:	fc                   	cld    
  8004216f74:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004216f76:	89 c8                	mov    %ecx,%eax
  8004216f78:	48 89 fe             	mov    %rdi,%rsi
  8004216f7b:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004216f7f:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004216f82:	c9                   	leaveq 
  8004216f83:	c3                   	retq   
  8004216f84:	0f 1f 40 00          	nopl   0x0(%rax)

0000008004216f88 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004216f88:	fa                   	cli    
	xorw    %ax, %ax
  8004216f89:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004216f8b:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004216f8d:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004216f8f:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004216f91:	0f 01 16             	lgdt   (%rsi)
  8004216f94:	e0 70                	loopne 8004217006 <start64+0x10>
	movl    %cr0, %eax
  8004216f96:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004216f99:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004216f9d:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004216fa0:	ea                   	(bad)  
  8004216fa1:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004216fa5 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004216fa5:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004216fa9:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004216fab:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004216fad:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004216faf:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004216fb3:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004216fb5:	8e e8                	mov    %eax,%gs

#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
  8004216fb7:	b8 20 00 00 00       	mov    $0x20,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
#endif

	movl %eax,%cr4
  8004216fbc:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004216fbf:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421e086 <etext+0xea0>
	movl    %cr0, %eax
  8004216fc6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004216fc9:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004216fcc:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004216fcf:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004216fd4:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004216fd7:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004216fdc:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004216fde:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004216fe2:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004216fe4:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004216fe7:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004216fec:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004216fef:	ea                   	(bad)  
  8004216ff0:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004216ff1:	70 00                	jo     8004216ff3 <start32+0x4e>
  8004216ff3:	00 08                	add    %cl,(%rax)
	...

0000008004216ff6 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004216ff6:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004216ffa:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004216ffc:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004216ffe:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004217000:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004217004:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004217006:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004217008:	48 a1 80 e7 3a 04 80 	movabs 0x80043ae780,%rax
  800421700f:	00 00 00 
	movq    %rax,%rsp
  8004217012:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004217015:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  800421701c:	48 b8 7b 04 20 04 80 	movabs $0x800420047b,%rax
  8004217023:	00 00 00 
	call    *%rax
  8004217026:	ff d0                	callq  *%rax

0000008004217028 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004217028:	eb fe                	jmp    8004217028 <spin>
  800421702a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004217030 <gdt>:
	...
  8004217038:	ff                   	(bad)  
  8004217039:	ff 00                	incl   (%rax)
  800421703b:	00 00                	add    %al,(%rax)
  800421703d:	9a                   	(bad)  
  800421703e:	af                   	scas   %es:(%rdi),%eax
  800421703f:	00 ff                	add    %bh,%bh
  8004217041:	ff 00                	incl   (%rax)
  8004217043:	00 00                	add    %al,(%rax)
  8004217045:	92                   	xchg   %eax,%edx
  8004217046:	af                   	scas   %es:(%rdi),%eax
	...

0000008004217048 <gdtdesc>:
  8004217048:	17                   	(bad)  
  8004217049:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  800421704f:	90                   	nop

0000008004217050 <gdt32>:
	...
  8004217058:	ff                   	(bad)  
  8004217059:	ff 00                	incl   (%rax)
  800421705b:	00 00                	add    %al,(%rax)
  800421705d:	9a                   	(bad)  
  800421705e:	cf                   	iret   
  800421705f:	00 ff                	add    %bh,%bh
  8004217061:	ff 00                	incl   (%rax)
  8004217063:	00 00                	add    %al,(%rax)
  8004217065:	92                   	xchg   %eax,%edx
  8004217066:	cf                   	iret   
	...

0000008004217068 <gdt32desc>:
  8004217068:	17                   	(bad)  
  8004217069:	00 c8                	add    %cl,%al
  800421706b:	70 00                	jo     800421706d <gdt32desc+0x5>
	...

000000800421706e <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  800421706e:	90                   	nop

000000800421706f <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  800421706f:	55                   	push   %rbp
  8004217070:	48 89 e5             	mov    %rsp,%rbp
  8004217073:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004217077:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421707b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  800421707e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004217085:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421708c:	eb 1a                	jmp    80042170a8 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  800421708e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217091:	48 63 d0             	movslq %eax,%rdx
  8004217094:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217098:	48 01 d0             	add    %rdx,%rax
  800421709b:	0f b6 00             	movzbl (%rax),%eax
  800421709e:	0f b6 c0             	movzbl %al,%eax
  80042170a1:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  80042170a4:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042170a8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042170ab:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042170ae:	7c de                	jl     800421708e <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  80042170b0:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  80042170b3:	c9                   	leaveq 
  80042170b4:	c3                   	retq   

00000080042170b5 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  80042170b5:	55                   	push   %rbp
  80042170b6:	48 89 e5             	mov    %rsp,%rbp
  80042170b9:	48 83 ec 40          	sub    $0x40,%rsp
  80042170bd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042170c1:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  80042170c4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042170c8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042170cc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042170d0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042170d4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042170d7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042170da:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042170e1:	00 00 00 
  80042170e4:	48 8b 00             	mov    (%rax),%rax
  80042170e7:	48 39 c2             	cmp    %rax,%rdx
  80042170ea:	72 32                	jb     800421711e <mpsearch1+0x69>
  80042170ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042170f0:	48 89 c1             	mov    %rax,%rcx
  80042170f3:	48 ba b0 fa 21 04 80 	movabs $0x800421fab0,%rdx
  80042170fa:	00 00 00 
  80042170fd:	be 58 00 00 00       	mov    $0x58,%esi
  8004217102:	48 bf d3 fa 21 04 80 	movabs $0x800421fad3,%rdi
  8004217109:	00 00 00 
  800421710c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217111:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004217118:	00 00 00 
  800421711b:	41 ff d0             	callq  *%r8
  800421711e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004217125:	00 00 00 
  8004217128:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421712c:	48 01 d0             	add    %rdx,%rax
  800421712f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004217133:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004217136:	48 63 d0             	movslq %eax,%rdx
  8004217139:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421713d:	48 01 d0             	add    %rdx,%rax
  8004217140:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004217144:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217148:	48 c1 e8 0c          	shr    $0xc,%rax
  800421714c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421714f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004217152:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004217159:	00 00 00 
  800421715c:	48 8b 00             	mov    (%rax),%rax
  800421715f:	48 39 c2             	cmp    %rax,%rdx
  8004217162:	72 32                	jb     8004217196 <mpsearch1+0xe1>
  8004217164:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217168:	48 89 c1             	mov    %rax,%rcx
  800421716b:	48 ba b0 fa 21 04 80 	movabs $0x800421fab0,%rdx
  8004217172:	00 00 00 
  8004217175:	be 58 00 00 00       	mov    $0x58,%esi
  800421717a:	48 bf d3 fa 21 04 80 	movabs $0x800421fad3,%rdi
  8004217181:	00 00 00 
  8004217184:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217189:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004217190:	00 00 00 
  8004217193:	41 ff d0             	callq  *%r8
  8004217196:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421719d:	00 00 00 
  80042171a0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042171a4:	48 01 d0             	add    %rdx,%rax
  80042171a7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  80042171ab:	eb 4d                	jmp    80042171fa <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042171ad:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042171b1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042171b6:	48 be e3 fa 21 04 80 	movabs $0x800421fae3,%rsi
  80042171bd:	00 00 00 
  80042171c0:	48 89 c7             	mov    %rax,%rdi
  80042171c3:	48 b8 62 0d 21 04 80 	movabs $0x8004210d62,%rax
  80042171ca:	00 00 00 
  80042171cd:	ff d0                	callq  *%rax
  80042171cf:	85 c0                	test   %eax,%eax
  80042171d1:	75 22                	jne    80042171f5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  80042171d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042171d7:	be 10 00 00 00       	mov    $0x10,%esi
  80042171dc:	48 89 c7             	mov    %rax,%rdi
  80042171df:	48 b8 6f 70 21 04 80 	movabs $0x800421706f,%rax
  80042171e6:	00 00 00 
  80042171e9:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042171eb:	84 c0                	test   %al,%al
  80042171ed:	75 06                	jne    80042171f5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  80042171ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042171f3:	eb 14                	jmp    8004217209 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  80042171f5:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  80042171fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042171fe:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004217202:	72 a9                	jb     80042171ad <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  8004217204:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217209:	c9                   	leaveq 
  800421720a:	c3                   	retq   

000000800421720b <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  800421720b:	55                   	push   %rbp
  800421720c:	48 89 e5             	mov    %rsp,%rbp
  800421720f:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004217213:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800421721a:	00 
  800421721b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421721f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217223:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004217226:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004217229:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004217230:	00 00 00 
  8004217233:	48 8b 00             	mov    (%rax),%rax
  8004217236:	48 39 c2             	cmp    %rax,%rdx
  8004217239:	72 32                	jb     800421726d <mpsearch+0x62>
  800421723b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421723f:	48 89 c1             	mov    %rax,%rcx
  8004217242:	48 ba b0 fa 21 04 80 	movabs $0x800421fab0,%rdx
  8004217249:	00 00 00 
  800421724c:	be 70 00 00 00       	mov    $0x70,%esi
  8004217251:	48 bf d3 fa 21 04 80 	movabs $0x800421fad3,%rdi
  8004217258:	00 00 00 
  800421725b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217260:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004217267:	00 00 00 
  800421726a:	41 ff d0             	callq  *%r8
  800421726d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004217274:	00 00 00 
  8004217277:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421727b:	48 01 d0             	add    %rdx,%rax
  800421727e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004217282:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217286:	48 83 c0 0e          	add    $0xe,%rax
  800421728a:	0f b7 00             	movzwl (%rax),%eax
  800421728d:	0f b7 c0             	movzwl %ax,%eax
  8004217290:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004217293:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004217297:	74 2c                	je     80042172c5 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004217299:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  800421729d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042172a0:	be 00 04 00 00       	mov    $0x400,%esi
  80042172a5:	48 89 c7             	mov    %rax,%rdi
  80042172a8:	48 b8 b5 70 21 04 80 	movabs $0x80042170b5,%rax
  80042172af:	00 00 00 
  80042172b2:	ff d0                	callq  *%rax
  80042172b4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042172b8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042172bd:	74 49                	je     8004217308 <mpsearch+0xfd>
			return mp;
  80042172bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042172c3:	eb 59                	jmp    800421731e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  80042172c5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042172c9:	48 83 c0 13          	add    $0x13,%rax
  80042172cd:	0f b7 00             	movzwl (%rax),%eax
  80042172d0:	0f b7 c0             	movzwl %ax,%eax
  80042172d3:	c1 e0 0a             	shl    $0xa,%eax
  80042172d6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  80042172d9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042172dc:	2d 00 04 00 00       	sub    $0x400,%eax
  80042172e1:	89 c0                	mov    %eax,%eax
  80042172e3:	be 00 04 00 00       	mov    $0x400,%esi
  80042172e8:	48 89 c7             	mov    %rax,%rdi
  80042172eb:	48 b8 b5 70 21 04 80 	movabs $0x80042170b5,%rax
  80042172f2:	00 00 00 
  80042172f5:	ff d0                	callq  *%rax
  80042172f7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042172fb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004217300:	74 06                	je     8004217308 <mpsearch+0xfd>
			return mp;
  8004217302:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217306:	eb 16                	jmp    800421731e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  8004217308:	be 00 00 01 00       	mov    $0x10000,%esi
  800421730d:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004217312:	48 b8 b5 70 21 04 80 	movabs $0x80042170b5,%rax
  8004217319:	00 00 00 
  800421731c:	ff d0                	callq  *%rax
}
  800421731e:	c9                   	leaveq 
  800421731f:	c3                   	retq   

0000008004217320 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004217320:	55                   	push   %rbp
  8004217321:	48 89 e5             	mov    %rsp,%rbp
  8004217324:	48 83 ec 30          	sub    $0x30,%rsp
  8004217328:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  800421732c:	48 b8 0b 72 21 04 80 	movabs $0x800421720b,%rax
  8004217333:	00 00 00 
  8004217336:	ff d0                	callq  *%rax
  8004217338:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421733c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004217341:	75 0a                	jne    800421734d <mpconfig+0x2d>
		return NULL;
  8004217343:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217348:	e9 f6 01 00 00       	jmpq   8004217543 <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  800421734d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217351:	8b 40 04             	mov    0x4(%rax),%eax
  8004217354:	85 c0                	test   %eax,%eax
  8004217356:	74 0c                	je     8004217364 <mpconfig+0x44>
  8004217358:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421735c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004217360:	84 c0                	test   %al,%al
  8004217362:	74 25                	je     8004217389 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004217364:	48 bf e8 fa 21 04 80 	movabs $0x800421fae8,%rdi
  800421736b:	00 00 00 
  800421736e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217373:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421737a:	00 00 00 
  800421737d:	ff d2                	callq  *%rdx
		return NULL;
  800421737f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217384:	e9 ba 01 00 00       	jmpq   8004217543 <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004217389:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421738d:	8b 40 04             	mov    0x4(%rax),%eax
  8004217390:	89 c0                	mov    %eax,%eax
  8004217392:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004217396:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421739a:	48 c1 e8 0c          	shr    $0xc,%rax
  800421739e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042173a1:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042173a4:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042173ab:	00 00 00 
  80042173ae:	48 8b 00             	mov    (%rax),%rax
  80042173b1:	48 39 c2             	cmp    %rax,%rdx
  80042173b4:	72 32                	jb     80042173e8 <mpconfig+0xc8>
  80042173b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042173ba:	48 89 c1             	mov    %rax,%rcx
  80042173bd:	48 ba b0 fa 21 04 80 	movabs $0x800421fab0,%rdx
  80042173c4:	00 00 00 
  80042173c7:	be 91 00 00 00       	mov    $0x91,%esi
  80042173cc:	48 bf d3 fa 21 04 80 	movabs $0x800421fad3,%rdi
  80042173d3:	00 00 00 
  80042173d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042173db:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042173e2:	00 00 00 
  80042173e5:	41 ff d0             	callq  *%r8
  80042173e8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042173ef:	00 00 00 
  80042173f2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042173f6:	48 01 d0             	add    %rdx,%rax
  80042173f9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  80042173fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217401:	ba 04 00 00 00       	mov    $0x4,%edx
  8004217406:	48 be 15 fb 21 04 80 	movabs $0x800421fb15,%rsi
  800421740d:	00 00 00 
  8004217410:	48 89 c7             	mov    %rax,%rdi
  8004217413:	48 b8 62 0d 21 04 80 	movabs $0x8004210d62,%rax
  800421741a:	00 00 00 
  800421741d:	ff d0                	callq  *%rax
  800421741f:	85 c0                	test   %eax,%eax
  8004217421:	74 25                	je     8004217448 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004217423:	48 bf 20 fb 21 04 80 	movabs $0x800421fb20,%rdi
  800421742a:	00 00 00 
  800421742d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217432:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004217439:	00 00 00 
  800421743c:	ff d2                	callq  *%rdx
		return NULL;
  800421743e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217443:	e9 fb 00 00 00       	jmpq   8004217543 <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004217448:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421744c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004217450:	0f b7 d0             	movzwl %ax,%edx
  8004217453:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217457:	89 d6                	mov    %edx,%esi
  8004217459:	48 89 c7             	mov    %rax,%rdi
  800421745c:	48 b8 6f 70 21 04 80 	movabs $0x800421706f,%rax
  8004217463:	00 00 00 
  8004217466:	ff d0                	callq  *%rax
  8004217468:	84 c0                	test   %al,%al
  800421746a:	74 25                	je     8004217491 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  800421746c:	48 bf 58 fb 21 04 80 	movabs $0x800421fb58,%rdi
  8004217473:	00 00 00 
  8004217476:	b8 00 00 00 00       	mov    $0x0,%eax
  800421747b:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004217482:	00 00 00 
  8004217485:	ff d2                	callq  *%rdx
		return NULL;
  8004217487:	b8 00 00 00 00       	mov    $0x0,%eax
  800421748c:	e9 b2 00 00 00       	jmpq   8004217543 <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004217491:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217495:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004217499:	3c 01                	cmp    $0x1,%al
  800421749b:	74 3b                	je     80042174d8 <mpconfig+0x1b8>
  800421749d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042174a1:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042174a5:	3c 04                	cmp    $0x4,%al
  80042174a7:	74 2f                	je     80042174d8 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  80042174a9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042174ad:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042174b1:	0f b6 c0             	movzbl %al,%eax
  80042174b4:	89 c6                	mov    %eax,%esi
  80042174b6:	48 bf 80 fb 21 04 80 	movabs $0x800421fb80,%rdi
  80042174bd:	00 00 00 
  80042174c0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042174c5:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042174cc:	00 00 00 
  80042174cf:	ff d2                	callq  *%rdx
		return NULL;
  80042174d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042174d6:	eb 6b                	jmp    8004217543 <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  80042174d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042174dc:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80042174e0:	0f b7 c0             	movzwl %ax,%eax
  80042174e3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042174e7:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  80042174eb:	0f b7 ca             	movzwl %dx,%ecx
  80042174ee:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042174f2:	48 01 ca             	add    %rcx,%rdx
  80042174f5:	89 c6                	mov    %eax,%esi
  80042174f7:	48 89 d7             	mov    %rdx,%rdi
  80042174fa:	48 b8 6f 70 21 04 80 	movabs $0x800421706f,%rax
  8004217501:	00 00 00 
  8004217504:	ff d0                	callq  *%rax
  8004217506:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421750a:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  800421750e:	38 d0                	cmp    %dl,%al
  8004217510:	74 22                	je     8004217534 <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004217512:	48 bf a0 fb 21 04 80 	movabs $0x800421fba0,%rdi
  8004217519:	00 00 00 
  800421751c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217521:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004217528:	00 00 00 
  800421752b:	ff d2                	callq  *%rdx
		return NULL;
  800421752d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217532:	eb 0f                	jmp    8004217543 <mpconfig+0x223>
	}
	*pmp = mp;
  8004217534:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217538:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421753c:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  800421753f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004217543:	c9                   	leaveq 
  8004217544:	c3                   	retq   

0000008004217545 <mp_init>:

void
mp_init(void)
{
  8004217545:	55                   	push   %rbp
  8004217546:	48 89 e5             	mov    %rsp,%rbp
  8004217549:	53                   	push   %rbx
  800421754a:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  800421754e:	48 b8 40 02 3b 04 80 	movabs $0x80043b0240,%rax
  8004217555:	00 00 00 
  8004217558:	48 bb 20 00 3b 04 80 	movabs $0x80043b0020,%rbx
  800421755f:	00 00 00 
  8004217562:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004217565:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004217569:	48 89 c7             	mov    %rax,%rdi
  800421756c:	48 b8 20 73 21 04 80 	movabs $0x8004217320,%rax
  8004217573:	00 00 00 
  8004217576:	ff d0                	callq  *%rax
  8004217578:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421757c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004217581:	75 05                	jne    8004217588 <mp_init+0x43>
		return;
  8004217583:	e9 d2 03 00 00       	jmpq   800421795a <mp_init+0x415>
	ismp = 1;
  8004217588:	48 b8 00 00 3b 04 80 	movabs $0x80043b0000,%rax
  800421758f:	00 00 00 
  8004217592:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004217598:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421759c:	8b 40 24             	mov    0x24(%rax),%eax
  800421759f:	89 c2                	mov    %eax,%edx
  80042175a1:	48 b8 00 10 3f 04 80 	movabs $0x80043f1000,%rax
  80042175a8:	00 00 00 
  80042175ab:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042175ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042175b2:	48 83 c0 2c          	add    $0x2c,%rax
  80042175b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042175ba:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  80042175c1:	e9 17 02 00 00       	jmpq   80042177dd <mp_init+0x298>
		switch (*p) {
  80042175c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042175ca:	0f b6 00             	movzbl (%rax),%eax
  80042175cd:	0f b6 c0             	movzbl %al,%eax
  80042175d0:	85 c0                	test   %eax,%eax
  80042175d2:	74 16                	je     80042175ea <mp_init+0xa5>
  80042175d4:	85 c0                	test   %eax,%eax
  80042175d6:	0f 88 b8 01 00 00    	js     8004217794 <mp_init+0x24f>
  80042175dc:	83 f8 04             	cmp    $0x4,%eax
  80042175df:	0f 8f af 01 00 00    	jg     8004217794 <mp_init+0x24f>
  80042175e5:	e9 a3 01 00 00       	jmpq   800421778d <mp_init+0x248>
		case MPPROC:
			proc = (struct mpproc *)p;
  80042175ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042175ee:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  80042175f2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042175f6:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042175fa:	0f b6 c0             	movzbl %al,%eax
  80042175fd:	83 e0 02             	and    $0x2,%eax
  8004217600:	85 c0                	test   %eax,%eax
  8004217602:	74 51                	je     8004217655 <mp_init+0x110>
				bootcpu = &cpus[ncpu];
  8004217604:	48 b8 48 02 3b 04 80 	movabs $0x80043b0248,%rax
  800421760b:	00 00 00 
  800421760e:	8b 00                	mov    (%rax),%eax
  8004217610:	48 98                	cltq   
  8004217612:	48 c1 e0 03          	shl    $0x3,%rax
  8004217616:	48 89 c2             	mov    %rax,%rdx
  8004217619:	48 c1 e2 04          	shl    $0x4,%rdx
  800421761d:	48 01 d0             	add    %rdx,%rax
  8004217620:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004217627:	00 00 00 
  800421762a:	48 01 c2             	add    %rax,%rdx
  800421762d:	48 b8 40 02 3b 04 80 	movabs $0x80043b0240,%rax
  8004217634:	00 00 00 
  8004217637:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  800421763a:	48 bf cd fb 21 04 80 	movabs $0x800421fbcd,%rdi
  8004217641:	00 00 00 
  8004217644:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217649:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004217650:	00 00 00 
  8004217653:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004217655:	48 b8 48 02 3b 04 80 	movabs $0x80043b0248,%rax
  800421765c:	00 00 00 
  800421765f:	8b 00                	mov    (%rax),%eax
  8004217661:	83 f8 03             	cmp    $0x3,%eax
  8004217664:	0f 8f f4 00 00 00    	jg     800421775e <mp_init+0x219>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  800421766a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421766e:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  8004217672:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217676:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421767a:	0f b6 f0             	movzbl %al,%esi
  800421767d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217681:	8b 78 08             	mov    0x8(%rax),%edi
  8004217684:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217688:	4c 8d 50 04          	lea    0x4(%rax),%r10
  800421768c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217690:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  8004217694:	0f b6 c8             	movzbl %al,%ecx
  8004217697:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421769b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800421769f:	0f b6 d0             	movzbl %al,%edx
  80042176a2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042176a6:	0f b6 00             	movzbl (%rax),%eax
  80042176a9:	0f b6 c0             	movzbl %al,%eax
  80042176ac:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  80042176b1:	89 34 24             	mov    %esi,(%rsp)
  80042176b4:	41 89 f9             	mov    %edi,%r9d
  80042176b7:	4d 89 d0             	mov    %r10,%r8
  80042176ba:	89 c6                	mov    %eax,%esi
  80042176bc:	48 bf e0 fb 21 04 80 	movabs $0x800421fbe0,%rdi
  80042176c3:	00 00 00 
  80042176c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042176cb:	49 ba 1a 96 20 04 80 	movabs $0x800420961a,%r10
  80042176d2:	00 00 00 
  80042176d5:	41 ff d2             	callq  *%r10
				if (proc->flags & MPROC_EN) {
  80042176d8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042176dc:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042176e0:	0f b6 c0             	movzbl %al,%eax
  80042176e3:	83 e0 01             	and    $0x1,%eax
  80042176e6:	85 c0                	test   %eax,%eax
  80042176e8:	74 57                	je     8004217741 <mp_init+0x1fc>
					cpus[ncpu].cpu_id = ncpu;
  80042176ea:	48 b8 48 02 3b 04 80 	movabs $0x80043b0248,%rax
  80042176f1:	00 00 00 
  80042176f4:	8b 30                	mov    (%rax),%esi
  80042176f6:	48 b8 48 02 3b 04 80 	movabs $0x80043b0248,%rax
  80042176fd:	00 00 00 
  8004217700:	8b 00                	mov    (%rax),%eax
  8004217702:	89 c2                	mov    %eax,%edx
  8004217704:	48 b9 20 00 3b 04 80 	movabs $0x80043b0020,%rcx
  800421770b:	00 00 00 
  800421770e:	48 63 c6             	movslq %esi,%rax
  8004217711:	48 c1 e0 03          	shl    $0x3,%rax
  8004217715:	48 89 c6             	mov    %rax,%rsi
  8004217718:	48 c1 e6 04          	shl    $0x4,%rsi
  800421771c:	48 01 f0             	add    %rsi,%rax
  800421771f:	48 01 c8             	add    %rcx,%rax
  8004217722:	88 10                	mov    %dl,(%rax)
					ncpu++;
  8004217724:	48 b8 48 02 3b 04 80 	movabs $0x80043b0248,%rax
  800421772b:	00 00 00 
  800421772e:	8b 00                	mov    (%rax),%eax
  8004217730:	8d 50 01             	lea    0x1(%rax),%edx
  8004217733:	48 b8 48 02 3b 04 80 	movabs $0x80043b0248,%rax
  800421773a:	00 00 00 
  800421773d:	89 10                	mov    %edx,(%rax)
  800421773f:	eb 45                	jmp    8004217786 <mp_init+0x241>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  8004217741:	48 bf 30 fc 21 04 80 	movabs $0x800421fc30,%rdi
  8004217748:	00 00 00 
  800421774b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217750:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004217757:	00 00 00 
  800421775a:	ff d2                	callq  *%rdx
  800421775c:	eb 28                	jmp    8004217786 <mp_init+0x241>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  800421775e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217762:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004217766:	0f b6 c0             	movzbl %al,%eax
  8004217769:	89 c6                	mov    %eax,%esi
  800421776b:	48 bf 60 fc 21 04 80 	movabs $0x800421fc60,%rdi
  8004217772:	00 00 00 
  8004217775:	b8 00 00 00 00       	mov    $0x0,%eax
  800421777a:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004217781:	00 00 00 
  8004217784:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004217786:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  800421778b:	eb 4c                	jmp    80042177d9 <mp_init+0x294>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  800421778d:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  8004217792:	eb 45                	jmp    80042177d9 <mp_init+0x294>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004217794:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217798:	0f b6 00             	movzbl (%rax),%eax
  800421779b:	0f b6 c0             	movzbl %al,%eax
  800421779e:	89 c6                	mov    %eax,%esi
  80042177a0:	48 bf 88 fc 21 04 80 	movabs $0x800421fc88,%rdi
  80042177a7:	00 00 00 
  80042177aa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042177af:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042177b6:	00 00 00 
  80042177b9:	ff d2                	callq  *%rdx
			ismp = 0;
  80042177bb:	48 b8 00 00 3b 04 80 	movabs $0x80043b0000,%rax
  80042177c2:	00 00 00 
  80042177c5:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  80042177cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042177cf:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  80042177d3:	0f b7 c0             	movzwl %ax,%eax
  80042177d6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042177d9:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  80042177dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042177e1:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  80042177e5:	0f b7 c0             	movzwl %ax,%eax
  80042177e8:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042177eb:	0f 87 d5 fd ff ff    	ja     80042175c6 <mp_init+0x81>
			ismp = 0;
			i = conf->entry;
		}
	}

	for (i=0; i< NCPU; ++i) {
  80042177f1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  80042177f8:	eb 53                	jmp    800421784d <mp_init+0x308>
		cpus[i].is_vmx_root = false;
  80042177fa:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004217801:	00 00 00 
  8004217804:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217807:	48 c1 e0 03          	shl    $0x3,%rax
  800421780b:	48 89 c1             	mov    %rax,%rcx
  800421780e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217812:	48 01 c8             	add    %rcx,%rax
  8004217815:	48 01 d0             	add    %rdx,%rax
  8004217818:	48 83 c0 70          	add    $0x70,%rax
  800421781c:	c6 40 08 00          	movb   $0x0,0x8(%rax)
		cpus[i].vmxon_region = 0;
  8004217820:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004217827:	00 00 00 
  800421782a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421782d:	48 c1 e0 03          	shl    $0x3,%rax
  8004217831:	48 89 c1             	mov    %rax,%rcx
  8004217834:	48 c1 e1 04          	shl    $0x4,%rcx
  8004217838:	48 01 c8             	add    %rcx,%rax
  800421783b:	48 01 d0             	add    %rdx,%rax
  800421783e:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004217842:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			ismp = 0;
			i = conf->entry;
		}
	}

	for (i=0; i< NCPU; ++i) {
  8004217849:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  800421784d:	83 7d e4 03          	cmpl   $0x3,-0x1c(%rbp)
  8004217851:	76 a7                	jbe    80042177fa <mp_init+0x2b5>
		cpus[i].is_vmx_root = false;
		cpus[i].vmxon_region = 0;
	}

	bootcpu->cpu_status = CPU_STARTED;
  8004217853:	48 b8 40 02 3b 04 80 	movabs $0x80043b0240,%rax
  800421785a:	00 00 00 
  800421785d:	48 8b 00             	mov    (%rax),%rax
  8004217860:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004217867:	48 b8 00 00 3b 04 80 	movabs $0x80043b0000,%rax
  800421786e:	00 00 00 
  8004217871:	8b 00                	mov    (%rax),%eax
  8004217873:	85 c0                	test   %eax,%eax
  8004217875:	75 41                	jne    80042178b8 <mp_init+0x373>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004217877:	48 b8 48 02 3b 04 80 	movabs $0x80043b0248,%rax
  800421787e:	00 00 00 
  8004217881:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  8004217887:	48 b8 00 10 3f 04 80 	movabs $0x80043f1000,%rax
  800421788e:	00 00 00 
  8004217891:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  8004217898:	48 bf a8 fc 21 04 80 	movabs $0x800421fca8,%rdi
  800421789f:	00 00 00 
  80042178a2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178a7:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042178ae:	00 00 00 
  80042178b1:	ff d2                	callq  *%rdx
		return;
  80042178b3:	e9 a2 00 00 00       	jmpq   800421795a <mp_init+0x415>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  80042178b8:	48 b8 48 02 3b 04 80 	movabs $0x80043b0248,%rax
  80042178bf:	00 00 00 
  80042178c2:	8b 10                	mov    (%rax),%edx
  80042178c4:	48 b8 40 02 3b 04 80 	movabs $0x80043b0240,%rax
  80042178cb:	00 00 00 
  80042178ce:	48 8b 00             	mov    (%rax),%rax
  80042178d1:	0f b6 00             	movzbl (%rax),%eax
  80042178d4:	0f b6 c0             	movzbl %al,%eax
  80042178d7:	89 c6                	mov    %eax,%esi
  80042178d9:	48 bf d4 fc 21 04 80 	movabs $0x800421fcd4,%rdi
  80042178e0:	00 00 00 
  80042178e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178e8:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  80042178ef:	00 00 00 
  80042178f2:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  80042178f4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042178f8:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  80042178fc:	84 c0                	test   %al,%al
  80042178fe:	74 5a                	je     800421795a <mp_init+0x415>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  8004217900:	48 bf f8 fc 21 04 80 	movabs $0x800421fcf8,%rdi
  8004217907:	00 00 00 
  800421790a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421790f:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004217916:	00 00 00 
  8004217919:	ff d2                	callq  *%rdx
  800421791b:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  8004217922:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004217926:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  800421792a:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800421792d:	ee                   	out    %al,(%dx)
  800421792e:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004217935:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004217938:	89 c2                	mov    %eax,%edx
  800421793a:	ec                   	in     (%dx),%al
  800421793b:	88 45 c3             	mov    %al,-0x3d(%rbp)
    return data;
  800421793e:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004217942:	83 c8 01             	or     $0x1,%eax
  8004217945:	0f b6 c0             	movzbl %al,%eax
  8004217948:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  800421794f:	88 45 bb             	mov    %al,-0x45(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004217952:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004217956:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004217959:	ee                   	out    %al,(%dx)
	}
}
  800421795a:	48 83 c4 58          	add    $0x58,%rsp
  800421795e:	5b                   	pop    %rbx
  800421795f:	5d                   	pop    %rbp
  8004217960:	c3                   	retq   

0000008004217961 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004217961:	55                   	push   %rbp
  8004217962:	48 89 e5             	mov    %rsp,%rbp
  8004217965:	48 83 ec 08          	sub    $0x8,%rsp
  8004217969:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800421796c:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  800421796f:	48 b8 08 10 3f 04 80 	movabs $0x80043f1008,%rax
  8004217976:	00 00 00 
  8004217979:	48 8b 00             	mov    (%rax),%rax
  800421797c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421797f:	48 63 d2             	movslq %edx,%rdx
  8004217982:	48 c1 e2 02          	shl    $0x2,%rdx
  8004217986:	48 01 c2             	add    %rax,%rdx
  8004217989:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421798c:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  800421798e:	48 b8 08 10 3f 04 80 	movabs $0x80043f1008,%rax
  8004217995:	00 00 00 
  8004217998:	48 8b 00             	mov    (%rax),%rax
  800421799b:	48 83 c0 20          	add    $0x20,%rax
  800421799f:	8b 00                	mov    (%rax),%eax
}
  80042179a1:	c9                   	leaveq 
  80042179a2:	c3                   	retq   

00000080042179a3 <lapic_init>:

void
lapic_init(void)
{
  80042179a3:	55                   	push   %rbp
  80042179a4:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  80042179a7:	48 b8 00 10 3f 04 80 	movabs $0x80043f1000,%rax
  80042179ae:	00 00 00 
  80042179b1:	48 8b 00             	mov    (%rax),%rax
  80042179b4:	48 85 c0             	test   %rax,%rax
  80042179b7:	75 05                	jne    80042179be <lapic_init+0x1b>
		return;
  80042179b9:	e9 da 01 00 00       	jmpq   8004217b98 <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  80042179be:	48 b8 00 10 3f 04 80 	movabs $0x80043f1000,%rax
  80042179c5:	00 00 00 
  80042179c8:	48 8b 00             	mov    (%rax),%rax
  80042179cb:	be 00 10 00 00       	mov    $0x1000,%esi
  80042179d0:	48 89 c7             	mov    %rax,%rdi
  80042179d3:	48 b8 34 3b 20 04 80 	movabs $0x8004203b34,%rax
  80042179da:	00 00 00 
  80042179dd:	ff d0                	callq  *%rax
  80042179df:	48 ba 08 10 3f 04 80 	movabs $0x80043f1008,%rdx
  80042179e6:	00 00 00 
  80042179e9:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  80042179ec:	be 27 01 00 00       	mov    $0x127,%esi
  80042179f1:	bf 3c 00 00 00       	mov    $0x3c,%edi
  80042179f6:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  80042179fd:	00 00 00 
  8004217a00:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  8004217a02:	be 0b 00 00 00       	mov    $0xb,%esi
  8004217a07:	bf f8 00 00 00       	mov    $0xf8,%edi
  8004217a0c:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217a13:	00 00 00 
  8004217a16:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  8004217a18:	be 20 00 02 00       	mov    $0x20020,%esi
  8004217a1d:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004217a22:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217a29:	00 00 00 
  8004217a2c:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  8004217a2e:	be 80 96 98 00       	mov    $0x989680,%esi
  8004217a33:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004217a38:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217a3f:	00 00 00 
  8004217a42:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004217a44:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004217a4b:	00 00 00 
  8004217a4e:	ff d0                	callq  *%rax
  8004217a50:	48 98                	cltq   
  8004217a52:	48 c1 e0 03          	shl    $0x3,%rax
  8004217a56:	48 89 c2             	mov    %rax,%rdx
  8004217a59:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217a5d:	48 01 d0             	add    %rdx,%rax
  8004217a60:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004217a67:	00 00 00 
  8004217a6a:	48 01 c2             	add    %rax,%rdx
  8004217a6d:	48 b8 40 02 3b 04 80 	movabs $0x80043b0240,%rax
  8004217a74:	00 00 00 
  8004217a77:	48 8b 00             	mov    (%rax),%rax
  8004217a7a:	48 39 c2             	cmp    %rax,%rdx
  8004217a7d:	74 16                	je     8004217a95 <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  8004217a7f:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217a84:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004217a89:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217a90:	00 00 00 
  8004217a93:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004217a95:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217a9a:	bf d8 00 00 00       	mov    $0xd8,%edi
  8004217a9f:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217aa6:	00 00 00 
  8004217aa9:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  8004217aab:	48 b8 08 10 3f 04 80 	movabs $0x80043f1008,%rax
  8004217ab2:	00 00 00 
  8004217ab5:	48 8b 00             	mov    (%rax),%rax
  8004217ab8:	48 83 c0 30          	add    $0x30,%rax
  8004217abc:	8b 00                	mov    (%rax),%eax
  8004217abe:	c1 e8 10             	shr    $0x10,%eax
  8004217ac1:	0f b6 c0             	movzbl %al,%eax
  8004217ac4:	83 f8 03             	cmp    $0x3,%eax
  8004217ac7:	76 16                	jbe    8004217adf <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  8004217ac9:	be 00 00 01 00       	mov    $0x10000,%esi
  8004217ace:	bf d0 00 00 00       	mov    $0xd0,%edi
  8004217ad3:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217ada:	00 00 00 
  8004217add:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  8004217adf:	be 33 00 00 00       	mov    $0x33,%esi
  8004217ae4:	bf dc 00 00 00       	mov    $0xdc,%edi
  8004217ae9:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217af0:	00 00 00 
  8004217af3:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  8004217af5:	be 00 00 00 00       	mov    $0x0,%esi
  8004217afa:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004217aff:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217b06:	00 00 00 
  8004217b09:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  8004217b0b:	be 00 00 00 00       	mov    $0x0,%esi
  8004217b10:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004217b15:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217b1c:	00 00 00 
  8004217b1f:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004217b21:	be 00 00 00 00       	mov    $0x0,%esi
  8004217b26:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004217b2b:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217b32:	00 00 00 
  8004217b35:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004217b37:	be 00 00 00 00       	mov    $0x0,%esi
  8004217b3c:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004217b41:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217b48:	00 00 00 
  8004217b4b:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004217b4d:	be 00 85 08 00       	mov    $0x88500,%esi
  8004217b52:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004217b57:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217b5e:	00 00 00 
  8004217b61:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  8004217b63:	90                   	nop
  8004217b64:	48 b8 08 10 3f 04 80 	movabs $0x80043f1008,%rax
  8004217b6b:	00 00 00 
  8004217b6e:	48 8b 00             	mov    (%rax),%rax
  8004217b71:	48 05 00 03 00 00    	add    $0x300,%rax
  8004217b77:	8b 00                	mov    (%rax),%eax
  8004217b79:	25 00 10 00 00       	and    $0x1000,%eax
  8004217b7e:	85 c0                	test   %eax,%eax
  8004217b80:	75 e2                	jne    8004217b64 <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004217b82:	be 00 00 00 00       	mov    $0x0,%esi
  8004217b87:	bf 20 00 00 00       	mov    $0x20,%edi
  8004217b8c:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217b93:	00 00 00 
  8004217b96:	ff d0                	callq  *%rax
}
  8004217b98:	5d                   	pop    %rbp
  8004217b99:	c3                   	retq   

0000008004217b9a <cpunum>:

int
cpunum(void)
{
  8004217b9a:	55                   	push   %rbp
  8004217b9b:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004217b9e:	48 b8 08 10 3f 04 80 	movabs $0x80043f1008,%rax
  8004217ba5:	00 00 00 
  8004217ba8:	48 8b 00             	mov    (%rax),%rax
  8004217bab:	48 85 c0             	test   %rax,%rax
  8004217bae:	74 18                	je     8004217bc8 <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004217bb0:	48 b8 08 10 3f 04 80 	movabs $0x80043f1008,%rax
  8004217bb7:	00 00 00 
  8004217bba:	48 8b 00             	mov    (%rax),%rax
  8004217bbd:	48 83 c0 20          	add    $0x20,%rax
  8004217bc1:	8b 00                	mov    (%rax),%eax
  8004217bc3:	c1 e8 18             	shr    $0x18,%eax
  8004217bc6:	eb 05                	jmp    8004217bcd <cpunum+0x33>
	return 0;
  8004217bc8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217bcd:	5d                   	pop    %rbp
  8004217bce:	c3                   	retq   

0000008004217bcf <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004217bcf:	55                   	push   %rbp
  8004217bd0:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004217bd3:	48 b8 08 10 3f 04 80 	movabs $0x80043f1008,%rax
  8004217bda:	00 00 00 
  8004217bdd:	48 8b 00             	mov    (%rax),%rax
  8004217be0:	48 85 c0             	test   %rax,%rax
  8004217be3:	74 16                	je     8004217bfb <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004217be5:	be 00 00 00 00       	mov    $0x0,%esi
  8004217bea:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004217bef:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217bf6:	00 00 00 
  8004217bf9:	ff d0                	callq  *%rax
}
  8004217bfb:	5d                   	pop    %rbp
  8004217bfc:	c3                   	retq   

0000008004217bfd <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004217bfd:	55                   	push   %rbp
  8004217bfe:	48 89 e5             	mov    %rsp,%rbp
  8004217c01:	48 83 ec 04          	sub    $0x4,%rsp
  8004217c05:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004217c08:	c9                   	leaveq 
  8004217c09:	c3                   	retq   

0000008004217c0a <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004217c0a:	55                   	push   %rbp
  8004217c0b:	48 89 e5             	mov    %rsp,%rbp
  8004217c0e:	48 83 ec 40          	sub    $0x40,%rsp
  8004217c12:	89 f8                	mov    %edi,%eax
  8004217c14:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004217c17:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004217c1a:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004217c21:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004217c25:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004217c29:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004217c2c:	ee                   	out    %al,(%dx)
  8004217c2d:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004217c34:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004217c38:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004217c3c:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004217c3f:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004217c40:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004217c47:	00 
  8004217c48:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217c4c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004217c50:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004217c53:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004217c56:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004217c5d:	00 00 00 
  8004217c60:	48 8b 00             	mov    (%rax),%rax
  8004217c63:	48 39 c2             	cmp    %rax,%rdx
  8004217c66:	72 32                	jb     8004217c9a <lapic_startap+0x90>
  8004217c68:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217c6c:	48 89 c1             	mov    %rax,%rcx
  8004217c6f:	48 ba 40 fd 21 04 80 	movabs $0x800421fd40,%rdx
  8004217c76:	00 00 00 
  8004217c79:	be 98 00 00 00       	mov    $0x98,%esi
  8004217c7e:	48 bf 63 fd 21 04 80 	movabs $0x800421fd63,%rdi
  8004217c85:	00 00 00 
  8004217c88:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217c8d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004217c94:	00 00 00 
  8004217c97:	41 ff d0             	callq  *%r8
  8004217c9a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004217ca1:	00 00 00 
  8004217ca4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004217ca8:	48 01 d0             	add    %rdx,%rax
  8004217cab:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004217caf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217cb3:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004217cb8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217cbc:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004217cc0:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004217cc3:	c1 e8 04             	shr    $0x4,%eax
  8004217cc6:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004217cc9:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004217ccd:	c1 e0 18             	shl    $0x18,%eax
  8004217cd0:	89 c6                	mov    %eax,%esi
  8004217cd2:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004217cd7:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217cde:	00 00 00 
  8004217ce1:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004217ce3:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004217ce8:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004217ced:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217cf4:	00 00 00 
  8004217cf7:	ff d0                	callq  *%rax
	microdelay(200);
  8004217cf9:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004217cfe:	48 b8 fd 7b 21 04 80 	movabs $0x8004217bfd,%rax
  8004217d05:	00 00 00 
  8004217d08:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004217d0a:	be 00 85 00 00       	mov    $0x8500,%esi
  8004217d0f:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004217d14:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217d1b:	00 00 00 
  8004217d1e:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004217d20:	bf 64 00 00 00       	mov    $0x64,%edi
  8004217d25:	48 b8 fd 7b 21 04 80 	movabs $0x8004217bfd,%rax
  8004217d2c:	00 00 00 
  8004217d2f:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004217d31:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004217d38:	eb 4b                	jmp    8004217d85 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004217d3a:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004217d3e:	c1 e0 18             	shl    $0x18,%eax
  8004217d41:	89 c6                	mov    %eax,%esi
  8004217d43:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004217d48:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217d4f:	00 00 00 
  8004217d52:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004217d54:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004217d57:	c1 e8 0c             	shr    $0xc,%eax
  8004217d5a:	80 cc 06             	or     $0x6,%ah
  8004217d5d:	89 c6                	mov    %eax,%esi
  8004217d5f:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004217d64:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217d6b:	00 00 00 
  8004217d6e:	ff d0                	callq  *%rax
		microdelay(200);
  8004217d70:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004217d75:	48 b8 fd 7b 21 04 80 	movabs $0x8004217bfd,%rax
  8004217d7c:	00 00 00 
  8004217d7f:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004217d81:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217d85:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004217d89:	7e af                	jle    8004217d3a <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004217d8b:	c9                   	leaveq 
  8004217d8c:	c3                   	retq   

0000008004217d8d <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004217d8d:	55                   	push   %rbp
  8004217d8e:	48 89 e5             	mov    %rsp,%rbp
  8004217d91:	48 83 ec 08          	sub    $0x8,%rsp
  8004217d95:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004217d98:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217d9b:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004217da0:	89 c6                	mov    %eax,%esi
  8004217da2:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004217da7:	48 b8 61 79 21 04 80 	movabs $0x8004217961,%rax
  8004217dae:	00 00 00 
  8004217db1:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004217db3:	90                   	nop
  8004217db4:	48 b8 08 10 3f 04 80 	movabs $0x80043f1008,%rax
  8004217dbb:	00 00 00 
  8004217dbe:	48 8b 00             	mov    (%rax),%rax
  8004217dc1:	48 05 00 03 00 00    	add    $0x300,%rax
  8004217dc7:	8b 00                	mov    (%rax),%eax
  8004217dc9:	25 00 10 00 00       	and    $0x1000,%eax
  8004217dce:	85 c0                	test   %eax,%eax
  8004217dd0:	75 e2                	jne    8004217db4 <lapic_ipi+0x27>
		;
}
  8004217dd2:	c9                   	leaveq 
  8004217dd3:	c3                   	retq   

0000008004217dd4 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004217dd4:	55                   	push   %rbp
  8004217dd5:	48 89 e5             	mov    %rsp,%rbp
  8004217dd8:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004217ddc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004217de0:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004217de3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004217de7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217dea:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004217dee:	f0 87 02             	lock xchg %eax,(%rdx)
  8004217df1:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004217df4:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004217df7:	c9                   	leaveq 
  8004217df8:	c3                   	retq   

0000008004217df9 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004217df9:	55                   	push   %rbp
  8004217dfa:	48 89 e5             	mov    %rsp,%rbp
  8004217dfd:	48 83 ec 28          	sub    $0x28,%rsp
  8004217e01:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

    static __inline uint64_t
read_rbp(void)
{
    uint64_t rbp;
    __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004217e05:	48 89 e8             	mov    %rbp,%rax
  8004217e08:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    return rbp;
  8004217e0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004217e10:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004217e14:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004217e1b:	eb 45                	jmp    8004217e62 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004217e1d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004217e22:	74 44                	je     8004217e68 <get_caller_pcs+0x6f>
  8004217e24:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004217e2b:	00 00 00 
  8004217e2e:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004217e32:	76 34                	jbe    8004217e68 <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004217e34:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217e37:	48 98                	cltq   
  8004217e39:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004217e40:	00 
  8004217e41:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217e45:	48 01 c2             	add    %rax,%rdx
  8004217e48:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217e4c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004217e50:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004217e53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217e57:	48 8b 00             	mov    (%rax),%rax
  8004217e5a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004217e5e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004217e62:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004217e66:	7e b5                	jle    8004217e1d <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004217e68:	eb 1f                	jmp    8004217e89 <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004217e6a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217e6d:	48 98                	cltq   
  8004217e6f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004217e76:	00 
  8004217e77:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217e7b:	48 01 d0             	add    %rdx,%rax
  8004217e7e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004217e85:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004217e89:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004217e8d:	7e db                	jle    8004217e6a <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004217e8f:	c9                   	leaveq 
  8004217e90:	c3                   	retq   

0000008004217e91 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004217e91:	55                   	push   %rbp
  8004217e92:	48 89 e5             	mov    %rsp,%rbp
  8004217e95:	53                   	push   %rbx
  8004217e96:	48 83 ec 18          	sub    $0x18,%rsp
  8004217e9a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004217e9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217ea2:	8b 00                	mov    (%rax),%eax
  8004217ea4:	85 c0                	test   %eax,%eax
  8004217ea6:	74 3d                	je     8004217ee5 <holding+0x54>
  8004217ea8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217eac:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004217eb0:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004217eb7:	00 00 00 
  8004217eba:	ff d0                	callq  *%rax
  8004217ebc:	48 98                	cltq   
  8004217ebe:	48 c1 e0 03          	shl    $0x3,%rax
  8004217ec2:	48 89 c2             	mov    %rax,%rdx
  8004217ec5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217ec9:	48 01 d0             	add    %rdx,%rax
  8004217ecc:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004217ed3:	00 00 00 
  8004217ed6:	48 01 d0             	add    %rdx,%rax
  8004217ed9:	48 39 c3             	cmp    %rax,%rbx
  8004217edc:	75 07                	jne    8004217ee5 <holding+0x54>
  8004217ede:	b8 01 00 00 00       	mov    $0x1,%eax
  8004217ee3:	eb 05                	jmp    8004217eea <holding+0x59>
  8004217ee5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217eea:	48 83 c4 18          	add    $0x18,%rsp
  8004217eee:	5b                   	pop    %rbx
  8004217eef:	5d                   	pop    %rbp
  8004217ef0:	c3                   	retq   

0000008004217ef1 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004217ef1:	55                   	push   %rbp
  8004217ef2:	48 89 e5             	mov    %rsp,%rbp
  8004217ef5:	48 83 ec 10          	sub    $0x10,%rsp
  8004217ef9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004217efd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004217f01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217f05:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004217f0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217f0f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004217f13:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004217f17:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004217f1b:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004217f22:	00 
#endif
}
  8004217f23:	c9                   	leaveq 
  8004217f24:	c3                   	retq   

0000008004217f25 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004217f25:	55                   	push   %rbp
  8004217f26:	48 89 e5             	mov    %rsp,%rbp
  8004217f29:	53                   	push   %rbx
  8004217f2a:	48 83 ec 18          	sub    $0x18,%rsp
  8004217f2e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004217f32:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217f36:	48 89 c7             	mov    %rax,%rdi
  8004217f39:	48 b8 91 7e 21 04 80 	movabs $0x8004217e91,%rax
  8004217f40:	00 00 00 
  8004217f43:	ff d0                	callq  *%rax
  8004217f45:	85 c0                	test   %eax,%eax
  8004217f47:	74 44                	je     8004217f8d <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004217f49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217f4d:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004217f51:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004217f58:	00 00 00 
  8004217f5b:	ff d0                	callq  *%rax
  8004217f5d:	49 89 d8             	mov    %rbx,%r8
  8004217f60:	89 c1                	mov    %eax,%ecx
  8004217f62:	48 ba 80 fd 21 04 80 	movabs $0x800421fd80,%rdx
  8004217f69:	00 00 00 
  8004217f6c:	be 41 00 00 00       	mov    $0x41,%esi
  8004217f71:	48 bf aa fd 21 04 80 	movabs $0x800421fdaa,%rdi
  8004217f78:	00 00 00 
  8004217f7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217f80:	49 b9 41 05 20 04 80 	movabs $0x8004200541,%r9
  8004217f87:	00 00 00 
  8004217f8a:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004217f8d:	eb 02                	jmp    8004217f91 <spin_lock+0x6c>
		asm volatile ("pause");
  8004217f8f:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004217f91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217f95:	be 01 00 00 00       	mov    $0x1,%esi
  8004217f9a:	48 89 c7             	mov    %rax,%rdi
  8004217f9d:	48 b8 d4 7d 21 04 80 	movabs $0x8004217dd4,%rax
  8004217fa4:	00 00 00 
  8004217fa7:	ff d0                	callq  *%rax
  8004217fa9:	85 c0                	test   %eax,%eax
  8004217fab:	75 e2                	jne    8004217f8f <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004217fad:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  8004217fb4:	00 00 00 
  8004217fb7:	ff d0                	callq  *%rax
  8004217fb9:	48 98                	cltq   
  8004217fbb:	48 c1 e0 03          	shl    $0x3,%rax
  8004217fbf:	48 89 c2             	mov    %rax,%rdx
  8004217fc2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004217fc6:	48 01 d0             	add    %rdx,%rax
  8004217fc9:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  8004217fd0:	00 00 00 
  8004217fd3:	48 01 c2             	add    %rax,%rdx
  8004217fd6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217fda:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004217fde:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217fe2:	48 83 c0 18          	add    $0x18,%rax
  8004217fe6:	48 89 c7             	mov    %rax,%rdi
  8004217fe9:	48 b8 f9 7d 21 04 80 	movabs $0x8004217df9,%rax
  8004217ff0:	00 00 00 
  8004217ff3:	ff d0                	callq  *%rax
#endif
}
  8004217ff5:	48 83 c4 18          	add    $0x18,%rsp
  8004217ff9:	5b                   	pop    %rbx
  8004217ffa:	5d                   	pop    %rbp
  8004217ffb:	c3                   	retq   

0000008004217ffc <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004217ffc:	55                   	push   %rbp
  8004217ffd:	48 89 e5             	mov    %rsp,%rbp
  8004218000:	41 54                	push   %r12
  8004218002:	53                   	push   %rbx
  8004218003:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  800421800a:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004218011:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218018:	48 89 c7             	mov    %rax,%rdi
  800421801b:	48 b8 91 7e 21 04 80 	movabs $0x8004217e91,%rax
  8004218022:	00 00 00 
  8004218025:	ff d0                	callq  *%rax
  8004218027:	85 c0                	test   %eax,%eax
  8004218029:	0f 85 d2 01 00 00    	jne    8004218201 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  800421802f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218036:	48 8d 48 18          	lea    0x18(%rax),%rcx
  800421803a:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004218041:	ba 28 00 00 00       	mov    $0x28,%edx
  8004218046:	48 89 ce             	mov    %rcx,%rsi
  8004218049:	48 89 c7             	mov    %rax,%rdi
  800421804c:	48 b8 17 0c 21 04 80 	movabs $0x8004210c17,%rax
  8004218053:	00 00 00 
  8004218056:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004218058:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421805f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004218063:	48 85 c0             	test   %rax,%rax
  8004218066:	75 39                	jne    80042180a1 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004218068:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  800421806f:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004218073:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421807a:	00 00 00 
  800421807d:	ff d0                	callq  *%rax
  800421807f:	48 89 da             	mov    %rbx,%rdx
  8004218082:	89 c6                	mov    %eax,%esi
  8004218084:	48 bf c0 fd 21 04 80 	movabs $0x800421fdc0,%rdi
  800421808b:	00 00 00 
  800421808e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218093:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800421809a:	00 00 00 
  800421809d:	ff d1                	callq  *%rcx
  800421809f:	eb 4d                	jmp    80042180ee <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  80042180a1:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042180a8:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042180ac:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  80042180af:	44 0f b6 e0          	movzbl %al,%r12d
  80042180b3:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042180ba:	48 8b 58 08          	mov    0x8(%rax),%rbx
  80042180be:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  80042180c5:	00 00 00 
  80042180c8:	ff d0                	callq  *%rax
  80042180ca:	44 89 e1             	mov    %r12d,%ecx
  80042180cd:	48 89 da             	mov    %rbx,%rdx
  80042180d0:	89 c6                	mov    %eax,%esi
  80042180d2:	48 bf 00 fe 21 04 80 	movabs $0x800421fe00,%rdi
  80042180d9:	00 00 00 
  80042180dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042180e1:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  80042180e8:	00 00 00 
  80042180eb:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042180ee:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042180f5:	e9 c3 00 00 00       	jmpq   80042181bd <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  80042180fa:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042180fd:	48 98                	cltq   
  80042180ff:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004218106:	89 c0                	mov    %eax,%eax
  8004218108:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  800421810f:	48 89 d6             	mov    %rdx,%rsi
  8004218112:	48 89 c7             	mov    %rax,%rdi
  8004218115:	48 b8 f8 f7 20 04 80 	movabs $0x800420f7f8,%rax
  800421811c:	00 00 00 
  800421811f:	ff d0                	callq  *%rax
  8004218121:	85 c0                	test   %eax,%eax
  8004218123:	78 6b                	js     8004218190 <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004218125:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218128:	48 98                	cltq   
  800421812a:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004218131:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004218133:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  800421813a:	48 29 c2             	sub    %rax,%rdx
  800421813d:	49 89 d0             	mov    %rdx,%r8
  8004218140:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004218147:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  800421814d:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  8004218153:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  800421815a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421815d:	48 98                	cltq   
  800421815f:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004218166:	4c 89 04 24          	mov    %r8,(%rsp)
  800421816a:	49 89 f9             	mov    %rdi,%r9
  800421816d:	41 89 f0             	mov    %esi,%r8d
  8004218170:	89 c6                	mov    %eax,%esi
  8004218172:	48 bf 36 fe 21 04 80 	movabs $0x800421fe36,%rdi
  8004218179:	00 00 00 
  800421817c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218181:	49 ba 1a 96 20 04 80 	movabs $0x800420961a,%r10
  8004218188:	00 00 00 
  800421818b:	41 ff d2             	callq  *%r10
  800421818e:	eb 29                	jmp    80042181b9 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004218190:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218193:	48 98                	cltq   
  8004218195:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421819c:	89 c6                	mov    %eax,%esi
  800421819e:	48 bf 4d fe 21 04 80 	movabs $0x800421fe4d,%rdi
  80042181a5:	00 00 00 
  80042181a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042181ad:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042181b4:	00 00 00 
  80042181b7:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042181b9:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042181bd:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042181c1:	7f 14                	jg     80042181d7 <spin_unlock+0x1db>
  80042181c3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042181c6:	48 98                	cltq   
  80042181c8:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042181cf:	85 c0                	test   %eax,%eax
  80042181d1:	0f 85 23 ff ff ff    	jne    80042180fa <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  80042181d7:	48 ba 55 fe 21 04 80 	movabs $0x800421fe55,%rdx
  80042181de:	00 00 00 
  80042181e1:	be 6b 00 00 00       	mov    $0x6b,%esi
  80042181e6:	48 bf aa fd 21 04 80 	movabs $0x800421fdaa,%rdi
  80042181ed:	00 00 00 
  80042181f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042181f5:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  80042181fc:	00 00 00 
  80042181ff:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  8004218201:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218208:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  800421820f:	00 
	lk->cpu = 0;
  8004218210:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218217:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421821e:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  800421821f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004218226:	be 00 00 00 00       	mov    $0x0,%esi
  800421822b:	48 89 c7             	mov    %rax,%rdi
  800421822e:	48 b8 d4 7d 21 04 80 	movabs $0x8004217dd4,%rax
  8004218235:	00 00 00 
  8004218238:	ff d0                	callq  *%rax
}
  800421823a:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004218241:	5b                   	pop    %rbx
  8004218242:	41 5c                	pop    %r12
  8004218244:	5d                   	pop    %rbp
  8004218245:	c3                   	retq   

0000008004218246 <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  8004218246:	55                   	push   %rbp
  8004218247:	48 89 e5             	mov    %rsp,%rbp
  800421824a:	48 83 ec 20          	sub    $0x20,%rsp
  800421824e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004218251:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004218254:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004218257:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  800421825a:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  8004218261:	76 35                	jbe    8004218298 <pci_conf1_set_addr+0x52>
  8004218263:	48 b9 68 fe 21 04 80 	movabs $0x800421fe68,%rcx
  800421826a:	00 00 00 
  800421826d:	48 ba 72 fe 21 04 80 	movabs $0x800421fe72,%rdx
  8004218274:	00 00 00 
  8004218277:	be 29 00 00 00       	mov    $0x29,%esi
  800421827c:	48 bf 87 fe 21 04 80 	movabs $0x800421fe87,%rdi
  8004218283:	00 00 00 
  8004218286:	b8 00 00 00 00       	mov    $0x0,%eax
  800421828b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004218292:	00 00 00 
  8004218295:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004218298:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  800421829c:	76 35                	jbe    80042182d3 <pci_conf1_set_addr+0x8d>
  800421829e:	48 b9 92 fe 21 04 80 	movabs $0x800421fe92,%rcx
  80042182a5:	00 00 00 
  80042182a8:	48 ba 72 fe 21 04 80 	movabs $0x800421fe72,%rdx
  80042182af:	00 00 00 
  80042182b2:	be 2a 00 00 00       	mov    $0x2a,%esi
  80042182b7:	48 bf 87 fe 21 04 80 	movabs $0x800421fe87,%rdi
  80042182be:	00 00 00 
  80042182c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042182c6:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042182cd:	00 00 00 
  80042182d0:	41 ff d0             	callq  *%r8
	assert(func < 8);
  80042182d3:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  80042182d7:	76 35                	jbe    800421830e <pci_conf1_set_addr+0xc8>
  80042182d9:	48 b9 9b fe 21 04 80 	movabs $0x800421fe9b,%rcx
  80042182e0:	00 00 00 
  80042182e3:	48 ba 72 fe 21 04 80 	movabs $0x800421fe72,%rdx
  80042182ea:	00 00 00 
  80042182ed:	be 2b 00 00 00       	mov    $0x2b,%esi
  80042182f2:	48 bf 87 fe 21 04 80 	movabs $0x800421fe87,%rdi
  80042182f9:	00 00 00 
  80042182fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218301:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004218308:	00 00 00 
  800421830b:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  800421830e:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  8004218315:	76 35                	jbe    800421834c <pci_conf1_set_addr+0x106>
  8004218317:	48 b9 a4 fe 21 04 80 	movabs $0x800421fea4,%rcx
  800421831e:	00 00 00 
  8004218321:	48 ba 72 fe 21 04 80 	movabs $0x800421fe72,%rdx
  8004218328:	00 00 00 
  800421832b:	be 2c 00 00 00       	mov    $0x2c,%esi
  8004218330:	48 bf 87 fe 21 04 80 	movabs $0x800421fe87,%rdi
  8004218337:	00 00 00 
  800421833a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421833f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004218346:	00 00 00 
  8004218349:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  800421834c:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421834f:	83 e0 03             	and    $0x3,%eax
  8004218352:	85 c0                	test   %eax,%eax
  8004218354:	74 35                	je     800421838b <pci_conf1_set_addr+0x145>
  8004218356:	48 b9 b1 fe 21 04 80 	movabs $0x800421feb1,%rcx
  800421835d:	00 00 00 
  8004218360:	48 ba 72 fe 21 04 80 	movabs $0x800421fe72,%rdx
  8004218367:	00 00 00 
  800421836a:	be 2d 00 00 00       	mov    $0x2d,%esi
  800421836f:	48 bf 87 fe 21 04 80 	movabs $0x800421fe87,%rdi
  8004218376:	00 00 00 
  8004218379:	b8 00 00 00 00       	mov    $0x0,%eax
  800421837e:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004218385:	00 00 00 
  8004218388:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  800421838b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421838e:	c1 e0 10             	shl    $0x10,%eax
  8004218391:	89 c2                	mov    %eax,%edx
  8004218393:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218396:	c1 e0 0b             	shl    $0xb,%eax
  8004218399:	09 c2                	or     %eax,%edx
  800421839b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421839e:	c1 e0 08             	shl    $0x8,%eax
  80042183a1:	09 d0                	or     %edx,%eax
  80042183a3:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  80042183a6:	0d 00 00 00 80       	or     $0x80000000,%eax
  80042183ab:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  80042183ae:	48 b8 c4 37 23 04 80 	movabs $0x80042337c4,%rax
  80042183b5:	00 00 00 
  80042183b8:	8b 00                	mov    (%rax),%eax
  80042183ba:	89 45 f8             	mov    %eax,-0x8(%rbp)
  80042183bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042183c0:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

    static __inline void
outl(int port, uint32_t data)
{
    __asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  80042183c3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042183c6:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042183c9:	ef                   	out    %eax,(%dx)
}
  80042183ca:	c9                   	leaveq 
  80042183cb:	c3                   	retq   

00000080042183cc <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  80042183cc:	55                   	push   %rbp
  80042183cd:	48 89 e5             	mov    %rsp,%rbp
  80042183d0:	48 83 ec 20          	sub    $0x20,%rsp
  80042183d4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042183d8:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  80042183db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042183df:	8b 50 0c             	mov    0xc(%rax),%edx
  80042183e2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042183e6:	8b 70 08             	mov    0x8(%rax),%esi
  80042183e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042183ed:	48 8b 00             	mov    (%rax),%rax
  80042183f0:	8b 40 08             	mov    0x8(%rax),%eax
  80042183f3:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80042183f6:	89 c7                	mov    %eax,%edi
  80042183f8:	48 b8 46 82 21 04 80 	movabs $0x8004218246,%rax
  80042183ff:	00 00 00 
  8004218402:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  8004218404:	48 b8 c8 37 23 04 80 	movabs $0x80042337c8,%rax
  800421840b:	00 00 00 
  800421840e:	8b 00                	mov    (%rax),%eax
  8004218410:	89 45 fc             	mov    %eax,-0x4(%rbp)

    static __inline uint32_t
inl(int port)
{
    uint32_t data;
    __asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  8004218413:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218416:	89 c2                	mov    %eax,%edx
  8004218418:	ed                   	in     (%dx),%eax
  8004218419:	89 45 f8             	mov    %eax,-0x8(%rbp)
    return data;
  800421841c:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  800421841f:	c9                   	leaveq 
  8004218420:	c3                   	retq   

0000008004218421 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  8004218421:	55                   	push   %rbp
  8004218422:	48 89 e5             	mov    %rsp,%rbp
  8004218425:	48 83 ec 20          	sub    $0x20,%rsp
  8004218429:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421842d:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8004218430:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004218433:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218437:	8b 50 0c             	mov    0xc(%rax),%edx
  800421843a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421843e:	8b 70 08             	mov    0x8(%rax),%esi
  8004218441:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218445:	48 8b 00             	mov    (%rax),%rax
  8004218448:	8b 40 08             	mov    0x8(%rax),%eax
  800421844b:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800421844e:	89 c7                	mov    %eax,%edi
  8004218450:	48 b8 46 82 21 04 80 	movabs $0x8004218246,%rax
  8004218457:	00 00 00 
  800421845a:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  800421845c:	48 b8 c8 37 23 04 80 	movabs $0x80042337c8,%rax
  8004218463:	00 00 00 
  8004218466:	8b 00                	mov    (%rax),%eax
  8004218468:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800421846b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421846e:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

    static __inline void
outl(int port, uint32_t data)
{
    __asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004218471:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218474:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004218477:	ef                   	out    %eax,(%dx)
}
  8004218478:	c9                   	leaveq 
  8004218479:	c3                   	retq   

000000800421847a <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  800421847a:	55                   	push   %rbp
  800421847b:	48 89 e5             	mov    %rsp,%rbp
  800421847e:	48 83 ec 30          	sub    $0x30,%rsp
  8004218482:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004218485:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004218488:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  800421848c:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004218490:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004218497:	e9 aa 00 00 00       	jmpq   8004218546 <pci_attach_match+0xcc>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  800421849c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421849f:	48 c1 e0 04          	shl    $0x4,%rax
  80042184a3:	48 89 c2             	mov    %rax,%rdx
  80042184a6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042184aa:	48 01 d0             	add    %rdx,%rax
  80042184ad:	8b 00                	mov    (%rax),%eax
  80042184af:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042184b2:	0f 85 8a 00 00 00    	jne    8004218542 <pci_attach_match+0xc8>
  80042184b8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042184bb:	48 c1 e0 04          	shl    $0x4,%rax
  80042184bf:	48 89 c2             	mov    %rax,%rdx
  80042184c2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042184c6:	48 01 d0             	add    %rdx,%rax
  80042184c9:	8b 40 04             	mov    0x4(%rax),%eax
  80042184cc:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  80042184cf:	75 71                	jne    8004218542 <pci_attach_match+0xc8>
			int r = list[i].attachfn(pcif);
  80042184d1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042184d4:	48 c1 e0 04          	shl    $0x4,%rax
  80042184d8:	48 89 c2             	mov    %rax,%rdx
  80042184db:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042184df:	48 01 d0             	add    %rdx,%rax
  80042184e2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042184e6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042184ea:	48 89 d7             	mov    %rdx,%rdi
  80042184ed:	ff d0                	callq  *%rax
  80042184ef:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  80042184f2:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042184f6:	7e 05                	jle    80042184fd <pci_attach_match+0x83>
				return r;
  80042184f8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042184fb:	eb 6c                	jmp    8004218569 <pci_attach_match+0xef>
			if (r < 0)
  80042184fd:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004218501:	79 3f                	jns    8004218542 <pci_attach_match+0xc8>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  8004218503:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218506:	48 c1 e0 04          	shl    $0x4,%rax
  800421850a:	48 89 c2             	mov    %rax,%rdx
  800421850d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218511:	48 01 d0             	add    %rdx,%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  8004218514:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004218518:	8b 75 f8             	mov    -0x8(%rbp),%esi
  800421851b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421851e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218521:	41 89 f0             	mov    %esi,%r8d
  8004218524:	89 c6                	mov    %eax,%esi
  8004218526:	48 bf c8 fe 21 04 80 	movabs $0x800421fec8,%rdi
  800421852d:	00 00 00 
  8004218530:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218535:	49 b9 1a 96 20 04 80 	movabs $0x800420961a,%r9
  800421853c:	00 00 00 
  800421853f:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004218542:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004218546:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218549:	48 c1 e0 04          	shl    $0x4,%rax
  800421854d:	48 89 c2             	mov    %rax,%rdx
  8004218550:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004218554:	48 01 d0             	add    %rdx,%rax
  8004218557:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421855b:	48 85 c0             	test   %rax,%rax
  800421855e:	0f 85 38 ff ff ff    	jne    800421849c <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  8004218564:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004218569:	c9                   	leaveq 
  800421856a:	c3                   	retq   

000000800421856b <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  800421856b:	55                   	push   %rbp
  800421856c:	48 89 e5             	mov    %rsp,%rbp
  800421856f:	48 83 ec 10          	sub    $0x10,%rsp
  8004218573:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004218577:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421857b:	8b 40 14             	mov    0x14(%rax),%eax
  800421857e:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  8004218581:	0f b6 c0             	movzbl %al,%eax
  8004218584:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218588:	8b 52 14             	mov    0x14(%rdx),%edx
  800421858b:	89 d7                	mov    %edx,%edi
  800421858d:	c1 ef 18             	shr    $0x18,%edi
  8004218590:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218594:	48 89 d1             	mov    %rdx,%rcx
  8004218597:	48 ba e0 37 23 04 80 	movabs $0x80042337e0,%rdx
  800421859e:	00 00 00 
  80042185a1:	89 c6                	mov    %eax,%esi
  80042185a3:	48 b8 7a 84 21 04 80 	movabs $0x800421847a,%rax
  80042185aa:	00 00 00 
  80042185ad:	ff d0                	callq  *%rax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  80042185af:	85 c0                	test   %eax,%eax
  80042185b1:	75 39                	jne    80042185ec <pci_attach+0x81>
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  80042185b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042185b7:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  80042185ba:	c1 e8 10             	shr    $0x10,%eax
  80042185bd:	89 c6                	mov    %eax,%esi
  80042185bf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042185c3:	8b 40 10             	mov    0x10(%rax),%eax
  80042185c6:	0f b7 c0             	movzwl %ax,%eax
  80042185c9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042185cd:	48 89 d1             	mov    %rdx,%rcx
  80042185d0:	48 ba 30 e7 3a 04 80 	movabs $0x80043ae730,%rdx
  80042185d7:	00 00 00 
  80042185da:	89 c7                	mov    %eax,%edi
  80042185dc:	48 b8 7a 84 21 04 80 	movabs $0x800421847a,%rax
  80042185e3:	00 00 00 
  80042185e6:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  80042185e8:	85 c0                	test   %eax,%eax
  80042185ea:	74 07                	je     80042185f3 <pci_attach+0x88>
  80042185ec:	b8 01 00 00 00       	mov    $0x1,%eax
  80042185f1:	eb 05                	jmp    80042185f8 <pci_attach+0x8d>
  80042185f3:	b8 00 00 00 00       	mov    $0x0,%eax
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  80042185f8:	c9                   	leaveq 
  80042185f9:	c3                   	retq   

00000080042185fa <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  80042185fa:	55                   	push   %rbp
  80042185fb:	48 89 e5             	mov    %rsp,%rbp
  80042185fe:	48 83 ec 40          	sub    $0x40,%rsp
  8004218602:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  8004218606:	48 b8 00 38 23 04 80 	movabs $0x8004233800,%rax
  800421860d:	00 00 00 
  8004218610:	48 8b 00             	mov    (%rax),%rax
  8004218613:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  8004218617:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421861b:	8b 40 14             	mov    0x14(%rax),%eax
  800421861e:	c1 e8 18             	shr    $0x18,%eax
  8004218621:	83 f8 06             	cmp    $0x6,%eax
  8004218624:	77 20                	ja     8004218646 <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  8004218626:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421862a:	8b 40 14             	mov    0x14(%rax),%eax
  800421862d:	c1 e8 18             	shr    $0x18,%eax
  8004218630:	89 c2                	mov    %eax,%edx
  8004218632:	48 b8 00 38 23 04 80 	movabs $0x8004233800,%rax
  8004218639:	00 00 00 
  800421863c:	89 d2                	mov    %edx,%edx
  800421863e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004218642:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  8004218646:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421864a:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421864e:	0f b6 f8             	movzbl %al,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004218651:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218655:	8b 40 14             	mov    0x14(%rax),%eax
  8004218658:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421865b:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  800421865e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218662:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004218665:	c1 e8 18             	shr    $0x18,%eax
  8004218668:	41 89 c1             	mov    %eax,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  800421866b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421866f:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004218672:	c1 e8 10             	shr    $0x10,%eax
  8004218675:	41 89 c2             	mov    %eax,%r10d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004218678:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421867c:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421867f:	44 0f b7 c0          	movzwl %ax,%r8d
  8004218683:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218687:	8b 48 0c             	mov    0xc(%rax),%ecx
  800421868a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421868e:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004218691:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218695:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004218698:	8b 40 08             	mov    0x8(%rax),%eax
  800421869b:	89 7c 24 18          	mov    %edi,0x18(%rsp)
  800421869f:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  80042186a3:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  80042186a8:	89 74 24 08          	mov    %esi,0x8(%rsp)
  80042186ac:	44 89 0c 24          	mov    %r9d,(%rsp)
  80042186b0:	45 89 d1             	mov    %r10d,%r9d
  80042186b3:	89 c6                	mov    %eax,%esi
  80042186b5:	48 bf 68 ff 21 04 80 	movabs $0x800421ff68,%rdi
  80042186bc:	00 00 00 
  80042186bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042186c4:	49 ba 1a 96 20 04 80 	movabs $0x800420961a,%r10
  80042186cb:	00 00 00 
  80042186ce:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  80042186d1:	c9                   	leaveq 
  80042186d2:	c3                   	retq   

00000080042186d3 <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  80042186d3:	55                   	push   %rbp
  80042186d4:	48 89 e5             	mov    %rsp,%rbp
  80042186d7:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  80042186de:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  80042186e5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  80042186ec:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042186f0:	ba 50 00 00 00       	mov    $0x50,%edx
  80042186f5:	be 00 00 00 00       	mov    $0x0,%esi
  80042186fa:	48 89 c7             	mov    %rax,%rdi
  80042186fd:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004218704:	00 00 00 
  8004218707:	ff d0                	callq  *%rax
	df.bus = bus;
  8004218709:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004218710:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004218714:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  800421871b:	e9 22 02 00 00       	jmpq   8004218942 <pci_scan_bus+0x26f>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  8004218720:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004218724:	be 0c 00 00 00       	mov    $0xc,%esi
  8004218729:	48 89 c7             	mov    %rax,%rdi
  800421872c:	48 b8 cc 83 21 04 80 	movabs $0x80042183cc,%rax
  8004218733:	00 00 00 
  8004218736:	ff d0                	callq  *%rax
  8004218738:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  800421873b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421873e:	c1 e8 10             	shr    $0x10,%eax
  8004218741:	83 e0 7f             	and    $0x7f,%eax
  8004218744:	83 f8 01             	cmp    $0x1,%eax
  8004218747:	0f 87 ec 01 00 00    	ja     8004218939 <pci_scan_bus+0x266>
			continue;

		totaldev++;
  800421874d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  8004218751:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004218755:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  800421875c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004218760:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004218767:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421876b:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004218772:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004218776:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  800421877d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004218781:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004218788:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421878c:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004218793:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004218797:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800421879e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042187a2:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  80042187a9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042187ad:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042187b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042187b8:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  80042187bf:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  80042187c6:	00 00 00 
  80042187c9:	e9 45 01 00 00       	jmpq   8004218913 <pci_scan_bus+0x240>
		     f.func++) {
			struct pci_func af = f;
  80042187ce:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042187d5:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  80042187dc:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042187e3:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80042187ea:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042187f1:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  80042187f8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042187ff:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004218806:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800421880d:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004218814:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421881b:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004218822:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004218829:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  800421882d:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004218834:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004218838:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800421883f:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004218843:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800421884a:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  800421884e:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  8004218855:	be 00 00 00 00       	mov    $0x0,%esi
  800421885a:	48 89 c7             	mov    %rax,%rdi
  800421885d:	48 b8 cc 83 21 04 80 	movabs $0x80042183cc,%rax
  8004218864:	00 00 00 
  8004218867:	ff d0                	callq  *%rax
  8004218869:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  800421886f:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  8004218875:	0f b7 c0             	movzwl %ax,%eax
  8004218878:	3d ff ff 00 00       	cmp    $0xffff,%eax
  800421887d:	0f 84 81 00 00 00    	je     8004218904 <pci_scan_bus+0x231>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  8004218883:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800421888a:	be 3c 00 00 00       	mov    $0x3c,%esi
  800421888f:	48 89 c7             	mov    %rax,%rdi
  8004218892:	48 b8 cc 83 21 04 80 	movabs $0x80042183cc,%rax
  8004218899:	00 00 00 
  800421889c:	ff d0                	callq  *%rax
  800421889e:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  80042188a1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042188a4:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  80042188a7:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042188ae:	be 08 00 00 00       	mov    $0x8,%esi
  80042188b3:	48 89 c7             	mov    %rax,%rdi
  80042188b6:	48 b8 cc 83 21 04 80 	movabs $0x80042183cc,%rax
  80042188bd:	00 00 00 
  80042188c0:	ff d0                	callq  *%rax
  80042188c2:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  80042188c8:	48 b8 c0 37 23 04 80 	movabs $0x80042337c0,%rax
  80042188cf:	00 00 00 
  80042188d2:	8b 00                	mov    (%rax),%eax
  80042188d4:	85 c0                	test   %eax,%eax
  80042188d6:	74 16                	je     80042188ee <pci_scan_bus+0x21b>
				pci_print_func(&af);
  80042188d8:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042188df:	48 89 c7             	mov    %rax,%rdi
  80042188e2:	48 b8 fa 85 21 04 80 	movabs $0x80042185fa,%rax
  80042188e9:	00 00 00 
  80042188ec:	ff d0                	callq  *%rax
			pci_attach(&af);
  80042188ee:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042188f5:	48 89 c7             	mov    %rax,%rdi
  80042188f8:	48 b8 6b 85 21 04 80 	movabs $0x800421856b,%rax
  80042188ff:	00 00 00 
  8004218902:	ff d0                	callq  *%rax

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  8004218904:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  800421890a:	83 c0 01             	add    $0x1,%eax
  800421890d:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004218913:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004218919:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421891c:	25 00 00 80 00       	and    $0x800000,%eax
  8004218921:	85 c0                	test   %eax,%eax
  8004218923:	74 07                	je     800421892c <pci_scan_bus+0x259>
  8004218925:	b8 08 00 00 00       	mov    $0x8,%eax
  800421892a:	eb 05                	jmp    8004218931 <pci_scan_bus+0x25e>
  800421892c:	b8 01 00 00 00       	mov    $0x1,%eax
  8004218931:	39 c2                	cmp    %eax,%edx
  8004218933:	0f 82 95 fe ff ff    	jb     80042187ce <pci_scan_bus+0xfb>
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004218939:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800421893c:	83 c0 01             	add    $0x1,%eax
  800421893f:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8004218942:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004218945:	83 f8 1f             	cmp    $0x1f,%eax
  8004218948:	0f 86 d2 fd ff ff    	jbe    8004218720 <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  800421894e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004218951:	c9                   	leaveq 
  8004218952:	c3                   	retq   

0000008004218953 <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  8004218953:	55                   	push   %rbp
  8004218954:	48 89 e5             	mov    %rsp,%rbp
  8004218957:	48 83 ec 30          	sub    $0x30,%rsp
  800421895b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  800421895f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218963:	be 1c 00 00 00       	mov    $0x1c,%esi
  8004218968:	48 89 c7             	mov    %rax,%rdi
  800421896b:	48 b8 cc 83 21 04 80 	movabs $0x80042183cc,%rax
  8004218972:	00 00 00 
  8004218975:	ff d0                	callq  *%rax
  8004218977:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  800421897a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421897e:	be 18 00 00 00       	mov    $0x18,%esi
  8004218983:	48 89 c7             	mov    %rax,%rdi
  8004218986:	48 b8 cc 83 21 04 80 	movabs $0x80042183cc,%rax
  800421898d:	00 00 00 
  8004218990:	ff d0                	callq  *%rax
  8004218992:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  8004218995:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218998:	83 e0 0f             	and    $0xf,%eax
  800421899b:	83 f8 01             	cmp    $0x1,%eax
  800421899e:	75 40                	jne    80042189e0 <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  80042189a0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042189a4:	8b 48 0c             	mov    0xc(%rax),%ecx
  80042189a7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042189ab:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  80042189ae:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042189b2:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  80042189b5:	8b 40 08             	mov    0x8(%rax),%eax
  80042189b8:	89 c6                	mov    %eax,%esi
  80042189ba:	48 bf a8 ff 21 04 80 	movabs $0x800421ffa8,%rdi
  80042189c1:	00 00 00 
  80042189c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042189c9:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  80042189d0:	00 00 00 
  80042189d3:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  80042189d6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042189db:	e9 a1 00 00 00       	jmpq   8004218a81 <pci_bridge_attach+0x12e>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  80042189e0:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042189e4:	ba 10 00 00 00       	mov    $0x10,%edx
  80042189e9:	be 00 00 00 00       	mov    $0x0,%esi
  80042189ee:	48 89 c7             	mov    %rax,%rdi
  80042189f1:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  80042189f8:	00 00 00 
  80042189fb:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  80042189fd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218a01:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  8004218a05:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218a08:	c1 e8 08             	shr    $0x8,%eax
  8004218a0b:	0f b6 c0             	movzbl %al,%eax
  8004218a0e:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  8004218a11:	48 b8 c0 37 23 04 80 	movabs $0x80042337c0,%rax
  8004218a18:	00 00 00 
  8004218a1b:	8b 00                	mov    (%rax),%eax
  8004218a1d:	85 c0                	test   %eax,%eax
  8004218a1f:	74 48                	je     8004218a69 <pci_bridge_attach+0x116>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  8004218a21:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218a24:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004218a27:	0f b6 f8             	movzbl %al,%edi
  8004218a2a:	8b 75 e8             	mov    -0x18(%rbp),%esi
  8004218a2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218a31:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004218a34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218a38:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  8004218a3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218a3f:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004218a42:	8b 40 08             	mov    0x8(%rax),%eax
  8004218a45:	41 89 f9             	mov    %edi,%r9d
  8004218a48:	41 89 f0             	mov    %esi,%r8d
  8004218a4b:	89 c6                	mov    %eax,%esi
  8004218a4d:	48 bf e0 ff 21 04 80 	movabs $0x800421ffe0,%rdi
  8004218a54:	00 00 00 
  8004218a57:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218a5c:	49 ba 1a 96 20 04 80 	movabs $0x800420961a,%r10
  8004218a63:	00 00 00 
  8004218a66:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  8004218a69:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004218a6d:	48 89 c7             	mov    %rax,%rdi
  8004218a70:	48 b8 d3 86 21 04 80 	movabs $0x80042186d3,%rax
  8004218a77:	00 00 00 
  8004218a7a:	ff d0                	callq  *%rax
	return 1;
  8004218a7c:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004218a81:	c9                   	leaveq 
  8004218a82:	c3                   	retq   

0000008004218a83 <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  8004218a83:	55                   	push   %rbp
  8004218a84:	48 89 e5             	mov    %rsp,%rbp
  8004218a87:	48 83 ec 40          	sub    $0x40,%rsp
  8004218a8b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  8004218a8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218a93:	ba 07 00 00 00       	mov    $0x7,%edx
  8004218a98:	be 04 00 00 00       	mov    $0x4,%esi
  8004218a9d:	48 89 c7             	mov    %rax,%rdi
  8004218aa0:	48 b8 21 84 21 04 80 	movabs $0x8004218421,%rax
  8004218aa7:	00 00 00 
  8004218aaa:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004218aac:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  8004218ab3:	e9 ee 01 00 00       	jmpq   8004218ca6 <pci_func_enable+0x223>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  8004218ab8:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218abb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218abf:	89 d6                	mov    %edx,%esi
  8004218ac1:	48 89 c7             	mov    %rax,%rdi
  8004218ac4:	48 b8 cc 83 21 04 80 	movabs $0x80042183cc,%rax
  8004218acb:	00 00 00 
  8004218ace:	ff d0                	callq  *%rax
  8004218ad0:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  8004218ad3:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  8004218ada:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004218add:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218ae1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004218ae6:	89 ce                	mov    %ecx,%esi
  8004218ae8:	48 89 c7             	mov    %rax,%rdi
  8004218aeb:	48 b8 21 84 21 04 80 	movabs $0x8004218421,%rax
  8004218af2:	00 00 00 
  8004218af5:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  8004218af7:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004218afa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218afe:	89 d6                	mov    %edx,%esi
  8004218b00:	48 89 c7             	mov    %rax,%rdi
  8004218b03:	48 b8 cc 83 21 04 80 	movabs $0x80042183cc,%rax
  8004218b0a:	00 00 00 
  8004218b0d:	ff d0                	callq  *%rax
  8004218b0f:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  8004218b12:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004218b16:	75 05                	jne    8004218b1d <pci_func_enable+0x9a>
			continue;
  8004218b18:	e9 83 01 00 00       	jmpq   8004218ca0 <pci_func_enable+0x21d>

		int regnum = PCI_MAPREG_NUM(bar);
  8004218b1d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004218b20:	83 e8 10             	sub    $0x10,%eax
  8004218b23:	c1 e8 02             	shr    $0x2,%eax
  8004218b26:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  8004218b29:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218b2c:	83 e0 01             	and    $0x1,%eax
  8004218b2f:	85 c0                	test   %eax,%eax
  8004218b31:	75 65                	jne    8004218b98 <pci_func_enable+0x115>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  8004218b33:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218b36:	83 e0 06             	and    $0x6,%eax
  8004218b39:	83 f8 04             	cmp    $0x4,%eax
  8004218b3c:	75 07                	jne    8004218b45 <pci_func_enable+0xc2>
				bar_width = 8;
  8004218b3e:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  8004218b45:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218b48:	83 e0 f0             	and    $0xfffffff0,%eax
  8004218b4b:	f7 d8                	neg    %eax
  8004218b4d:	23 45 e8             	and    -0x18(%rbp),%eax
  8004218b50:	83 e0 f0             	and    $0xfffffff0,%eax
  8004218b53:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  8004218b56:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218b59:	83 e0 f0             	and    $0xfffffff0,%eax
  8004218b5c:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004218b5f:	48 b8 40 e7 3a 04 80 	movabs $0x80043ae740,%rax
  8004218b66:	00 00 00 
  8004218b69:	8b 00                	mov    (%rax),%eax
  8004218b6b:	85 c0                	test   %eax,%eax
  8004218b6d:	74 7a                	je     8004218be9 <pci_func_enable+0x166>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  8004218b6f:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004218b72:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004218b75:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218b78:	89 c6                	mov    %eax,%esi
  8004218b7a:	48 bf 10 00 22 04 80 	movabs $0x8004220010,%rdi
  8004218b81:	00 00 00 
  8004218b84:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218b89:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  8004218b90:	00 00 00 
  8004218b93:	41 ff d0             	callq  *%r8
  8004218b96:	eb 51                	jmp    8004218be9 <pci_func_enable+0x166>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  8004218b98:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004218b9b:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218b9e:	f7 d8                	neg    %eax
  8004218ba0:	23 45 e8             	and    -0x18(%rbp),%eax
  8004218ba3:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218ba6:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  8004218ba9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004218bac:	83 e0 fc             	and    $0xfffffffc,%eax
  8004218baf:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004218bb2:	48 b8 40 e7 3a 04 80 	movabs $0x80043ae740,%rax
  8004218bb9:	00 00 00 
  8004218bbc:	8b 00                	mov    (%rax),%eax
  8004218bbe:	85 c0                	test   %eax,%eax
  8004218bc0:	74 27                	je     8004218be9 <pci_func_enable+0x166>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  8004218bc2:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004218bc5:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004218bc8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004218bcb:	89 c6                	mov    %eax,%esi
  8004218bcd:	48 bf 38 00 22 04 80 	movabs $0x8004220038,%rdi
  8004218bd4:	00 00 00 
  8004218bd7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218bdc:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  8004218be3:	00 00 00 
  8004218be6:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  8004218be9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004218bec:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004218bef:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218bf3:	89 ce                	mov    %ecx,%esi
  8004218bf5:	48 89 c7             	mov    %rax,%rdi
  8004218bf8:	48 b8 21 84 21 04 80 	movabs $0x8004218421,%rax
  8004218bff:	00 00 00 
  8004218c02:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  8004218c04:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218c08:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218c0b:	48 63 d2             	movslq %edx,%rdx
  8004218c0e:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  8004218c12:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004218c15:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  8004218c19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218c1d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004218c20:	48 63 d2             	movslq %edx,%rdx
  8004218c23:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8004218c27:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004218c2a:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  8004218c2d:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004218c31:	74 6d                	je     8004218ca0 <pci_func_enable+0x21d>
  8004218c33:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004218c37:	75 67                	jne    8004218ca0 <pci_func_enable+0x21d>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004218c39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218c3d:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004218c40:	c1 e8 10             	shr    $0x10,%eax
  8004218c43:	41 89 c0             	mov    %eax,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004218c46:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218c4a:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004218c4d:	0f b7 f8             	movzwl %ax,%edi
  8004218c50:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218c54:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004218c57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218c5b:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  8004218c5e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218c62:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004218c65:	8b 40 08             	mov    0x8(%rax),%eax
  8004218c68:	8b 75 f0             	mov    -0x10(%rbp),%esi
  8004218c6b:	89 74 24 10          	mov    %esi,0x10(%rsp)
  8004218c6f:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8004218c72:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004218c76:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004218c79:	89 34 24             	mov    %esi,(%rsp)
  8004218c7c:	45 89 c1             	mov    %r8d,%r9d
  8004218c7f:	41 89 f8             	mov    %edi,%r8d
  8004218c82:	89 c6                	mov    %eax,%esi
  8004218c84:	48 bf 60 00 22 04 80 	movabs $0x8004220060,%rdi
  8004218c8b:	00 00 00 
  8004218c8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218c93:	49 ba 1a 96 20 04 80 	movabs $0x800420961a,%r10
  8004218c9a:	00 00 00 
  8004218c9d:	41 ff d2             	callq  *%r10
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  8004218ca0:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004218ca3:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004218ca6:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  8004218caa:	0f 86 08 fe ff ff    	jbe    8004218ab8 <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004218cb0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218cb4:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218cb7:	c1 e8 10             	shr    $0x10,%eax
  8004218cba:	89 c7                	mov    %eax,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004218cbc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218cc0:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218cc3:	0f b7 f0             	movzwl %ax,%esi
  8004218cc6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218cca:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004218ccd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218cd1:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004218cd4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004218cd8:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004218cdb:	8b 40 08             	mov    0x8(%rax),%eax
  8004218cde:	41 89 f9             	mov    %edi,%r9d
  8004218ce1:	41 89 f0             	mov    %esi,%r8d
  8004218ce4:	89 c6                	mov    %eax,%esi
  8004218ce6:	48 bf c0 00 22 04 80 	movabs $0x80042200c0,%rdi
  8004218ced:	00 00 00 
  8004218cf0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218cf5:	49 ba 1a 96 20 04 80 	movabs $0x800420961a,%r10
  8004218cfc:	00 00 00 
  8004218cff:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  8004218d02:	c9                   	leaveq 
  8004218d03:	c3                   	retq   

0000008004218d04 <pci_init>:

int
pci_init(void)
{
  8004218d04:	55                   	push   %rbp
  8004218d05:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  8004218d08:	ba 10 00 00 00       	mov    $0x10,%edx
  8004218d0d:	be 00 00 00 00       	mov    $0x0,%esi
  8004218d12:	48 bf 50 e7 3a 04 80 	movabs $0x80043ae750,%rdi
  8004218d19:	00 00 00 
  8004218d1c:	48 b8 8c 0b 21 04 80 	movabs $0x8004210b8c,%rax
  8004218d23:	00 00 00 
  8004218d26:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  8004218d28:	48 bf 50 e7 3a 04 80 	movabs $0x80043ae750,%rdi
  8004218d2f:	00 00 00 
  8004218d32:	48 b8 d3 86 21 04 80 	movabs $0x80042186d3,%rax
  8004218d39:	00 00 00 
  8004218d3c:	ff d0                	callq  *%rax
}
  8004218d3e:	5d                   	pop    %rbp
  8004218d3f:	c3                   	retq   

0000008004218d40 <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  8004218d40:	55                   	push   %rbp
  8004218d41:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  8004218d44:	48 b8 60 e7 3a 04 80 	movabs $0x80043ae760,%rax
  8004218d4b:	00 00 00 
  8004218d4e:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  8004218d54:	5d                   	pop    %rbp
  8004218d55:	c3                   	retq   

0000008004218d56 <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  8004218d56:	55                   	push   %rbp
  8004218d57:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  8004218d5a:	48 b8 60 e7 3a 04 80 	movabs $0x80043ae760,%rax
  8004218d61:	00 00 00 
  8004218d64:	8b 00                	mov    (%rax),%eax
  8004218d66:	8d 50 01             	lea    0x1(%rax),%edx
  8004218d69:	48 b8 60 e7 3a 04 80 	movabs $0x80043ae760,%rax
  8004218d70:	00 00 00 
  8004218d73:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  8004218d75:	48 b8 60 e7 3a 04 80 	movabs $0x80043ae760,%rax
  8004218d7c:	00 00 00 
  8004218d7f:	8b 10                	mov    (%rax),%edx
  8004218d81:	89 d0                	mov    %edx,%eax
  8004218d83:	c1 e0 02             	shl    $0x2,%eax
  8004218d86:	01 d0                	add    %edx,%eax
  8004218d88:	01 c0                	add    %eax,%eax
  8004218d8a:	89 c2                	mov    %eax,%edx
  8004218d8c:	48 b8 60 e7 3a 04 80 	movabs $0x80043ae760,%rax
  8004218d93:	00 00 00 
  8004218d96:	8b 00                	mov    (%rax),%eax
  8004218d98:	39 c2                	cmp    %eax,%edx
  8004218d9a:	73 2a                	jae    8004218dc6 <time_tick+0x70>
		panic("time_tick: time overflowed");
  8004218d9c:	48 ba ef 00 22 04 80 	movabs $0x80042200ef,%rdx
  8004218da3:	00 00 00 
  8004218da6:	be 13 00 00 00       	mov    $0x13,%esi
  8004218dab:	48 bf 0a 01 22 04 80 	movabs $0x800422010a,%rdi
  8004218db2:	00 00 00 
  8004218db5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218dba:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  8004218dc1:	00 00 00 
  8004218dc4:	ff d1                	callq  *%rcx
}
  8004218dc6:	5d                   	pop    %rbp
  8004218dc7:	c3                   	retq   

0000008004218dc8 <time_msec>:

unsigned int
time_msec(void)
{
  8004218dc8:	55                   	push   %rbp
  8004218dc9:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  8004218dcc:	48 b8 60 e7 3a 04 80 	movabs $0x80043ae760,%rax
  8004218dd3:	00 00 00 
  8004218dd6:	8b 10                	mov    (%rax),%edx
  8004218dd8:	89 d0                	mov    %edx,%eax
  8004218dda:	c1 e0 02             	shl    $0x2,%eax
  8004218ddd:	01 d0                	add    %edx,%eax
  8004218ddf:	01 c0                	add    %eax,%eax
}
  8004218de1:	5d                   	pop    %rbp
  8004218de2:	c3                   	retq   

0000008004218de3 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004218de3:	55                   	push   %rbp
  8004218de4:	48 89 e5             	mov    %rsp,%rbp
  8004218de7:	48 83 ec 08          	sub    $0x8,%rsp
  8004218deb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004218def:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218df3:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004218dfa:	00 00 00 
  8004218dfd:	48 8b 00             	mov    (%rax),%rax
  8004218e00:	48 29 c2             	sub    %rax,%rdx
  8004218e03:	48 89 d0             	mov    %rdx,%rax
  8004218e06:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004218e0a:	c9                   	leaveq 
  8004218e0b:	c3                   	retq   

0000008004218e0c <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004218e0c:	55                   	push   %rbp
  8004218e0d:	48 89 e5             	mov    %rsp,%rbp
  8004218e10:	48 83 ec 08          	sub    $0x8,%rsp
  8004218e14:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004218e18:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218e1c:	48 89 c7             	mov    %rax,%rdi
  8004218e1f:	48 b8 e3 8d 21 04 80 	movabs $0x8004218de3,%rax
  8004218e26:	00 00 00 
  8004218e29:	ff d0                	callq  *%rax
  8004218e2b:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004218e2f:	c9                   	leaveq 
  8004218e30:	c3                   	retq   

0000008004218e31 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004218e31:	55                   	push   %rbp
  8004218e32:	48 89 e5             	mov    %rsp,%rbp
  8004218e35:	48 83 ec 10          	sub    $0x10,%rsp
  8004218e39:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004218e3d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218e41:	48 c1 e8 0c          	shr    $0xc,%rax
  8004218e45:	48 89 c2             	mov    %rax,%rdx
  8004218e48:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004218e4f:	00 00 00 
  8004218e52:	48 8b 00             	mov    (%rax),%rax
  8004218e55:	48 39 c2             	cmp    %rax,%rdx
  8004218e58:	72 2a                	jb     8004218e84 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004218e5a:	48 ba 18 01 22 04 80 	movabs $0x8004220118,%rdx
  8004218e61:	00 00 00 
  8004218e64:	be 54 00 00 00       	mov    $0x54,%esi
  8004218e69:	48 bf 37 01 22 04 80 	movabs $0x8004220137,%rdi
  8004218e70:	00 00 00 
  8004218e73:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218e78:	48 b9 41 05 20 04 80 	movabs $0x8004200541,%rcx
  8004218e7f:	00 00 00 
  8004218e82:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004218e84:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  8004218e8b:	00 00 00 
  8004218e8e:	48 8b 00             	mov    (%rax),%rax
  8004218e91:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004218e95:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004218e99:	48 c1 e2 04          	shl    $0x4,%rdx
  8004218e9d:	48 01 d0             	add    %rdx,%rax
}
  8004218ea0:	c9                   	leaveq 
  8004218ea1:	c3                   	retq   

0000008004218ea2 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004218ea2:	55                   	push   %rbp
  8004218ea3:	48 89 e5             	mov    %rsp,%rbp
  8004218ea6:	48 83 ec 20          	sub    $0x20,%rsp
  8004218eaa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004218eae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218eb2:	48 89 c7             	mov    %rax,%rdi
  8004218eb5:	48 b8 0c 8e 21 04 80 	movabs $0x8004218e0c,%rax
  8004218ebc:	00 00 00 
  8004218ebf:	ff d0                	callq  *%rax
  8004218ec1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004218ec5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218ec9:	48 c1 e8 0c          	shr    $0xc,%rax
  8004218ecd:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004218ed0:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004218ed3:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  8004218eda:	00 00 00 
  8004218edd:	48 8b 00             	mov    (%rax),%rax
  8004218ee0:	48 39 c2             	cmp    %rax,%rdx
  8004218ee3:	72 32                	jb     8004218f17 <page2kva+0x75>
  8004218ee5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218ee9:	48 89 c1             	mov    %rax,%rcx
  8004218eec:	48 ba 48 01 22 04 80 	movabs $0x8004220148,%rdx
  8004218ef3:	00 00 00 
  8004218ef6:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004218efb:	48 bf 37 01 22 04 80 	movabs $0x8004220137,%rdi
  8004218f02:	00 00 00 
  8004218f05:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218f0a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004218f11:	00 00 00 
  8004218f14:	41 ff d0             	callq  *%r8
  8004218f17:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004218f1e:	00 00 00 
  8004218f21:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218f25:	48 01 d0             	add    %rdx,%rax
}
  8004218f28:	c9                   	leaveq 
  8004218f29:	c3                   	retq   

0000008004218f2a <epte_addr>:
#include <kern/pmap.h>
#include <inc/string.h>

// Return the physical address of an ept entry
static inline uintptr_t epte_addr(epte_t epte)
{
  8004218f2a:	55                   	push   %rbp
  8004218f2b:	48 89 e5             	mov    %rsp,%rbp
  8004218f2e:	48 83 ec 08          	sub    $0x8,%rsp
  8004218f32:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (epte & EPTE_ADDR);
  8004218f36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218f3a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  8004218f40:	c9                   	leaveq 
  8004218f41:	c3                   	retq   

0000008004218f42 <epte_present>:
	return (epte & EPTE_FLAGS);
}

// Return true if an ept entry's mapping is present
static inline int epte_present(epte_t epte)
{
  8004218f42:	55                   	push   %rbp
  8004218f43:	48 89 e5             	mov    %rsp,%rbp
  8004218f46:	48 83 ec 08          	sub    $0x8,%rsp
  8004218f4a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return (epte & __EPTE_FULL) > 0;
  8004218f4e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004218f52:	83 e0 07             	and    $0x7,%eax
  8004218f55:	48 85 c0             	test   %rax,%rax
  8004218f58:	0f 95 c0             	setne  %al
  8004218f5b:	0f b6 c0             	movzbl %al,%eax
}
  8004218f5e:	c9                   	leaveq 
  8004218f5f:	c3                   	retq   

0000008004218f60 <ept_lookup_gpa>:
//
// Hint: Set the permissions of intermediate ept entries to __EPTE_FULL.
//       The hardware ANDs the permissions at each level, so removing a permission
//       bit at the last level entry is sufficient (and the bookkeeping is much simpler).
static int ept_lookup_gpa(epte_t* eptrt, void *gpa, 
			  int create, epte_t **epte_out) {
  8004218f60:	55                   	push   %rbp
  8004218f61:	48 89 e5             	mov    %rsp,%rbp
  8004218f64:	48 83 ec 30          	sub    $0x30,%rsp
  8004218f68:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004218f6c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004218f70:	89 55 dc             	mov    %edx,-0x24(%rbp)
  8004218f73:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	epte_t * pgTblIndexPtr = NULL;
  8004218f77:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004218f7e:	00 
	struct PageInfo * page = NULL;
  8004218f7f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004218f86:	00 

    /* Your code here */

	if(eptrt == NULL){
  8004218f87:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004218f8c:	75 25                	jne    8004218fb3 <ept_lookup_gpa+0x53>
			cprintf("ept_lookup_gpa : 1\n");
  8004218f8e:	48 bf 6b 01 22 04 80 	movabs $0x800422016b,%rdi
  8004218f95:	00 00 00 
  8004218f98:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218f9d:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004218fa4:	00 00 00 
  8004218fa7:	ff d2                	callq  *%rdx
			return -E_INVAL;
  8004218fa9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8004218fae:	e9 88 00 00 00       	jmpq   800421903b <ept_lookup_gpa+0xdb>
	}
	pgTblIndexPtr =  pml4e_walk(eptrt, gpa, create);
  8004218fb3:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004218fb6:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004218fba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004218fbe:	48 89 ce             	mov    %rcx,%rsi
  8004218fc1:	48 89 c7             	mov    %rax,%rdi
  8004218fc4:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  8004218fcb:	00 00 00 
  8004218fce:	ff d0                	callq  *%rax
  8004218fd0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(pgTblIndexPtr == NULL){
  8004218fd4:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004218fd9:	75 2f                	jne    800421900a <ept_lookup_gpa+0xaa>
		cprintf("ept_lookup_gpa : 2\n");
  8004218fdb:	48 bf 7f 01 22 04 80 	movabs $0x800422017f,%rdi
  8004218fe2:	00 00 00 
  8004218fe5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004218fea:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004218ff1:	00 00 00 
  8004218ff4:	ff d2                	callq  *%rdx
		if(create  == 0)
  8004218ff6:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004218ffa:	75 07                	jne    8004219003 <ept_lookup_gpa+0xa3>
			return -E_NO_ENT;			
  8004218ffc:	b8 eb ff ff ff       	mov    $0xffffffeb,%eax
  8004219001:	eb 38                	jmp    800421903b <ept_lookup_gpa+0xdb>
		else
			return  -E_NO_MEM;
  8004219003:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004219008:	eb 31                	jmp    800421903b <ept_lookup_gpa+0xdb>
	}
	
	page = pa2page(*pgTblIndexPtr);				
  800421900a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421900e:	48 8b 00             	mov    (%rax),%rax
  8004219011:	48 89 c7             	mov    %rax,%rdi
  8004219014:	48 b8 31 8e 21 04 80 	movabs $0x8004218e31,%rax
  800421901b:	00 00 00 
  800421901e:	ff d0                	callq  *%rax
  8004219020:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(epte_out)
  8004219024:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004219029:	74 0b                	je     8004219036 <ept_lookup_gpa+0xd6>
	{
		*epte_out = pgTblIndexPtr;
  800421902b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421902f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004219033:	48 89 10             	mov    %rdx,(%rax)
	}
	return 0;
  8004219036:	b8 00 00 00 00       	mov    $0x0,%eax
	
    //panic("ept_lookup_gpa not implemented\n");
    //return 0;

}
  800421903b:	c9                   	leaveq 
  800421903c:	c3                   	retq   

000000800421903d <ept_gpa2hva>:

void ept_gpa2hva(epte_t* eptrt, void *gpa, void **hva) {
  800421903d:	55                   	push   %rbp
  800421903e:	48 89 e5             	mov    %rsp,%rbp
  8004219041:	48 83 ec 40          	sub    $0x40,%rsp
  8004219045:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004219049:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421904d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    epte_t* pte;
    int ret = ept_lookup_gpa(eptrt, gpa, 0, &pte);
  8004219051:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  8004219055:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004219059:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421905d:	48 89 d1             	mov    %rdx,%rcx
  8004219060:	ba 00 00 00 00       	mov    $0x0,%edx
  8004219065:	48 89 c7             	mov    %rax,%rdi
  8004219068:	48 b8 60 8f 21 04 80 	movabs $0x8004218f60,%rax
  800421906f:	00 00 00 
  8004219072:	ff d0                	callq  *%rax
  8004219074:	89 45 fc             	mov    %eax,-0x4(%rbp)
    if(ret < 0) {
  8004219077:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421907b:	79 10                	jns    800421908d <ept_gpa2hva+0x50>
        *hva = NULL;
  800421907d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219081:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  8004219088:	e9 b1 00 00 00       	jmpq   800421913e <ept_gpa2hva+0x101>
    } else {
        if(!epte_present(*pte)) {
  800421908d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219091:	48 8b 00             	mov    (%rax),%rax
  8004219094:	48 89 c7             	mov    %rax,%rdi
  8004219097:	48 b8 42 8f 21 04 80 	movabs $0x8004218f42,%rax
  800421909e:	00 00 00 
  80042190a1:	ff d0                	callq  *%rax
  80042190a3:	85 c0                	test   %eax,%eax
  80042190a5:	75 10                	jne    80042190b7 <ept_gpa2hva+0x7a>
           *hva = NULL;
  80042190a7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042190ab:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
  80042190b2:	e9 87 00 00 00       	jmpq   800421913e <ept_gpa2hva+0x101>
        } else {
           *hva = KADDR(epte_addr(*pte));
  80042190b7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042190bb:	48 8b 00             	mov    (%rax),%rax
  80042190be:	48 89 c7             	mov    %rax,%rdi
  80042190c1:	48 b8 2a 8f 21 04 80 	movabs $0x8004218f2a,%rax
  80042190c8:	00 00 00 
  80042190cb:	ff d0                	callq  *%rax
  80042190cd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042190d1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042190d5:	48 c1 e8 0c          	shr    $0xc,%rax
  80042190d9:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042190dc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042190df:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042190e6:	00 00 00 
  80042190e9:	48 8b 00             	mov    (%rax),%rax
  80042190ec:	48 39 c2             	cmp    %rax,%rdx
  80042190ef:	72 32                	jb     8004219123 <ept_gpa2hva+0xe6>
  80042190f1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042190f5:	48 89 c1             	mov    %rax,%rcx
  80042190f8:	48 ba 48 01 22 04 80 	movabs $0x8004220148,%rdx
  80042190ff:	00 00 00 
  8004219102:	be 58 00 00 00       	mov    $0x58,%esi
  8004219107:	48 bf 93 01 22 04 80 	movabs $0x8004220193,%rdi
  800421910e:	00 00 00 
  8004219111:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219116:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421911d:	00 00 00 
  8004219120:	41 ff d0             	callq  *%r8
  8004219123:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421912a:	00 00 00 
  800421912d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219131:	48 01 d0             	add    %rdx,%rax
  8004219134:	48 89 c2             	mov    %rax,%rdx
  8004219137:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421913b:	48 89 10             	mov    %rdx,(%rax)
        }
    }
}
  800421913e:	c9                   	leaveq 
  800421913f:	c3                   	retq   

0000008004219140 <free_ept_level>:

static void free_ept_level(epte_t* eptrt, int level) {
  8004219140:	55                   	push   %rbp
  8004219141:	48 89 e5             	mov    %rsp,%rbp
  8004219144:	48 83 ec 40          	sub    $0x40,%rsp
  8004219148:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421914c:	89 75 c4             	mov    %esi,-0x3c(%rbp)
    epte_t* dir = eptrt;
  800421914f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219153:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    int i;

    for(i=0; i<NPTENTRIES; ++i) {
  8004219157:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421915e:	e9 82 01 00 00       	jmpq   80042192e5 <free_ept_level+0x1a5>
        if(level != 0) {
  8004219163:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004219167:	0f 84 fe 00 00 00    	je     800421926b <free_ept_level+0x12b>
            if(epte_present(dir[i])) {
  800421916d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219170:	48 98                	cltq   
  8004219172:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219179:	00 
  800421917a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421917e:	48 01 d0             	add    %rdx,%rax
  8004219181:	48 8b 00             	mov    (%rax),%rax
  8004219184:	48 89 c7             	mov    %rax,%rdi
  8004219187:	48 b8 42 8f 21 04 80 	movabs $0x8004218f42,%rax
  800421918e:	00 00 00 
  8004219191:	ff d0                	callq  *%rax
  8004219193:	85 c0                	test   %eax,%eax
  8004219195:	0f 84 46 01 00 00    	je     80042192e1 <free_ept_level+0x1a1>
                physaddr_t pa = epte_addr(dir[i]);
  800421919b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421919e:	48 98                	cltq   
  80042191a0:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042191a7:	00 
  80042191a8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042191ac:	48 01 d0             	add    %rdx,%rax
  80042191af:	48 8b 00             	mov    (%rax),%rax
  80042191b2:	48 89 c7             	mov    %rax,%rdi
  80042191b5:	48 b8 2a 8f 21 04 80 	movabs $0x8004218f2a,%rax
  80042191bc:	00 00 00 
  80042191bf:	ff d0                	callq  *%rax
  80042191c1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
                free_ept_level((epte_t*) KADDR(pa), level-1);
  80042191c5:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042191c8:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042191cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042191cf:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042191d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042191d7:	48 c1 e8 0c          	shr    $0xc,%rax
  80042191db:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042191de:	8b 4d dc             	mov    -0x24(%rbp),%ecx
  80042191e1:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042191e8:	00 00 00 
  80042191eb:	48 8b 00             	mov    (%rax),%rax
  80042191ee:	48 39 c1             	cmp    %rax,%rcx
  80042191f1:	72 32                	jb     8004219225 <free_ept_level+0xe5>
  80042191f3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042191f7:	48 89 c1             	mov    %rax,%rcx
  80042191fa:	48 ba 48 01 22 04 80 	movabs $0x8004220148,%rdx
  8004219201:	00 00 00 
  8004219204:	be 65 00 00 00       	mov    $0x65,%esi
  8004219209:	48 bf 93 01 22 04 80 	movabs $0x8004220193,%rdi
  8004219210:	00 00 00 
  8004219213:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219218:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421921f:	00 00 00 
  8004219222:	41 ff d0             	callq  *%r8
  8004219225:	48 b9 00 00 00 04 80 	movabs $0x8004000000,%rcx
  800421922c:	00 00 00 
  800421922f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219233:	48 01 c8             	add    %rcx,%rax
  8004219236:	89 d6                	mov    %edx,%esi
  8004219238:	48 89 c7             	mov    %rax,%rdi
  800421923b:	48 b8 40 91 21 04 80 	movabs $0x8004219140,%rax
  8004219242:	00 00 00 
  8004219245:	ff d0                	callq  *%rax
                // free the table.
                page_decref(pa2page(pa));
  8004219247:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421924b:	48 89 c7             	mov    %rax,%rdi
  800421924e:	48 b8 31 8e 21 04 80 	movabs $0x8004218e31,%rax
  8004219255:	00 00 00 
  8004219258:	ff d0                	callq  *%rax
  800421925a:	48 89 c7             	mov    %rax,%rdi
  800421925d:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004219264:	00 00 00 
  8004219267:	ff d0                	callq  *%rax
  8004219269:	eb 76                	jmp    80042192e1 <free_ept_level+0x1a1>
            }
        } else {
            // Last level, free the guest physical page.
            if(epte_present(dir[i])) {
  800421926b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421926e:	48 98                	cltq   
  8004219270:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004219277:	00 
  8004219278:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421927c:	48 01 d0             	add    %rdx,%rax
  800421927f:	48 8b 00             	mov    (%rax),%rax
  8004219282:	48 89 c7             	mov    %rax,%rdi
  8004219285:	48 b8 42 8f 21 04 80 	movabs $0x8004218f42,%rax
  800421928c:	00 00 00 
  800421928f:	ff d0                	callq  *%rax
  8004219291:	85 c0                	test   %eax,%eax
  8004219293:	74 4c                	je     80042192e1 <free_ept_level+0x1a1>
                physaddr_t pa = epte_addr(dir[i]);                
  8004219295:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219298:	48 98                	cltq   
  800421929a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042192a1:	00 
  80042192a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042192a6:	48 01 d0             	add    %rdx,%rax
  80042192a9:	48 8b 00             	mov    (%rax),%rax
  80042192ac:	48 89 c7             	mov    %rax,%rdi
  80042192af:	48 b8 2a 8f 21 04 80 	movabs $0x8004218f2a,%rax
  80042192b6:	00 00 00 
  80042192b9:	ff d0                	callq  *%rax
  80042192bb:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                page_decref(pa2page(pa));
  80042192bf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042192c3:	48 89 c7             	mov    %rax,%rdi
  80042192c6:	48 b8 31 8e 21 04 80 	movabs $0x8004218e31,%rax
  80042192cd:	00 00 00 
  80042192d0:	ff d0                	callq  *%rax
  80042192d2:	48 89 c7             	mov    %rax,%rdi
  80042192d5:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  80042192dc:	00 00 00 
  80042192df:	ff d0                	callq  *%rax

static void free_ept_level(epte_t* eptrt, int level) {
    epte_t* dir = eptrt;
    int i;

    for(i=0; i<NPTENTRIES; ++i) {
  80042192e1:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042192e5:	81 7d fc ff 01 00 00 	cmpl   $0x1ff,-0x4(%rbp)
  80042192ec:	0f 8e 71 fe ff ff    	jle    8004219163 <free_ept_level+0x23>
                physaddr_t pa = epte_addr(dir[i]);                
                page_decref(pa2page(pa));
            }
        }
    }
    return;
  80042192f2:	90                   	nop
}
  80042192f3:	c9                   	leaveq 
  80042192f4:	c3                   	retq   

00000080042192f5 <free_guest_mem>:

// Free the EPT table entries and the EPT tables.
// NOTE: Does not deallocate EPT PML4 page.
void free_guest_mem(epte_t* eptrt) {
  80042192f5:	55                   	push   %rbp
  80042192f6:	48 89 e5             	mov    %rsp,%rbp
  80042192f9:	48 83 ec 20          	sub    $0x20,%rsp
  80042192fd:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    free_ept_level(eptrt, EPT_LEVELS - 1);
  8004219301:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219305:	be 03 00 00 00       	mov    $0x3,%esi
  800421930a:	48 89 c7             	mov    %rax,%rdi
  800421930d:	48 b8 40 91 21 04 80 	movabs $0x8004219140,%rax
  8004219314:	00 00 00 
  8004219317:	ff d0                	callq  *%rax

    static __inline void
tlbflush(void)
{
    uint64_t cr3;
    __asm __volatile("movq %%cr3,%0" : "=r" (cr3));
  8004219319:	0f 20 d8             	mov    %cr3,%rax
  800421931c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    __asm __volatile("movq %0,%%cr3" : : "r" (cr3));
  8004219320:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219324:	0f 22 d8             	mov    %rax,%cr3
    tlbflush();
}
  8004219327:	c9                   	leaveq 
  8004219328:	c3                   	retq   

0000008004219329 <ept_page_insert>:
//  with permission perm.  eptrt is the EPT root.
// 
// Return 0 on success, <0 on failure.
//

int ept_page_insert(epte_t* eptrt, struct PageInfo* pp, void* gpa, int perm) {
  8004219329:	55                   	push   %rbp
  800421932a:	48 89 e5             	mov    %rsp,%rbp
  800421932d:	48 83 ec 30          	sub    $0x30,%rsp
  8004219331:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004219335:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004219339:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800421933d:	89 4d d4             	mov    %ecx,-0x2c(%rbp)

    /* Your code here */

	// Fill this function ineptrteptrt
	epte_t * pgTblIndexPtr;
	if(eptrt == NULL || pp == NULL)
  8004219340:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004219345:	74 07                	je     800421934e <ept_page_insert+0x25>
  8004219347:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421934c:	75 25                	jne    8004219373 <ept_page_insert+0x4a>
	{
		cprintf("returning  here 1");
  800421934e:	48 bf 9d 01 22 04 80 	movabs $0x800422019d,%rdi
  8004219355:	00 00 00 
  8004219358:	b8 00 00 00 00       	mov    $0x0,%eax
  800421935d:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004219364:	00 00 00 
  8004219367:	ff d2                	callq  *%rdx
		return -E_INVAL;
  8004219369:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800421936e:	e9 13 01 00 00       	jmpq   8004219486 <ept_page_insert+0x15d>
	}
	
	pgTblIndexPtr =  pml4e_walk(eptrt, gpa, 1);
  8004219373:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004219377:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421937b:	ba 01 00 00 00       	mov    $0x1,%edx
  8004219380:	48 89 ce             	mov    %rcx,%rsi
  8004219383:	48 89 c7             	mov    %rax,%rdi
  8004219386:	48 b8 49 31 20 04 80 	movabs $0x8004203149,%rax
  800421938d:	00 00 00 
  8004219390:	ff d0                	callq  *%rax
  8004219392:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//cprintf("pgTblIndexPtr %p %x\n", pgTblIndexPtr, pgTblIndexPtr);
	if(!pgTblIndexPtr)
  8004219396:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421939b:	75 25                	jne    80042193c2 <ept_page_insert+0x99>
	{
		cprintf("returning  here 2");
  800421939d:	48 bf af 01 22 04 80 	movabs $0x80042201af,%rdi
  80042193a4:	00 00 00 
  80042193a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042193ac:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042193b3:	00 00 00 
  80042193b6:	ff d2                	callq  *%rdx
		return 	-E_NO_MEM;
  80042193b8:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80042193bd:	e9 c4 00 00 00       	jmpq   8004219486 <ept_page_insert+0x15d>
	}
	//set present bit
	perm = perm|__EPTE_READ|__EPTE_IPAT;
  80042193c2:	83 4d d4 41          	orl    $0x41,-0x2c(%rbp)
	bool present = *pgTblIndexPtr & __EPTE_READ;
  80042193c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042193ca:	48 8b 00             	mov    (%rax),%rax
  80042193cd:	83 e0 01             	and    $0x1,%eax
  80042193d0:	48 85 c0             	test   %rax,%rax
  80042193d3:	0f 95 c0             	setne  %al
  80042193d6:	88 45 f7             	mov    %al,-0x9(%rbp)
	if(present &&pa2page(PTE_ADDR(*pgTblIndexPtr)) == pp)
  80042193d9:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  80042193dd:	74 4c                	je     800421942b <ept_page_insert+0x102>
  80042193df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042193e3:	48 8b 00             	mov    (%rax),%rax
  80042193e6:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042193ec:	48 89 c7             	mov    %rax,%rdi
  80042193ef:	48 b8 31 8e 21 04 80 	movabs $0x8004218e31,%rax
  80042193f6:	00 00 00 
  80042193f9:	ff d0                	callq  *%rax
  80042193fb:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042193ff:	75 2a                	jne    800421942b <ept_page_insert+0x102>
	{	*pgTblIndexPtr = (page2pa(pp) | perm);
  8004219401:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219405:	48 89 c7             	mov    %rax,%rdi
  8004219408:	48 b8 0c 8e 21 04 80 	movabs $0x8004218e0c,%rax
  800421940f:	00 00 00 
  8004219412:	ff d0                	callq  *%rax
  8004219414:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004219417:	48 63 d2             	movslq %edx,%rdx
  800421941a:	48 09 c2             	or     %rax,%rdx
  800421941d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219421:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004219424:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219429:	eb 5b                	jmp    8004219486 <ept_page_insert+0x15d>
	}
	//check and remove previous existing page
	else if(present)
  800421942b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  800421942f:	74 1a                	je     800421944b <ept_page_insert+0x122>
	{	
		page_remove(eptrt, gpa);
  8004219431:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004219435:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219439:	48 89 d6             	mov    %rdx,%rsi
  800421943c:	48 89 c7             	mov    %rax,%rdi
  800421943f:	48 b8 d7 39 20 04 80 	movabs $0x80042039d7,%rax
  8004219446:	00 00 00 
  8004219449:	ff d0                	callq  *%rax
	}

	//add new page
	*pgTblIndexPtr = (page2pa(pp) | perm);
  800421944b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421944f:	48 89 c7             	mov    %rax,%rdi
  8004219452:	48 b8 0c 8e 21 04 80 	movabs $0x8004218e0c,%rax
  8004219459:	00 00 00 
  800421945c:	ff d0                	callq  *%rax
  800421945e:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004219461:	48 63 d2             	movslq %edx,%rdx
  8004219464:	48 09 c2             	or     %rax,%rdx
  8004219467:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421946b:	48 89 10             	mov    %rdx,(%rax)
	//increment reference
	pp->pp_ref += 1;
  800421946e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219472:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004219476:	8d 50 01             	lea    0x1(%rax),%edx
  8004219479:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421947d:	66 89 50 08          	mov    %dx,0x8(%rax)

	return 0;
  8004219481:	b8 00 00 00 00       	mov    $0x0,%eax
    //panic("ept_page_insert not implemented\n");
    //return 0;
}
  8004219486:	c9                   	leaveq 
  8004219487:	c3                   	retq   

0000008004219488 <ept_map_hva2gpa>:
// 
// Hint: use ept_lookup_gpa to create the intermediate 
//       ept levels, and return the final epte_t pointer.
//       You should set the type to EPTE_TYPE_WB and set __EPTE_IPAT flag.
int ept_map_hva2gpa(epte_t* eptrt, void* hva, void* gpa, int perm, 
        int overwrite) {
  8004219488:	55                   	push   %rbp
  8004219489:	48 89 e5             	mov    %rsp,%rbp
  800421948c:	48 83 ec 40          	sub    $0x40,%rsp
  8004219490:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004219494:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004219498:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421949c:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
  800421949f:	44 89 45 c0          	mov    %r8d,-0x40(%rbp)
	epte_t* epte_out = NULL; 
  80042194a3:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042194aa:	00 
	int result = 0;
  80042194ab:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
    /* Your code here */

	result = ept_lookup_gpa(eptrt, gpa, 1 , &epte_out);
  80042194b2:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
  80042194b6:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
  80042194ba:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042194be:	48 89 d1             	mov    %rdx,%rcx
  80042194c1:	ba 01 00 00 00       	mov    $0x1,%edx
  80042194c6:	48 89 c7             	mov    %rax,%rdi
  80042194c9:	48 b8 60 8f 21 04 80 	movabs $0x8004218f60,%rax
  80042194d0:	00 00 00 
  80042194d3:	ff d0                	callq  *%rax
  80042194d5:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result < 0){
  80042194d8:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042194dc:	79 23                	jns    8004219501 <ept_map_hva2gpa+0x79>
		cprintf("ept_map_hva2gpa :  failing with result < 0\n");
  80042194de:	48 bf c8 01 22 04 80 	movabs $0x80042201c8,%rdi
  80042194e5:	00 00 00 
  80042194e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042194ed:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042194f4:	00 00 00 
  80042194f7:	ff d2                	callq  *%rdx
		return result;
  80042194f9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042194fc:	e9 43 01 00 00       	jmpq   8004219644 <ept_map_hva2gpa+0x1bc>
	}
	else if(result  == 0){
  8004219501:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004219505:	0f 85 34 01 00 00    	jne    800421963f <ept_map_hva2gpa+0x1b7>
		if(*epte_out == '\0')	
  800421950b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421950f:	48 8b 00             	mov    (%rax),%rax
  8004219512:	48 85 c0             	test   %rax,%rax
  8004219515:	75 70                	jne    8004219587 <ept_map_hva2gpa+0xff>
			*epte_out = (uint64_t)PADDR(hva)|perm;
  8004219517:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421951b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421951f:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004219523:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  800421952a:	00 00 00 
  800421952d:	48 39 55 f0          	cmp    %rdx,-0x10(%rbp)
  8004219531:	77 32                	ja     8004219565 <ept_map_hva2gpa+0xdd>
  8004219533:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004219537:	48 89 c1             	mov    %rax,%rcx
  800421953a:	48 ba f8 01 22 04 80 	movabs $0x80042201f8,%rdx
  8004219541:	00 00 00 
  8004219544:	be c4 00 00 00       	mov    $0xc4,%esi
  8004219549:	48 bf 93 01 22 04 80 	movabs $0x8004220193,%rdi
  8004219550:	00 00 00 
  8004219553:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219558:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421955f:	00 00 00 
  8004219562:	41 ff d0             	callq  *%r8
  8004219565:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  800421956c:	ff ff ff 
  800421956f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004219573:	48 01 d1             	add    %rdx,%rcx
  8004219576:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004219579:	48 63 d2             	movslq %edx,%rdx
  800421957c:	48 09 ca             	or     %rcx,%rdx
  800421957f:	48 89 10             	mov    %rdx,(%rax)
  8004219582:	e9 b8 00 00 00       	jmpq   800421963f <ept_map_hva2gpa+0x1b7>
		else if(*epte_out != '\0' && overwrite == 0){
  8004219587:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421958b:	48 8b 00             	mov    (%rax),%rax
  800421958e:	48 85 c0             	test   %rax,%rax
  8004219591:	74 2b                	je     80042195be <ept_map_hva2gpa+0x136>
  8004219593:	83 7d c0 00          	cmpl   $0x0,-0x40(%rbp)
  8004219597:	75 25                	jne    80042195be <ept_map_hva2gpa+0x136>
			cprintf("ept_map_hva2gpa :	failing with result < 0\n");
  8004219599:	48 bf 20 02 22 04 80 	movabs $0x8004220220,%rdi
  80042195a0:	00 00 00 
  80042195a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042195a8:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  80042195af:	00 00 00 
  80042195b2:	ff d2                	callq  *%rdx
			return -E_INVAL;
  80042195b4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80042195b9:	e9 86 00 00 00       	jmpq   8004219644 <ept_map_hva2gpa+0x1bc>
		}else if((*epte_out != '\0' && overwrite == 1)){
  80042195be:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042195c2:	48 8b 00             	mov    (%rax),%rax
  80042195c5:	48 85 c0             	test   %rax,%rax
  80042195c8:	74 75                	je     800421963f <ept_map_hva2gpa+0x1b7>
  80042195ca:	83 7d c0 01          	cmpl   $0x1,-0x40(%rbp)
  80042195ce:	75 6f                	jne    800421963f <ept_map_hva2gpa+0x1b7>
			*epte_out = (uint64_t)PADDR(hva)|perm|__EPTE_IPAT|__EPTE_TYPE(EPTE_TYPE_WB);
  80042195d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042195d4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042195d8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042195dc:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042195e3:	00 00 00 
  80042195e6:	48 39 55 e8          	cmp    %rdx,-0x18(%rbp)
  80042195ea:	77 32                	ja     800421961e <ept_map_hva2gpa+0x196>
  80042195ec:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042195f0:	48 89 c1             	mov    %rax,%rcx
  80042195f3:	48 ba f8 01 22 04 80 	movabs $0x80042201f8,%rdx
  80042195fa:	00 00 00 
  80042195fd:	be c9 00 00 00       	mov    $0xc9,%esi
  8004219602:	48 bf 93 01 22 04 80 	movabs $0x8004220193,%rdi
  8004219609:	00 00 00 
  800421960c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219611:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004219618:	00 00 00 
  800421961b:	41 ff d0             	callq  *%r8
  800421961e:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004219625:	ff ff ff 
  8004219628:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421962c:	48 01 d1             	add    %rdx,%rcx
  800421962f:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004219632:	48 63 d2             	movslq %edx,%rdx
  8004219635:	48 09 ca             	or     %rcx,%rdx
  8004219638:	48 83 ca 70          	or     $0x70,%rdx
  800421963c:	48 89 10             	mov    %rdx,(%rax)
		}
	}
    //panic("ept_map_hva2gpa not implemented\n");

    return 0;
  800421963f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219644:	c9                   	leaveq 
  8004219645:	c3                   	retq   

0000008004219646 <ept_alloc_static>:

int ept_alloc_static(epte_t *eptrt, struct VmxGuestInfo *ginfo) {
  8004219646:	55                   	push   %rbp
  8004219647:	48 89 e5             	mov    %rsp,%rbp
  800421964a:	53                   	push   %rbx
  800421964b:	48 83 ec 48          	sub    $0x48,%rsp
  800421964f:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004219653:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    physaddr_t i;
    
    for(i=0x0; i < 0xA0000; i+=PGSIZE) {
  8004219657:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421965e:	00 
  800421965f:	eb 6e                	jmp    80042196cf <ept_alloc_static+0x89>
        struct PageInfo *p = page_alloc(0);
  8004219661:	bf 00 00 00 00       	mov    $0x0,%edi
  8004219666:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  800421966d:	00 00 00 
  8004219670:	ff d0                	callq  *%rax
  8004219672:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
        p->pp_ref += 1;
  8004219676:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421967a:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421967e:	8d 50 01             	lea    0x1(%rax),%edx
  8004219681:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219685:	66 89 50 08          	mov    %dx,0x8(%rax)
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
  8004219689:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  800421968d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219691:	48 89 c7             	mov    %rax,%rdi
  8004219694:	48 b8 a2 8e 21 04 80 	movabs $0x8004218ea2,%rax
  800421969b:	00 00 00 
  800421969e:	ff d0                	callq  *%rax
  80042196a0:	48 89 c6             	mov    %rax,%rsi
  80042196a3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042196a7:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  80042196ad:	b9 07 00 00 00       	mov    $0x7,%ecx
  80042196b2:	48 89 da             	mov    %rbx,%rdx
  80042196b5:	48 89 c7             	mov    %rax,%rdi
  80042196b8:	48 b8 88 94 21 04 80 	movabs $0x8004219488,%rax
  80042196bf:	00 00 00 
  80042196c2:	ff d0                	callq  *%rax
  80042196c4:	89 45 dc             	mov    %eax,-0x24(%rbp)
}

int ept_alloc_static(epte_t *eptrt, struct VmxGuestInfo *ginfo) {
    physaddr_t i;
    
    for(i=0x0; i < 0xA0000; i+=PGSIZE) {
  80042196c7:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  80042196ce:	00 
  80042196cf:	48 81 7d e8 ff ff 09 	cmpq   $0x9ffff,-0x18(%rbp)
  80042196d6:	00 
  80042196d7:	76 88                	jbe    8004219661 <ept_alloc_static+0x1b>
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }

    for(i=0x100000; i < ginfo->phys_sz; i+=PGSIZE) {
  80042196d9:	48 c7 45 e8 00 00 10 	movq   $0x100000,-0x18(%rbp)
  80042196e0:	00 
  80042196e1:	eb 6e                	jmp    8004219751 <ept_alloc_static+0x10b>
        struct PageInfo *p = page_alloc(0);
  80042196e3:	bf 00 00 00 00       	mov    $0x0,%edi
  80042196e8:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  80042196ef:	00 00 00 
  80042196f2:	ff d0                	callq  *%rax
  80042196f4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        p->pp_ref += 1;
  80042196f8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042196fc:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004219700:	8d 50 01             	lea    0x1(%rax),%edx
  8004219703:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219707:	66 89 50 08          	mov    %dx,0x8(%rax)
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
  800421970b:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
  800421970f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004219713:	48 89 c7             	mov    %rax,%rdi
  8004219716:	48 b8 a2 8e 21 04 80 	movabs $0x8004218ea2,%rax
  800421971d:	00 00 00 
  8004219720:	ff d0                	callq  *%rax
  8004219722:	48 89 c6             	mov    %rax,%rsi
  8004219725:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004219729:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421972f:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004219734:	48 89 da             	mov    %rbx,%rdx
  8004219737:	48 89 c7             	mov    %rax,%rdi
  800421973a:	48 b8 88 94 21 04 80 	movabs $0x8004219488,%rax
  8004219741:	00 00 00 
  8004219744:	ff d0                	callq  *%rax
  8004219746:	89 45 cc             	mov    %eax,-0x34(%rbp)
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }

    for(i=0x100000; i < ginfo->phys_sz; i+=PGSIZE) {
  8004219749:	48 81 45 e8 00 10 00 	addq   $0x1000,-0x18(%rbp)
  8004219750:	00 
  8004219751:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004219755:	48 8b 00             	mov    (%rax),%rax
  8004219758:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421975c:	77 85                	ja     80042196e3 <ept_alloc_static+0x9d>
        struct PageInfo *p = page_alloc(0);
        p->pp_ref += 1;
        int r = ept_map_hva2gpa(eptrt, page2kva(p), (void *)i, __EPTE_FULL, 0);
    }
    return 0;
  800421975e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219763:	48 83 c4 48          	add    $0x48,%rsp
  8004219767:	5b                   	pop    %rbx
  8004219768:	5d                   	pop    %rbp
  8004219769:	c3                   	retq   

000000800421976a <vmcs_writel>:
#define IA32_VMX_EPT_VPID_CAP 0x48C
#define IA32_FEATURE_CONTROL 0x03A

#define BIT( val, x ) ( ( val >> x ) & 0x1 )

static __inline uint8_t vmcs_writel( uint32_t field, uint64_t value) {
  800421976a:	55                   	push   %rbp
  800421976b:	48 89 e5             	mov    %rsp,%rbp
  800421976e:	48 83 ec 20          	sub    $0x20,%rsp
  8004219772:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004219775:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint8_t error;

	__asm __volatile ( "clc; vmwrite %%rax, %%rdx; setna %0"
  8004219779:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421977d:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004219780:	f8                   	clc    
  8004219781:	0f 79 d0             	vmwrite %rax,%rdx
  8004219784:	0f 96 c0             	setbe  %al
  8004219787:	88 45 ff             	mov    %al,-0x1(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
  800421978a:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  800421978e:	c9                   	leaveq 
  800421978f:	c3                   	retq   

0000008004219790 <vmcs_readl>:
static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
}

static __inline uint64_t vmcs_readl(uint32_t field)
{
  8004219790:	55                   	push   %rbp
  8004219791:	48 89 e5             	mov    %rsp,%rbp
  8004219794:	48 83 ec 14          	sub    $0x14,%rsp
  8004219798:	89 7d ec             	mov    %edi,-0x14(%rbp)
	uint64_t value;

	__asm __volatile ( "vmread %%rdx, %%rax;"
  800421979b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421979e:	89 c2                	mov    %eax,%edx
  80042197a0:	0f 78 d0             	vmread %rdx,%rax
  80042197a3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		      : "=a"(value) : "d"(field) : "cc");
	return value;
  80042197a7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042197ab:	c9                   	leaveq 
  80042197ac:	c3                   	retq   

00000080042197ad <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  80042197ad:	55                   	push   %rbp
  80042197ae:	48 89 e5             	mov    %rsp,%rbp
  80042197b1:	53                   	push   %rbx
  80042197b2:	48 83 ec 38          	sub    $0x38,%rsp
  80042197b6:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  80042197b9:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  80042197bd:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  80042197c1:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  80042197c5:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  80042197c9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042197cc:	0f a2                	cpuid  
  80042197ce:	89 de                	mov    %ebx,%esi
  80042197d0:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042197d3:	89 75 f0             	mov    %esi,-0x10(%rbp)
  80042197d6:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  80042197d9:	89 55 e8             	mov    %edx,-0x18(%rbp)
		     : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
		     : "a" (info));
	if (eaxp)
  80042197dc:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042197e1:	74 09                	je     80042197ec <cpuid+0x3f>
		*eaxp = eax;
  80042197e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042197e7:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042197ea:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  80042197ec:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  80042197f1:	74 09                	je     80042197fc <cpuid+0x4f>
		*ebxp = ebx;
  80042197f3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042197f7:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042197fa:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  80042197fc:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004219801:	74 09                	je     800421980c <cpuid+0x5f>
		*ecxp = ecx;
  8004219803:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004219807:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421980a:	89 10                	mov    %edx,(%rax)
	if (edxp)
  800421980c:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004219811:	74 09                	je     800421981c <cpuid+0x6f>
		*edxp = edx;
  8004219813:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004219817:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421981a:	89 10                	mov    %edx,(%rax)
}
  800421981c:	48 83 c4 38          	add    $0x38,%rsp
  8004219820:	5b                   	pop    %rbx
  8004219821:	5d                   	pop    %rbp
  8004219822:	c3                   	retq   

0000008004219823 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004219823:	55                   	push   %rbp
  8004219824:	48 89 e5             	mov    %rsp,%rbp
  8004219827:	48 83 ec 08          	sub    $0x8,%rsp
  800421982b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800421982f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004219833:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  800421983a:	00 00 00 
  800421983d:	48 8b 00             	mov    (%rax),%rax
  8004219840:	48 29 c2             	sub    %rax,%rdx
  8004219843:	48 89 d0             	mov    %rdx,%rax
  8004219846:	48 c1 f8 04          	sar    $0x4,%rax
}
  800421984a:	c9                   	leaveq 
  800421984b:	c3                   	retq   

000000800421984c <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800421984c:	55                   	push   %rbp
  800421984d:	48 89 e5             	mov    %rsp,%rbp
  8004219850:	48 83 ec 08          	sub    $0x8,%rsp
  8004219854:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004219858:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421985c:	48 89 c7             	mov    %rax,%rdi
  800421985f:	48 b8 23 98 21 04 80 	movabs $0x8004219823,%rax
  8004219866:	00 00 00 
  8004219869:	ff d0                	callq  *%rax
  800421986b:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800421986f:	c9                   	leaveq 
  8004219870:	c3                   	retq   

0000008004219871 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  8004219871:	55                   	push   %rbp
  8004219872:	48 89 e5             	mov    %rsp,%rbp
  8004219875:	48 83 ec 20          	sub    $0x20,%rsp
  8004219879:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800421987d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219881:	48 89 c7             	mov    %rax,%rdi
  8004219884:	48 b8 4c 98 21 04 80 	movabs $0x800421984c,%rax
  800421988b:	00 00 00 
  800421988e:	ff d0                	callq  *%rax
  8004219890:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004219894:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219898:	48 c1 e8 0c          	shr    $0xc,%rax
  800421989c:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421989f:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042198a2:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  80042198a9:	00 00 00 
  80042198ac:	48 8b 00             	mov    (%rax),%rax
  80042198af:	48 39 c2             	cmp    %rax,%rdx
  80042198b2:	72 32                	jb     80042198e6 <page2kva+0x75>
  80042198b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042198b8:	48 89 c1             	mov    %rax,%rcx
  80042198bb:	48 ba 50 02 22 04 80 	movabs $0x8004220250,%rdx
  80042198c2:	00 00 00 
  80042198c5:	be 5b 00 00 00       	mov    $0x5b,%esi
  80042198ca:	48 bf 73 02 22 04 80 	movabs $0x8004220273,%rdi
  80042198d1:	00 00 00 
  80042198d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042198d9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  80042198e0:	00 00 00 
  80042198e3:	41 ff d0             	callq  *%r8
  80042198e6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042198ed:	00 00 00 
  80042198f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042198f4:	48 01 d0             	add    %rdx,%rax
}
  80042198f7:	c9                   	leaveq 
  80042198f8:	c3                   	retq   

00000080042198f9 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  80042198f9:	55                   	push   %rbp
  80042198fa:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  80042198fd:	48 bf 40 37 23 04 80 	movabs $0x8004233740,%rdi
  8004219904:	00 00 00 
  8004219907:	48 b8 25 7f 21 04 80 	movabs $0x8004217f25,%rax
  800421990e:	00 00 00 
  8004219911:	ff d0                	callq  *%rax
}
  8004219913:	5d                   	pop    %rbp
  8004219914:	c3                   	retq   

0000008004219915 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  8004219915:	55                   	push   %rbp
  8004219916:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  8004219919:	48 bf 40 37 23 04 80 	movabs $0x8004233740,%rdi
  8004219920:	00 00 00 
  8004219923:	48 b8 fc 7f 21 04 80 	movabs $0x8004217ffc,%rax
  800421992a:	00 00 00 
  800421992d:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800421992f:	f3 90                	pause  
}
  8004219931:	5d                   	pop    %rbp
  8004219932:	c3                   	retq   

0000008004219933 <vmx_list_vms>:
#include <kern/kclock.h>
#include <kern/console.h>
#include <kern/spinlock.h>


void vmx_list_vms() {
  8004219933:	55                   	push   %rbp
  8004219934:	48 89 e5             	mov    %rsp,%rbp
  8004219937:	48 83 ec 10          	sub    $0x10,%rsp
	//findout how many VMs there
	int i;
	int vm_count = 0;
  800421993b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < NENV; ++i) {
  8004219942:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004219949:	e9 96 00 00 00       	jmpq   80042199e4 <vmx_list_vms+0xb1>
		if (envs[i].env_type == ENV_TYPE_GUEST) {
  800421994e:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  8004219955:	00 00 00 
  8004219958:	48 8b 10             	mov    (%rax),%rdx
  800421995b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421995e:	48 98                	cltq   
  8004219960:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004219967:	48 01 d0             	add    %rdx,%rax
  800421996a:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004219970:	83 f8 03             	cmp    $0x3,%eax
  8004219973:	75 6b                	jne    80042199e0 <vmx_list_vms+0xad>
			if (vm_count == 0) {
  8004219975:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004219979:	75 1b                	jne    8004219996 <vmx_list_vms+0x63>
				cprintf("Running VMs:\n");
  800421997b:	48 bf 81 02 22 04 80 	movabs $0x8004220281,%rdi
  8004219982:	00 00 00 
  8004219985:	b8 00 00 00 00       	mov    $0x0,%eax
  800421998a:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004219991:	00 00 00 
  8004219994:	ff d2                	callq  *%rdx
			}
			vm_count++;
  8004219996:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
			cprintf("%d.[%x]vm%d\n", vm_count, envs[i].env_id, vm_count);
  800421999a:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  80042199a1:	00 00 00 
  80042199a4:	48 8b 10             	mov    (%rax),%rdx
  80042199a7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042199aa:	48 98                	cltq   
  80042199ac:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  80042199b3:	48 01 d0             	add    %rdx,%rax
  80042199b6:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  80042199bc:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  80042199bf:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042199c2:	89 c6                	mov    %eax,%esi
  80042199c4:	48 bf 8f 02 22 04 80 	movabs $0x800422028f,%rdi
  80042199cb:	00 00 00 
  80042199ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042199d3:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  80042199da:	00 00 00 
  80042199dd:	41 ff d0             	callq  *%r8

void vmx_list_vms() {
	//findout how many VMs there
	int i;
	int vm_count = 0;
	for (i = 0; i < NENV; ++i) {
  80042199e0:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  80042199e4:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  80042199eb:	0f 8e 5d ff ff ff    	jle    800421994e <vmx_list_vms+0x1b>
			}
			vm_count++;
			cprintf("%d.[%x]vm%d\n", vm_count, envs[i].env_id, vm_count);
		}
	}
}
  80042199f1:	c9                   	leaveq 
  80042199f2:	c3                   	retq   

00000080042199f3 <vmx_sel_resume>:

bool vmx_sel_resume(int num) {
  80042199f3:	55                   	push   %rbp
  80042199f4:	48 89 e5             	mov    %rsp,%rbp
  80042199f7:	48 83 ec 20          	sub    $0x20,%rsp
  80042199fb:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	int vm_count = 0;
  80042199fe:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < NENV; ++i) {
  8004219a05:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004219a0c:	e9 84 00 00 00       	jmpq   8004219a95 <vmx_sel_resume+0xa2>
		if (envs[i].env_type == ENV_TYPE_GUEST) {
  8004219a11:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  8004219a18:	00 00 00 
  8004219a1b:	48 8b 10             	mov    (%rax),%rdx
  8004219a1e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219a21:	48 98                	cltq   
  8004219a23:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004219a2a:	48 01 d0             	add    %rdx,%rax
  8004219a2d:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004219a33:	83 f8 03             	cmp    $0x3,%eax
  8004219a36:	75 59                	jne    8004219a91 <vmx_sel_resume+0x9e>
			vm_count++;
  8004219a38:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
			if (vm_count == num) {
  8004219a3c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004219a3f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004219a42:	75 4d                	jne    8004219a91 <vmx_sel_resume+0x9e>
				cprintf("Resume vm.%d\n", num);	
  8004219a44:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219a47:	89 c6                	mov    %eax,%esi
  8004219a49:	48 bf 9c 02 22 04 80 	movabs $0x800422029c,%rdi
  8004219a50:	00 00 00 
  8004219a53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219a58:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004219a5f:	00 00 00 
  8004219a62:	ff d2                	callq  *%rdx
				envs[i].env_status = ENV_RUNNABLE;
  8004219a64:	48 b8 58 d2 3a 04 80 	movabs $0x80043ad258,%rax
  8004219a6b:	00 00 00 
  8004219a6e:	48 8b 10             	mov    (%rax),%rdx
  8004219a71:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219a74:	48 98                	cltq   
  8004219a76:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004219a7d:	48 01 d0             	add    %rdx,%rax
  8004219a80:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004219a87:	00 00 00 
				return true;
  8004219a8a:	b8 01 00 00 00       	mov    $0x1,%eax
  8004219a8f:	eb 36                	jmp    8004219ac7 <vmx_sel_resume+0xd4>
}

bool vmx_sel_resume(int num) {
	int i;
	int vm_count = 0;
	for (i = 0; i < NENV; ++i) {
  8004219a91:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004219a95:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  8004219a9c:	0f 8e 6f ff ff ff    	jle    8004219a11 <vmx_sel_resume+0x1e>
				envs[i].env_status = ENV_RUNNABLE;
				return true;
			}
		}
	}
	cprintf("Selected VM(No.%d VM) not found.\n", num);	
  8004219aa2:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219aa5:	89 c6                	mov    %eax,%esi
  8004219aa7:	48 bf b0 02 22 04 80 	movabs $0x80042202b0,%rdi
  8004219aae:	00 00 00 
  8004219ab1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219ab6:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004219abd:	00 00 00 
  8004219ac0:	ff d2                	callq  *%rdx
	return false;
  8004219ac2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219ac7:	c9                   	leaveq 
  8004219ac8:	c3                   	retq   

0000008004219ac9 <vmx_check_support>:
 * See Section 23.6 of the Intel manual.
 * 
 * Hint: the TA solution uses the BIT() macro 
 *  to simplify the implementation.
 */
inline bool vmx_check_support() {
  8004219ac9:	55                   	push   %rbp
  8004219aca:	48 89 e5             	mov    %rsp,%rbp
  8004219acd:	48 83 ec 10          	sub    $0x10,%rsp
    uint32_t eax, ebx, ecx, edx;
    cpuid( 1, &eax, &ebx, &ecx, &edx );
  8004219ad1:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004219ad5:	48 8d 4d f4          	lea    -0xc(%rbp),%rcx
  8004219ad9:	48 8d 55 f8          	lea    -0x8(%rbp),%rdx
  8004219add:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004219ae1:	49 89 f0             	mov    %rsi,%r8
  8004219ae4:	48 89 c6             	mov    %rax,%rsi
  8004219ae7:	bf 01 00 00 00       	mov    $0x1,%edi
  8004219aec:	48 b8 ad 97 21 04 80 	movabs $0x80042197ad,%rax
  8004219af3:	00 00 00 
  8004219af6:	ff d0                	callq  *%rax
    /* Your code here */
	if(BIT(ecx,5))
  8004219af8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004219afb:	83 e0 20             	and    $0x20,%eax
  8004219afe:	85 c0                	test   %eax,%eax
  8004219b00:	74 07                	je     8004219b09 <vmx_check_support+0x40>
		return true;
  8004219b02:	b8 01 00 00 00       	mov    $0x1,%eax
  8004219b07:	eb 20                	jmp    8004219b29 <vmx_check_support+0x60>
    //panic ("vmx check not implemented\n");
    cprintf("[VMM] VMX extension not supported.\n");
  8004219b09:	48 bf d8 02 22 04 80 	movabs $0x80042202d8,%rdi
  8004219b10:	00 00 00 
  8004219b13:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219b18:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004219b1f:	00 00 00 
  8004219b22:	ff d2                	callq  *%rdx
    return false;
  8004219b24:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219b29:	c9                   	leaveq 
  8004219b2a:	c3                   	retq   

0000008004219b2b <vmx_check_ept>:
 *
 * Hint: This needs to check two MSR bits---first verifying
 *   that secondary VMX controls are enabled, and then that
 *   EPT is available.
 */
inline bool vmx_check_ept() {
  8004219b2b:	55                   	push   %rbp
  8004219b2c:	48 89 e5             	mov    %rsp,%rbp
  8004219b2f:	48 83 ec 40          	sub    $0x40,%rsp
  8004219b33:	c7 45 ec 82 04 00 00 	movl   $0x482,-0x14(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  8004219b3a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004219b3d:	89 c1                	mov    %eax,%ecx
  8004219b3f:	0f 32                	rdmsr  
  8004219b41:	89 55 e8             	mov    %edx,-0x18(%rbp)
  8004219b44:	89 45 e4             	mov    %eax,-0x1c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219b47:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  8004219b4e:	00 
    ret = edx;
  8004219b4f:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004219b52:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    ret = ret << 32;
  8004219b56:	48 c1 65 d8 20       	shlq   $0x20,-0x28(%rbp)
    ret |= eax;
  8004219b5b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004219b5e:	48 09 45 d8          	or     %rax,-0x28(%rbp)

    return ret;
  8004219b62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    /* Your code here */
	uint64_t msr1 = read_msr(IA32_VMX_PROCBASED_CTLS);
  8004219b66:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004219b6a:	c7 45 d4 8b 04 00 00 	movl   $0x48b,-0x2c(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  8004219b71:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004219b74:	89 c1                	mov    %eax,%ecx
  8004219b76:	0f 32                	rdmsr  
  8004219b78:	89 55 d0             	mov    %edx,-0x30(%rbp)
  8004219b7b:	89 45 cc             	mov    %eax,-0x34(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219b7e:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004219b85:	00 
    ret = edx;
  8004219b86:	8b 45 d0             	mov    -0x30(%rbp),%eax
  8004219b89:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    ret = ret << 32;
  8004219b8d:	48 c1 65 c0 20       	shlq   $0x20,-0x40(%rbp)
    ret |= eax;
  8004219b92:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004219b95:	48 09 45 c0          	or     %rax,-0x40(%rbp)

    return ret;
  8004219b99:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
	uint64_t msr2 = read_msr(IA32_VMX_PROCBASED_CTLS2);
  8004219b9d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	if(BIT(msr1,63) && BIT(msr2,33)){
  8004219ba1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219ba5:	48 85 c0             	test   %rax,%rax
  8004219ba8:	79 35                	jns    8004219bdf <vmx_check_ept+0xb4>
  8004219baa:	48 b8 00 00 00 00 02 	movabs $0x200000000,%rax
  8004219bb1:	00 00 00 
  8004219bb4:	48 23 45 f0          	and    -0x10(%rbp),%rax
  8004219bb8:	48 85 c0             	test   %rax,%rax
  8004219bbb:	74 22                	je     8004219bdf <vmx_check_ept+0xb4>
		cprintf("ept is supported \n");
  8004219bbd:	48 bf fc 02 22 04 80 	movabs $0x80042202fc,%rdi
  8004219bc4:	00 00 00 
  8004219bc7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219bcc:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004219bd3:	00 00 00 
  8004219bd6:	ff d2                	callq  *%rdx
		return true;
  8004219bd8:	b8 01 00 00 00       	mov    $0x1,%eax
  8004219bdd:	eb 20                	jmp    8004219bff <vmx_check_ept+0xd4>
	}
	
    //panic ("ept check not implemented\n");
    cprintf("[VMM] EPT extension not supported.\n");
  8004219bdf:	48 bf 10 03 22 04 80 	movabs $0x8004220310,%rdi
  8004219be6:	00 00 00 
  8004219be9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219bee:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  8004219bf5:	00 00 00 
  8004219bf8:	ff d2                	callq  *%rdx
    return false;
  8004219bfa:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004219bff:	c9                   	leaveq 
  8004219c00:	c3                   	retq   

0000008004219c01 <check_fixed_bits>:

/* Checks if curr_val is compatible with fixed0 and fixed1 
* (allowed values read from the MSR). This is to ensure current processor
* operating mode meets the required fixed bit requirement of VMX.  
*/
bool check_fixed_bits( uint64_t curr_val, uint64_t fixed0, uint64_t fixed1 ) {
  8004219c01:	55                   	push   %rbp
  8004219c02:	48 89 e5             	mov    %rsp,%rbp
  8004219c05:	48 83 ec 30          	sub    $0x30,%rsp
  8004219c09:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004219c0d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004219c11:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    // TODO: Simplify this code.
    int i;
    for( i = 0 ; i < sizeof( curr_val ) * 8 ; ++i ) {
  8004219c15:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004219c1c:	e9 96 00 00 00       	jmpq   8004219cb7 <check_fixed_bits+0xb6>
        int bit = BIT( curr_val, i );
  8004219c21:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219c24:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004219c28:	89 c1                	mov    %eax,%ecx
  8004219c2a:	48 d3 ea             	shr    %cl,%rdx
  8004219c2d:	48 89 d0             	mov    %rdx,%rax
  8004219c30:	83 e0 01             	and    $0x1,%eax
  8004219c33:	89 45 f8             	mov    %eax,-0x8(%rbp)
        if ( bit == 1 ) {
  8004219c36:	83 7d f8 01          	cmpl   $0x1,-0x8(%rbp)
  8004219c3a:	75 1e                	jne    8004219c5a <check_fixed_bits+0x59>
            // Check if this bit is fixed to 0.
            if ( BIT( fixed1, i ) == 0 ) {
  8004219c3c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219c3f:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004219c43:	89 c1                	mov    %eax,%ecx
  8004219c45:	48 d3 ea             	shr    %cl,%rdx
  8004219c48:	48 89 d0             	mov    %rdx,%rax
  8004219c4b:	83 e0 01             	and    $0x1,%eax
  8004219c4e:	48 85 c0             	test   %rax,%rax
  8004219c51:	75 60                	jne    8004219cb3 <check_fixed_bits+0xb2>
                return false;
  8004219c53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219c58:	eb 6e                	jmp    8004219cc8 <check_fixed_bits+0xc7>
            }
        } else if ( bit == 0 ) {
  8004219c5a:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  8004219c5e:	75 1e                	jne    8004219c7e <check_fixed_bits+0x7d>
            // Check if this bit is fixed to 1.
            if ( BIT( fixed0, i ) == 1 ) {
  8004219c60:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219c63:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004219c67:	89 c1                	mov    %eax,%ecx
  8004219c69:	48 d3 ea             	shr    %cl,%rdx
  8004219c6c:	48 89 d0             	mov    %rdx,%rax
  8004219c6f:	83 e0 01             	and    $0x1,%eax
  8004219c72:	48 85 c0             	test   %rax,%rax
  8004219c75:	74 3c                	je     8004219cb3 <check_fixed_bits+0xb2>
                return false;
  8004219c77:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219c7c:	eb 4a                	jmp    8004219cc8 <check_fixed_bits+0xc7>
            }
        } else {
            assert(false);
  8004219c7e:	48 b9 34 03 22 04 80 	movabs $0x8004220334,%rcx
  8004219c85:	00 00 00 
  8004219c88:	48 ba 3a 03 22 04 80 	movabs $0x800422033a,%rdx
  8004219c8f:	00 00 00 
  8004219c92:	be 77 00 00 00       	mov    $0x77,%esi
  8004219c97:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  8004219c9e:	00 00 00 
  8004219ca1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219ca6:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004219cad:	00 00 00 
  8004219cb0:	41 ff d0             	callq  *%r8
* operating mode meets the required fixed bit requirement of VMX.  
*/
bool check_fixed_bits( uint64_t curr_val, uint64_t fixed0, uint64_t fixed1 ) {
    // TODO: Simplify this code.
    int i;
    for( i = 0 ; i < sizeof( curr_val ) * 8 ; ++i ) {
  8004219cb3:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004219cb7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004219cba:	83 f8 3f             	cmp    $0x3f,%eax
  8004219cbd:	0f 86 5e ff ff ff    	jbe    8004219c21 <check_fixed_bits+0x20>
            }
        } else {
            assert(false);
        }
    }
    return true;
  8004219cc3:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004219cc8:	c9                   	leaveq 
  8004219cc9:	c3                   	retq   

0000008004219cca <vmx_init_vmcs>:

/* 
 * Allocate a page for the VMCS region and write the VMCS Rev. ID in the first 
 * 31 bits.
 */
struct PageInfo * vmx_init_vmcs() {
  8004219cca:	55                   	push   %rbp
  8004219ccb:	48 89 e5             	mov    %rsp,%rbp
  8004219cce:	48 83 ec 40          	sub    $0x40,%rsp
  8004219cd2:	c7 45 dc 80 04 00 00 	movl   $0x480,-0x24(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  8004219cd9:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004219cdc:	89 c1                	mov    %eax,%ecx
  8004219cde:	0f 32                	rdmsr  
  8004219ce0:	89 55 d8             	mov    %edx,-0x28(%rbp)
  8004219ce3:	89 45 d4             	mov    %eax,-0x2c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219ce6:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004219ced:	00 
    ret = edx;
  8004219cee:	8b 45 d8             	mov    -0x28(%rbp),%eax
  8004219cf1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    ret = ret << 32;
  8004219cf5:	48 c1 65 c8 20       	shlq   $0x20,-0x38(%rbp)
    ret |= eax;
  8004219cfa:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004219cfd:	48 09 45 c8          	or     %rax,-0x38(%rbp)

    return ret;
  8004219d01:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    // Read the VMX_BASIC MSR.
    uint64_t vmx_basic_msr =  read_msr( IA32_VMX_BASIC );
  8004219d05:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    uint32_t vmcs_rev_id = (uint32_t) vmx_basic_msr; // Bits 30:0, Bit 31 is always 0.
  8004219d09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219d0d:	89 45 c4             	mov    %eax,-0x3c(%rbp)

    uint32_t vmcs_num_bytes =  ( vmx_basic_msr >> 32 ) & 0xfff; // Bits 44:32.
  8004219d10:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004219d14:	48 c1 e8 20          	shr    $0x20,%rax
  8004219d18:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004219d1d:	89 45 f4             	mov    %eax,-0xc(%rbp)
    assert( vmcs_num_bytes <= 4096 ); // VMCS can have a max size of 4096.
  8004219d20:	81 7d f4 00 10 00 00 	cmpl   $0x1000,-0xc(%rbp)
  8004219d27:	76 35                	jbe    8004219d5e <vmx_init_vmcs+0x94>
  8004219d29:	48 b9 59 03 22 04 80 	movabs $0x8004220359,%rcx
  8004219d30:	00 00 00 
  8004219d33:	48 ba 3a 03 22 04 80 	movabs $0x800422033a,%rdx
  8004219d3a:	00 00 00 
  8004219d3d:	be 87 00 00 00       	mov    $0x87,%esi
  8004219d42:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  8004219d49:	00 00 00 
  8004219d4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219d51:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  8004219d58:	00 00 00 
  8004219d5b:	41 ff d0             	callq  *%r8

    //Alocate mem for VMCS region.
    struct PageInfo *p_vmxon_region = page_alloc( ALLOC_ZERO );
  8004219d5e:	bf 01 00 00 00       	mov    $0x1,%edi
  8004219d63:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  8004219d6a:	00 00 00 
  8004219d6d:	ff d0                	callq  *%rax
  8004219d6f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(!p_vmxon_region) {
  8004219d73:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004219d78:	75 07                	jne    8004219d81 <vmx_init_vmcs+0xb7>
        return NULL;
  8004219d7a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219d7f:	eb 4d                	jmp    8004219dce <vmx_init_vmcs+0x104>
    }
    p_vmxon_region->pp_ref += 1; 
  8004219d81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219d85:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004219d89:	8d 50 01             	lea    0x1(%rax),%edx
  8004219d8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219d90:	66 89 50 08          	mov    %dx,0x8(%rax)
    
    unsigned char* vmxon_region = (unsigned char *) page2kva( p_vmxon_region );
  8004219d94:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219d98:	48 89 c7             	mov    %rax,%rdi
  8004219d9b:	48 b8 71 98 21 04 80 	movabs $0x8004219871,%rax
  8004219da2:	00 00 00 
  8004219da5:	ff d0                	callq  *%rax
  8004219da7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    memcpy( vmxon_region, &vmcs_rev_id, sizeof( vmcs_rev_id ) );
  8004219dab:	48 8d 4d c4          	lea    -0x3c(%rbp),%rcx
  8004219daf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219db3:	ba 04 00 00 00       	mov    $0x4,%edx
  8004219db8:	48 89 ce             	mov    %rcx,%rsi
  8004219dbb:	48 89 c7             	mov    %rax,%rdi
  8004219dbe:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  8004219dc5:	00 00 00 
  8004219dc8:	ff d0                	callq  *%rax

    return p_vmxon_region;
  8004219dca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004219dce:	c9                   	leaveq 
  8004219dcf:	c3                   	retq   

0000008004219dd0 <vmx_init_vmxon>:

/* 
 * Sets up a VMXON region and executes VMXON to put the processor in VMX root 
 * operation. Returns a >=0 value if VMX root operation is achieved.
 */
int vmx_init_vmxon() {
  8004219dd0:	55                   	push   %rbp
  8004219dd1:	48 89 e5             	mov    %rsp,%rbp
  8004219dd4:	53                   	push   %rbx
  8004219dd5:	48 81 ec f8 00 00 00 	sub    $0xf8,%rsp
    
    //Alocate mem and init the VMXON region.
    struct PageInfo *p_vmxon_region = vmx_init_vmcs();
  8004219ddc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004219de1:	48 ba ca 9c 21 04 80 	movabs $0x8004219cca,%rdx
  8004219de8:	00 00 00 
  8004219deb:	ff d2                	callq  *%rdx
  8004219ded:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(!p_vmxon_region)
  8004219df1:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004219df6:	75 0a                	jne    8004219e02 <vmx_init_vmxon+0x32>
        return -E_NO_MEM;
  8004219df8:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004219dfd:	e9 b5 03 00 00       	jmpq   800421a1b7 <vmx_init_vmxon+0x3e7>

    static __inline uint64_t
rcr0(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr0,%0" : "=r" (val));
  8004219e02:	0f 20 c0             	mov    %cr0,%rax
  8004219e05:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    return val;
  8004219e09:	48 8b 45 b8          	mov    -0x48(%rbp),%rax

    uint64_t cr0 = rcr0();
  8004219e0d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

    static __inline uint64_t
rcr4(void)
{
    uint64_t cr4;
    __asm __volatile("movq %%cr4,%0" : "=r" (cr4));
  8004219e11:	0f 20 e0             	mov    %cr4,%rax
  8004219e14:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    return cr4;
  8004219e18:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    uint64_t cr4 = rcr4();
  8004219e1c:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    // Paging and protected mode are enabled in JOS.
    
    // FIXME: Workaround for CR0.NE (bochs needs this to be set to 1)
    cr0 = cr0 | CR0_NE;
  8004219e20:	48 83 4d e0 20       	orq    $0x20,-0x20(%rbp)
  8004219e25:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219e29:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

    static __inline void
lcr0(uint64_t val)
{
    __asm __volatile("movq %0,%%cr0" : : "r" (val));
  8004219e2d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004219e31:	0f 22 c0             	mov    %rax,%cr0
  8004219e34:	c7 45 a4 87 04 00 00 	movl   $0x487,-0x5c(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  8004219e3b:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004219e3e:	89 c1                	mov    %eax,%ecx
  8004219e40:	0f 32                	rdmsr  
  8004219e42:	89 55 a0             	mov    %edx,-0x60(%rbp)
  8004219e45:	89 45 9c             	mov    %eax,-0x64(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219e48:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004219e4f:	00 
    ret = edx;
  8004219e50:	8b 45 a0             	mov    -0x60(%rbp),%eax
  8004219e53:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    ret = ret << 32;
  8004219e57:	48 c1 65 90 20       	shlq   $0x20,-0x70(%rbp)
    ret |= eax;
  8004219e5c:	8b 45 9c             	mov    -0x64(%rbp),%eax
  8004219e5f:	48 09 45 90          	or     %rax,-0x70(%rbp)

    return ret;
  8004219e63:	48 8b 45 90          	mov    -0x70(%rbp),%rax
    lcr0( cr0 );

    bool ret =  check_fixed_bits( cr0,
  8004219e67:	48 89 c6             	mov    %rax,%rsi
  8004219e6a:	c7 45 8c 86 04 00 00 	movl   $0x486,-0x74(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  8004219e71:	8b 45 8c             	mov    -0x74(%rbp),%eax
  8004219e74:	89 c1                	mov    %eax,%ecx
  8004219e76:	0f 32                	rdmsr  
  8004219e78:	89 55 88             	mov    %edx,-0x78(%rbp)
  8004219e7b:	89 45 84             	mov    %eax,-0x7c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219e7e:	48 c7 85 78 ff ff ff 	movq   $0x0,-0x88(%rbp)
  8004219e85:	00 00 00 00 
    ret = edx;
  8004219e89:	8b 45 88             	mov    -0x78(%rbp),%eax
  8004219e8c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    ret = ret << 32;
  8004219e93:	48 c1 a5 78 ff ff ff 	shlq   $0x20,-0x88(%rbp)
  8004219e9a:	20 
    ret |= eax;
  8004219e9b:	8b 45 84             	mov    -0x7c(%rbp),%eax
  8004219e9e:	48 09 85 78 ff ff ff 	or     %rax,-0x88(%rbp)

    return ret;
  8004219ea5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004219eac:	48 89 c1             	mov    %rax,%rcx
  8004219eaf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004219eb3:	48 89 f2             	mov    %rsi,%rdx
  8004219eb6:	48 89 ce             	mov    %rcx,%rsi
  8004219eb9:	48 89 c7             	mov    %rax,%rdi
  8004219ebc:	48 b8 01 9c 21 04 80 	movabs $0x8004219c01,%rax
  8004219ec3:	00 00 00 
  8004219ec6:	ff d0                	callq  *%rax
  8004219ec8:	88 45 d7             	mov    %al,-0x29(%rbp)
                                  read_msr( IA32_VMX_CR0_FIXED0 ), 
                                  read_msr( IA32_VMX_CR0_FIXED1 ) );
    if ( !ret ) {
  8004219ecb:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
  8004219ecf:	83 f0 01             	xor    $0x1,%eax
  8004219ed2:	84 c0                	test   %al,%al
  8004219ed4:	74 1d                	je     8004219ef3 <vmx_init_vmxon+0x123>
        page_decref( p_vmxon_region );
  8004219ed6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219eda:	48 89 c7             	mov    %rax,%rdi
  8004219edd:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004219ee4:	00 00 00 
  8004219ee7:	ff d0                	callq  *%rax
        return -E_VMX_ON;
  8004219ee9:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  8004219eee:	e9 c4 02 00 00       	jmpq   800421a1b7 <vmx_init_vmxon+0x3e7>
    }
    // Enable VMX in CR4.
    cr4 = cr4 | CR4_VMXE;
  8004219ef3:	48 81 4d d8 00 20 00 	orq    $0x2000,-0x28(%rbp)
  8004219efa:	00 
  8004219efb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219eff:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

    static __inline void
lcr4(uint64_t val)
{
    __asm __volatile("movq %0,%%cr4" : : "r" (val));
  8004219f06:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004219f0d:	0f 22 e0             	mov    %rax,%cr4
  8004219f10:	c7 85 6c ff ff ff 89 	movl   $0x489,-0x94(%rbp)
  8004219f17:	04 00 00 
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  8004219f1a:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  8004219f20:	89 c1                	mov    %eax,%ecx
  8004219f22:	0f 32                	rdmsr  
  8004219f24:	89 95 68 ff ff ff    	mov    %edx,-0x98(%rbp)
  8004219f2a:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219f30:	48 c7 85 58 ff ff ff 	movq   $0x0,-0xa8(%rbp)
  8004219f37:	00 00 00 00 
    ret = edx;
  8004219f3b:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
  8004219f41:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
    ret = ret << 32;
  8004219f48:	48 c1 a5 58 ff ff ff 	shlq   $0x20,-0xa8(%rbp)
  8004219f4f:	20 
    ret |= eax;
  8004219f50:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
  8004219f56:	48 09 85 58 ff ff ff 	or     %rax,-0xa8(%rbp)

    return ret;
  8004219f5d:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
    lcr4( cr4 );
    ret =  check_fixed_bits( cr4,
  8004219f64:	48 89 c6             	mov    %rax,%rsi
  8004219f67:	c7 85 54 ff ff ff 88 	movl   $0x488,-0xac(%rbp)
  8004219f6e:	04 00 00 
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  8004219f71:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
  8004219f77:	89 c1                	mov    %eax,%ecx
  8004219f79:	0f 32                	rdmsr  
  8004219f7b:	89 95 50 ff ff ff    	mov    %edx,-0xb0(%rbp)
  8004219f81:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  8004219f87:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  8004219f8e:	00 00 00 00 
    ret = edx;
  8004219f92:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax
  8004219f98:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    ret = ret << 32;
  8004219f9f:	48 c1 a5 40 ff ff ff 	shlq   $0x20,-0xc0(%rbp)
  8004219fa6:	20 
    ret |= eax;
  8004219fa7:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  8004219fad:	48 09 85 40 ff ff ff 	or     %rax,-0xc0(%rbp)

    return ret;
  8004219fb4:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004219fbb:	48 89 c1             	mov    %rax,%rcx
  8004219fbe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004219fc2:	48 89 f2             	mov    %rsi,%rdx
  8004219fc5:	48 89 ce             	mov    %rcx,%rsi
  8004219fc8:	48 89 c7             	mov    %rax,%rdi
  8004219fcb:	48 b8 01 9c 21 04 80 	movabs $0x8004219c01,%rax
  8004219fd2:	00 00 00 
  8004219fd5:	ff d0                	callq  *%rax
  8004219fd7:	88 45 d7             	mov    %al,-0x29(%rbp)
                             read_msr( IA32_VMX_CR4_FIXED0 ), 
                             read_msr( IA32_VMX_CR4_FIXED1 ) );
    if ( !ret ) {
  8004219fda:	0f b6 45 d7          	movzbl -0x29(%rbp),%eax
  8004219fde:	83 f0 01             	xor    $0x1,%eax
  8004219fe1:	84 c0                	test   %al,%al
  8004219fe3:	74 1d                	je     800421a002 <vmx_init_vmxon+0x232>
        page_decref( p_vmxon_region );
  8004219fe5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004219fe9:	48 89 c7             	mov    %rax,%rdi
  8004219fec:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  8004219ff3:	00 00 00 
  8004219ff6:	ff d0                	callq  *%rax
        return -E_VMX_ON;
  8004219ff8:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  8004219ffd:	e9 b5 01 00 00       	jmpq   800421a1b7 <vmx_init_vmxon+0x3e7>
  800421a002:	c7 85 3c ff ff ff 3a 	movl   $0x3a,-0xc4(%rbp)
  800421a009:	00 00 00 
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  800421a00c:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
  800421a012:	89 c1                	mov    %eax,%ecx
  800421a014:	0f 32                	rdmsr  
  800421a016:	89 95 38 ff ff ff    	mov    %edx,-0xc8(%rbp)
  800421a01c:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  800421a022:	48 c7 85 28 ff ff ff 	movq   $0x0,-0xd8(%rbp)
  800421a029:	00 00 00 00 
    ret = edx;
  800421a02d:	8b 85 38 ff ff ff    	mov    -0xc8(%rbp),%eax
  800421a033:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    ret = ret << 32;
  800421a03a:	48 c1 a5 28 ff ff ff 	shlq   $0x20,-0xd8(%rbp)
  800421a041:	20 
    ret |= eax;
  800421a042:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
  800421a048:	48 09 85 28 ff ff ff 	or     %rax,-0xd8(%rbp)

    return ret;
  800421a04f:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
    }
    // Ensure that IA32_FEATURE_CONTROL MSR has been properly programmed and 
    // and that it's lock bit has been set.
    uint64_t feature_control = read_msr( IA32_FEATURE_CONTROL );
  800421a056:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    if ( !BIT( feature_control, 2 )) {
  800421a05a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421a05e:	83 e0 04             	and    $0x4,%eax
  800421a061:	48 85 c0             	test   %rax,%rax
  800421a064:	75 1d                	jne    800421a083 <vmx_init_vmxon+0x2b3>
        page_decref( p_vmxon_region );
  800421a066:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a06a:	48 89 c7             	mov    %rax,%rdi
  800421a06d:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  800421a074:	00 00 00 
  800421a077:	ff d0                	callq  *%rax
        // VMX disabled in BIOS.
        return -E_NO_VMX;
  800421a079:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
  800421a07e:	e9 34 01 00 00       	jmpq   800421a1b7 <vmx_init_vmxon+0x3e7>
    }
    if ( !BIT( feature_control, 0 )) {
  800421a083:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421a087:	83 e0 01             	and    $0x1,%eax
  800421a08a:	48 85 c0             	test   %rax,%rax
  800421a08d:	75 4c                	jne    800421a0db <vmx_init_vmxon+0x30b>
        // Lock bit not set, try setting it.
        feature_control |= 0x1;
  800421a08f:	48 83 4d c8 01       	orq    $0x1,-0x38(%rbp)
  800421a094:	c7 85 24 ff ff ff 3a 	movl   $0x3a,-0xdc(%rbp)
  800421a09b:	00 00 00 
  800421a09e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421a0a2:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
}

static __inline void
write_msr( uint32_t ecx, uint64_t val ) {
    uint32_t edx, eax;
    eax = (uint32_t) val;
  800421a0a9:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421a0b0:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
    edx = (uint32_t) ( val >> 32 );
  800421a0b6:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421a0bd:	48 c1 e8 20          	shr    $0x20,%rax
  800421a0c1:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
    __asm __volatile("wrmsr"
  800421a0c7:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  800421a0cd:	8b 95 10 ff ff ff    	mov    -0xf0(%rbp),%edx
  800421a0d3:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421a0d9:	0f 30                	wrmsr  
        write_msr( IA32_FEATURE_CONTROL, feature_control );   
    }
    
    uint8_t error = vmxon( (physaddr_t) page2pa( p_vmxon_region ) );
  800421a0db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a0df:	48 89 c7             	mov    %rax,%rdi
  800421a0e2:	48 b8 4c 98 21 04 80 	movabs $0x800421984c,%rax
  800421a0e9:	00 00 00 
  800421a0ec:	ff d0                	callq  *%rax
  800421a0ee:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
static __inline uint8_t vmptrld( physaddr_t vmcs_region ) __attribute((always_inline));


static __inline uint8_t
vmxon( physaddr_t vmxon_region ) {
	uint8_t error = 0;
  800421a0f5:	c6 85 0f ff ff ff 00 	movb   $0x0,-0xf1(%rbp)

    __asm __volatile("clc; vmxon %1; setna %0"
  800421a0fc:	f8                   	clc    
  800421a0fd:	f3 0f c7 b5 00 ff ff 	vmxon  -0x100(%rbp)
  800421a104:	ff 
  800421a105:	0f 96 c0             	setbe  %al
  800421a108:	88 85 0f ff ff ff    	mov    %al,-0xf1(%rbp)
            : "=q"( error ) : "m" ( vmxon_region ): "cc" );
    return error;
  800421a10e:	0f b6 85 0f ff ff ff 	movzbl -0xf1(%rbp),%eax
  800421a115:	88 45 c7             	mov    %al,-0x39(%rbp)
    if ( error ) { 
  800421a118:	80 7d c7 00          	cmpb   $0x0,-0x39(%rbp)
  800421a11c:	74 1a                	je     800421a138 <vmx_init_vmxon+0x368>
        page_decref( p_vmxon_region );
  800421a11e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a122:	48 89 c7             	mov    %rax,%rdi
  800421a125:	48 b8 08 31 20 04 80 	movabs $0x8004203108,%rax
  800421a12c:	00 00 00 
  800421a12f:	ff d0                	callq  *%rax
        return -E_VMX_ON; 
  800421a131:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
  800421a136:	eb 7f                	jmp    800421a1b7 <vmx_init_vmxon+0x3e7>
    }

    thiscpu->is_vmx_root = true;
  800421a138:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421a13f:	00 00 00 
  800421a142:	ff d0                	callq  *%rax
  800421a144:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421a14b:	00 00 00 
  800421a14e:	48 98                	cltq   
  800421a150:	48 c1 e0 03          	shl    $0x3,%rax
  800421a154:	48 89 c1             	mov    %rax,%rcx
  800421a157:	48 c1 e1 04          	shl    $0x4,%rcx
  800421a15b:	48 01 c8             	add    %rcx,%rax
  800421a15e:	48 01 d0             	add    %rdx,%rax
  800421a161:	48 83 c0 70          	add    $0x70,%rax
  800421a165:	c6 40 08 01          	movb   $0x1,0x8(%rax)
    thiscpu->vmxon_region = (uintptr_t) page2kva( p_vmxon_region );
  800421a169:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421a170:	00 00 00 
  800421a173:	ff d0                	callq  *%rax
  800421a175:	89 c3                	mov    %eax,%ebx
  800421a177:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a17b:	48 89 c7             	mov    %rax,%rdi
  800421a17e:	48 b8 71 98 21 04 80 	movabs $0x8004219871,%rax
  800421a185:	00 00 00 
  800421a188:	ff d0                	callq  *%rax
  800421a18a:	48 89 c2             	mov    %rax,%rdx
  800421a18d:	48 b9 20 00 3b 04 80 	movabs $0x80043b0020,%rcx
  800421a194:	00 00 00 
  800421a197:	48 63 c3             	movslq %ebx,%rax
  800421a19a:	48 c1 e0 03          	shl    $0x3,%rax
  800421a19e:	48 89 c6             	mov    %rax,%rsi
  800421a1a1:	48 c1 e6 04          	shl    $0x4,%rsi
  800421a1a5:	48 01 f0             	add    %rsi,%rax
  800421a1a8:	48 01 c8             	add    %rcx,%rax
  800421a1ab:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  800421a1af:	48 89 10             	mov    %rdx,(%rax)

    return 0;
  800421a1b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421a1b7:	48 81 c4 f8 00 00 00 	add    $0xf8,%rsp
  800421a1be:	5b                   	pop    %rbx
  800421a1bf:	5d                   	pop    %rbp
  800421a1c0:	c3                   	retq   

000000800421a1c1 <vmcs_host_init>:

void vmcs_host_init() {
  800421a1c1:	55                   	push   %rbp
  800421a1c2:	48 89 e5             	mov    %rsp,%rbp
  800421a1c5:	48 81 ec 30 01 00 00 	sub    $0x130,%rsp

    static __inline uint64_t
rcr0(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr0,%0" : "=r" (val));
  800421a1cc:	0f 20 c0             	mov    %cr0,%rax
  800421a1cf:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    return val;
  800421a1d3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421a1d7:	c7 45 e4 00 6c 00 00 	movl   $0x6c00,-0x1c(%rbp)
  800421a1de:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421a1e2:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421a1e6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421a1e9:	48 89 d6             	mov    %rdx,%rsi
  800421a1ec:	89 c7                	mov    %eax,%edi
  800421a1ee:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a1f5:	00 00 00 
  800421a1f8:	ff d0                	callq  *%rax

    static __inline uint64_t
rcr3(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr3,%0" : "=r" (val));
  800421a1fa:	0f 20 d8             	mov    %cr3,%rax
  800421a1fd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    return val;
  800421a201:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421a205:	c7 45 cc 02 6c 00 00 	movl   $0x6c02,-0x34(%rbp)
  800421a20c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800421a210:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421a214:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421a217:	48 89 d6             	mov    %rdx,%rsi
  800421a21a:	89 c7                	mov    %eax,%edi
  800421a21c:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a223:	00 00 00 
  800421a226:	ff d0                	callq  *%rax

    static __inline uint64_t
rcr4(void)
{
    uint64_t cr4;
    __asm __volatile("movq %%cr4,%0" : "=r" (cr4));
  800421a228:	0f 20 e0             	mov    %cr4,%rax
  800421a22b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    return cr4;
  800421a22f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421a233:	c7 45 b4 04 6c 00 00 	movl   $0x6c04,-0x4c(%rbp)
  800421a23a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  800421a23e:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800421a242:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800421a245:	48 89 d6             	mov    %rdx,%rsi
  800421a248:	89 c7                	mov    %eax,%edi
  800421a24a:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a251:	00 00 00 
  800421a254:	ff d0                	callq  *%rax
  800421a256:	c7 45 a4 00 0c 00 00 	movl   $0xc00,-0x5c(%rbp)
  800421a25d:	66 c7 45 a2 10 00    	movw   $0x10,-0x5e(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
}

static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
  800421a263:	0f b7 55 a2          	movzwl -0x5e(%rbp),%edx
  800421a267:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  800421a26a:	48 89 d6             	mov    %rdx,%rsi
  800421a26d:	89 c7                	mov    %eax,%edi
  800421a26f:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a276:	00 00 00 
  800421a279:	ff d0                	callq  *%rax
  800421a27b:	c7 45 9c 04 0c 00 00 	movl   $0xc04,-0x64(%rbp)
  800421a282:	66 c7 45 9a 10 00    	movw   $0x10,-0x66(%rbp)
  800421a288:	0f b7 55 9a          	movzwl -0x66(%rbp),%edx
  800421a28c:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421a28f:	48 89 d6             	mov    %rdx,%rsi
  800421a292:	89 c7                	mov    %eax,%edi
  800421a294:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a29b:	00 00 00 
  800421a29e:	ff d0                	callq  *%rax
  800421a2a0:	c7 45 94 06 0c 00 00 	movl   $0xc06,-0x6c(%rbp)
  800421a2a7:	66 c7 45 92 10 00    	movw   $0x10,-0x6e(%rbp)
  800421a2ad:	0f b7 55 92          	movzwl -0x6e(%rbp),%edx
  800421a2b1:	8b 45 94             	mov    -0x6c(%rbp),%eax
  800421a2b4:	48 89 d6             	mov    %rdx,%rsi
  800421a2b7:	89 c7                	mov    %eax,%edi
  800421a2b9:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a2c0:	00 00 00 
  800421a2c3:	ff d0                	callq  *%rax
  800421a2c5:	c7 45 8c 08 0c 00 00 	movl   $0xc08,-0x74(%rbp)
  800421a2cc:	66 c7 45 8a 10 00    	movw   $0x10,-0x76(%rbp)
  800421a2d2:	0f b7 55 8a          	movzwl -0x76(%rbp),%edx
  800421a2d6:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421a2d9:	48 89 d6             	mov    %rdx,%rsi
  800421a2dc:	89 c7                	mov    %eax,%edi
  800421a2de:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a2e5:	00 00 00 
  800421a2e8:	ff d0                	callq  *%rax
  800421a2ea:	c7 45 84 0a 0c 00 00 	movl   $0xc0a,-0x7c(%rbp)
  800421a2f1:	66 c7 45 82 10 00    	movw   $0x10,-0x7e(%rbp)
  800421a2f7:	0f b7 55 82          	movzwl -0x7e(%rbp),%edx
  800421a2fb:	8b 45 84             	mov    -0x7c(%rbp),%eax
  800421a2fe:	48 89 d6             	mov    %rdx,%rsi
  800421a301:	89 c7                	mov    %eax,%edi
  800421a303:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a30a:	00 00 00 
  800421a30d:	ff d0                	callq  *%rax
  800421a30f:	c7 85 7c ff ff ff 02 	movl   $0xc02,-0x84(%rbp)
  800421a316:	0c 00 00 
  800421a319:	66 c7 85 7a ff ff ff 	movw   $0x8,-0x86(%rbp)
  800421a320:	08 00 
  800421a322:	0f b7 95 7a ff ff ff 	movzwl -0x86(%rbp),%edx
  800421a329:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421a32f:	48 89 d6             	mov    %rdx,%rsi
  800421a332:	89 c7                	mov    %eax,%edi
  800421a334:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a33b:	00 00 00 
  800421a33e:	ff d0                	callq  *%rax
    vmcs_write16( VMCS_16BIT_HOST_DS_SELECTOR, GD_KD );
    vmcs_write16( VMCS_16BIT_HOST_FS_SELECTOR, GD_KD );
    vmcs_write16( VMCS_16BIT_HOST_GS_SELECTOR, GD_KD );
    vmcs_write16( VMCS_16BIT_HOST_CS_SELECTOR, GD_KT );

	int gd_tss = (GD_TSS0 >> 3) + thiscpu->cpu_id*2;
  800421a340:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421a347:	00 00 00 
  800421a34a:	ff d0                	callq  *%rax
  800421a34c:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421a353:	00 00 00 
  800421a356:	48 98                	cltq   
  800421a358:	48 c1 e0 03          	shl    $0x3,%rax
  800421a35c:	48 89 c1             	mov    %rax,%rcx
  800421a35f:	48 c1 e1 04          	shl    $0x4,%rcx
  800421a363:	48 01 c8             	add    %rcx,%rax
  800421a366:	48 01 d0             	add    %rdx,%rax
  800421a369:	0f b6 00             	movzbl (%rax),%eax
  800421a36c:	0f b6 c0             	movzbl %al,%eax
  800421a36f:	01 c0                	add    %eax,%eax
  800421a371:	83 c0 05             	add    $0x5,%eax
  800421a374:	89 45 fc             	mov    %eax,-0x4(%rbp)
    vmcs_write16( VMCS_16BIT_HOST_TR_SELECTOR, gd_tss << 3 );
  800421a377:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a37a:	c1 e0 03             	shl    $0x3,%eax
  800421a37d:	0f b7 c0             	movzwl %ax,%eax
  800421a380:	c7 85 74 ff ff ff 0c 	movl   $0xc0c,-0x8c(%rbp)
  800421a387:	0c 00 00 
  800421a38a:	66 89 85 72 ff ff ff 	mov    %ax,-0x8e(%rbp)
  800421a391:	0f b7 95 72 ff ff ff 	movzwl -0x8e(%rbp),%edx
  800421a398:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
  800421a39e:	48 89 d6             	mov    %rdx,%rsi
  800421a3a1:	89 c7                	mov    %eax,%edi
  800421a3a3:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a3aa:	00 00 00 
  800421a3ad:	ff d0                	callq  *%rax
  800421a3af:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  800421a3b6:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  800421a3bd:	48 8d 85 fe fe ff ff 	lea    -0x102(%rbp),%rax
  800421a3c4:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
    static __inline void
read_idtr (uint64_t *idtbase, uint16_t *idtlimit)
{
    struct Pseudodesc idtr;

    asm volatile ("sidt %0"
  800421a3cb:	0f 01 8d d0 fe ff ff 	sidt   -0x130(%rbp)
            : "=m" (idtr));
    *idtbase = idtr.pd_base;
  800421a3d2:	48 8b 95 d2 fe ff ff 	mov    -0x12e(%rbp),%rdx
  800421a3d9:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421a3e0:	48 89 10             	mov    %rdx,(%rax)
    *idtlimit = idtr.pd_lim;
  800421a3e3:	0f b7 95 d0 fe ff ff 	movzwl -0x130(%rbp),%edx
  800421a3ea:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800421a3f1:	66 89 10             	mov    %dx,(%rax)
    
    uint16_t xdtr_limit;
    uint64_t xdtr_base;
    read_idtr( &xdtr_base, &xdtr_limit );
    vmcs_write64( VMCS_HOST_IDTR_BASE, xdtr_base );
  800421a3f4:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800421a3fb:	c7 85 5c ff ff ff 0e 	movl   $0x6c0e,-0xa4(%rbp)
  800421a402:	6c 00 00 
  800421a405:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421a40c:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800421a413:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421a419:	48 89 d6             	mov    %rdx,%rsi
  800421a41c:	89 c7                	mov    %eax,%edi
  800421a41e:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a425:	00 00 00 
  800421a428:	ff d0                	callq  *%rax
  800421a42a:	48 8d 85 f0 fe ff ff 	lea    -0x110(%rbp),%rax
  800421a431:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  800421a438:	48 8d 85 fe fe ff ff 	lea    -0x102(%rbp),%rax
  800421a43f:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    static __inline void
read_gdtr (uint64_t *gdtbase, uint16_t *gdtlimit)
{
    struct Pseudodesc gdtr;

    asm volatile ("sgdt %0"
  800421a446:	0f 01 85 e0 fe ff ff 	sgdt   -0x120(%rbp)
            : "=m" (gdtr));
    *gdtbase = gdtr.pd_base;
  800421a44d:	48 8b 95 e2 fe ff ff 	mov    -0x11e(%rbp),%rdx
  800421a454:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800421a45b:	48 89 10             	mov    %rdx,(%rax)
    *gdtlimit = gdtr.pd_lim;
  800421a45e:	0f b7 95 e0 fe ff ff 	movzwl -0x120(%rbp),%edx
  800421a465:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800421a46c:	66 89 10             	mov    %dx,(%rax)

    read_gdtr( &xdtr_base, &xdtr_limit );
    vmcs_write64( VMCS_HOST_GDTR_BASE, xdtr_base );
  800421a46f:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800421a476:	c7 85 3c ff ff ff 0c 	movl   $0x6c0c,-0xc4(%rbp)
  800421a47d:	6c 00 00 
  800421a480:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800421a487:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
  800421a48e:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
  800421a494:	48 89 d6             	mov    %rdx,%rsi
  800421a497:	89 c7                	mov    %eax,%edi
  800421a499:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a4a0:	00 00 00 
  800421a4a3:	ff d0                	callq  *%rax
  800421a4a5:	c7 85 2c ff ff ff 06 	movl   $0x6c06,-0xd4(%rbp)
  800421a4ac:	6c 00 00 
  800421a4af:	48 c7 85 20 ff ff ff 	movq   $0x0,-0xe0(%rbp)
  800421a4b6:	00 00 00 00 
  800421a4ba:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  800421a4c1:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800421a4c7:	48 89 d6             	mov    %rdx,%rsi
  800421a4ca:	89 c7                	mov    %eax,%edi
  800421a4cc:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a4d3:	00 00 00 
  800421a4d6:	ff d0                	callq  *%rax
  800421a4d8:	c7 85 1c ff ff ff 08 	movl   $0x6c08,-0xe4(%rbp)
  800421a4df:	6c 00 00 
  800421a4e2:	48 c7 85 10 ff ff ff 	movq   $0x0,-0xf0(%rbp)
  800421a4e9:	00 00 00 00 
  800421a4ed:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  800421a4f4:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421a4fa:	48 89 d6             	mov    %rdx,%rsi
  800421a4fd:	89 c7                	mov    %eax,%edi
  800421a4ff:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a506:	00 00 00 
  800421a509:	ff d0                	callq  *%rax

    vmcs_write64( VMCS_HOST_FS_BASE, 0x0 );
    vmcs_write64( VMCS_HOST_GS_BASE, 0x0 );
    vmcs_write64( VMCS_HOST_TR_BASE, (uint64_t) &thiscpu->cpu_ts );
  800421a50b:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421a512:	00 00 00 
  800421a515:	ff d0                	callq  *%rax
  800421a517:	48 98                	cltq   
  800421a519:	48 c1 e0 03          	shl    $0x3,%rax
  800421a51d:	48 89 c2             	mov    %rax,%rdx
  800421a520:	48 c1 e2 04          	shl    $0x4,%rdx
  800421a524:	48 01 d0             	add    %rdx,%rax
  800421a527:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800421a52b:	48 b8 20 00 3b 04 80 	movabs $0x80043b0020,%rax
  800421a532:	00 00 00 
  800421a535:	48 01 d0             	add    %rdx,%rax
  800421a538:	c7 85 0c ff ff ff 0a 	movl   $0x6c0a,-0xf4(%rbp)
  800421a53f:	6c 00 00 
  800421a542:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  800421a549:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
  800421a550:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  800421a556:	48 89 d6             	mov    %rdx,%rsi
  800421a559:	89 c7                	mov    %eax,%edi
  800421a55b:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a562:	00 00 00 
  800421a565:	ff d0                	callq  *%rax

    uint64_t tmpl;
	asm("movabs $.Lvmx_return, %0" : "=r"(tmpl));
  800421a567:	48 b8 81 bc 21 04 80 	movabs $0x800421bc81,%rax
  800421a56e:	00 00 00 
  800421a571:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	vmcs_writel(VMCS_HOST_RIP, tmpl);
  800421a575:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421a579:	48 89 c6             	mov    %rax,%rsi
  800421a57c:	bf 16 6c 00 00       	mov    $0x6c16,%edi
  800421a581:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a588:	00 00 00 
  800421a58b:	ff d0                	callq  *%rax
}
  800421a58d:	c9                   	leaveq 
  800421a58e:	c3                   	retq   

000000800421a58f <vmcs_guest_init>:

void vmcs_guest_init() {
  800421a58f:	55                   	push   %rbp
  800421a590:	48 89 e5             	mov    %rsp,%rbp
  800421a593:	48 81 ec f0 01 00 00 	sub    $0x1f0,%rsp
  800421a59a:	c7 45 fc 02 08 00 00 	movl   $0x802,-0x4(%rbp)
  800421a5a1:	66 c7 45 fa 00 00    	movw   $0x0,-0x6(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
}

static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
  800421a5a7:	0f b7 55 fa          	movzwl -0x6(%rbp),%edx
  800421a5ab:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421a5ae:	48 89 d6             	mov    %rdx,%rsi
  800421a5b1:	89 c7                	mov    %eax,%edi
  800421a5b3:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a5ba:	00 00 00 
  800421a5bd:	ff d0                	callq  *%rax
  800421a5bf:	c7 45 f4 00 08 00 00 	movl   $0x800,-0xc(%rbp)
  800421a5c6:	66 c7 45 f2 00 00    	movw   $0x0,-0xe(%rbp)
  800421a5cc:	0f b7 55 f2          	movzwl -0xe(%rbp),%edx
  800421a5d0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421a5d3:	48 89 d6             	mov    %rdx,%rsi
  800421a5d6:	89 c7                	mov    %eax,%edi
  800421a5d8:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a5df:	00 00 00 
  800421a5e2:	ff d0                	callq  *%rax
  800421a5e4:	c7 45 ec 04 08 00 00 	movl   $0x804,-0x14(%rbp)
  800421a5eb:	66 c7 45 ea 00 00    	movw   $0x0,-0x16(%rbp)
  800421a5f1:	0f b7 55 ea          	movzwl -0x16(%rbp),%edx
  800421a5f5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421a5f8:	48 89 d6             	mov    %rdx,%rsi
  800421a5fb:	89 c7                	mov    %eax,%edi
  800421a5fd:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a604:	00 00 00 
  800421a607:	ff d0                	callq  *%rax
  800421a609:	c7 45 e4 06 08 00 00 	movl   $0x806,-0x1c(%rbp)
  800421a610:	66 c7 45 e2 00 00    	movw   $0x0,-0x1e(%rbp)
  800421a616:	0f b7 55 e2          	movzwl -0x1e(%rbp),%edx
  800421a61a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421a61d:	48 89 d6             	mov    %rdx,%rsi
  800421a620:	89 c7                	mov    %eax,%edi
  800421a622:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a629:	00 00 00 
  800421a62c:	ff d0                	callq  *%rax
  800421a62e:	c7 45 dc 08 08 00 00 	movl   $0x808,-0x24(%rbp)
  800421a635:	66 c7 45 da 00 00    	movw   $0x0,-0x26(%rbp)
  800421a63b:	0f b7 55 da          	movzwl -0x26(%rbp),%edx
  800421a63f:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421a642:	48 89 d6             	mov    %rdx,%rsi
  800421a645:	89 c7                	mov    %eax,%edi
  800421a647:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a64e:	00 00 00 
  800421a651:	ff d0                	callq  *%rax
  800421a653:	c7 45 d4 0a 08 00 00 	movl   $0x80a,-0x2c(%rbp)
  800421a65a:	66 c7 45 d2 00 00    	movw   $0x0,-0x2e(%rbp)
  800421a660:	0f b7 55 d2          	movzwl -0x2e(%rbp),%edx
  800421a664:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421a667:	48 89 d6             	mov    %rdx,%rsi
  800421a66a:	89 c7                	mov    %eax,%edi
  800421a66c:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a673:	00 00 00 
  800421a676:	ff d0                	callq  *%rax
  800421a678:	c7 45 cc 0e 08 00 00 	movl   $0x80e,-0x34(%rbp)
  800421a67f:	66 c7 45 ca 00 00    	movw   $0x0,-0x36(%rbp)
  800421a685:	0f b7 55 ca          	movzwl -0x36(%rbp),%edx
  800421a689:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421a68c:	48 89 d6             	mov    %rdx,%rsi
  800421a68f:	89 c7                	mov    %eax,%edi
  800421a691:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a698:	00 00 00 
  800421a69b:	ff d0                	callq  *%rax
  800421a69d:	c7 45 c4 0c 08 00 00 	movl   $0x80c,-0x3c(%rbp)
  800421a6a4:	66 c7 45 c2 00 00    	movw   $0x0,-0x3e(%rbp)
  800421a6aa:	0f b7 55 c2          	movzwl -0x3e(%rbp),%edx
  800421a6ae:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421a6b1:	48 89 d6             	mov    %rdx,%rsi
  800421a6b4:	89 c7                	mov    %eax,%edi
  800421a6b6:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a6bd:	00 00 00 
  800421a6c0:	ff d0                	callq  *%rax
  800421a6c2:	c7 45 bc 08 68 00 00 	movl   $0x6808,-0x44(%rbp)
  800421a6c9:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
  800421a6d0:	00 
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421a6d1:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800421a6d5:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421a6d8:	48 89 d6             	mov    %rdx,%rsi
  800421a6db:	89 c7                	mov    %eax,%edi
  800421a6dd:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a6e4:	00 00 00 
  800421a6e7:	ff d0                	callq  *%rax
  800421a6e9:	c7 45 ac 06 68 00 00 	movl   $0x6806,-0x54(%rbp)
  800421a6f0:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  800421a6f7:	00 
  800421a6f8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421a6fc:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421a6ff:	48 89 d6             	mov    %rdx,%rsi
  800421a702:	89 c7                	mov    %eax,%edi
  800421a704:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a70b:	00 00 00 
  800421a70e:	ff d0                	callq  *%rax
  800421a710:	c7 45 9c 0a 68 00 00 	movl   $0x680a,-0x64(%rbp)
  800421a717:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  800421a71e:	00 
  800421a71f:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800421a723:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421a726:	48 89 d6             	mov    %rdx,%rsi
  800421a729:	89 c7                	mov    %eax,%edi
  800421a72b:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a732:	00 00 00 
  800421a735:	ff d0                	callq  *%rax
  800421a737:	c7 45 8c 0c 68 00 00 	movl   $0x680c,-0x74(%rbp)
  800421a73e:	48 c7 45 80 00 00 00 	movq   $0x0,-0x80(%rbp)
  800421a745:	00 
  800421a746:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  800421a74a:	8b 45 8c             	mov    -0x74(%rbp),%eax
  800421a74d:	48 89 d6             	mov    %rdx,%rsi
  800421a750:	89 c7                	mov    %eax,%edi
  800421a752:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a759:	00 00 00 
  800421a75c:	ff d0                	callq  *%rax
  800421a75e:	c7 85 7c ff ff ff 0e 	movl   $0x680e,-0x84(%rbp)
  800421a765:	68 00 00 
  800421a768:	48 c7 85 70 ff ff ff 	movq   $0x0,-0x90(%rbp)
  800421a76f:	00 00 00 00 
  800421a773:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421a77a:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421a780:	48 89 d6             	mov    %rdx,%rsi
  800421a783:	89 c7                	mov    %eax,%edi
  800421a785:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a78c:	00 00 00 
  800421a78f:	ff d0                	callq  *%rax
  800421a791:	c7 85 6c ff ff ff 10 	movl   $0x6810,-0x94(%rbp)
  800421a798:	68 00 00 
  800421a79b:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
  800421a7a2:	00 00 00 00 
  800421a7a6:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421a7ad:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  800421a7b3:	48 89 d6             	mov    %rdx,%rsi
  800421a7b6:	89 c7                	mov    %eax,%edi
  800421a7b8:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a7bf:	00 00 00 
  800421a7c2:	ff d0                	callq  *%rax
  800421a7c4:	c7 85 5c ff ff ff 12 	movl   $0x6812,-0xa4(%rbp)
  800421a7cb:	68 00 00 
  800421a7ce:	48 c7 85 50 ff ff ff 	movq   $0x0,-0xb0(%rbp)
  800421a7d5:	00 00 00 00 
  800421a7d9:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800421a7e0:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421a7e6:	48 89 d6             	mov    %rdx,%rsi
  800421a7e9:	89 c7                	mov    %eax,%edi
  800421a7eb:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a7f2:	00 00 00 
  800421a7f5:	ff d0                	callq  *%rax
  800421a7f7:	c7 85 4c ff ff ff 16 	movl   $0x6816,-0xb4(%rbp)
  800421a7fe:	68 00 00 
  800421a801:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
  800421a808:	00 00 00 00 
  800421a80c:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
  800421a813:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421a819:	48 89 d6             	mov    %rdx,%rsi
  800421a81c:	89 c7                	mov    %eax,%edi
  800421a81e:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a825:	00 00 00 
  800421a828:	ff d0                	callq  *%rax
  800421a82a:	c7 85 3c ff ff ff 18 	movl   $0x6818,-0xc4(%rbp)
  800421a831:	68 00 00 
  800421a834:	48 c7 85 30 ff ff ff 	movq   $0x0,-0xd0(%rbp)
  800421a83b:	00 00 00 00 
  800421a83f:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
  800421a846:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
  800421a84c:	48 89 d6             	mov    %rdx,%rsi
  800421a84f:	89 c7                	mov    %eax,%edi
  800421a851:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a858:	00 00 00 
  800421a85b:	ff d0                	callq  *%rax
  800421a85d:	c7 85 2c ff ff ff 14 	movl   $0x6814,-0xd4(%rbp)
  800421a864:	68 00 00 
  800421a867:	48 c7 85 20 ff ff ff 	movq   $0x0,-0xe0(%rbp)
  800421a86e:	00 00 00 00 
  800421a872:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
  800421a879:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
  800421a87f:	48 89 d6             	mov    %rdx,%rsi
  800421a882:	89 c7                	mov    %eax,%edi
  800421a884:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a88b:	00 00 00 
  800421a88e:	ff d0                	callq  *%rax
  800421a890:	c7 85 1c ff ff ff 02 	movl   $0x4802,-0xe4(%rbp)
  800421a897:	48 00 00 
  800421a89a:	c7 85 18 ff ff ff ff 	movl   $0xffff,-0xe8(%rbp)
  800421a8a1:	ff 00 00 
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421a8a4:	8b 95 18 ff ff ff    	mov    -0xe8(%rbp),%edx
  800421a8aa:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421a8b0:	48 89 d6             	mov    %rdx,%rsi
  800421a8b3:	89 c7                	mov    %eax,%edi
  800421a8b5:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a8bc:	00 00 00 
  800421a8bf:	ff d0                	callq  *%rax
  800421a8c1:	c7 85 14 ff ff ff 00 	movl   $0x4800,-0xec(%rbp)
  800421a8c8:	48 00 00 
  800421a8cb:	c7 85 10 ff ff ff ff 	movl   $0xffff,-0xf0(%rbp)
  800421a8d2:	ff 00 00 
  800421a8d5:	8b 95 10 ff ff ff    	mov    -0xf0(%rbp),%edx
  800421a8db:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421a8e1:	48 89 d6             	mov    %rdx,%rsi
  800421a8e4:	89 c7                	mov    %eax,%edi
  800421a8e6:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a8ed:	00 00 00 
  800421a8f0:	ff d0                	callq  *%rax
  800421a8f2:	c7 85 0c ff ff ff 04 	movl   $0x4804,-0xf4(%rbp)
  800421a8f9:	48 00 00 
  800421a8fc:	c7 85 08 ff ff ff ff 	movl   $0xffff,-0xf8(%rbp)
  800421a903:	ff 00 00 
  800421a906:	8b 95 08 ff ff ff    	mov    -0xf8(%rbp),%edx
  800421a90c:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  800421a912:	48 89 d6             	mov    %rdx,%rsi
  800421a915:	89 c7                	mov    %eax,%edi
  800421a917:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a91e:	00 00 00 
  800421a921:	ff d0                	callq  *%rax
  800421a923:	c7 85 04 ff ff ff 06 	movl   $0x4806,-0xfc(%rbp)
  800421a92a:	48 00 00 
  800421a92d:	c7 85 00 ff ff ff ff 	movl   $0xffff,-0x100(%rbp)
  800421a934:	ff 00 00 
  800421a937:	8b 95 00 ff ff ff    	mov    -0x100(%rbp),%edx
  800421a93d:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
  800421a943:	48 89 d6             	mov    %rdx,%rsi
  800421a946:	89 c7                	mov    %eax,%edi
  800421a948:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a94f:	00 00 00 
  800421a952:	ff d0                	callq  *%rax
  800421a954:	c7 85 fc fe ff ff 08 	movl   $0x4808,-0x104(%rbp)
  800421a95b:	48 00 00 
  800421a95e:	c7 85 f8 fe ff ff ff 	movl   $0xffff,-0x108(%rbp)
  800421a965:	ff 00 00 
  800421a968:	8b 95 f8 fe ff ff    	mov    -0x108(%rbp),%edx
  800421a96e:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
  800421a974:	48 89 d6             	mov    %rdx,%rsi
  800421a977:	89 c7                	mov    %eax,%edi
  800421a979:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a980:	00 00 00 
  800421a983:	ff d0                	callq  *%rax
  800421a985:	c7 85 f4 fe ff ff 0a 	movl   $0x480a,-0x10c(%rbp)
  800421a98c:	48 00 00 
  800421a98f:	c7 85 f0 fe ff ff ff 	movl   $0xffff,-0x110(%rbp)
  800421a996:	ff 00 00 
  800421a999:	8b 95 f0 fe ff ff    	mov    -0x110(%rbp),%edx
  800421a99f:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
  800421a9a5:	48 89 d6             	mov    %rdx,%rsi
  800421a9a8:	89 c7                	mov    %eax,%edi
  800421a9aa:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a9b1:	00 00 00 
  800421a9b4:	ff d0                	callq  *%rax
  800421a9b6:	c7 85 ec fe ff ff 0c 	movl   $0x480c,-0x114(%rbp)
  800421a9bd:	48 00 00 
  800421a9c0:	c7 85 e8 fe ff ff ff 	movl   $0xffff,-0x118(%rbp)
  800421a9c7:	ff 00 00 
  800421a9ca:	8b 95 e8 fe ff ff    	mov    -0x118(%rbp),%edx
  800421a9d0:	8b 85 ec fe ff ff    	mov    -0x114(%rbp),%eax
  800421a9d6:	48 89 d6             	mov    %rdx,%rsi
  800421a9d9:	89 c7                	mov    %eax,%edi
  800421a9db:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421a9e2:	00 00 00 
  800421a9e5:	ff d0                	callq  *%rax
  800421a9e7:	c7 85 e4 fe ff ff 0e 	movl   $0x480e,-0x11c(%rbp)
  800421a9ee:	48 00 00 
  800421a9f1:	c7 85 e0 fe ff ff ff 	movl   $0xfffff,-0x120(%rbp)
  800421a9f8:	ff 0f 00 
  800421a9fb:	8b 95 e0 fe ff ff    	mov    -0x120(%rbp),%edx
  800421aa01:	8b 85 e4 fe ff ff    	mov    -0x11c(%rbp),%eax
  800421aa07:	48 89 d6             	mov    %rdx,%rsi
  800421aa0a:	89 c7                	mov    %eax,%edi
  800421aa0c:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421aa13:	00 00 00 
  800421aa16:	ff d0                	callq  *%rax
  800421aa18:	c7 85 dc fe ff ff 10 	movl   $0x4810,-0x124(%rbp)
  800421aa1f:	48 00 00 
  800421aa22:	c7 85 d8 fe ff ff 30 	movl   $0x30,-0x128(%rbp)
  800421aa29:	00 00 00 
  800421aa2c:	8b 95 d8 fe ff ff    	mov    -0x128(%rbp),%edx
  800421aa32:	8b 85 dc fe ff ff    	mov    -0x124(%rbp),%eax
  800421aa38:	48 89 d6             	mov    %rdx,%rsi
  800421aa3b:	89 c7                	mov    %eax,%edi
  800421aa3d:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421aa44:	00 00 00 
  800421aa47:	ff d0                	callq  *%rax
  800421aa49:	c7 85 d4 fe ff ff 12 	movl   $0x4812,-0x12c(%rbp)
  800421aa50:	48 00 00 
  800421aa53:	c7 85 d0 fe ff ff ff 	movl   $0x3ff,-0x130(%rbp)
  800421aa5a:	03 00 00 
  800421aa5d:	8b 95 d0 fe ff ff    	mov    -0x130(%rbp),%edx
  800421aa63:	8b 85 d4 fe ff ff    	mov    -0x12c(%rbp),%eax
  800421aa69:	48 89 d6             	mov    %rdx,%rsi
  800421aa6c:	89 c7                	mov    %eax,%edi
  800421aa6e:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421aa75:	00 00 00 
  800421aa78:	ff d0                	callq  *%rax
  800421aa7a:	c7 85 cc fe ff ff 16 	movl   $0x4816,-0x134(%rbp)
  800421aa81:	48 00 00 
  800421aa84:	c7 85 c8 fe ff ff 93 	movl   $0x93,-0x138(%rbp)
  800421aa8b:	00 00 00 
  800421aa8e:	8b 95 c8 fe ff ff    	mov    -0x138(%rbp),%edx
  800421aa94:	8b 85 cc fe ff ff    	mov    -0x134(%rbp),%eax
  800421aa9a:	48 89 d6             	mov    %rdx,%rsi
  800421aa9d:	89 c7                	mov    %eax,%edi
  800421aa9f:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421aaa6:	00 00 00 
  800421aaa9:	ff d0                	callq  *%rax
  800421aaab:	c7 85 c4 fe ff ff 14 	movl   $0x4814,-0x13c(%rbp)
  800421aab2:	48 00 00 
  800421aab5:	c7 85 c0 fe ff ff 93 	movl   $0x93,-0x140(%rbp)
  800421aabc:	00 00 00 
  800421aabf:	8b 95 c0 fe ff ff    	mov    -0x140(%rbp),%edx
  800421aac5:	8b 85 c4 fe ff ff    	mov    -0x13c(%rbp),%eax
  800421aacb:	48 89 d6             	mov    %rdx,%rsi
  800421aace:	89 c7                	mov    %eax,%edi
  800421aad0:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421aad7:	00 00 00 
  800421aada:	ff d0                	callq  *%rax
  800421aadc:	c7 85 bc fe ff ff 18 	movl   $0x4818,-0x144(%rbp)
  800421aae3:	48 00 00 
  800421aae6:	c7 85 b8 fe ff ff 93 	movl   $0x93,-0x148(%rbp)
  800421aaed:	00 00 00 
  800421aaf0:	8b 95 b8 fe ff ff    	mov    -0x148(%rbp),%edx
  800421aaf6:	8b 85 bc fe ff ff    	mov    -0x144(%rbp),%eax
  800421aafc:	48 89 d6             	mov    %rdx,%rsi
  800421aaff:	89 c7                	mov    %eax,%edi
  800421ab01:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ab08:	00 00 00 
  800421ab0b:	ff d0                	callq  *%rax
  800421ab0d:	c7 85 b4 fe ff ff 1a 	movl   $0x481a,-0x14c(%rbp)
  800421ab14:	48 00 00 
  800421ab17:	c7 85 b0 fe ff ff 93 	movl   $0x93,-0x150(%rbp)
  800421ab1e:	00 00 00 
  800421ab21:	8b 95 b0 fe ff ff    	mov    -0x150(%rbp),%edx
  800421ab27:	8b 85 b4 fe ff ff    	mov    -0x14c(%rbp),%eax
  800421ab2d:	48 89 d6             	mov    %rdx,%rsi
  800421ab30:	89 c7                	mov    %eax,%edi
  800421ab32:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ab39:	00 00 00 
  800421ab3c:	ff d0                	callq  *%rax
  800421ab3e:	c7 85 ac fe ff ff 1c 	movl   $0x481c,-0x154(%rbp)
  800421ab45:	48 00 00 
  800421ab48:	c7 85 a8 fe ff ff 93 	movl   $0x93,-0x158(%rbp)
  800421ab4f:	00 00 00 
  800421ab52:	8b 95 a8 fe ff ff    	mov    -0x158(%rbp),%edx
  800421ab58:	8b 85 ac fe ff ff    	mov    -0x154(%rbp),%eax
  800421ab5e:	48 89 d6             	mov    %rdx,%rsi
  800421ab61:	89 c7                	mov    %eax,%edi
  800421ab63:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ab6a:	00 00 00 
  800421ab6d:	ff d0                	callq  *%rax
  800421ab6f:	c7 85 a4 fe ff ff 1e 	movl   $0x481e,-0x15c(%rbp)
  800421ab76:	48 00 00 
  800421ab79:	c7 85 a0 fe ff ff 93 	movl   $0x93,-0x160(%rbp)
  800421ab80:	00 00 00 
  800421ab83:	8b 95 a0 fe ff ff    	mov    -0x160(%rbp),%edx
  800421ab89:	8b 85 a4 fe ff ff    	mov    -0x15c(%rbp),%eax
  800421ab8f:	48 89 d6             	mov    %rdx,%rsi
  800421ab92:	89 c7                	mov    %eax,%edi
  800421ab94:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ab9b:	00 00 00 
  800421ab9e:	ff d0                	callq  *%rax
  800421aba0:	c7 85 9c fe ff ff 20 	movl   $0x4820,-0x164(%rbp)
  800421aba7:	48 00 00 
  800421abaa:	c7 85 98 fe ff ff 82 	movl   $0x82,-0x168(%rbp)
  800421abb1:	00 00 00 
  800421abb4:	8b 95 98 fe ff ff    	mov    -0x168(%rbp),%edx
  800421abba:	8b 85 9c fe ff ff    	mov    -0x164(%rbp),%eax
  800421abc0:	48 89 d6             	mov    %rdx,%rsi
  800421abc3:	89 c7                	mov    %eax,%edi
  800421abc5:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421abcc:	00 00 00 
  800421abcf:	ff d0                	callq  *%rax
  800421abd1:	c7 85 94 fe ff ff 22 	movl   $0x4822,-0x16c(%rbp)
  800421abd8:	48 00 00 
  800421abdb:	c7 85 90 fe ff ff 8b 	movl   $0x8b,-0x170(%rbp)
  800421abe2:	00 00 00 
  800421abe5:	8b 95 90 fe ff ff    	mov    -0x170(%rbp),%edx
  800421abeb:	8b 85 94 fe ff ff    	mov    -0x16c(%rbp),%eax
  800421abf1:	48 89 d6             	mov    %rdx,%rsi
  800421abf4:	89 c7                	mov    %eax,%edi
  800421abf6:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421abfd:	00 00 00 
  800421ac00:	ff d0                	callq  *%rax
  800421ac02:	c7 85 8c fe ff ff 26 	movl   $0x4826,-0x174(%rbp)
  800421ac09:	48 00 00 
  800421ac0c:	c7 85 88 fe ff ff 00 	movl   $0x0,-0x178(%rbp)
  800421ac13:	00 00 00 
  800421ac16:	8b 95 88 fe ff ff    	mov    -0x178(%rbp),%edx
  800421ac1c:	8b 85 8c fe ff ff    	mov    -0x174(%rbp),%eax
  800421ac22:	48 89 d6             	mov    %rdx,%rsi
  800421ac25:	89 c7                	mov    %eax,%edi
  800421ac27:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ac2e:	00 00 00 
  800421ac31:	ff d0                	callq  *%rax
  800421ac33:	c7 85 84 fe ff ff 24 	movl   $0x4824,-0x17c(%rbp)
  800421ac3a:	48 00 00 
  800421ac3d:	c7 85 80 fe ff ff 00 	movl   $0x0,-0x180(%rbp)
  800421ac44:	00 00 00 
  800421ac47:	8b 95 80 fe ff ff    	mov    -0x180(%rbp),%edx
  800421ac4d:	8b 85 84 fe ff ff    	mov    -0x17c(%rbp),%eax
  800421ac53:	48 89 d6             	mov    %rdx,%rsi
  800421ac56:	89 c7                	mov    %eax,%edi
  800421ac58:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ac5f:	00 00 00 
  800421ac62:	ff d0                	callq  *%rax
  800421ac64:	c7 85 7c fe ff ff 02 	movl   $0x6802,-0x184(%rbp)
  800421ac6b:	68 00 00 
  800421ac6e:	48 c7 85 70 fe ff ff 	movq   $0x0,-0x190(%rbp)
  800421ac75:	00 00 00 00 
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421ac79:	48 8b 95 70 fe ff ff 	mov    -0x190(%rbp),%rdx
  800421ac80:	8b 85 7c fe ff ff    	mov    -0x184(%rbp),%eax
  800421ac86:	48 89 d6             	mov    %rdx,%rsi
  800421ac89:	89 c7                	mov    %eax,%edi
  800421ac8b:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ac92:	00 00 00 
  800421ac95:	ff d0                	callq  *%rax
  800421ac97:	c7 85 6c fe ff ff 00 	movl   $0x6800,-0x194(%rbp)
  800421ac9e:	68 00 00 
  800421aca1:	48 c7 85 60 fe ff ff 	movq   $0x20,-0x1a0(%rbp)
  800421aca8:	20 00 00 00 
  800421acac:	48 8b 95 60 fe ff ff 	mov    -0x1a0(%rbp),%rdx
  800421acb3:	8b 85 6c fe ff ff    	mov    -0x194(%rbp),%eax
  800421acb9:	48 89 d6             	mov    %rdx,%rsi
  800421acbc:	89 c7                	mov    %eax,%edi
  800421acbe:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421acc5:	00 00 00 
  800421acc8:	ff d0                	callq  *%rax
  800421acca:	c7 85 5c fe ff ff 04 	movl   $0x6804,-0x1a4(%rbp)
  800421acd1:	68 00 00 
  800421acd4:	48 c7 85 50 fe ff ff 	movq   $0x2000,-0x1b0(%rbp)
  800421acdb:	00 20 00 00 
  800421acdf:	48 8b 95 50 fe ff ff 	mov    -0x1b0(%rbp),%rdx
  800421ace6:	8b 85 5c fe ff ff    	mov    -0x1a4(%rbp),%eax
  800421acec:	48 89 d6             	mov    %rdx,%rsi
  800421acef:	89 c7                	mov    %eax,%edi
  800421acf1:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421acf8:	00 00 00 
  800421acfb:	ff d0                	callq  *%rax
  800421acfd:	c7 85 4c fe ff ff 00 	movl   $0x2800,-0x1b4(%rbp)
  800421ad04:	28 00 00 
  800421ad07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421ad0c:	48 89 85 40 fe ff ff 	mov    %rax,-0x1c0(%rbp)
  800421ad13:	48 8b 95 40 fe ff ff 	mov    -0x1c0(%rbp),%rdx
  800421ad1a:	8b 85 4c fe ff ff    	mov    -0x1b4(%rbp),%eax
  800421ad20:	48 89 d6             	mov    %rdx,%rsi
  800421ad23:	89 c7                	mov    %eax,%edi
  800421ad25:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ad2c:	00 00 00 
  800421ad2f:	ff d0                	callq  *%rax
  800421ad31:	c7 85 3c fe ff ff 01 	movl   $0x2801,-0x1c4(%rbp)
  800421ad38:	28 00 00 
  800421ad3b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421ad40:	48 89 85 30 fe ff ff 	mov    %rax,-0x1d0(%rbp)
  800421ad47:	48 8b 95 30 fe ff ff 	mov    -0x1d0(%rbp),%rdx
  800421ad4e:	8b 85 3c fe ff ff    	mov    -0x1c4(%rbp),%eax
  800421ad54:	48 89 d6             	mov    %rdx,%rsi
  800421ad57:	89 c7                	mov    %eax,%edi
  800421ad59:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ad60:	00 00 00 
  800421ad63:	ff d0                	callq  *%rax
  800421ad65:	c7 85 2c fe ff ff 1a 	movl   $0x681a,-0x1d4(%rbp)
  800421ad6c:	68 00 00 
  800421ad6f:	48 c7 85 20 fe ff ff 	movq   $0x0,-0x1e0(%rbp)
  800421ad76:	00 00 00 00 
  800421ad7a:	48 8b 95 20 fe ff ff 	mov    -0x1e0(%rbp),%rdx
  800421ad81:	8b 85 2c fe ff ff    	mov    -0x1d4(%rbp),%eax
  800421ad87:	48 89 d6             	mov    %rdx,%rsi
  800421ad8a:	89 c7                	mov    %eax,%edi
  800421ad8c:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421ad93:	00 00 00 
  800421ad96:	ff d0                	callq  *%rax
  800421ad98:	c7 85 1c fe ff ff 20 	movl   $0x6820,-0x1e4(%rbp)
  800421ad9f:	68 00 00 
  800421ada2:	48 c7 85 10 fe ff ff 	movq   $0x2,-0x1f0(%rbp)
  800421ada9:	02 00 00 00 
  800421adad:	48 8b 95 10 fe ff ff 	mov    -0x1f0(%rbp),%rdx
  800421adb4:	8b 85 1c fe ff ff    	mov    -0x1e4(%rbp),%eax
  800421adba:	48 89 d6             	mov    %rdx,%rsi
  800421adbd:	89 c7                	mov    %eax,%edi
  800421adbf:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421adc6:	00 00 00 
  800421adc9:	ff d0                	callq  *%rax
    vmcs_write64( VMCS_64BIT_GUEST_LINK_POINTER, 0xffffffff );
    vmcs_write64( VMCS_64BIT_GUEST_LINK_POINTER_HI, 0xffffffff ); 
    vmcs_write64( VMCS_GUEST_DR7, 0x0 );
    vmcs_write64( VMCS_GUEST_RFLAGS, 0x2 );

}
  800421adcb:	c9                   	leaveq 
  800421adcc:	c3                   	retq   

000000800421adcd <vmx_read_capability_msr>:

void vmx_read_capability_msr( uint32_t msr, uint32_t* hi, uint32_t* lo ) {
  800421adcd:	55                   	push   %rbp
  800421adce:	48 89 e5             	mov    %rsp,%rbp
  800421add1:	48 83 ec 38          	sub    $0x38,%rsp
  800421add5:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800421add8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421addc:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  800421ade0:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421ade3:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  800421ade6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421ade9:	89 c1                	mov    %eax,%ecx
  800421adeb:	0f 32                	rdmsr  
  800421aded:	89 55 f0             	mov    %edx,-0x10(%rbp)
  800421adf0:	89 45 ec             	mov    %eax,-0x14(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  800421adf3:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800421adfa:	00 
    ret = edx;
  800421adfb:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421adfe:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    ret = ret << 32;
  800421ae02:	48 c1 65 e0 20       	shlq   $0x20,-0x20(%rbp)
    ret |= eax;
  800421ae07:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421ae0a:	48 09 45 e0          	or     %rax,-0x20(%rbp)

    return ret;
  800421ae0e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    uint64_t msr_val = read_msr( msr );
  800421ae12:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    *hi = (uint32_t)( msr_val >> 32 );
  800421ae16:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421ae1a:	48 c1 e8 20          	shr    $0x20,%rax
  800421ae1e:	89 c2                	mov    %eax,%edx
  800421ae20:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ae24:	89 10                	mov    %edx,(%rax)
    *lo = (uint32_t)( msr_val );
  800421ae26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421ae2a:	89 c2                	mov    %eax,%edx
  800421ae2c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421ae30:	89 10                	mov    %edx,(%rax)
}
  800421ae32:	c9                   	leaveq 
  800421ae33:	c3                   	retq   

000000800421ae34 <vmcs_ctls_init>:

static void 
vmcs_ctls_init( struct Env* e ) {
  800421ae34:	55                   	push   %rbp
  800421ae35:	48 89 e5             	mov    %rsp,%rbp
  800421ae38:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800421ae3f:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
    // Set pin based vm exec controls.
    uint32_t pinbased_ctls_or, pinbased_ctls_and;
    vmx_read_capability_msr( IA32_VMX_PINBASED_CTLS, 
  800421ae46:	48 8d 95 24 ff ff ff 	lea    -0xdc(%rbp),%rdx
  800421ae4d:	48 8d 85 20 ff ff ff 	lea    -0xe0(%rbp),%rax
  800421ae54:	48 89 c6             	mov    %rax,%rsi
  800421ae57:	bf 81 04 00 00       	mov    $0x481,%edi
  800421ae5c:	48 b8 cd ad 21 04 80 	movabs $0x800421adcd,%rax
  800421ae63:	00 00 00 
  800421ae66:	ff d0                	callq  *%rax
            &pinbased_ctls_and, &pinbased_ctls_or );

	//enable the guest external interrupt exit    
	pinbased_ctls_or |= VMCS_PIN_BASED_VMEXEC_CTL_EXINTEXIT;
  800421ae68:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
  800421ae6e:	83 c8 01             	or     $0x1,%eax
  800421ae71:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
    vmcs_write32( VMCS_32BIT_CONTROL_PIN_BASED_EXEC_CONTROLS, 
  800421ae77:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  800421ae7d:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
  800421ae83:	21 d0                	and    %edx,%eax
  800421ae85:	c7 45 cc 00 40 00 00 	movl   $0x4000,-0x34(%rbp)
  800421ae8c:	89 45 c8             	mov    %eax,-0x38(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421ae8f:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800421ae92:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421ae95:	48 89 d6             	mov    %rdx,%rsi
  800421ae98:	89 c7                	mov    %eax,%edi
  800421ae9a:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421aea1:	00 00 00 
  800421aea4:	ff d0                	callq  *%rax
            pinbased_ctls_or & pinbased_ctls_and );

    // Set proc-based controls.
    uint32_t procbased_ctls_or, procbased_ctls_and;
    vmx_read_capability_msr( IA32_VMX_PROCBASED_CTLS, 
  800421aea6:	48 8d 95 1c ff ff ff 	lea    -0xe4(%rbp),%rdx
  800421aead:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800421aeb4:	48 89 c6             	mov    %rax,%rsi
  800421aeb7:	bf 82 04 00 00       	mov    $0x482,%edi
  800421aebc:	48 b8 cd ad 21 04 80 	movabs $0x800421adcd,%rax
  800421aec3:	00 00 00 
  800421aec6:	ff d0                	callq  *%rax
            &procbased_ctls_and, &procbased_ctls_or );
    // Make sure there are secondary controls.
    assert( BIT( procbased_ctls_and, 31 ) == 0x1 ); 
  800421aec8:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
  800421aece:	c1 e8 1f             	shr    $0x1f,%eax
  800421aed1:	83 f8 01             	cmp    $0x1,%eax
  800421aed4:	74 35                	je     800421af0b <vmcs_ctls_init+0xd7>
  800421aed6:	48 b9 70 03 22 04 80 	movabs $0x8004220370,%rcx
  800421aedd:	00 00 00 
  800421aee0:	48 ba 3a 03 22 04 80 	movabs $0x800422033a,%rdx
  800421aee7:	00 00 00 
  800421aeea:	be 42 01 00 00       	mov    $0x142,%esi
  800421aeef:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421aef6:	00 00 00 
  800421aef9:	b8 00 00 00 00       	mov    $0x0,%eax
  800421aefe:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421af05:	00 00 00 
  800421af08:	41 ff d0             	callq  *%r8
   
    procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_ACTIVESECCTL; 
  800421af0b:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421af11:	0d 00 00 00 80       	or     $0x80000000,%eax
  800421af16:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_HLTEXIT;
  800421af1c:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421af22:	0c 80                	or     $0x80,%al
  800421af24:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_USEIOBMP;
  800421af2a:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421af30:	0d 00 00 00 02       	or     $0x2000000,%eax
  800421af35:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    /* CR3 accesses and invlpg don't need to cause VM Exits when EPT
       enabled */
    procbased_ctls_or &= ~( VMCS_PROC_BASED_VMEXEC_CTL_CR3LOADEXIT |
  800421af3b:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
  800421af41:	25 ff 7d fe ff       	and    $0xfffe7dff,%eax
  800421af46:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
            VMCS_PROC_BASED_VMEXEC_CTL_CR3STOREXIT | 
            VMCS_PROC_BASED_VMEXEC_CTL_INVLPGEXIT );

    vmcs_write32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS, 
  800421af4c:	8b 95 1c ff ff ff    	mov    -0xe4(%rbp),%edx
  800421af52:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
  800421af58:	21 d0                	and    %edx,%eax
  800421af5a:	c7 45 c4 02 40 00 00 	movl   $0x4002,-0x3c(%rbp)
  800421af61:	89 45 c0             	mov    %eax,-0x40(%rbp)
  800421af64:	8b 55 c0             	mov    -0x40(%rbp),%edx
  800421af67:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421af6a:	48 89 d6             	mov    %rdx,%rsi
  800421af6d:	89 c7                	mov    %eax,%edi
  800421af6f:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421af76:	00 00 00 
  800421af79:	ff d0                	callq  *%rax
            procbased_ctls_or & procbased_ctls_and );

    // Set Proc based secondary controls.
    uint32_t procbased_ctls2_or, procbased_ctls2_and;
    vmx_read_capability_msr( IA32_VMX_PROCBASED_CTLS2, 
  800421af7b:	48 8d 95 14 ff ff ff 	lea    -0xec(%rbp),%rdx
  800421af82:	48 8d 85 10 ff ff ff 	lea    -0xf0(%rbp),%rax
  800421af89:	48 89 c6             	mov    %rax,%rsi
  800421af8c:	bf 8b 04 00 00       	mov    $0x48b,%edi
  800421af91:	48 b8 cd ad 21 04 80 	movabs $0x800421adcd,%rax
  800421af98:	00 00 00 
  800421af9b:	ff d0                	callq  *%rax
            &procbased_ctls2_and, &procbased_ctls2_or );
    
    // Enable EPT.
    procbased_ctls2_or |= VMCS_SECONDARY_VMEXEC_CTL_ENABLE_EPT;
  800421af9d:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421afa3:	83 c8 02             	or     $0x2,%eax
  800421afa6:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
    procbased_ctls2_or |= VMCS_SECONDARY_VMEXEC_CTL_UNRESTRICTED_GUEST;
  800421afac:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
  800421afb2:	0c 80                	or     $0x80,%al
  800421afb4:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
    vmcs_write32( VMCS_32BIT_CONTROL_SECONDARY_VMEXEC_CONTROLS, 
  800421afba:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  800421afc0:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
  800421afc6:	21 d0                	and    %edx,%eax
  800421afc8:	c7 45 bc 1e 40 00 00 	movl   $0x401e,-0x44(%rbp)
  800421afcf:	89 45 b8             	mov    %eax,-0x48(%rbp)
  800421afd2:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800421afd5:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421afd8:	48 89 d6             	mov    %rdx,%rsi
  800421afdb:	89 c7                	mov    %eax,%edi
  800421afdd:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421afe4:	00 00 00 
  800421afe7:	ff d0                	callq  *%rax
            procbased_ctls2_or & procbased_ctls2_and );

    // Set VM exit controls.
    uint32_t exit_ctls_or, exit_ctls_and;
    vmx_read_capability_msr( IA32_VMX_EXIT_CTLS, 
  800421afe9:	48 8d 95 0c ff ff ff 	lea    -0xf4(%rbp),%rdx
  800421aff0:	48 8d 85 08 ff ff ff 	lea    -0xf8(%rbp),%rax
  800421aff7:	48 89 c6             	mov    %rax,%rsi
  800421affa:	bf 83 04 00 00       	mov    $0x483,%edi
  800421afff:	48 b8 cd ad 21 04 80 	movabs $0x800421adcd,%rax
  800421b006:	00 00 00 
  800421b009:	ff d0                	callq  *%rax
            &exit_ctls_and, &exit_ctls_or );

    exit_ctls_or |= VMCS_VMEXIT_HOST_ADDR_SIZE;
  800421b00b:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  800421b011:	80 cc 02             	or     $0x2,%ah
  800421b014:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
    exit_ctls_or |= VMCS_VMEXIT_GUEST_ACK_INTR_ON_EXIT;	
  800421b01a:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  800421b020:	80 cc 80             	or     $0x80,%ah
  800421b023:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_CONTROLS, 
  800421b029:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  800421b02f:	8b 85 08 ff ff ff    	mov    -0xf8(%rbp),%eax
  800421b035:	21 d0                	and    %edx,%eax
  800421b037:	c7 45 b4 0c 40 00 00 	movl   $0x400c,-0x4c(%rbp)
  800421b03e:	89 45 b0             	mov    %eax,-0x50(%rbp)
  800421b041:	8b 55 b0             	mov    -0x50(%rbp),%edx
  800421b044:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800421b047:	48 89 d6             	mov    %rdx,%rsi
  800421b04a:	89 c7                	mov    %eax,%edi
  800421b04c:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b053:	00 00 00 
  800421b056:	ff d0                	callq  *%rax
            exit_ctls_or & exit_ctls_and );

    vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_STORE_ADDR,
            PADDR(e->env_vmxinfo.msr_guest_area));
  800421b058:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b05f:	48 8b 80 58 01 00 00 	mov    0x158(%rax),%rax
  800421b066:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421b06a:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421b071:	00 00 00 
  800421b074:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421b078:	77 32                	ja     800421b0ac <vmcs_ctls_init+0x278>
  800421b07a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421b07e:	48 89 c1             	mov    %rax,%rcx
  800421b081:	48 ba 98 03 22 04 80 	movabs $0x8004220398,%rdx
  800421b088:	00 00 00 
  800421b08b:	be 66 01 00 00       	mov    $0x166,%esi
  800421b090:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421b097:	00 00 00 
  800421b09a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b09f:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421b0a6:	00 00 00 
  800421b0a9:	41 ff d0             	callq  *%r8
  800421b0ac:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421b0b3:	ff ff ff 
  800421b0b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421b0ba:	48 01 d0             	add    %rdx,%rax
  800421b0bd:	c7 45 ac 06 20 00 00 	movl   $0x2006,-0x54(%rbp)
  800421b0c4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b0c8:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421b0cc:	8b 45 ac             	mov    -0x54(%rbp),%eax
  800421b0cf:	48 89 d6             	mov    %rdx,%rsi
  800421b0d2:	89 c7                	mov    %eax,%edi
  800421b0d4:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b0db:	00 00 00 
  800421b0de:	ff d0                	callq  *%rax
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_STORE_COUNT,
            e->env_vmxinfo.msr_count);
  800421b0e0:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b0e7:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
  800421b0ed:	c7 45 9c 0e 40 00 00 	movl   $0x400e,-0x64(%rbp)
  800421b0f4:	89 45 98             	mov    %eax,-0x68(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421b0f7:	8b 55 98             	mov    -0x68(%rbp),%edx
  800421b0fa:	8b 45 9c             	mov    -0x64(%rbp),%eax
  800421b0fd:	48 89 d6             	mov    %rdx,%rsi
  800421b100:	89 c7                	mov    %eax,%edi
  800421b102:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b109:	00 00 00 
  800421b10c:	ff d0                	callq  *%rax
    vmcs_write64( VMCS_64BIT_CONTROL_VMEXIT_MSR_LOAD_ADDR,
            PADDR(e->env_vmxinfo.msr_host_area));
  800421b10e:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b115:	48 8b 80 50 01 00 00 	mov    0x150(%rax),%rax
  800421b11c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421b120:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421b127:	00 00 00 
  800421b12a:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800421b12e:	77 32                	ja     800421b162 <vmcs_ctls_init+0x32e>
  800421b130:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421b134:	48 89 c1             	mov    %rax,%rcx
  800421b137:	48 ba 98 03 22 04 80 	movabs $0x8004220398,%rdx
  800421b13e:	00 00 00 
  800421b141:	be 6a 01 00 00       	mov    $0x16a,%esi
  800421b146:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421b14d:	00 00 00 
  800421b150:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b155:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421b15c:	00 00 00 
  800421b15f:	41 ff d0             	callq  *%r8
  800421b162:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421b169:	ff ff ff 
  800421b16c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421b170:	48 01 d0             	add    %rdx,%rax
  800421b173:	c7 45 94 08 20 00 00 	movl   $0x2008,-0x6c(%rbp)
  800421b17a:	48 89 45 88          	mov    %rax,-0x78(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b17e:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800421b182:	8b 45 94             	mov    -0x6c(%rbp),%eax
  800421b185:	48 89 d6             	mov    %rdx,%rsi
  800421b188:	89 c7                	mov    %eax,%edi
  800421b18a:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b191:	00 00 00 
  800421b194:	ff d0                	callq  *%rax
    vmcs_write32( VMCS_32BIT_CONTROL_VMEXIT_MSR_LOAD_COUNT,
            e->env_vmxinfo.msr_count);
  800421b196:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b19d:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
  800421b1a3:	c7 45 84 10 40 00 00 	movl   $0x4010,-0x7c(%rbp)
  800421b1aa:	89 45 80             	mov    %eax,-0x80(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421b1ad:	8b 55 80             	mov    -0x80(%rbp),%edx
  800421b1b0:	8b 45 84             	mov    -0x7c(%rbp),%eax
  800421b1b3:	48 89 d6             	mov    %rdx,%rsi
  800421b1b6:	89 c7                	mov    %eax,%edi
  800421b1b8:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b1bf:	00 00 00 
  800421b1c2:	ff d0                	callq  *%rax

    // Set VM entry controls.
    uint32_t entry_ctls_or, entry_ctls_and;
    vmx_read_capability_msr( IA32_VMX_ENTRY_CTLS, 
  800421b1c4:	48 8d 95 04 ff ff ff 	lea    -0xfc(%rbp),%rdx
  800421b1cb:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  800421b1d2:	48 89 c6             	mov    %rax,%rsi
  800421b1d5:	bf 84 04 00 00       	mov    $0x484,%edi
  800421b1da:	48 b8 cd ad 21 04 80 	movabs $0x800421adcd,%rax
  800421b1e1:	00 00 00 
  800421b1e4:	ff d0                	callq  *%rax
            &entry_ctls_and, &entry_ctls_or );

    vmcs_write64( VMCS_64BIT_CONTROL_VMENTRY_MSR_LOAD_ADDR,
            PADDR(e->env_vmxinfo.msr_guest_area));
  800421b1e6:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b1ed:	48 8b 80 58 01 00 00 	mov    0x158(%rax),%rax
  800421b1f4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800421b1f8:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421b1ff:	00 00 00 
  800421b202:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800421b206:	77 32                	ja     800421b23a <vmcs_ctls_init+0x406>
  800421b208:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421b20c:	48 89 c1             	mov    %rax,%rcx
  800421b20f:	48 ba 98 03 22 04 80 	movabs $0x8004220398,%rdx
  800421b216:	00 00 00 
  800421b219:	be 74 01 00 00       	mov    $0x174,%esi
  800421b21e:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421b225:	00 00 00 
  800421b228:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b22d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421b234:	00 00 00 
  800421b237:	41 ff d0             	callq  *%r8
  800421b23a:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421b241:	ff ff ff 
  800421b244:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421b248:	48 01 d0             	add    %rdx,%rax
  800421b24b:	c7 85 7c ff ff ff 0a 	movl   $0x200a,-0x84(%rbp)
  800421b252:	20 00 00 
  800421b255:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b25c:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421b263:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
  800421b269:	48 89 d6             	mov    %rdx,%rsi
  800421b26c:	89 c7                	mov    %eax,%edi
  800421b26e:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b275:	00 00 00 
  800421b278:	ff d0                	callq  *%rax
    vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_MSR_LOAD_COUNT,
            e->env_vmxinfo.msr_count);
  800421b27a:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b281:	8b 80 48 01 00 00    	mov    0x148(%rax),%eax
  800421b287:	c7 85 6c ff ff ff 14 	movl   $0x4014,-0x94(%rbp)
  800421b28e:	40 00 00 
  800421b291:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421b297:	8b 95 68 ff ff ff    	mov    -0x98(%rbp),%edx
  800421b29d:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
  800421b2a3:	48 89 d6             	mov    %rdx,%rsi
  800421b2a6:	89 c7                	mov    %eax,%edi
  800421b2a8:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b2af:	00 00 00 
  800421b2b2:	ff d0                	callq  *%rax

    vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS, 
  800421b2b4:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  800421b2ba:	8b 85 00 ff ff ff    	mov    -0x100(%rbp),%eax
  800421b2c0:	21 d0                	and    %edx,%eax
  800421b2c2:	c7 85 64 ff ff ff 12 	movl   $0x4012,-0x9c(%rbp)
  800421b2c9:	40 00 00 
  800421b2cc:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
  800421b2d2:	8b 95 60 ff ff ff    	mov    -0xa0(%rbp),%edx
  800421b2d8:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
  800421b2de:	48 89 d6             	mov    %rdx,%rsi
  800421b2e1:	89 c7                	mov    %eax,%edi
  800421b2e3:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b2ea:	00 00 00 
  800421b2ed:	ff d0                	callq  *%rax
            entry_ctls_or & entry_ctls_and );
    
    uint64_t ept_ptr = e->env_cr3 | ( ( EPT_LEVELS - 1 ) << 3 );
  800421b2ef:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b2f6:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  800421b2fd:	48 83 c8 18          	or     $0x18,%rax
  800421b301:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421b305:	c7 85 5c ff ff ff 1a 	movl   $0x201a,-0xa4(%rbp)
  800421b30c:	20 00 00 
  800421b30f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421b313:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b31a:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  800421b321:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
  800421b327:	48 89 d6             	mov    %rdx,%rsi
  800421b32a:	89 c7                	mov    %eax,%edi
  800421b32c:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b333:	00 00 00 
  800421b336:	ff d0                	callq  *%rax
    vmcs_write64( VMCS_64BIT_CONTROL_EPTPTR, ept_ptr );

    vmcs_write32( VMCS_32BIT_CONTROL_EXCEPTION_BITMAP, 
  800421b338:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b33f:	8b 80 30 01 00 00    	mov    0x130(%rax),%eax
  800421b345:	c7 85 4c ff ff ff 04 	movl   $0x4004,-0xb4(%rbp)
  800421b34c:	40 00 00 
  800421b34f:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421b355:	8b 95 48 ff ff ff    	mov    -0xb8(%rbp),%edx
  800421b35b:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
  800421b361:	48 89 d6             	mov    %rdx,%rsi
  800421b364:	89 c7                	mov    %eax,%edi
  800421b366:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b36d:	00 00 00 
  800421b370:	ff d0                	callq  *%rax
            e->env_vmxinfo.exception_bmap);
    vmcs_write64( VMCS_64BIT_CONTROL_IO_BITMAP_A,
            PADDR(e->env_vmxinfo.io_bmap_a));
  800421b372:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b379:	48 8b 80 38 01 00 00 	mov    0x138(%rax),%rax
  800421b380:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421b384:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421b38b:	00 00 00 
  800421b38e:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  800421b392:	77 32                	ja     800421b3c6 <vmcs_ctls_init+0x592>
  800421b394:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421b398:	48 89 c1             	mov    %rax,%rcx
  800421b39b:	48 ba 98 03 22 04 80 	movabs $0x8004220398,%rdx
  800421b3a2:	00 00 00 
  800421b3a5:	be 81 01 00 00       	mov    $0x181,%esi
  800421b3aa:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421b3b1:	00 00 00 
  800421b3b4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b3b9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421b3c0:	00 00 00 
  800421b3c3:	41 ff d0             	callq  *%r8
  800421b3c6:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421b3cd:	ff ff ff 
  800421b3d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421b3d4:	48 01 d0             	add    %rdx,%rax
  800421b3d7:	c7 85 44 ff ff ff 00 	movl   $0x2000,-0xbc(%rbp)
  800421b3de:	20 00 00 
  800421b3e1:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421b3e8:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
  800421b3ef:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
  800421b3f5:	48 89 d6             	mov    %rdx,%rsi
  800421b3f8:	89 c7                	mov    %eax,%edi
  800421b3fa:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b401:	00 00 00 
  800421b404:	ff d0                	callq  *%rax
    vmcs_write64( VMCS_64BIT_CONTROL_IO_BITMAP_B,
            PADDR(e->env_vmxinfo.io_bmap_b));
  800421b406:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  800421b40d:	48 8b 80 40 01 00 00 	mov    0x140(%rax),%rax
  800421b414:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800421b418:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421b41f:	00 00 00 
  800421b422:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  800421b426:	77 32                	ja     800421b45a <vmcs_ctls_init+0x626>
  800421b428:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421b42c:	48 89 c1             	mov    %rax,%rcx
  800421b42f:	48 ba 98 03 22 04 80 	movabs $0x8004220398,%rdx
  800421b436:	00 00 00 
  800421b439:	be 83 01 00 00       	mov    $0x183,%esi
  800421b43e:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421b445:	00 00 00 
  800421b448:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b44d:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421b454:	00 00 00 
  800421b457:	41 ff d0             	callq  *%r8
  800421b45a:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421b461:	ff ff ff 
  800421b464:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421b468:	48 01 d0             	add    %rdx,%rax
  800421b46b:	c7 85 34 ff ff ff 02 	movl   $0x2002,-0xcc(%rbp)
  800421b472:	20 00 00 
  800421b475:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  800421b47c:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  800421b483:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
  800421b489:	48 89 d6             	mov    %rdx,%rsi
  800421b48c:	89 c7                	mov    %eax,%edi
  800421b48e:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421b495:	00 00 00 
  800421b498:	ff d0                	callq  *%rax

}
  800421b49a:	c9                   	leaveq 
  800421b49b:	c3                   	retq   

000000800421b49c <vmcs_dump_cpu>:

void vmcs_dump_cpu() {
  800421b49c:	55                   	push   %rbp
  800421b49d:	48 89 e5             	mov    %rsp,%rbp
  800421b4a0:	53                   	push   %rbx
  800421b4a1:	48 83 ec 28          	sub    $0x28,%rsp
	uint64_t flags = vmcs_readl(VMCS_GUEST_RFLAGS);
  800421b4a5:	bf 20 68 00 00       	mov    $0x6820,%edi
  800421b4aa:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421b4b1:	00 00 00 
  800421b4b4:	ff d0                	callq  *%rax
  800421b4b6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    // TODO: print all the regs.
	cprintf( "vmx: --- Begin VCPU Dump ---\n");
  800421b4ba:	48 bf bc 03 22 04 80 	movabs $0x80042203bc,%rdi
  800421b4c1:	00 00 00 
  800421b4c4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b4c9:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421b4d0:	00 00 00 
  800421b4d3:	ff d2                	callq  *%rdx
  800421b4d5:	c7 45 e4 1c 68 00 00 	movl   $0x681c,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421b4dc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421b4df:	89 c7                	mov    %eax,%edi
  800421b4e1:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421b4e8:	00 00 00 
  800421b4eb:	ff d0                	callq  *%rax
	cprintf( "vmx: RIP 0x%016llx RSP 0x%016llx RFLAGS 0x%016llx\n",
  800421b4ed:	48 89 c3             	mov    %rax,%rbx
  800421b4f0:	c7 45 e0 1e 68 00 00 	movl   $0x681e,-0x20(%rbp)
  800421b4f7:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421b4fa:	89 c7                	mov    %eax,%edi
  800421b4fc:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421b503:	00 00 00 
  800421b506:	ff d0                	callq  *%rax
  800421b508:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421b50c:	48 89 d1             	mov    %rdx,%rcx
  800421b50f:	48 89 da             	mov    %rbx,%rdx
  800421b512:	48 89 c6             	mov    %rax,%rsi
  800421b515:	48 bf e0 03 22 04 80 	movabs $0x80042203e0,%rdi
  800421b51c:	00 00 00 
  800421b51f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b524:	49 b8 1a 96 20 04 80 	movabs $0x800420961a,%r8
  800421b52b:	00 00 00 
  800421b52e:	41 ff d0             	callq  *%r8
  800421b531:	c7 45 dc 02 68 00 00 	movl   $0x6802,-0x24(%rbp)
  800421b538:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421b53b:	89 c7                	mov    %eax,%edi
  800421b53d:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421b544:	00 00 00 
  800421b547:	ff d0                	callq  *%rax
	       vmcs_read64( VMCS_GUEST_RIP ) , vmcs_read64( VMCS_GUEST_RSP ), flags);
	cprintf( "vmx: CR0 0x%016llx CR3 0x%016llx\n",
  800421b549:	48 89 c3             	mov    %rax,%rbx
  800421b54c:	c7 45 d8 00 68 00 00 	movl   $0x6800,-0x28(%rbp)
  800421b553:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421b556:	89 c7                	mov    %eax,%edi
  800421b558:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421b55f:	00 00 00 
  800421b562:	ff d0                	callq  *%rax
  800421b564:	48 89 da             	mov    %rbx,%rdx
  800421b567:	48 89 c6             	mov    %rax,%rsi
  800421b56a:	48 bf 18 04 22 04 80 	movabs $0x8004220418,%rdi
  800421b571:	00 00 00 
  800421b574:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b579:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800421b580:	00 00 00 
  800421b583:	ff d1                	callq  *%rcx
  800421b585:	c7 45 d4 04 68 00 00 	movl   $0x6804,-0x2c(%rbp)
  800421b58c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421b58f:	89 c7                	mov    %eax,%edi
  800421b591:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421b598:	00 00 00 
  800421b59b:	ff d0                	callq  *%rax
            vmcs_read64( VMCS_GUEST_CR0 ), vmcs_read64( VMCS_GUEST_CR3 ) );
    cprintf( "vmx: CR4 0x%016llx \n",
  800421b59d:	48 89 c6             	mov    %rax,%rsi
  800421b5a0:	48 bf 3a 04 22 04 80 	movabs $0x800422043a,%rdi
  800421b5a7:	00 00 00 
  800421b5aa:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b5af:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421b5b6:	00 00 00 
  800421b5b9:	ff d2                	callq  *%rdx
            vmcs_read64( VMCS_GUEST_CR4 ) );

    cprintf( "vmx: --- End VCPU Dump ---\n");
  800421b5bb:	48 bf 4f 04 22 04 80 	movabs $0x800422044f,%rdi
  800421b5c2:	00 00 00 
  800421b5c5:	b8 00 00 00 00       	mov    $0x0,%eax
  800421b5ca:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421b5d1:	00 00 00 
  800421b5d4:	ff d2                	callq  *%rdx

}
  800421b5d6:	48 83 c4 28          	add    $0x28,%rsp
  800421b5da:	5b                   	pop    %rbx
  800421b5db:	5d                   	pop    %rbp
  800421b5dc:	c3                   	retq   

000000800421b5dd <vmexit>:

void vmexit() {
  800421b5dd:	55                   	push   %rbp
  800421b5de:	48 89 e5             	mov    %rsp,%rbp
  800421b5e1:	41 54                	push   %r12
  800421b5e3:	53                   	push   %rbx
  800421b5e4:	48 83 ec 10          	sub    $0x10,%rsp
    int exit_reason = -1;
  800421b5e8:	c7 45 e8 ff ff ff ff 	movl   $0xffffffff,-0x18(%rbp)
    bool exit_handled = false;
  800421b5ef:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
  800421b5f3:	c7 45 e4 02 44 00 00 	movl   $0x4402,-0x1c(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421b5fa:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421b5fd:	89 c7                	mov    %eax,%edi
  800421b5ff:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421b606:	00 00 00 
  800421b609:	ff d0                	callq  *%rax
    static uint32_t host_vector;
    // Get the reason for VMEXIT from the VMCS.
    // Your code here.
	exit_reason = vmcs_read32(VMCS_32BIT_VMEXIT_REASON);
  800421b60b:	89 45 e8             	mov    %eax,-0x18(%rbp)
    // cprintf( "---VMEXIT Reason: %d---\n", exit_reason ); 
    /* vmcs_dump_cpu(); */
    switch(exit_reason & EXIT_REASON_MASK) {
  800421b60e:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421b611:	0f b7 c0             	movzwl %ax,%eax
  800421b614:	83 f8 30             	cmp    $0x30,%eax
  800421b617:	0f 87 03 05 00 00    	ja     800421bb20 <vmexit+0x543>
  800421b61d:	89 c0                	mov    %eax,%eax
  800421b61f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421b626:	00 
  800421b627:	48 b8 b8 04 22 04 80 	movabs $0x80042204b8,%rax
  800421b62e:	00 00 00 
  800421b631:	48 01 d0             	add    %rdx,%rax
  800421b634:	48 8b 00             	mov    (%rax),%rax
  800421b637:	ff e0                	jmpq   *%rax
  800421b639:	c7 45 e0 04 44 00 00 	movl   $0x4404,-0x20(%rbp)
  800421b640:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421b643:	89 c7                	mov    %eax,%edi
  800421b645:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421b64c:	00 00 00 
  800421b64f:	ff d0                	callq  *%rax
    	case EXIT_REASON_EXTERNAL_INT:
    		host_vector = vmcs_read32(VMCS_32BIT_VMEXIT_INTERRUPTION_INFO);
  800421b651:	89 c2                	mov    %eax,%edx
  800421b653:	48 b8 64 e7 3a 04 80 	movabs $0x80043ae764,%rax
  800421b65a:	00 00 00 
  800421b65d:	89 10                	mov    %edx,(%rax)
    		exit_handled = handle_interrupts(&curenv->env_tf, &curenv->env_vmxinfo, host_vector);
  800421b65f:	48 b8 64 e7 3a 04 80 	movabs $0x80043ae764,%rax
  800421b666:	00 00 00 
  800421b669:	8b 18                	mov    (%rax),%ebx
  800421b66b:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b672:	00 00 00 
  800421b675:	ff d0                	callq  *%rax
  800421b677:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b67e:	00 00 00 
  800421b681:	48 98                	cltq   
  800421b683:	48 c1 e0 03          	shl    $0x3,%rax
  800421b687:	48 89 c1             	mov    %rax,%rcx
  800421b68a:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b68e:	48 01 c8             	add    %rcx,%rax
  800421b691:	48 01 d0             	add    %rdx,%rax
  800421b694:	48 83 c0 08          	add    $0x8,%rax
  800421b698:	48 8b 00             	mov    (%rax),%rax
  800421b69b:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421b6a2:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b6a9:	00 00 00 
  800421b6ac:	ff d0                	callq  *%rax
  800421b6ae:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b6b5:	00 00 00 
  800421b6b8:	48 98                	cltq   
  800421b6ba:	48 c1 e0 03          	shl    $0x3,%rax
  800421b6be:	48 89 c1             	mov    %rax,%rcx
  800421b6c1:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b6c5:	48 01 c8             	add    %rcx,%rax
  800421b6c8:	48 01 d0             	add    %rdx,%rax
  800421b6cb:	48 83 c0 08          	add    $0x8,%rax
  800421b6cf:	48 8b 00             	mov    (%rax),%rax
  800421b6d2:	89 da                	mov    %ebx,%edx
  800421b6d4:	4c 89 e6             	mov    %r12,%rsi
  800421b6d7:	48 89 c7             	mov    %rax,%rdi
  800421b6da:	48 b8 85 c5 21 04 80 	movabs $0x800421c585,%rax
  800421b6e1:	00 00 00 
  800421b6e4:	ff d0                	callq  *%rax
  800421b6e6:	88 45 ef             	mov    %al,-0x11(%rbp)
    		break;
  800421b6e9:	e9 32 04 00 00       	jmpq   800421bb20 <vmexit+0x543>
    	case EXIT_REASON_INTERRUPT_WINDOW:
    		exit_handled = handle_interrupt_window(&curenv->env_tf, &curenv->env_vmxinfo, host_vector);
  800421b6ee:	48 b8 64 e7 3a 04 80 	movabs $0x80043ae764,%rax
  800421b6f5:	00 00 00 
  800421b6f8:	8b 18                	mov    (%rax),%ebx
  800421b6fa:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b701:	00 00 00 
  800421b704:	ff d0                	callq  *%rax
  800421b706:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b70d:	00 00 00 
  800421b710:	48 98                	cltq   
  800421b712:	48 c1 e0 03          	shl    $0x3,%rax
  800421b716:	48 89 c1             	mov    %rax,%rcx
  800421b719:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b71d:	48 01 c8             	add    %rcx,%rax
  800421b720:	48 01 d0             	add    %rdx,%rax
  800421b723:	48 83 c0 08          	add    $0x8,%rax
  800421b727:	48 8b 00             	mov    (%rax),%rax
  800421b72a:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421b731:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b738:	00 00 00 
  800421b73b:	ff d0                	callq  *%rax
  800421b73d:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b744:	00 00 00 
  800421b747:	48 98                	cltq   
  800421b749:	48 c1 e0 03          	shl    $0x3,%rax
  800421b74d:	48 89 c1             	mov    %rax,%rcx
  800421b750:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b754:	48 01 c8             	add    %rcx,%rax
  800421b757:	48 01 d0             	add    %rdx,%rax
  800421b75a:	48 83 c0 08          	add    $0x8,%rax
  800421b75e:	48 8b 00             	mov    (%rax),%rax
  800421b761:	89 da                	mov    %ebx,%edx
  800421b763:	4c 89 e6             	mov    %r12,%rsi
  800421b766:	48 89 c7             	mov    %rax,%rdi
  800421b769:	48 b8 04 c5 21 04 80 	movabs $0x800421c504,%rax
  800421b770:	00 00 00 
  800421b773:	ff d0                	callq  *%rax
  800421b775:	88 45 ef             	mov    %al,-0x11(%rbp)
    		break;
  800421b778:	e9 a3 03 00 00       	jmpq   800421bb20 <vmexit+0x543>
        case EXIT_REASON_RDMSR:
            exit_handled = handle_rdmsr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421b77d:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b784:	00 00 00 
  800421b787:	ff d0                	callq  *%rax
  800421b789:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b790:	00 00 00 
  800421b793:	48 98                	cltq   
  800421b795:	48 c1 e0 03          	shl    $0x3,%rax
  800421b799:	48 89 c1             	mov    %rax,%rcx
  800421b79c:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b7a0:	48 01 c8             	add    %rcx,%rax
  800421b7a3:	48 01 d0             	add    %rdx,%rax
  800421b7a6:	48 83 c0 08          	add    $0x8,%rax
  800421b7aa:	48 8b 00             	mov    (%rax),%rax
  800421b7ad:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421b7b4:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b7bb:	00 00 00 
  800421b7be:	ff d0                	callq  *%rax
  800421b7c0:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b7c7:	00 00 00 
  800421b7ca:	48 98                	cltq   
  800421b7cc:	48 c1 e0 03          	shl    $0x3,%rax
  800421b7d0:	48 89 c1             	mov    %rax,%rcx
  800421b7d3:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b7d7:	48 01 c8             	add    %rcx,%rax
  800421b7da:	48 01 d0             	add    %rdx,%rax
  800421b7dd:	48 83 c0 08          	add    $0x8,%rax
  800421b7e1:	48 8b 00             	mov    (%rax),%rax
  800421b7e4:	48 89 de             	mov    %rbx,%rsi
  800421b7e7:	48 89 c7             	mov    %rax,%rdi
  800421b7ea:	48 b8 32 c6 21 04 80 	movabs $0x800421c632,%rax
  800421b7f1:	00 00 00 
  800421b7f4:	ff d0                	callq  *%rax
  800421b7f6:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421b7f9:	e9 22 03 00 00       	jmpq   800421bb20 <vmexit+0x543>
        case EXIT_REASON_WRMSR:
            exit_handled = handle_wrmsr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421b7fe:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b805:	00 00 00 
  800421b808:	ff d0                	callq  *%rax
  800421b80a:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b811:	00 00 00 
  800421b814:	48 98                	cltq   
  800421b816:	48 c1 e0 03          	shl    $0x3,%rax
  800421b81a:	48 89 c1             	mov    %rax,%rcx
  800421b81d:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b821:	48 01 c8             	add    %rcx,%rax
  800421b824:	48 01 d0             	add    %rdx,%rax
  800421b827:	48 83 c0 08          	add    $0x8,%rax
  800421b82b:	48 8b 00             	mov    (%rax),%rax
  800421b82e:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421b835:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b83c:	00 00 00 
  800421b83f:	ff d0                	callq  *%rax
  800421b841:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b848:	00 00 00 
  800421b84b:	48 98                	cltq   
  800421b84d:	48 c1 e0 03          	shl    $0x3,%rax
  800421b851:	48 89 c1             	mov    %rax,%rcx
  800421b854:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b858:	48 01 c8             	add    %rcx,%rax
  800421b85b:	48 01 d0             	add    %rdx,%rax
  800421b85e:	48 83 c0 08          	add    $0x8,%rax
  800421b862:	48 8b 00             	mov    (%rax),%rax
  800421b865:	48 89 de             	mov    %rbx,%rsi
  800421b868:	48 89 c7             	mov    %rax,%rdi
  800421b86b:	48 b8 3a c7 21 04 80 	movabs $0x800421c73a,%rax
  800421b872:	00 00 00 
  800421b875:	ff d0                	callq  *%rax
  800421b877:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421b87a:	e9 a1 02 00 00       	jmpq   800421bb20 <vmexit+0x543>
        case EXIT_REASON_EPT_VIOLATION:
            exit_handled = handle_eptviolation(curenv->env_pml4e, &curenv->env_vmxinfo);
  800421b87f:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b886:	00 00 00 
  800421b889:	ff d0                	callq  *%rax
  800421b88b:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b892:	00 00 00 
  800421b895:	48 98                	cltq   
  800421b897:	48 c1 e0 03          	shl    $0x3,%rax
  800421b89b:	48 89 c1             	mov    %rax,%rcx
  800421b89e:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b8a2:	48 01 c8             	add    %rcx,%rax
  800421b8a5:	48 01 d0             	add    %rdx,%rax
  800421b8a8:	48 83 c0 08          	add    $0x8,%rax
  800421b8ac:	48 8b 00             	mov    (%rax),%rax
  800421b8af:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421b8b6:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b8bd:	00 00 00 
  800421b8c0:	ff d0                	callq  *%rax
  800421b8c2:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b8c9:	00 00 00 
  800421b8cc:	48 98                	cltq   
  800421b8ce:	48 c1 e0 03          	shl    $0x3,%rax
  800421b8d2:	48 89 c1             	mov    %rax,%rcx
  800421b8d5:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b8d9:	48 01 c8             	add    %rcx,%rax
  800421b8dc:	48 01 d0             	add    %rdx,%rax
  800421b8df:	48 83 c0 08          	add    $0x8,%rax
  800421b8e3:	48 8b 00             	mov    (%rax),%rax
  800421b8e6:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800421b8ed:	48 89 de             	mov    %rbx,%rsi
  800421b8f0:	48 89 c7             	mov    %rax,%rdi
  800421b8f3:	48 b8 ad c8 21 04 80 	movabs $0x800421c8ad,%rax
  800421b8fa:	00 00 00 
  800421b8fd:	ff d0                	callq  *%rax
  800421b8ff:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421b902:	e9 19 02 00 00       	jmpq   800421bb20 <vmexit+0x543>
        case EXIT_REASON_IO_INSTRUCTION:
            exit_handled = handle_ioinstr(&curenv->env_tf, &curenv->env_vmxinfo);
  800421b907:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b90e:	00 00 00 
  800421b911:	ff d0                	callq  *%rax
  800421b913:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b91a:	00 00 00 
  800421b91d:	48 98                	cltq   
  800421b91f:	48 c1 e0 03          	shl    $0x3,%rax
  800421b923:	48 89 c1             	mov    %rax,%rcx
  800421b926:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b92a:	48 01 c8             	add    %rcx,%rax
  800421b92d:	48 01 d0             	add    %rdx,%rax
  800421b930:	48 83 c0 08          	add    $0x8,%rax
  800421b934:	48 8b 00             	mov    (%rax),%rax
  800421b937:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421b93e:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b945:	00 00 00 
  800421b948:	ff d0                	callq  *%rax
  800421b94a:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b951:	00 00 00 
  800421b954:	48 98                	cltq   
  800421b956:	48 c1 e0 03          	shl    $0x3,%rax
  800421b95a:	48 89 c1             	mov    %rax,%rcx
  800421b95d:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b961:	48 01 c8             	add    %rcx,%rax
  800421b964:	48 01 d0             	add    %rdx,%rax
  800421b967:	48 83 c0 08          	add    $0x8,%rax
  800421b96b:	48 8b 00             	mov    (%rax),%rax
  800421b96e:	48 89 de             	mov    %rbx,%rsi
  800421b971:	48 89 c7             	mov    %rax,%rdi
  800421b974:	48 b8 62 ca 21 04 80 	movabs $0x800421ca62,%rax
  800421b97b:	00 00 00 
  800421b97e:	ff d0                	callq  *%rax
  800421b980:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421b983:	e9 98 01 00 00       	jmpq   800421bb20 <vmexit+0x543>
        case EXIT_REASON_CPUID:
            exit_handled = handle_cpuid(&curenv->env_tf, &curenv->env_vmxinfo);
  800421b988:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b98f:	00 00 00 
  800421b992:	ff d0                	callq  *%rax
  800421b994:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b99b:	00 00 00 
  800421b99e:	48 98                	cltq   
  800421b9a0:	48 c1 e0 03          	shl    $0x3,%rax
  800421b9a4:	48 89 c1             	mov    %rax,%rcx
  800421b9a7:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b9ab:	48 01 c8             	add    %rcx,%rax
  800421b9ae:	48 01 d0             	add    %rdx,%rax
  800421b9b1:	48 83 c0 08          	add    $0x8,%rax
  800421b9b5:	48 8b 00             	mov    (%rax),%rax
  800421b9b8:	48 8d 98 20 01 00 00 	lea    0x120(%rax),%rbx
  800421b9bf:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421b9c6:	00 00 00 
  800421b9c9:	ff d0                	callq  *%rax
  800421b9cb:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421b9d2:	00 00 00 
  800421b9d5:	48 98                	cltq   
  800421b9d7:	48 c1 e0 03          	shl    $0x3,%rax
  800421b9db:	48 89 c1             	mov    %rax,%rcx
  800421b9de:	48 c1 e1 04          	shl    $0x4,%rcx
  800421b9e2:	48 01 c8             	add    %rcx,%rax
  800421b9e5:	48 01 d0             	add    %rdx,%rax
  800421b9e8:	48 83 c0 08          	add    $0x8,%rax
  800421b9ec:	48 8b 00             	mov    (%rax),%rax
  800421b9ef:	48 89 de             	mov    %rbx,%rsi
  800421b9f2:	48 89 c7             	mov    %rax,%rdi
  800421b9f5:	48 b8 25 cc 21 04 80 	movabs $0x800421cc25,%rax
  800421b9fc:	00 00 00 
  800421b9ff:	ff d0                	callq  *%rax
  800421ba01:	88 45 ef             	mov    %al,-0x11(%rbp)
            break;
  800421ba04:	e9 17 01 00 00       	jmpq   800421bb20 <vmexit+0x543>
        case EXIT_REASON_VMCALL:
            exit_handled = handle_vmcall(&curenv->env_tf, &curenv->env_vmxinfo,
                    curenv->env_pml4e);
  800421ba09:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421ba10:	00 00 00 
  800421ba13:	ff d0                	callq  *%rax
  800421ba15:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421ba1c:	00 00 00 
  800421ba1f:	48 98                	cltq   
  800421ba21:	48 c1 e0 03          	shl    $0x3,%rax
  800421ba25:	48 89 c1             	mov    %rax,%rcx
  800421ba28:	48 c1 e1 04          	shl    $0x4,%rcx
  800421ba2c:	48 01 c8             	add    %rcx,%rax
  800421ba2f:	48 01 d0             	add    %rdx,%rax
  800421ba32:	48 83 c0 08          	add    $0x8,%rax
  800421ba36:	48 8b 00             	mov    (%rax),%rax
  800421ba39:	48 8b 98 e0 00 00 00 	mov    0xe0(%rax),%rbx
            break;
        case EXIT_REASON_CPUID:
            exit_handled = handle_cpuid(&curenv->env_tf, &curenv->env_vmxinfo);
            break;
        case EXIT_REASON_VMCALL:
            exit_handled = handle_vmcall(&curenv->env_tf, &curenv->env_vmxinfo,
  800421ba40:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421ba47:	00 00 00 
  800421ba4a:	ff d0                	callq  *%rax
  800421ba4c:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421ba53:	00 00 00 
  800421ba56:	48 98                	cltq   
  800421ba58:	48 c1 e0 03          	shl    $0x3,%rax
  800421ba5c:	48 89 c1             	mov    %rax,%rcx
  800421ba5f:	48 c1 e1 04          	shl    $0x4,%rcx
  800421ba63:	48 01 c8             	add    %rcx,%rax
  800421ba66:	48 01 d0             	add    %rdx,%rax
  800421ba69:	48 83 c0 08          	add    $0x8,%rax
  800421ba6d:	48 8b 00             	mov    (%rax),%rax
  800421ba70:	4c 8d a0 20 01 00 00 	lea    0x120(%rax),%r12
  800421ba77:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421ba7e:	00 00 00 
  800421ba81:	ff d0                	callq  *%rax
  800421ba83:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421ba8a:	00 00 00 
  800421ba8d:	48 98                	cltq   
  800421ba8f:	48 c1 e0 03          	shl    $0x3,%rax
  800421ba93:	48 89 c1             	mov    %rax,%rcx
  800421ba96:	48 c1 e1 04          	shl    $0x4,%rcx
  800421ba9a:	48 01 c8             	add    %rcx,%rax
  800421ba9d:	48 01 d0             	add    %rdx,%rax
  800421baa0:	48 83 c0 08          	add    $0x8,%rax
  800421baa4:	48 8b 00             	mov    (%rax),%rax
  800421baa7:	48 89 da             	mov    %rbx,%rdx
  800421baaa:	4c 89 e6             	mov    %r12,%rsi
  800421baad:	48 89 c7             	mov    %rax,%rdi
  800421bab0:	48 b8 e8 cc 21 04 80 	movabs $0x800421cce8,%rax
  800421bab7:	00 00 00 
  800421baba:	ff d0                	callq  *%rax
  800421babc:	88 45 ef             	mov    %al,-0x11(%rbp)
                    curenv->env_pml4e);
            break;
  800421babf:	eb 5f                	jmp    800421bb20 <vmexit+0x543>
        case EXIT_REASON_HLT:
            cprintf("\nHLT in guest, exiting guest.\n");
  800421bac1:	48 bf 70 04 22 04 80 	movabs $0x8004220470,%rdi
  800421bac8:	00 00 00 
  800421bacb:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bad0:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421bad7:	00 00 00 
  800421bada:	ff d2                	callq  *%rdx
            env_destroy(curenv);
  800421badc:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421bae3:	00 00 00 
  800421bae6:	ff d0                	callq  *%rax
  800421bae8:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421baef:	00 00 00 
  800421baf2:	48 98                	cltq   
  800421baf4:	48 c1 e0 03          	shl    $0x3,%rax
  800421baf8:	48 89 c1             	mov    %rax,%rcx
  800421bafb:	48 c1 e1 04          	shl    $0x4,%rcx
  800421baff:	48 01 c8             	add    %rcx,%rax
  800421bb02:	48 01 d0             	add    %rdx,%rax
  800421bb05:	48 83 c0 08          	add    $0x8,%rax
  800421bb09:	48 8b 00             	mov    (%rax),%rax
  800421bb0c:	48 89 c7             	mov    %rax,%rdi
  800421bb0f:	48 b8 ac 8d 20 04 80 	movabs $0x8004208dac,%rax
  800421bb16:	00 00 00 
  800421bb19:	ff d0                	callq  *%rax
            exit_handled = true;
  800421bb1b:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
            break;
  800421bb1f:	90                   	nop
    }

    if(!exit_handled) {
  800421bb20:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800421bb24:	83 f0 01             	xor    $0x1,%eax
  800421bb27:	84 c0                	test   %al,%al
  800421bb29:	74 6b                	je     800421bb96 <vmexit+0x5b9>
        cprintf( "Unhandled VMEXIT, aborting guest.\n" );
  800421bb2b:	48 bf 90 04 22 04 80 	movabs $0x8004220490,%rdi
  800421bb32:	00 00 00 
  800421bb35:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bb3a:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421bb41:	00 00 00 
  800421bb44:	ff d2                	callq  *%rdx
        vmcs_dump_cpu();
  800421bb46:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bb4b:	48 ba 9c b4 21 04 80 	movabs $0x800421b49c,%rdx
  800421bb52:	00 00 00 
  800421bb55:	ff d2                	callq  *%rdx
        env_destroy(curenv);
  800421bb57:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421bb5e:	00 00 00 
  800421bb61:	ff d0                	callq  *%rax
  800421bb63:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421bb6a:	00 00 00 
  800421bb6d:	48 98                	cltq   
  800421bb6f:	48 c1 e0 03          	shl    $0x3,%rax
  800421bb73:	48 89 c1             	mov    %rax,%rcx
  800421bb76:	48 c1 e1 04          	shl    $0x4,%rcx
  800421bb7a:	48 01 c8             	add    %rcx,%rax
  800421bb7d:	48 01 d0             	add    %rdx,%rax
  800421bb80:	48 83 c0 08          	add    $0x8,%rax
  800421bb84:	48 8b 00             	mov    (%rax),%rax
  800421bb87:	48 89 c7             	mov    %rax,%rdi
  800421bb8a:	48 b8 ac 8d 20 04 80 	movabs $0x8004208dac,%rax
  800421bb91:	00 00 00 
  800421bb94:	ff d0                	callq  *%rax
    }
    
    
    sched_yield();
  800421bb96:	48 b8 98 d7 20 04 80 	movabs $0x800420d798,%rax
  800421bb9d:	00 00 00 
  800421bba0:	ff d0                	callq  *%rax

000000800421bba2 <asm_vmrun>:
}

void asm_vmrun(struct Trapframe *tf) {
  800421bba2:	55                   	push   %rbp
  800421bba3:	48 89 e5             	mov    %rsp,%rbp
  800421bba6:	41 57                	push   %r15
  800421bba8:	41 56                	push   %r14
  800421bbaa:	41 55                	push   %r13
  800421bbac:	41 54                	push   %r12
  800421bbae:	53                   	push   %rbx
  800421bbaf:	48 83 ec 28          	sub    $0x28,%rsp
  800421bbb3:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

//     cprintf("VMRUN\n"); 
    // NOTE: Since we re-use Trapframe structure, tf.tf_err contains the value
    // of cr2 of the guest.
    tf->tf_ds = curenv->env_runs;
  800421bbb7:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421bbbe:	00 00 00 
  800421bbc1:	ff d0                	callq  *%rax
  800421bbc3:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421bbca:	00 00 00 
  800421bbcd:	48 98                	cltq   
  800421bbcf:	48 c1 e0 03          	shl    $0x3,%rax
  800421bbd3:	48 89 c1             	mov    %rax,%rcx
  800421bbd6:	48 c1 e1 04          	shl    $0x4,%rcx
  800421bbda:	48 01 c8             	add    %rcx,%rax
  800421bbdd:	48 01 d0             	add    %rdx,%rax
  800421bbe0:	48 83 c0 08          	add    $0x8,%rax
  800421bbe4:	48 8b 00             	mov    (%rax),%rax
  800421bbe7:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800421bbed:	89 c2                	mov    %eax,%edx
  800421bbef:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421bbf3:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
    tf->tf_es = 0;
  800421bbfa:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421bbfe:	66 c7 40 78 00 00    	movw   $0x0,0x78(%rax)
    unlock_kernel();
  800421bc04:	48 b8 15 99 21 04 80 	movabs $0x8004219915,%rax
  800421bc0b:	00 00 00 
  800421bc0e:	ff d0                	callq  *%rax
    asm(
  800421bc10:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  800421bc14:	ba 14 6c 00 00       	mov    $0x6c14,%edx
  800421bc19:	52                   	push   %rdx
  800421bc1a:	55                   	push   %rbp
  800421bc1b:	51                   	push   %rcx
  800421bc1c:	51                   	push   %rcx
  800421bc1d:	48 89 e0             	mov    %rsp,%rax
  800421bc20:	0f 79 d0             	vmwrite %rax,%rdx
  800421bc23:	48 8b 81 90 00 00 00 	mov    0x90(%rcx),%rax
  800421bc2a:	0f 20 d2             	mov    %cr2,%rdx
  800421bc2d:	48 39 c2             	cmp    %rax,%rdx
  800421bc30:	74 03                	je     800421bc35 <asm_vmrun+0x93>
  800421bc32:	0f 22 d0             	mov    %rax,%cr2
  800421bc35:	83 b9 80 00 00 00 01 	cmpl   $0x1,0x80(%rcx)
  800421bc3c:	48 8b 41 70          	mov    0x70(%rcx),%rax
  800421bc40:	48 8b 59 68          	mov    0x68(%rcx),%rbx
  800421bc44:	48 8b 51 58          	mov    0x58(%rcx),%rdx
  800421bc48:	48 8b 69 50          	mov    0x50(%rcx),%rbp
  800421bc4c:	48 8b 79 48          	mov    0x48(%rcx),%rdi
  800421bc50:	48 8b 71 40          	mov    0x40(%rcx),%rsi
  800421bc54:	4c 8b 41 38          	mov    0x38(%rcx),%r8
  800421bc58:	4c 8b 49 30          	mov    0x30(%rcx),%r9
  800421bc5c:	4c 8b 51 28          	mov    0x28(%rcx),%r10
  800421bc60:	4c 8b 59 20          	mov    0x20(%rcx),%r11
  800421bc64:	4c 8b 61 18          	mov    0x18(%rcx),%r12
  800421bc68:	4c 8b 69 10          	mov    0x10(%rcx),%r13
  800421bc6c:	4c 8b 71 08          	mov    0x8(%rcx),%r14
  800421bc70:	4c 8b 39             	mov    (%rcx),%r15
  800421bc73:	48 8b 49 60          	mov    0x60(%rcx),%rcx
  800421bc77:	75 05                	jne    800421bc7e <asm_vmrun+0xdc>
  800421bc79:	0f 01 c2             	vmlaunch 
  800421bc7c:	eb 03                	jmp    800421bc81 <asm_vmrun+0xdf>
  800421bc7e:	0f 01 c3             	vmresume 
  800421bc81:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  800421bc86:	59                   	pop    %rcx
  800421bc87:	48 89 41 70          	mov    %rax,0x70(%rcx)
  800421bc8b:	48 89 59 68          	mov    %rbx,0x68(%rcx)
  800421bc8f:	8f 41 60             	popq   0x60(%rcx)
  800421bc92:	48 89 51 58          	mov    %rdx,0x58(%rcx)
  800421bc96:	48 89 69 50          	mov    %rbp,0x50(%rcx)
  800421bc9a:	48 89 79 48          	mov    %rdi,0x48(%rcx)
  800421bc9e:	48 89 71 40          	mov    %rsi,0x40(%rcx)
  800421bca2:	4c 89 41 38          	mov    %r8,0x38(%rcx)
  800421bca6:	4c 89 49 30          	mov    %r9,0x30(%rcx)
  800421bcaa:	4c 89 51 28          	mov    %r10,0x28(%rcx)
  800421bcae:	4c 89 59 20          	mov    %r11,0x20(%rcx)
  800421bcb2:	4c 89 61 18          	mov    %r12,0x18(%rcx)
  800421bcb6:	4c 89 69 10          	mov    %r13,0x10(%rcx)
  800421bcba:	4c 89 71 08          	mov    %r14,0x8(%rcx)
  800421bcbe:	4c 89 39             	mov    %r15,(%rcx)
  800421bcc1:	0f 20 d0             	mov    %cr2,%rax
  800421bcc4:	48 89 81 90 00 00 00 	mov    %rax,0x90(%rcx)
  800421bccb:	5d                   	pop    %rbp
  800421bccc:	5a                   	pop    %rdx
  800421bccd:	0f 96 41 78          	setbe  0x78(%rcx)
            [wordsize]"i"(sizeof(uint64_t))
                : "cc", "memory"
                    , "rax", "rbx", "rdi", "rsi"
                        , "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
    );
    lock_kernel();
  800421bcd1:	48 b8 f9 98 21 04 80 	movabs $0x80042198f9,%rax
  800421bcd8:	00 00 00 
  800421bcdb:	ff d0                	callq  *%rax
    if(tf->tf_es) {
  800421bcdd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421bce1:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800421bce5:	66 85 c0             	test   %ax,%ax
  800421bce8:	74 2d                	je     800421bd17 <asm_vmrun+0x175>
        cprintf("Error during VMLAUNCH/VMRESUME [%d ]\n ",tf->tf_es);
  800421bcea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421bcee:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800421bcf2:	0f b7 c0             	movzwl %ax,%eax
  800421bcf5:	89 c6                	mov    %eax,%esi
  800421bcf7:	48 bf 40 06 22 04 80 	movabs $0x8004220640,%rdi
  800421bcfe:	00 00 00 
  800421bd01:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bd06:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421bd0d:	00 00 00 
  800421bd10:	ff d2                	callq  *%rdx
  800421bd12:	e9 af 00 00 00       	jmpq   800421bdc6 <asm_vmrun+0x224>
    } else {
        curenv->env_tf.tf_rsp = vmcs_read64(VMCS_GUEST_RSP);
  800421bd17:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421bd1e:	00 00 00 
  800421bd21:	ff d0                	callq  *%rax
  800421bd23:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421bd2a:	00 00 00 
  800421bd2d:	48 98                	cltq   
  800421bd2f:	48 c1 e0 03          	shl    $0x3,%rax
  800421bd33:	48 89 c1             	mov    %rax,%rcx
  800421bd36:	48 c1 e1 04          	shl    $0x4,%rcx
  800421bd3a:	48 01 c8             	add    %rcx,%rax
  800421bd3d:	48 01 d0             	add    %rdx,%rax
  800421bd40:	48 83 c0 08          	add    $0x8,%rax
  800421bd44:	48 8b 18             	mov    (%rax),%rbx
  800421bd47:	c7 45 cc 1c 68 00 00 	movl   $0x681c,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421bd4e:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421bd51:	89 c7                	mov    %eax,%edi
  800421bd53:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421bd5a:	00 00 00 
  800421bd5d:	ff d0                	callq  *%rax
  800421bd5f:	48 89 83 b0 00 00 00 	mov    %rax,0xb0(%rbx)
        curenv->env_tf.tf_rip = vmcs_read64(VMCS_GUEST_RIP);
  800421bd66:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421bd6d:	00 00 00 
  800421bd70:	ff d0                	callq  *%rax
  800421bd72:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421bd79:	00 00 00 
  800421bd7c:	48 98                	cltq   
  800421bd7e:	48 c1 e0 03          	shl    $0x3,%rax
  800421bd82:	48 89 c1             	mov    %rax,%rcx
  800421bd85:	48 c1 e1 04          	shl    $0x4,%rcx
  800421bd89:	48 01 c8             	add    %rcx,%rax
  800421bd8c:	48 01 d0             	add    %rdx,%rax
  800421bd8f:	48 83 c0 08          	add    $0x8,%rax
  800421bd93:	48 8b 18             	mov    (%rax),%rbx
  800421bd96:	c7 45 c8 1e 68 00 00 	movl   $0x681e,-0x38(%rbp)
  800421bd9d:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421bda0:	89 c7                	mov    %eax,%edi
  800421bda2:	48 b8 90 97 21 04 80 	movabs $0x8004219790,%rax
  800421bda9:	00 00 00 
  800421bdac:	ff d0                	callq  *%rax
  800421bdae:	48 89 83 98 00 00 00 	mov    %rax,0x98(%rbx)
        vmexit();
  800421bdb5:	b8 00 00 00 00       	mov    $0x0,%eax
  800421bdba:	48 ba dd b5 21 04 80 	movabs $0x800421b5dd,%rdx
  800421bdc1:	00 00 00 
  800421bdc4:	ff d2                	callq  *%rdx
    }
}
  800421bdc6:	48 83 c4 28          	add    $0x28,%rsp
  800421bdca:	5b                   	pop    %rbx
  800421bdcb:	41 5c                	pop    %r12
  800421bdcd:	41 5d                	pop    %r13
  800421bdcf:	41 5e                	pop    %r14
  800421bdd1:	41 5f                	pop    %r15
  800421bdd3:	5d                   	pop    %rbp
  800421bdd4:	c3                   	retq   

000000800421bdd5 <msr_setup>:



void
msr_setup(struct VmxGuestInfo *ginfo) {
  800421bdd5:	55                   	push   %rbp
  800421bdd6:	48 89 e5             	mov    %rsp,%rbp
  800421bdd9:	48 83 ec 40          	sub    $0x40,%rsp
  800421bddd:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    struct vmx_msr_entry *entry;
    uint32_t idx[] = { EFER_MSR };
  800421bde1:	c7 45 d0 80 00 00 c0 	movl   $0xc0000080,-0x30(%rbp)
    int i, count = sizeof(idx) / sizeof(idx[0]);
  800421bde8:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%rbp)

    assert(count <= MAX_MSR_COUNT);
  800421bdef:	81 7d f8 80 00 00 00 	cmpl   $0x80,-0x8(%rbp)
  800421bdf6:	7e 35                	jle    800421be2d <msr_setup+0x58>
  800421bdf8:	48 b9 67 06 22 04 80 	movabs $0x8004220667,%rcx
  800421bdff:	00 00 00 
  800421be02:	48 ba 3a 03 22 04 80 	movabs $0x800422033a,%rdx
  800421be09:	00 00 00 
  800421be0c:	be 5e 02 00 00       	mov    $0x25e,%esi
  800421be11:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421be18:	00 00 00 
  800421be1b:	b8 00 00 00 00       	mov    $0x0,%eax
  800421be20:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421be27:	00 00 00 
  800421be2a:	41 ff d0             	callq  *%r8
    ginfo->msr_count = count;
  800421be2d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421be31:	8b 55 f8             	mov    -0x8(%rbp),%edx
  800421be34:	89 50 28             	mov    %edx,0x28(%rax)
    
    for(i=0; i<count; ++i) {
  800421be37:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421be3e:	e9 97 00 00 00       	jmpq   800421beda <msr_setup+0x105>
        entry = ((struct vmx_msr_entry *)ginfo->msr_host_area) + i;
  800421be43:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421be47:	48 8b 40 30          	mov    0x30(%rax),%rax
  800421be4b:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421be4e:	48 63 d2             	movslq %edx,%rdx
  800421be51:	48 c1 e2 04          	shl    $0x4,%rdx
  800421be55:	48 01 d0             	add    %rdx,%rax
  800421be58:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        entry->msr_index = idx[i];
  800421be5c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421be5f:	48 98                	cltq   
  800421be61:	8b 54 85 d0          	mov    -0x30(%rbp,%rax,4),%edx
  800421be65:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421be69:	89 10                	mov    %edx,(%rax)
        entry->msr_value = read_msr(idx[i]);
  800421be6b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421be6e:	48 98                	cltq   
  800421be70:	8b 44 85 d0          	mov    -0x30(%rbp,%rax,4),%eax
  800421be74:	89 45 ec             	mov    %eax,-0x14(%rbp)
}

static __inline uint64_t
read_msr( uint32_t ecx ) {
    uint32_t edx, eax;
    __asm __volatile("rdmsr"
  800421be77:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421be7a:	89 c1                	mov    %eax,%ecx
  800421be7c:	0f 32                	rdmsr  
  800421be7e:	89 55 e8             	mov    %edx,-0x18(%rbp)
  800421be81:	89 45 e4             	mov    %eax,-0x1c(%rbp)
            : "=d" (edx), "=a" (eax)
            : "c" (ecx));
    uint64_t ret = 0;
  800421be84:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  800421be8b:	00 
    ret = edx;
  800421be8c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421be8f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    ret = ret << 32;
  800421be93:	48 c1 65 d8 20       	shlq   $0x20,-0x28(%rbp)
    ret |= eax;
  800421be98:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421be9b:	48 09 45 d8          	or     %rax,-0x28(%rbp)

    return ret;
  800421be9f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bea3:	48 89 c2             	mov    %rax,%rdx
  800421bea6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421beaa:	48 89 50 08          	mov    %rdx,0x8(%rax)
        
        entry = ((struct vmx_msr_entry *)ginfo->msr_guest_area) + i;
  800421beae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421beb2:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421beb6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421beb9:	48 63 d2             	movslq %edx,%rdx
  800421bebc:	48 c1 e2 04          	shl    $0x4,%rdx
  800421bec0:	48 01 d0             	add    %rdx,%rax
  800421bec3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
        entry->msr_index = idx[i];
  800421bec7:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421beca:	48 98                	cltq   
  800421becc:	8b 54 85 d0          	mov    -0x30(%rbp,%rax,4),%edx
  800421bed0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421bed4:	89 10                	mov    %edx,(%rax)
    int i, count = sizeof(idx) / sizeof(idx[0]);

    assert(count <= MAX_MSR_COUNT);
    ginfo->msr_count = count;
    
    for(i=0; i<count; ++i) {
  800421bed6:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421beda:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421bedd:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  800421bee0:	0f 8c 5d ff ff ff    	jl     800421be43 <msr_setup+0x6e>
        entry->msr_value = read_msr(idx[i]);
        
        entry = ((struct vmx_msr_entry *)ginfo->msr_guest_area) + i;
        entry->msr_index = idx[i];
    }
}
  800421bee6:	c9                   	leaveq 
  800421bee7:	c3                   	retq   

000000800421bee8 <bitmap_setup>:

void
bitmap_setup(struct VmxGuestInfo *ginfo) {
  800421bee8:	55                   	push   %rbp
  800421bee9:	48 89 e5             	mov    %rsp,%rbp
  800421beec:	48 83 ec 30          	sub    $0x30,%rsp
  800421bef0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    unsigned int io_ports[] = { IO_RTC, IO_RTC+1 };
  800421bef4:	c7 45 e0 70 00 00 00 	movl   $0x70,-0x20(%rbp)
  800421befb:	c7 45 e4 71 00 00 00 	movl   $0x71,-0x1c(%rbp)
    int i, count = sizeof(io_ports) / sizeof(io_ports[0]);
  800421bf02:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%rbp)
    
    for(i=0; i<count; ++i) {
  800421bf09:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421bf10:	e9 07 01 00 00       	jmpq   800421c01c <bitmap_setup+0x134>
        int idx = io_ports[i] / (sizeof(uint64_t) * 8);
  800421bf15:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421bf18:	48 98                	cltq   
  800421bf1a:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421bf1e:	c1 e8 06             	shr    $0x6,%eax
  800421bf21:	89 45 f4             	mov    %eax,-0xc(%rbp)
        if(io_ports[i] < 0x7FFF) {
  800421bf24:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421bf27:	48 98                	cltq   
  800421bf29:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421bf2d:	3d fe 7f 00 00       	cmp    $0x7ffe,%eax
  800421bf32:	77 51                	ja     800421bf85 <bitmap_setup+0x9d>
            ginfo->io_bmap_a[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
  800421bf34:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bf38:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421bf3c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421bf3f:	48 63 d2             	movslq %edx,%rdx
  800421bf42:	48 c1 e2 03          	shl    $0x3,%rdx
  800421bf46:	48 01 c2             	add    %rax,%rdx
  800421bf49:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bf4d:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421bf51:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421bf54:	48 63 c9             	movslq %ecx,%rcx
  800421bf57:	48 c1 e1 03          	shl    $0x3,%rcx
  800421bf5b:	48 01 c8             	add    %rcx,%rax
  800421bf5e:	48 8b 30             	mov    (%rax),%rsi
  800421bf61:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421bf64:	48 98                	cltq   
  800421bf66:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421bf6a:	83 e0 3f             	and    $0x3f,%eax
  800421bf6d:	bf 01 00 00 00       	mov    $0x1,%edi
  800421bf72:	89 c1                	mov    %eax,%ecx
  800421bf74:	48 d3 e7             	shl    %cl,%rdi
  800421bf77:	48 89 f8             	mov    %rdi,%rax
  800421bf7a:	48 09 f0             	or     %rsi,%rax
  800421bf7d:	48 89 02             	mov    %rax,(%rdx)
  800421bf80:	e9 93 00 00 00       	jmpq   800421c018 <bitmap_setup+0x130>
        } else if (io_ports[i] < 0xFFFF) {
  800421bf85:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421bf88:	48 98                	cltq   
  800421bf8a:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421bf8e:	3d fe ff 00 00       	cmp    $0xfffe,%eax
  800421bf93:	77 4e                	ja     800421bfe3 <bitmap_setup+0xfb>
            ginfo->io_bmap_b[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
  800421bf95:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bf99:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421bf9d:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421bfa0:	48 63 d2             	movslq %edx,%rdx
  800421bfa3:	48 c1 e2 03          	shl    $0x3,%rdx
  800421bfa7:	48 01 c2             	add    %rax,%rdx
  800421bfaa:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421bfae:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421bfb2:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  800421bfb5:	48 63 c9             	movslq %ecx,%rcx
  800421bfb8:	48 c1 e1 03          	shl    $0x3,%rcx
  800421bfbc:	48 01 c8             	add    %rcx,%rax
  800421bfbf:	48 8b 30             	mov    (%rax),%rsi
  800421bfc2:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421bfc5:	48 98                	cltq   
  800421bfc7:	8b 44 85 e0          	mov    -0x20(%rbp,%rax,4),%eax
  800421bfcb:	83 e0 3f             	and    $0x3f,%eax
  800421bfce:	bf 01 00 00 00       	mov    $0x1,%edi
  800421bfd3:	89 c1                	mov    %eax,%ecx
  800421bfd5:	48 d3 e7             	shl    %cl,%rdi
  800421bfd8:	48 89 f8             	mov    %rdi,%rax
  800421bfdb:	48 09 f0             	or     %rsi,%rax
  800421bfde:	48 89 02             	mov    %rax,(%rdx)
  800421bfe1:	eb 35                	jmp    800421c018 <bitmap_setup+0x130>
        } else {
            assert(false);
  800421bfe3:	48 b9 34 03 22 04 80 	movabs $0x8004220334,%rcx
  800421bfea:	00 00 00 
  800421bfed:	48 ba 3a 03 22 04 80 	movabs $0x800422033a,%rdx
  800421bff4:	00 00 00 
  800421bff7:	be 77 02 00 00       	mov    $0x277,%esi
  800421bffc:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421c003:	00 00 00 
  800421c006:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c00b:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421c012:	00 00 00 
  800421c015:	41 ff d0             	callq  *%r8
void
bitmap_setup(struct VmxGuestInfo *ginfo) {
    unsigned int io_ports[] = { IO_RTC, IO_RTC+1 };
    int i, count = sizeof(io_ports) / sizeof(io_ports[0]);
    
    for(i=0; i<count; ++i) {
  800421c018:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421c01c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421c01f:	3b 45 f8             	cmp    -0x8(%rbp),%eax
  800421c022:	0f 8c ed fe ff ff    	jl     800421bf15 <bitmap_setup+0x2d>
            ginfo->io_bmap_b[idx] |= ((0x1uL << (io_ports[i] & 0x3F)));
        } else {
            assert(false);
        }
    }
}
  800421c028:	c9                   	leaveq 
  800421c029:	c3                   	retq   

000000800421c02a <vmx_vmrun>:

/* 
 * Processor must be in VMX root operation before executing this function.
 */
int vmx_vmrun( struct Env *e ) {
  800421c02a:	55                   	push   %rbp
  800421c02b:	48 89 e5             	mov    %rsp,%rbp
  800421c02e:	48 83 ec 70          	sub    $0x70,%rsp
  800421c032:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)

    if ( e->env_type != ENV_TYPE_GUEST ) {
  800421c036:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421c03a:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421c040:	83 f8 03             	cmp    $0x3,%eax
  800421c043:	74 0a                	je     800421c04f <vmx_vmrun+0x25>
        return -E_INVAL;
  800421c045:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800421c04a:	e9 9a 02 00 00       	jmpq   800421c2e9 <vmx_vmrun+0x2bf>
    }
    uint8_t error;

    if( e->env_runs == 1 ) {
  800421c04f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421c053:	8b 80 d8 00 00 00    	mov    0xd8(%rax),%eax
  800421c059:	83 f8 01             	cmp    $0x1,%eax
  800421c05c:	0f 85 2f 01 00 00    	jne    800421c191 <vmx_vmrun+0x167>
        physaddr_t vmcs_phy_addr = PADDR(e->env_vmxinfo.vmcs);
  800421c062:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421c066:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800421c06d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421c071:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421c078:	00 00 00 
  800421c07b:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421c07f:	77 32                	ja     800421c0b3 <vmx_vmrun+0x89>
  800421c081:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421c085:	48 89 c1             	mov    %rax,%rcx
  800421c088:	48 ba 98 03 22 04 80 	movabs $0x8004220398,%rdx
  800421c08f:	00 00 00 
  800421c092:	be 87 02 00 00       	mov    $0x287,%esi
  800421c097:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421c09e:	00 00 00 
  800421c0a1:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c0a6:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421c0ad:	00 00 00 
  800421c0b0:	41 ff d0             	callq  *%r8
  800421c0b3:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421c0ba:	ff ff ff 
  800421c0bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421c0c1:	48 01 d0             	add    %rdx,%rax
  800421c0c4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800421c0c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421c0cc:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

static __inline uint8_t
vmclear( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421c0d0:	c6 45 df 00          	movb   $0x0,-0x21(%rbp)

    __asm __volatile("clc; vmclear %1; setna %0"
  800421c0d4:	f8                   	clc    
  800421c0d5:	66 0f c7 75 a8       	vmclear -0x58(%rbp)
  800421c0da:	0f 96 c0             	setbe  %al
  800421c0dd:	88 45 df             	mov    %al,-0x21(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421c0e0:	0f b6 45 df          	movzbl -0x21(%rbp),%eax

        // Call VMCLEAR on the VMCS region.
        error = vmclear(vmcs_phy_addr);
  800421c0e4:	88 45 ef             	mov    %al,-0x11(%rbp)
        // Check if VMCLEAR succeeded. ( RFLAGS.CF = 0 and RFLAGS.ZF = 0 )
        if ( error )
  800421c0e7:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800421c0eb:	74 0a                	je     800421c0f7 <vmx_vmrun+0xcd>
            return -E_VMCS_INIT; 
  800421c0ed:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421c0f2:	e9 f2 01 00 00       	jmpq   800421c2e9 <vmx_vmrun+0x2bf>
  800421c0f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421c0fb:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
}

static __inline uint8_t
vmptrld( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421c0ff:	c6 45 de 00          	movb   $0x0,-0x22(%rbp)

    __asm __volatile("clc; vmptrld %1; setna %0"
  800421c103:	f8                   	clc    
  800421c104:	0f c7 75 b0          	vmptrld -0x50(%rbp)
  800421c108:	0f 96 c0             	setbe  %al
  800421c10b:	88 45 de             	mov    %al,-0x22(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421c10e:	0f b6 45 de          	movzbl -0x22(%rbp),%eax

        // Make this VMCS working VMCS.
        error = vmptrld(vmcs_phy_addr);
  800421c112:	88 45 ef             	mov    %al,-0x11(%rbp)
        if ( error )
  800421c115:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800421c119:	74 0a                	je     800421c125 <vmx_vmrun+0xfb>
            return -E_VMCS_INIT; 
  800421c11b:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421c120:	e9 c4 01 00 00       	jmpq   800421c2e9 <vmx_vmrun+0x2bf>

        vmcs_host_init();
  800421c125:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c12a:	48 ba c1 a1 21 04 80 	movabs $0x800421a1c1,%rdx
  800421c131:	00 00 00 
  800421c134:	ff d2                	callq  *%rdx
        vmcs_guest_init();
  800421c136:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c13b:	48 ba 8f a5 21 04 80 	movabs $0x800421a58f,%rdx
  800421c142:	00 00 00 
  800421c145:	ff d2                	callq  *%rdx
        // Setup IO and exception bitmaps.
        bitmap_setup(&e->env_vmxinfo);
  800421c147:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421c14b:	48 05 20 01 00 00    	add    $0x120,%rax
  800421c151:	48 89 c7             	mov    %rax,%rdi
  800421c154:	48 b8 e8 be 21 04 80 	movabs $0x800421bee8,%rax
  800421c15b:	00 00 00 
  800421c15e:	ff d0                	callq  *%rax
        // Setup the msr load/store area
        msr_setup(&e->env_vmxinfo);
  800421c160:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421c164:	48 05 20 01 00 00    	add    $0x120,%rax
  800421c16a:	48 89 c7             	mov    %rax,%rdi
  800421c16d:	48 b8 d5 bd 21 04 80 	movabs $0x800421bdd5,%rax
  800421c174:	00 00 00 
  800421c177:	ff d0                	callq  *%rax
        vmcs_ctls_init(e);
  800421c179:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421c17d:	48 89 c7             	mov    %rax,%rdi
  800421c180:	48 b8 34 ae 21 04 80 	movabs $0x800421ae34,%rax
  800421c187:	00 00 00 
  800421c18a:	ff d0                	callq  *%rax
  800421c18c:	e9 8c 00 00 00       	jmpq   800421c21d <vmx_vmrun+0x1f3>

        /* ept_alloc_static(e->env_pml4e, &e->env_vmxinfo); */

    } else {
        // Make this VMCS working VMCS.
        error = vmptrld(PADDR(e->env_vmxinfo.vmcs));
  800421c191:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421c195:	48 8b 80 28 01 00 00 	mov    0x128(%rax),%rax
  800421c19c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800421c1a0:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800421c1a7:	00 00 00 
  800421c1aa:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800421c1ae:	77 32                	ja     800421c1e2 <vmx_vmrun+0x1b8>
  800421c1b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421c1b4:	48 89 c1             	mov    %rax,%rcx
  800421c1b7:	48 ba 98 03 22 04 80 	movabs $0x8004220398,%rdx
  800421c1be:	00 00 00 
  800421c1c1:	be a0 02 00 00       	mov    $0x2a0,%esi
  800421c1c6:	48 bf 4f 03 22 04 80 	movabs $0x800422034f,%rdi
  800421c1cd:	00 00 00 
  800421c1d0:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c1d5:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421c1dc:	00 00 00 
  800421c1df:	41 ff d0             	callq  *%r8
  800421c1e2:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800421c1e9:	ff ff ff 
  800421c1ec:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421c1f0:	48 01 d0             	add    %rdx,%rax
  800421c1f3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    return error;
}

static __inline uint8_t
vmptrld( physaddr_t vmcs_region ) {
	uint8_t error = 0;
  800421c1f7:	c6 45 dd 00          	movb   $0x0,-0x23(%rbp)

    __asm __volatile("clc; vmptrld %1; setna %0"
  800421c1fb:	f8                   	clc    
  800421c1fc:	0f c7 75 b8          	vmptrld -0x48(%rbp)
  800421c200:	0f 96 c0             	setbe  %al
  800421c203:	88 45 dd             	mov    %al,-0x23(%rbp)
            : "=q"( error ) : "m" ( vmcs_region ) : "cc");
    return error;
  800421c206:	0f b6 45 dd          	movzbl -0x23(%rbp),%eax
  800421c20a:	88 45 ef             	mov    %al,-0x11(%rbp)
        if ( error ) {
  800421c20d:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800421c211:	74 0a                	je     800421c21d <vmx_vmrun+0x1f3>
            return -E_VMCS_INIT; 
  800421c213:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
  800421c218:	e9 cc 00 00 00       	jmpq   800421c2e9 <vmx_vmrun+0x2bf>
        }
    }

    vmcs_write64( VMCS_GUEST_RSP, curenv->env_tf.tf_rsp  );
  800421c21d:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421c224:	00 00 00 
  800421c227:	ff d0                	callq  *%rax
  800421c229:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421c230:	00 00 00 
  800421c233:	48 98                	cltq   
  800421c235:	48 c1 e0 03          	shl    $0x3,%rax
  800421c239:	48 89 c1             	mov    %rax,%rcx
  800421c23c:	48 c1 e1 04          	shl    $0x4,%rcx
  800421c240:	48 01 c8             	add    %rcx,%rax
  800421c243:	48 01 d0             	add    %rdx,%rax
  800421c246:	48 83 c0 08          	add    $0x8,%rax
  800421c24a:	48 8b 00             	mov    (%rax),%rax
  800421c24d:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800421c254:	c7 45 d8 1c 68 00 00 	movl   $0x681c,-0x28(%rbp)
  800421c25b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
}

static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
  800421c25f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421c263:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800421c266:	48 89 d6             	mov    %rdx,%rsi
  800421c269:	89 c7                	mov    %eax,%edi
  800421c26b:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421c272:	00 00 00 
  800421c275:	ff d0                	callq  *%rax
    vmcs_write64( VMCS_GUEST_RIP, curenv->env_tf.tf_rip );
  800421c277:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421c27e:	00 00 00 
  800421c281:	ff d0                	callq  *%rax
  800421c283:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421c28a:	00 00 00 
  800421c28d:	48 98                	cltq   
  800421c28f:	48 c1 e0 03          	shl    $0x3,%rax
  800421c293:	48 89 c1             	mov    %rax,%rcx
  800421c296:	48 c1 e1 04          	shl    $0x4,%rcx
  800421c29a:	48 01 c8             	add    %rcx,%rax
  800421c29d:	48 01 d0             	add    %rdx,%rax
  800421c2a0:	48 83 c0 08          	add    $0x8,%rax
  800421c2a4:	48 8b 00             	mov    (%rax),%rax
  800421c2a7:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800421c2ae:	c7 45 cc 1e 68 00 00 	movl   $0x681e,-0x34(%rbp)
  800421c2b5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  800421c2b9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421c2bd:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421c2c0:	48 89 d6             	mov    %rdx,%rsi
  800421c2c3:	89 c7                	mov    %eax,%edi
  800421c2c5:	48 b8 6a 97 21 04 80 	movabs $0x800421976a,%rax
  800421c2cc:	00 00 00 
  800421c2cf:	ff d0                	callq  *%rax
    //panic ("asm vmrun incomplete\n");
    asm_vmrun( &e->env_tf );    
  800421c2d1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421c2d5:	48 89 c7             	mov    %rax,%rdi
  800421c2d8:	48 b8 a2 bb 21 04 80 	movabs $0x800421bba2,%rax
  800421c2df:	00 00 00 
  800421c2e2:	ff d0                	callq  *%rax
    return 0;
  800421c2e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421c2e9:	c9                   	leaveq 
  800421c2ea:	c3                   	retq   

000000800421c2eb <vmcs_writel>:
#define IA32_VMX_EPT_VPID_CAP 0x48C
#define IA32_FEATURE_CONTROL 0x03A

#define BIT( val, x ) ( ( val >> x ) & 0x1 )

static __inline uint8_t vmcs_writel( uint32_t field, uint64_t value) {
  800421c2eb:	55                   	push   %rbp
  800421c2ec:	48 89 e5             	mov    %rsp,%rbp
  800421c2ef:	48 83 ec 20          	sub    $0x20,%rsp
  800421c2f3:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421c2f6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint8_t error;

	__asm __volatile ( "clc; vmwrite %%rax, %%rdx; setna %0"
  800421c2fa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421c2fe:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421c301:	f8                   	clc    
  800421c302:	0f 79 d0             	vmwrite %rax,%rdx
  800421c305:	0f 96 c0             	setbe  %al
  800421c308:	88 45 ff             	mov    %al,-0x1(%rbp)
		       : "=q"( error ) : "a"( value ), "d"( field ) : "cc");
    return error;
  800421c30b:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  800421c30f:	c9                   	leaveq 
  800421c310:	c3                   	retq   

000000800421c311 <vmcs_readl>:
static __inline uint8_t vmcs_write64( uint32_t field, uint64_t value ) {
	return vmcs_writel( field, value );
}

static __inline uint64_t vmcs_readl(uint32_t field)
{
  800421c311:	55                   	push   %rbp
  800421c312:	48 89 e5             	mov    %rsp,%rbp
  800421c315:	48 83 ec 14          	sub    $0x14,%rsp
  800421c319:	89 7d ec             	mov    %edi,-0x14(%rbp)
	uint64_t value;

	__asm __volatile ( "vmread %%rdx, %%rax;"
  800421c31c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421c31f:	89 c2                	mov    %eax,%edx
  800421c321:	0f 78 d0             	vmread %rdx,%rax
  800421c324:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		      : "=a"(value) : "d"(field) : "cc");
	return value;
  800421c328:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421c32c:	c9                   	leaveq 
  800421c32d:	c3                   	retq   

000000800421c32e <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  800421c32e:	55                   	push   %rbp
  800421c32f:	48 89 e5             	mov    %rsp,%rbp
  800421c332:	53                   	push   %rbx
  800421c333:	48 83 ec 38          	sub    $0x38,%rsp
  800421c337:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  800421c33a:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  800421c33e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800421c342:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  800421c346:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  800421c34a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421c34d:	0f a2                	cpuid  
  800421c34f:	89 de                	mov    %ebx,%esi
  800421c351:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421c354:	89 75 f0             	mov    %esi,-0x10(%rbp)
  800421c357:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  800421c35a:	89 55 e8             	mov    %edx,-0x18(%rbp)
		     : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
		     : "a" (info));
	if (eaxp)
  800421c35d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421c362:	74 09                	je     800421c36d <cpuid+0x3f>
		*eaxp = eax;
  800421c364:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c368:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421c36b:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  800421c36d:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800421c372:	74 09                	je     800421c37d <cpuid+0x4f>
		*ebxp = ebx;
  800421c374:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421c378:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421c37b:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  800421c37d:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421c382:	74 09                	je     800421c38d <cpuid+0x5f>
		*ecxp = ecx;
  800421c384:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c388:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800421c38b:	89 10                	mov    %edx,(%rax)
	if (edxp)
  800421c38d:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  800421c392:	74 09                	je     800421c39d <cpuid+0x6f>
		*edxp = edx;
  800421c394:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421c398:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421c39b:	89 10                	mov    %edx,(%rax)
}
  800421c39d:	48 83 c4 38          	add    $0x38,%rsp
  800421c3a1:	5b                   	pop    %rbx
  800421c3a2:	5d                   	pop    %rbp
  800421c3a3:	c3                   	retq   

000000800421c3a4 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  800421c3a4:	55                   	push   %rbp
  800421c3a5:	48 89 e5             	mov    %rsp,%rbp
  800421c3a8:	48 83 ec 08          	sub    $0x8,%rsp
  800421c3ac:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  800421c3b0:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421c3b4:	48 b8 a0 e7 3a 04 80 	movabs $0x80043ae7a0,%rax
  800421c3bb:	00 00 00 
  800421c3be:	48 8b 00             	mov    (%rax),%rax
  800421c3c1:	48 29 c2             	sub    %rax,%rdx
  800421c3c4:	48 89 d0             	mov    %rdx,%rax
  800421c3c7:	48 c1 f8 04          	sar    $0x4,%rax
}
  800421c3cb:	c9                   	leaveq 
  800421c3cc:	c3                   	retq   

000000800421c3cd <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  800421c3cd:	55                   	push   %rbp
  800421c3ce:	48 89 e5             	mov    %rsp,%rbp
  800421c3d1:	48 83 ec 08          	sub    $0x8,%rsp
  800421c3d5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800421c3d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421c3dd:	48 89 c7             	mov    %rax,%rdi
  800421c3e0:	48 b8 a4 c3 21 04 80 	movabs $0x800421c3a4,%rax
  800421c3e7:	00 00 00 
  800421c3ea:	ff d0                	callq  *%rax
  800421c3ec:	48 c1 e0 0c          	shl    $0xc,%rax
}
  800421c3f0:	c9                   	leaveq 
  800421c3f1:	c3                   	retq   

000000800421c3f2 <page2kva>:
	return &pages[PPN(pa)];
}

static inline void*
page2kva(struct PageInfo *pp)
{
  800421c3f2:	55                   	push   %rbp
  800421c3f3:	48 89 e5             	mov    %rsp,%rbp
  800421c3f6:	48 83 ec 20          	sub    $0x20,%rsp
  800421c3fa:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  800421c3fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421c402:	48 89 c7             	mov    %rax,%rdi
  800421c405:	48 b8 cd c3 21 04 80 	movabs $0x800421c3cd,%rax
  800421c40c:	00 00 00 
  800421c40f:	ff d0                	callq  *%rax
  800421c411:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421c415:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421c419:	48 c1 e8 0c          	shr    $0xc,%rax
  800421c41d:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800421c420:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421c423:	48 b8 98 e7 3a 04 80 	movabs $0x80043ae798,%rax
  800421c42a:	00 00 00 
  800421c42d:	48 8b 00             	mov    (%rax),%rax
  800421c430:	48 39 c2             	cmp    %rax,%rdx
  800421c433:	72 32                	jb     800421c467 <page2kva+0x75>
  800421c435:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421c439:	48 89 c1             	mov    %rax,%rcx
  800421c43c:	48 ba 80 06 22 04 80 	movabs $0x8004220680,%rdx
  800421c443:	00 00 00 
  800421c446:	be 5b 00 00 00       	mov    $0x5b,%esi
  800421c44b:	48 bf a3 06 22 04 80 	movabs $0x80042206a3,%rdi
  800421c452:	00 00 00 
  800421c455:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c45a:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421c461:	00 00 00 
  800421c464:	41 ff d0             	callq  *%r8
  800421c467:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421c46e:	00 00 00 
  800421c471:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421c475:	48 01 d0             	add    %rdx,%rax
}
  800421c478:	c9                   	leaveq 
  800421c479:	c3                   	retq   

000000800421c47a <vmx_get_vmdisk_number>:
#include <kern/env.h>
#include <kern/cpu.h>

static int vmdisk_number = 0;	//this number assign to the vm
int 
vmx_get_vmdisk_number() {
  800421c47a:	55                   	push   %rbp
  800421c47b:	48 89 e5             	mov    %rsp,%rbp
	return vmdisk_number;
  800421c47e:	48 b8 68 e7 3a 04 80 	movabs $0x80043ae768,%rax
  800421c485:	00 00 00 
  800421c488:	8b 00                	mov    (%rax),%eax
}
  800421c48a:	5d                   	pop    %rbp
  800421c48b:	c3                   	retq   

000000800421c48c <vmx_incr_vmdisk_number>:

void
vmx_incr_vmdisk_number() {
  800421c48c:	55                   	push   %rbp
  800421c48d:	48 89 e5             	mov    %rsp,%rbp
	vmdisk_number++;
  800421c490:	48 b8 68 e7 3a 04 80 	movabs $0x80043ae768,%rax
  800421c497:	00 00 00 
  800421c49a:	8b 00                	mov    (%rax),%eax
  800421c49c:	8d 50 01             	lea    0x1(%rax),%edx
  800421c49f:	48 b8 68 e7 3a 04 80 	movabs $0x80043ae768,%rax
  800421c4a6:	00 00 00 
  800421c4a9:	89 10                	mov    %edx,(%rax)
}
  800421c4ab:	5d                   	pop    %rbp
  800421c4ac:	c3                   	retq   

000000800421c4ad <find_msr_in_region>:
bool
find_msr_in_region(uint32_t msr_idx, uintptr_t *area, int area_sz, struct vmx_msr_entry **msr_entry) {
  800421c4ad:	55                   	push   %rbp
  800421c4ae:	48 89 e5             	mov    %rsp,%rbp
  800421c4b1:	48 83 ec 28          	sub    $0x28,%rsp
  800421c4b5:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800421c4b8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421c4bc:	89 55 e8             	mov    %edx,-0x18(%rbp)
  800421c4bf:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    struct vmx_msr_entry *entry = (struct vmx_msr_entry *)area;
  800421c4c3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421c4c7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    int i;
    for(i=0; i<area_sz; ++i) {
  800421c4cb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421c4d2:	eb 21                	jmp    800421c4f5 <find_msr_in_region+0x48>
        if(entry->msr_index == msr_idx) {
  800421c4d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421c4d8:	8b 00                	mov    (%rax),%eax
  800421c4da:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421c4dd:	75 12                	jne    800421c4f1 <find_msr_in_region+0x44>
            *msr_entry = entry;
  800421c4df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c4e3:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421c4e7:	48 89 10             	mov    %rdx,(%rax)
            return true;
  800421c4ea:	b8 01 00 00 00       	mov    $0x1,%eax
  800421c4ef:	eb 11                	jmp    800421c502 <find_msr_in_region+0x55>
}
bool
find_msr_in_region(uint32_t msr_idx, uintptr_t *area, int area_sz, struct vmx_msr_entry **msr_entry) {
    struct vmx_msr_entry *entry = (struct vmx_msr_entry *)area;
    int i;
    for(i=0; i<area_sz; ++i) {
  800421c4f1:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421c4f5:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421c4f8:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  800421c4fb:	7c d7                	jl     800421c4d4 <find_msr_in_region+0x27>
        if(entry->msr_index == msr_idx) {
            *msr_entry = entry;
            return true;
        }
    }
    return false;
  800421c4fd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421c502:	c9                   	leaveq 
  800421c503:	c3                   	retq   

000000800421c504 <handle_interrupt_window>:

bool
handle_interrupt_window(struct Trapframe *tf, struct VmxGuestInfo *ginfo, uint32_t host_vector) {
  800421c504:	55                   	push   %rbp
  800421c505:	48 89 e5             	mov    %rsp,%rbp
  800421c508:	48 83 ec 38          	sub    $0x38,%rsp
  800421c50c:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421c510:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800421c514:	89 55 cc             	mov    %edx,-0x34(%rbp)
  800421c517:	c7 45 f8 02 40 00 00 	movl   $0x4002,-0x8(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c51e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421c521:	89 c7                	mov    %eax,%edi
  800421c523:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421c52a:	00 00 00 
  800421c52d:	ff d0                	callq  *%rax
	uint64_t rflags;
	 uint32_t procbased_ctls_or;
	
	procbased_ctls_or = vmcs_read32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS );
  800421c52f:	89 45 fc             	mov    %eax,-0x4(%rbp)
            
        //disable the interrupt window exiting
        procbased_ctls_or &= ~(VMCS_PROC_BASED_VMEXEC_CTL_INTRWINEXIT); 
  800421c532:	83 65 fc fb          	andl   $0xfffffffb,-0x4(%rbp)
  800421c536:	c7 45 f4 02 40 00 00 	movl   $0x4002,-0xc(%rbp)
  800421c53d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421c540:	89 45 f0             	mov    %eax,-0x10(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421c543:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800421c546:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421c549:	48 89 d6             	mov    %rdx,%rsi
  800421c54c:	89 c7                	mov    %eax,%edi
  800421c54e:	48 b8 eb c2 21 04 80 	movabs $0x800421c2eb,%rax
  800421c555:	00 00 00 
  800421c558:	ff d0                	callq  *%rax
  800421c55a:	c7 45 ec 16 40 00 00 	movl   $0x4016,-0x14(%rbp)
  800421c561:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421c564:	89 45 e8             	mov    %eax,-0x18(%rbp)
  800421c567:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421c56a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421c56d:	48 89 d6             	mov    %rdx,%rsi
  800421c570:	89 c7                	mov    %eax,%edi
  800421c572:	48 b8 eb c2 21 04 80 	movabs $0x800421c2eb,%rax
  800421c579:	00 00 00 
  800421c57c:	ff d0                	callq  *%rax
        
        vmcs_write32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS, 
            procbased_ctls_or);
        //write back the host_vector, which can insert a virtual interrupt            
	vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO , host_vector);
	return true;
  800421c57e:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421c583:	c9                   	leaveq 
  800421c584:	c3                   	retq   

000000800421c585 <handle_interrupts>:
bool
handle_interrupts(struct Trapframe *tf, struct VmxGuestInfo *ginfo, uint32_t host_vector) {
  800421c585:	55                   	push   %rbp
  800421c586:	48 89 e5             	mov    %rsp,%rbp
  800421c589:	48 83 ec 48          	sub    $0x48,%rsp
  800421c58d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421c591:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421c595:	89 55 bc             	mov    %edx,-0x44(%rbp)
  800421c598:	c7 45 f0 20 68 00 00 	movl   $0x6820,-0x10(%rbp)
	return vmcs_readl(field);
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421c59f:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421c5a2:	89 c7                	mov    %eax,%edi
  800421c5a4:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421c5ab:	00 00 00 
  800421c5ae:	ff d0                	callq  *%rax
	uint64_t rflags;
	uint32_t procbased_ctls_or;
	rflags = vmcs_read64(VMCS_GUEST_RFLAGS);
  800421c5b0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if ( !(rflags & (0x1 << 9)) ) {	//we have to wait the interrupt window open
  800421c5b4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421c5b8:	25 00 02 00 00       	and    $0x200,%eax
  800421c5bd:	48 85 c0             	test   %rax,%rax
  800421c5c0:	75 45                	jne    800421c607 <handle_interrupts+0x82>
  800421c5c2:	c7 45 ec 02 40 00 00 	movl   $0x4002,-0x14(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c5c9:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421c5cc:	89 c7                	mov    %eax,%edi
  800421c5ce:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421c5d5:	00 00 00 
  800421c5d8:	ff d0                	callq  *%rax
		//get the interrupt info
		
		procbased_ctls_or = vmcs_read32( VMCS_32BIT_CONTROL_PROCESSOR_BASED_VMEXEC_CONTROLS);
  800421c5da:	89 45 f4             	mov    %eax,-0xc(%rbp)
            
		//disable the interrupt window exiting
		procbased_ctls_or |= VMCS_PROC_BASED_VMEXEC_CTL_INTRWINEXIT; 
  800421c5dd:	83 4d f4 04          	orl    $0x4,-0xc(%rbp)
  800421c5e1:	c7 45 e8 02 40 00 00 	movl   $0x4002,-0x18(%rbp)
  800421c5e8:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421c5eb:	89 45 e4             	mov    %eax,-0x1c(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421c5ee:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  800421c5f1:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421c5f4:	48 89 d6             	mov    %rdx,%rsi
  800421c5f7:	89 c7                	mov    %eax,%edi
  800421c5f9:	48 b8 eb c2 21 04 80 	movabs $0x800421c2eb,%rax
  800421c600:	00 00 00 
  800421c603:	ff d0                	callq  *%rax
  800421c605:	eb 24                	jmp    800421c62b <handle_interrupts+0xa6>
  800421c607:	c7 45 e0 16 40 00 00 	movl   $0x4016,-0x20(%rbp)
  800421c60e:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421c611:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421c614:	8b 55 dc             	mov    -0x24(%rbp),%edx
  800421c617:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421c61a:	48 89 d6             	mov    %rdx,%rsi
  800421c61d:	89 c7                	mov    %eax,%edi
  800421c61f:	48 b8 eb c2 21 04 80 	movabs $0x800421c2eb,%rax
  800421c626:	00 00 00 
  800421c629:	ff d0                	callq  *%rax
		vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_INTERRUPTION_INFO , host_vector);
	}
	
	
	
	return true;
  800421c62b:	b8 01 00 00 00       	mov    $0x1,%eax
}
  800421c630:	c9                   	leaveq 
  800421c631:	c3                   	retq   

000000800421c632 <handle_rdmsr>:

bool
handle_rdmsr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421c632:	55                   	push   %rbp
  800421c633:	48 89 e5             	mov    %rsp,%rbp
  800421c636:	53                   	push   %rbx
  800421c637:	48 83 ec 48          	sub    $0x48,%rsp
  800421c63b:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421c63f:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
    uint64_t msr = tf->tf_regs.reg_rcx;
  800421c643:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421c647:	48 8b 40 60          	mov    0x60(%rax),%rax
  800421c64b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(msr == EFER_MSR) {
  800421c64f:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421c654:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800421c658:	0f 85 d0 00 00 00    	jne    800421c72e <handle_rdmsr+0xfc>
        // TODO: setup msr_bitmap to ignore EFER_MSR
        uint64_t val;
        struct vmx_msr_entry *entry;
        bool r = find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
  800421c65e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421c662:	8b 50 28             	mov    0x28(%rax),%edx
  800421c665:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421c669:	48 8b 70 38          	mov    0x38(%rax),%rsi
  800421c66d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421c671:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
  800421c675:	89 c7                	mov    %eax,%edi
  800421c677:	48 b8 ad c4 21 04 80 	movabs $0x800421c4ad,%rax
  800421c67e:	00 00 00 
  800421c681:	ff d0                	callq  *%rax
  800421c683:	88 45 e7             	mov    %al,-0x19(%rbp)
        assert(r);
  800421c686:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421c68a:	83 f0 01             	xor    $0x1,%eax
  800421c68d:	84 c0                	test   %al,%al
  800421c68f:	74 35                	je     800421c6c6 <handle_rdmsr+0x94>
  800421c691:	48 b9 b1 06 22 04 80 	movabs $0x80042206b1,%rcx
  800421c698:	00 00 00 
  800421c69b:	48 ba b3 06 22 04 80 	movabs $0x80042206b3,%rdx
  800421c6a2:	00 00 00 
  800421c6a5:	be 5c 00 00 00       	mov    $0x5c,%esi
  800421c6aa:	48 bf c8 06 22 04 80 	movabs $0x80042206c8,%rdi
  800421c6b1:	00 00 00 
  800421c6b4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c6b9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421c6c0:	00 00 00 
  800421c6c3:	41 ff d0             	callq  *%r8
        val = entry->msr_value;
  800421c6c6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421c6ca:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421c6ce:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

        tf->tf_regs.reg_rdx = val << 32;
  800421c6d2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c6d6:	48 c1 e0 20          	shl    $0x20,%rax
  800421c6da:	48 89 c2             	mov    %rax,%rdx
  800421c6dd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421c6e1:	48 89 50 58          	mov    %rdx,0x58(%rax)
        tf->tf_regs.reg_rax = val & 0xFFFFFFFF;
  800421c6e5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c6e9:	89 c2                	mov    %eax,%edx
  800421c6eb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421c6ef:	48 89 50 70          	mov    %rdx,0x70(%rax)

        tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421c6f3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421c6f7:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800421c6fe:	c7 45 d4 0c 44 00 00 	movl   $0x440c,-0x2c(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c705:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421c708:	89 c7                	mov    %eax,%edi
  800421c70a:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421c711:	00 00 00 
  800421c714:	ff d0                	callq  *%rax
  800421c716:	89 c0                	mov    %eax,%eax
  800421c718:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  800421c71c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421c720:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
        return true;
  800421c727:	b8 01 00 00 00       	mov    $0x1,%eax
  800421c72c:	eb 05                	jmp    800421c733 <handle_rdmsr+0x101>
    }

    return false;
  800421c72e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421c733:	48 83 c4 48          	add    $0x48,%rsp
  800421c737:	5b                   	pop    %rbx
  800421c738:	5d                   	pop    %rbp
  800421c739:	c3                   	retq   

000000800421c73a <handle_wrmsr>:

bool 
handle_wrmsr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421c73a:	55                   	push   %rbp
  800421c73b:	48 89 e5             	mov    %rsp,%rbp
  800421c73e:	53                   	push   %rbx
  800421c73f:	48 83 ec 58          	sub    $0x58,%rsp
  800421c743:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800421c747:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
    uint64_t msr = tf->tf_regs.reg_rcx;
  800421c74b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421c74f:	48 8b 40 60          	mov    0x60(%rax),%rax
  800421c753:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(msr == EFER_MSR) {
  800421c757:	b8 80 00 00 c0       	mov    $0xc0000080,%eax
  800421c75c:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800421c760:	0f 85 3b 01 00 00    	jne    800421c8a1 <handle_wrmsr+0x167>

        uint64_t cur_val, new_val;
        struct vmx_msr_entry *entry;
        bool r = 
            find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
  800421c766:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421c76a:	8b 50 28             	mov    0x28(%rax),%edx
  800421c76d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421c771:	48 8b 70 38          	mov    0x38(%rax),%rsi
  800421c775:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    uint64_t msr = tf->tf_regs.reg_rcx;
    if(msr == EFER_MSR) {

        uint64_t cur_val, new_val;
        struct vmx_msr_entry *entry;
        bool r = 
  800421c779:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
  800421c77d:	89 c7                	mov    %eax,%edi
  800421c77f:	48 b8 ad c4 21 04 80 	movabs $0x800421c4ad,%rax
  800421c786:	00 00 00 
  800421c789:	ff d0                	callq  *%rax
  800421c78b:	88 45 e7             	mov    %al,-0x19(%rbp)
            find_msr_in_region(msr, ginfo->msr_guest_area, ginfo->msr_count, &entry);
        assert(r);
  800421c78e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421c792:	83 f0 01             	xor    $0x1,%eax
  800421c795:	84 c0                	test   %al,%al
  800421c797:	74 35                	je     800421c7ce <handle_wrmsr+0x94>
  800421c799:	48 b9 b1 06 22 04 80 	movabs $0x80042206b1,%rcx
  800421c7a0:	00 00 00 
  800421c7a3:	48 ba b3 06 22 04 80 	movabs $0x80042206b3,%rdx
  800421c7aa:	00 00 00 
  800421c7ad:	be 72 00 00 00       	mov    $0x72,%esi
  800421c7b2:	48 bf c8 06 22 04 80 	movabs $0x80042206c8,%rdi
  800421c7b9:	00 00 00 
  800421c7bc:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c7c1:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421c7c8:	00 00 00 
  800421c7cb:	41 ff d0             	callq  *%r8
        cur_val = entry->msr_value;
  800421c7ce:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421c7d2:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421c7d6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

        new_val = (tf->tf_regs.reg_rdx << 32)|tf->tf_regs.reg_rax;
  800421c7da:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421c7de:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421c7e2:	48 c1 e0 20          	shl    $0x20,%rax
  800421c7e6:	48 89 c2             	mov    %rax,%rdx
  800421c7e9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421c7ed:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421c7f1:	48 09 d0             	or     %rdx,%rax
  800421c7f4:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        if(BIT(cur_val, EFER_LME) == 0 && BIT(new_val, EFER_LME) == 1) {
  800421c7f8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c7fc:	25 00 01 00 00       	and    $0x100,%eax
  800421c801:	48 85 c0             	test   %rax,%rax
  800421c804:	75 54                	jne    800421c85a <handle_wrmsr+0x120>
  800421c806:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421c80a:	25 00 01 00 00       	and    $0x100,%eax
  800421c80f:	48 85 c0             	test   %rax,%rax
  800421c812:	74 46                	je     800421c85a <handle_wrmsr+0x120>
  800421c814:	c7 45 c8 12 40 00 00 	movl   $0x4012,-0x38(%rbp)
  800421c81b:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421c81e:	89 c7                	mov    %eax,%edi
  800421c820:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421c827:	00 00 00 
  800421c82a:	ff d0                	callq  *%rax
            // Long mode enable.
            uint32_t entry_ctls = vmcs_read32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS );
  800421c82c:	89 45 cc             	mov    %eax,-0x34(%rbp)
            entry_ctls |= VMCS_VMENTRY_x64_GUEST;
  800421c82f:	81 4d cc 00 02 00 00 	orl    $0x200,-0x34(%rbp)
  800421c836:	c7 45 c4 12 40 00 00 	movl   $0x4012,-0x3c(%rbp)
  800421c83d:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421c840:	89 45 c0             	mov    %eax,-0x40(%rbp)
static __inline uint8_t vmcs_write16( uint32_t field, uint16_t value) {
	return vmcs_writel( field, value );
}

static __inline uint8_t vmcs_write32( uint32_t field, uint32_t value ) {
	return vmcs_writel(field, value);
  800421c843:	8b 55 c0             	mov    -0x40(%rbp),%edx
  800421c846:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800421c849:	48 89 d6             	mov    %rdx,%rsi
  800421c84c:	89 c7                	mov    %eax,%edi
  800421c84e:	48 b8 eb c2 21 04 80 	movabs $0x800421c2eb,%rax
  800421c855:	00 00 00 
  800421c858:	ff d0                	callq  *%rax
            vmcs_write32( VMCS_32BIT_CONTROL_VMENTRY_CONTROLS, 
                    entry_ctls );

        }

        entry->msr_value = new_val;
  800421c85a:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421c85e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421c862:	48 89 50 08          	mov    %rdx,0x8(%rax)
        tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421c866:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421c86a:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800421c871:	c7 45 bc 0c 44 00 00 	movl   $0x440c,-0x44(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421c878:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800421c87b:	89 c7                	mov    %eax,%edi
  800421c87d:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421c884:	00 00 00 
  800421c887:	ff d0                	callq  *%rax
  800421c889:	89 c0                	mov    %eax,%eax
  800421c88b:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  800421c88f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421c893:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
        return true;
  800421c89a:	b8 01 00 00 00       	mov    $0x1,%eax
  800421c89f:	eb 05                	jmp    800421c8a6 <handle_wrmsr+0x16c>
    }

    return false;
  800421c8a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421c8a6:	48 83 c4 58          	add    $0x58,%rsp
  800421c8aa:	5b                   	pop    %rbx
  800421c8ab:	5d                   	pop    %rbp
  800421c8ac:	c3                   	retq   

000000800421c8ad <handle_eptviolation>:

bool
handle_eptviolation(uint64_t *eptrt, struct VmxGuestInfo *ginfo) {
  800421c8ad:	55                   	push   %rbp
  800421c8ae:	48 89 e5             	mov    %rsp,%rbp
  800421c8b1:	53                   	push   %rbx
  800421c8b2:	48 83 ec 48          	sub    $0x48,%rsp
  800421c8b6:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  800421c8ba:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800421c8be:	c7 45 cc 00 24 00 00 	movl   $0x2400,-0x34(%rbp)
}

static __inline uint64_t vmcs_read64(uint32_t field)
{
	return vmcs_readl(field);
  800421c8c5:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421c8c8:	89 c7                	mov    %eax,%edi
  800421c8ca:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421c8d1:	00 00 00 
  800421c8d4:	ff d0                	callq  *%rax
    uint64_t gpa = vmcs_read64(VMCS_64BIT_GUEST_PHYSICAL_ADDR);
  800421c8d6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    int r;
    if(gpa < 0xA0000 || (gpa >= 0x100000 && gpa < ginfo->phys_sz)) {
  800421c8da:	48 81 7d e8 ff ff 09 	cmpq   $0x9ffff,-0x18(%rbp)
  800421c8e1:	00 
  800421c8e2:	76 1f                	jbe    800421c903 <handle_eptviolation+0x56>
  800421c8e4:	48 81 7d e8 ff ff 0f 	cmpq   $0xfffff,-0x18(%rbp)
  800421c8eb:	00 
  800421c8ec:	0f 86 de 00 00 00    	jbe    800421c9d0 <handle_eptviolation+0x123>
  800421c8f2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421c8f6:	48 8b 00             	mov    (%rax),%rax
  800421c8f9:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  800421c8fd:	0f 86 cd 00 00 00    	jbe    800421c9d0 <handle_eptviolation+0x123>
        // Allocate a new page to the guest.
        struct PageInfo *p = page_alloc(0);
  800421c903:	bf 00 00 00 00       	mov    $0x0,%edi
  800421c908:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  800421c90f:	00 00 00 
  800421c912:	ff d0                	callq  *%rax
  800421c914:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
        if(!p)
  800421c918:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800421c91d:	75 0a                	jne    800421c929 <handle_eptviolation+0x7c>
            return false;
  800421c91f:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c924:	e9 32 01 00 00       	jmpq   800421ca5b <handle_eptviolation+0x1ae>
        p->pp_ref += 1;
  800421c929:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c92d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421c931:	8d 50 01             	lea    0x1(%rax),%edx
  800421c934:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c938:	66 89 50 08          	mov    %dx,0x8(%rax)
        r = ept_map_hva2gpa(eptrt, 
                page2kva(p), (void *)ROUNDDOWN(gpa, PGSIZE), __EPTE_FULL, 0);
  800421c93c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421c940:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800421c944:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421c948:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
        // Allocate a new page to the guest.
        struct PageInfo *p = page_alloc(0);
        if(!p)
            return false;
        p->pp_ref += 1;
        r = ept_map_hva2gpa(eptrt, 
  800421c94e:	48 89 c3             	mov    %rax,%rbx
  800421c951:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421c955:	48 89 c7             	mov    %rax,%rdi
  800421c958:	48 b8 f2 c3 21 04 80 	movabs $0x800421c3f2,%rax
  800421c95f:	00 00 00 
  800421c962:	ff d0                	callq  *%rax
  800421c964:	48 89 c6             	mov    %rax,%rsi
  800421c967:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421c96b:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421c971:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421c976:	48 89 da             	mov    %rbx,%rdx
  800421c979:	48 89 c7             	mov    %rax,%rdi
  800421c97c:	48 b8 88 94 21 04 80 	movabs $0x8004219488,%rax
  800421c983:	00 00 00 
  800421c986:	ff d0                	callq  *%rax
  800421c988:	89 45 e4             	mov    %eax,-0x1c(%rbp)
                page2kva(p), (void *)ROUNDDOWN(gpa, PGSIZE), __EPTE_FULL, 0);
        assert(r >= 0);
  800421c98b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421c98f:	79 35                	jns    800421c9c6 <handle_eptviolation+0x119>
  800421c991:	48 b9 d6 06 22 04 80 	movabs $0x80042206d6,%rcx
  800421c998:	00 00 00 
  800421c99b:	48 ba b3 06 22 04 80 	movabs $0x80042206b3,%rdx
  800421c9a2:	00 00 00 
  800421c9a5:	be 93 00 00 00       	mov    $0x93,%esi
  800421c9aa:	48 bf c8 06 22 04 80 	movabs $0x80042206c8,%rdi
  800421c9b1:	00 00 00 
  800421c9b4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421c9b9:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421c9c0:	00 00 00 
  800421c9c3:	41 ff d0             	callq  *%r8
        /* cprintf("EPT violation for gpa:%x mapped KVA:%x\n", gpa, page2kva(p)); */
        return true;
  800421c9c6:	b8 01 00 00 00       	mov    $0x1,%eax
  800421c9cb:	e9 8b 00 00 00       	jmpq   800421ca5b <handle_eptviolation+0x1ae>
    } else if (gpa >= CGA_BUF && gpa < CGA_BUF + PGSIZE) {
  800421c9d0:	48 81 7d e8 ff 7f 0b 	cmpq   $0xb7fff,-0x18(%rbp)
  800421c9d7:	00 
  800421c9d8:	76 7c                	jbe    800421ca56 <handle_eptviolation+0x1a9>
  800421c9da:	48 81 7d e8 ff 8f 0b 	cmpq   $0xb8fff,-0x18(%rbp)
  800421c9e1:	00 
  800421c9e2:	77 72                	ja     800421ca56 <handle_eptviolation+0x1a9>
        // FIXME: This give direct access to VGA MMIO region.
        r = ept_map_hva2gpa(eptrt, 
  800421c9e4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421c9e8:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421c9ee:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421c9f3:	ba 00 80 0b 00       	mov    $0xb8000,%edx
  800421c9f8:	48 be 00 80 0b 04 80 	movabs $0x80040b8000,%rsi
  800421c9ff:	00 00 00 
  800421ca02:	48 89 c7             	mov    %rax,%rdi
  800421ca05:	48 b8 88 94 21 04 80 	movabs $0x8004219488,%rax
  800421ca0c:	00 00 00 
  800421ca0f:	ff d0                	callq  *%rax
  800421ca11:	89 45 e4             	mov    %eax,-0x1c(%rbp)
                (void *)(KERNBASE + CGA_BUF), (void *)CGA_BUF, __EPTE_FULL, 0);
        assert(r >= 0);
  800421ca14:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421ca18:	79 35                	jns    800421ca4f <handle_eptviolation+0x1a2>
  800421ca1a:	48 b9 d6 06 22 04 80 	movabs $0x80042206d6,%rcx
  800421ca21:	00 00 00 
  800421ca24:	48 ba b3 06 22 04 80 	movabs $0x80042206b3,%rdx
  800421ca2b:	00 00 00 
  800421ca2e:	be 9a 00 00 00       	mov    $0x9a,%esi
  800421ca33:	48 bf c8 06 22 04 80 	movabs $0x80042206c8,%rdi
  800421ca3a:	00 00 00 
  800421ca3d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ca42:	49 b8 41 05 20 04 80 	movabs $0x8004200541,%r8
  800421ca49:	00 00 00 
  800421ca4c:	41 ff d0             	callq  *%r8
        return true;
  800421ca4f:	b8 01 00 00 00       	mov    $0x1,%eax
  800421ca54:	eb 05                	jmp    800421ca5b <handle_eptviolation+0x1ae>
    } 
    return false;
  800421ca56:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421ca5b:	48 83 c4 48          	add    $0x48,%rsp
  800421ca5f:	5b                   	pop    %rbx
  800421ca60:	5d                   	pop    %rbp
  800421ca61:	c3                   	retq   

000000800421ca62 <handle_ioinstr>:

bool
handle_ioinstr(struct Trapframe *tf, struct VmxGuestInfo *ginfo) {
  800421ca62:	55                   	push   %rbp
  800421ca63:	48 89 e5             	mov    %rsp,%rbp
  800421ca66:	53                   	push   %rbx
  800421ca67:	48 83 ec 38          	sub    $0x38,%rsp
  800421ca6b:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800421ca6f:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421ca73:	c7 45 d4 00 64 00 00 	movl   $0x6400,-0x2c(%rbp)
  800421ca7a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800421ca7d:	89 c7                	mov    %eax,%edi
  800421ca7f:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421ca86:	00 00 00 
  800421ca89:	ff d0                	callq  *%rax
    static int port_iortc;

    uint64_t qualification = vmcs_read64(VMCS_VMEXIT_QUALIFICATION);
  800421ca8b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    int port_number = (qualification >> 16) & 0xFFFF;
  800421ca8f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421ca93:	48 c1 e8 10          	shr    $0x10,%rax
  800421ca97:	25 ff ff 00 00       	and    $0xffff,%eax
  800421ca9c:	89 45 dc             	mov    %eax,-0x24(%rbp)
    bool is_in = BIT(qualification, 3);
  800421ca9f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421caa3:	48 c1 e8 03          	shr    $0x3,%rax
  800421caa7:	83 e0 01             	and    $0x1,%eax
  800421caaa:	48 85 c0             	test   %rax,%rax
  800421caad:	0f 95 c0             	setne  %al
  800421cab0:	88 45 db             	mov    %al,-0x25(%rbp)
    bool handled = false;
  800421cab3:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)

    // handle reading physical memory from the CMOS.
    if(port_number == IO_RTC) {
  800421cab7:	83 7d dc 70          	cmpl   $0x70,-0x24(%rbp)
  800421cabb:	75 2e                	jne    800421caeb <handle_ioinstr+0x89>
        if(!is_in) {
  800421cabd:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  800421cac1:	83 f0 01             	xor    $0x1,%eax
  800421cac4:	84 c0                	test   %al,%al
  800421cac6:	0f 84 de 00 00 00    	je     800421cbaa <handle_ioinstr+0x148>
            port_iortc = tf->tf_regs.reg_rax;
  800421cacc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421cad0:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421cad4:	89 c2                	mov    %eax,%edx
  800421cad6:	48 b8 6c e7 3a 04 80 	movabs $0x80043ae76c,%rax
  800421cadd:	00 00 00 
  800421cae0:	89 10                	mov    %edx,(%rax)
            handled = true;
  800421cae2:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  800421cae6:	e9 bf 00 00 00       	jmpq   800421cbaa <handle_ioinstr+0x148>
        }
    } else if (port_number == IO_RTC + 1) {
  800421caeb:	83 7d dc 71          	cmpl   $0x71,-0x24(%rbp)
  800421caef:	0f 85 b5 00 00 00    	jne    800421cbaa <handle_ioinstr+0x148>
        if(is_in) {
  800421caf5:	80 7d db 00          	cmpb   $0x0,-0x25(%rbp)
  800421caf9:	0f 84 ab 00 00 00    	je     800421cbaa <handle_ioinstr+0x148>
            if(port_iortc == NVRAM_BASELO) {
  800421caff:	48 b8 6c e7 3a 04 80 	movabs $0x80043ae76c,%rax
  800421cb06:	00 00 00 
  800421cb09:	8b 00                	mov    (%rax),%eax
  800421cb0b:	83 f8 15             	cmp    $0x15,%eax
  800421cb0e:	75 15                	jne    800421cb25 <handle_ioinstr+0xc3>
                tf->tf_regs.reg_rax = 640 & 0xFF;
  800421cb10:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421cb14:	48 c7 40 70 80 00 00 	movq   $0x80,0x70(%rax)
  800421cb1b:	00 
                handled = true;
  800421cb1c:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  800421cb20:	e9 85 00 00 00       	jmpq   800421cbaa <handle_ioinstr+0x148>
            } else if (port_iortc == NVRAM_BASEHI) {
  800421cb25:	48 b8 6c e7 3a 04 80 	movabs $0x80043ae76c,%rax
  800421cb2c:	00 00 00 
  800421cb2f:	8b 00                	mov    (%rax),%eax
  800421cb31:	83 f8 16             	cmp    $0x16,%eax
  800421cb34:	75 12                	jne    800421cb48 <handle_ioinstr+0xe6>
                tf->tf_regs.reg_rax = (640 >> 8) & 0xFF;
  800421cb36:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421cb3a:	48 c7 40 70 02 00 00 	movq   $0x2,0x70(%rax)
  800421cb41:	00 
                handled = true;
  800421cb42:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  800421cb46:	eb 62                	jmp    800421cbaa <handle_ioinstr+0x148>
            } else if (port_iortc == NVRAM_EXTLO) {
  800421cb48:	48 b8 6c e7 3a 04 80 	movabs $0x80043ae76c,%rax
  800421cb4f:	00 00 00 
  800421cb52:	8b 00                	mov    (%rax),%eax
  800421cb54:	83 f8 17             	cmp    $0x17,%eax
  800421cb57:	75 1c                	jne    800421cb75 <handle_ioinstr+0x113>
                tf->tf_regs.reg_rax = ((ginfo->phys_sz / 1024) - 1024) & 0xFF;
  800421cb59:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421cb5d:	48 8b 00             	mov    (%rax),%rax
  800421cb60:	48 c1 e8 0a          	shr    $0xa,%rax
  800421cb64:	0f b6 d0             	movzbl %al,%edx
  800421cb67:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421cb6b:	48 89 50 70          	mov    %rdx,0x70(%rax)
                handled = true;
  800421cb6f:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
  800421cb73:	eb 35                	jmp    800421cbaa <handle_ioinstr+0x148>
            } else if (port_iortc == NVRAM_EXTHI) {
  800421cb75:	48 b8 6c e7 3a 04 80 	movabs $0x80043ae76c,%rax
  800421cb7c:	00 00 00 
  800421cb7f:	8b 00                	mov    (%rax),%eax
  800421cb81:	83 f8 18             	cmp    $0x18,%eax
  800421cb84:	75 24                	jne    800421cbaa <handle_ioinstr+0x148>
                tf->tf_regs.reg_rax = (((ginfo->phys_sz / 1024) - 1024) >> 8) & 0xFF;
  800421cb86:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421cb8a:	48 8b 00             	mov    (%rax),%rax
  800421cb8d:	48 c1 e8 0a          	shr    $0xa,%rax
  800421cb91:	48 2d 00 04 00 00    	sub    $0x400,%rax
  800421cb97:	48 c1 e8 08          	shr    $0x8,%rax
  800421cb9b:	0f b6 d0             	movzbl %al,%edx
  800421cb9e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421cba2:	48 89 50 70          	mov    %rdx,0x70(%rax)
                handled = true;
  800421cba6:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
            }
        }

    } 
    if(handled) {
  800421cbaa:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800421cbae:	74 3b                	je     800421cbeb <handle_ioinstr+0x189>
        tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421cbb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421cbb4:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800421cbbb:	c7 45 d0 0c 44 00 00 	movl   $0x440c,-0x30(%rbp)
	return vmcs_readl(field);
}

static __inline uint32_t vmcs_read32(uint32_t field)
{
	return vmcs_readl(field);
  800421cbc2:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800421cbc5:	89 c7                	mov    %eax,%edi
  800421cbc7:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421cbce:	00 00 00 
  800421cbd1:	ff d0                	callq  *%rax
  800421cbd3:	89 c0                	mov    %eax,%eax
  800421cbd5:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  800421cbd9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421cbdd:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
        return true;
  800421cbe4:	b8 01 00 00 00       	mov    $0x1,%eax
  800421cbe9:	eb 33                	jmp    800421cc1e <handle_ioinstr+0x1bc>
    } else {
        cprintf("%x %x\n", qualification, port_iortc);
  800421cbeb:	48 b8 6c e7 3a 04 80 	movabs $0x80043ae76c,%rax
  800421cbf2:	00 00 00 
  800421cbf5:	8b 10                	mov    (%rax),%edx
  800421cbf7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421cbfb:	48 89 c6             	mov    %rax,%rsi
  800421cbfe:	48 bf dd 06 22 04 80 	movabs $0x80042206dd,%rdi
  800421cc05:	00 00 00 
  800421cc08:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cc0d:	48 b9 1a 96 20 04 80 	movabs $0x800420961a,%rcx
  800421cc14:	00 00 00 
  800421cc17:	ff d1                	callq  *%rcx
        return false;    
  800421cc19:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
  800421cc1e:	48 83 c4 38          	add    $0x38,%rsp
  800421cc22:	5b                   	pop    %rbx
  800421cc23:	5d                   	pop    %rbp
  800421cc24:	c3                   	retq   

000000800421cc25 <handle_cpuid>:
// Finally, you need to increment the program counter in the trap frame.
// 
// Hint: The TA's solution does not hard-code the length of the cpuid instruction.
bool
handle_cpuid(struct Trapframe *tf, struct VmxGuestInfo *ginfo)
{
  800421cc25:	55                   	push   %rbp
  800421cc26:	48 89 e5             	mov    %rsp,%rbp
  800421cc29:	53                   	push   %rbx
  800421cc2a:	48 83 ec 30          	sub    $0x30,%rsp
  800421cc2e:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  800421cc32:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    /* Your code here */
//    cprintf("Handle cpuid not implemented\n"); 

    uint32_t rax = (uint32_t) tf->tf_regs.reg_rax;
  800421cc36:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421cc3a:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421cc3e:	89 45 f4             	mov    %eax,-0xc(%rbp)
    uint32_t eax, ebx, ecx, edx;
    cpuid(rax, &eax, &ebx, &ecx, &edx );
  800421cc41:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  800421cc45:	48 8d 4d e4          	lea    -0x1c(%rbp),%rcx
  800421cc49:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
  800421cc4d:	48 8d 75 ec          	lea    -0x14(%rbp),%rsi
  800421cc51:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421cc54:	49 89 f8             	mov    %rdi,%r8
  800421cc57:	89 c7                	mov    %eax,%edi
  800421cc59:	48 b8 2e c3 21 04 80 	movabs $0x800421c32e,%rax
  800421cc60:	00 00 00 
  800421cc63:	ff d0                	callq  *%rax
    if (rax == 1)
  800421cc65:	83 7d f4 01          	cmpl   $0x1,-0xc(%rbp)
  800421cc69:	75 09                	jne    800421cc74 <handle_cpuid+0x4f>
    	ecx = ecx & ~(1<<5);
  800421cc6b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421cc6e:	83 e0 df             	and    $0xffffffdf,%eax
  800421cc71:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    
    tf->tf_regs.reg_rax = (uint64_t)eax;
  800421cc74:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421cc77:	89 c2                	mov    %eax,%edx
  800421cc79:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421cc7d:	48 89 50 70          	mov    %rdx,0x70(%rax)
    tf->tf_regs.reg_rbx = (uint64_t)ebx;
  800421cc81:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421cc84:	89 c2                	mov    %eax,%edx
  800421cc86:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421cc8a:	48 89 50 68          	mov    %rdx,0x68(%rax)
    tf->tf_regs.reg_rcx = (uint64_t)ecx;
  800421cc8e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421cc91:	89 c2                	mov    %eax,%edx
  800421cc93:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421cc97:	48 89 50 60          	mov    %rdx,0x60(%rax)
    tf->tf_regs.reg_rdx = (uint64_t)edx;
  800421cc9b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421cc9e:	89 c2                	mov    %eax,%edx
  800421cca0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421cca4:	48 89 50 58          	mov    %rdx,0x58(%rax)

    tf->tf_rip += vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH);
  800421cca8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ccac:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
  800421ccb3:	c7 45 f0 0c 44 00 00 	movl   $0x440c,-0x10(%rbp)
  800421ccba:	8b 45 f0             	mov    -0x10(%rbp),%eax
  800421ccbd:	89 c7                	mov    %eax,%edi
  800421ccbf:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421ccc6:	00 00 00 
  800421ccc9:	ff d0                	callq  *%rax
  800421cccb:	89 c0                	mov    %eax,%eax
  800421cccd:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  800421ccd1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ccd5:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	    
   return true;
  800421ccdc:	b8 01 00 00 00       	mov    $0x1,%eax

}
  800421cce1:	48 83 c4 30          	add    $0x30,%rsp
  800421cce5:	5b                   	pop    %rbx
  800421cce6:	5d                   	pop    %rbp
  800421cce7:	c3                   	retq   

000000800421cce8 <handle_vmcall>:
// 
// Hint: The TA's solution does not hard-code the length of the cpuid instruction.//

bool
handle_vmcall(struct Trapframe *tf, struct VmxGuestInfo *gInfo, uint64_t *eptrt)
{
  800421cce8:	55                   	push   %rbp
  800421cce9:	48 89 e5             	mov    %rsp,%rbp
  800421ccec:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800421ccf3:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800421ccfa:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800421cd01:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
    bool handled = false;
  800421cd08:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
	int result = 0;;
  800421cd0c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
    int perm, r;
    void *gpa_pg, *hva_pg;
    uint32_t val;
	uint64_t length_low;
	memory_map_t mmap_list[3];
	struct PageInfo *pp = NULL;
  800421cd13:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800421cd1a:	00 
  800421cd1b:	c7 45 c8 0c 44 00 00 	movl   $0x440c,-0x38(%rbp)
  800421cd22:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800421cd25:	89 c7                	mov    %eax,%edi
  800421cd27:	48 b8 11 c3 21 04 80 	movabs $0x800421c311,%rax
  800421cd2e:	00 00 00 
  800421cd31:	ff d0                	callq  *%rax
	uint64_t host_addr;
	uint32_t instr_length =vmcs_read32(VMCS_32BIT_VMEXIT_INSTRUCTION_LENGTH); 
  800421cd33:	89 45 ec             	mov    %eax,-0x14(%rbp)
	//cprintf("vmcall instr is  [%d]",tf->tf_regs.reg_rax );
    // phys address of the multiboot map in the guest.
    uint64_t multiboot_map_addr = 0x6000;
  800421cd36:	48 c7 45 e0 00 60 00 	movq   $0x6000,-0x20(%rbp)
  800421cd3d:	00 
    switch(tf->tf_regs.reg_rax) {
  800421cd3e:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421cd45:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421cd49:	48 83 f8 06          	cmp    $0x6,%rax
  800421cd4d:	0f 87 65 04 00 00    	ja     800421d1b8 <handle_vmcall+0x4d0>
  800421cd53:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421cd5a:	00 
  800421cd5b:	48 b8 88 07 22 04 80 	movabs $0x8004220788,%rax
  800421cd62:	00 00 00 
  800421cd65:	48 01 d0             	add    %rdx,%rax
  800421cd68:	48 8b 00             	mov    (%rax),%rax
  800421cd6b:	ff e0                	jmpq   *%rax
		    //   or allocate one and map it at the multiboot_map_addr (0x6000).
		    // Copy the mbinfo and memory_map_t (segment descriptions) into the guest page, and return
		    //   a pointer to this region in rbx (as a guest physical address).

			//Low memory segment:
			mmap_list[0].size = 20;
  800421cd6d:	c7 85 40 ff ff ff 14 	movl   $0x14,-0xc0(%rbp)
  800421cd74:	00 00 00 
		    mmap_list[0].base_addr_low = 0x0;
  800421cd77:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%rbp)
  800421cd7e:	00 00 00 
		    mmap_list[0].base_addr_high = 0x0;
  800421cd81:	c7 85 48 ff ff ff 00 	movl   $0x0,-0xb8(%rbp)
  800421cd88:	00 00 00 
		    mmap_list[0].length_low = IOPHYSMEM;
  800421cd8b:	c7 85 4c ff ff ff 00 	movl   $0xa0000,-0xb4(%rbp)
  800421cd92:	00 0a 00 
		    mmap_list[0].length_high = 0x0;
  800421cd95:	c7 85 50 ff ff ff 00 	movl   $0x0,-0xb0(%rbp)
  800421cd9c:	00 00 00 
		    mmap_list[0].type = MB_TYPE_USABLE;
  800421cd9f:	c7 85 54 ff ff ff 01 	movl   $0x1,-0xac(%rbp)
  800421cda6:	00 00 00 
			// IO Hole
		    mmap_list[1].size = 20;
  800421cda9:	c7 85 58 ff ff ff 14 	movl   $0x14,-0xa8(%rbp)
  800421cdb0:	00 00 00 
		    mmap_list[1].base_addr_low = IOPHYSMEM;
  800421cdb3:	c7 85 5c ff ff ff 00 	movl   $0xa0000,-0xa4(%rbp)
  800421cdba:	00 0a 00 
		    mmap_list[1].base_addr_high = 0x0;
  800421cdbd:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%rbp)
  800421cdc4:	00 00 00 
		    mmap_list[1].length_low = 0x60000;
  800421cdc7:	c7 85 64 ff ff ff 00 	movl   $0x60000,-0x9c(%rbp)
  800421cdce:	00 06 00 
		    mmap_list[1].length_high = 0x0;
  800421cdd1:	c7 85 68 ff ff ff 00 	movl   $0x0,-0x98(%rbp)
  800421cdd8:	00 00 00 
		    mmap_list[1].type = MB_TYPE_RESERVED;
  800421cddb:	c7 85 6c ff ff ff 02 	movl   $0x2,-0x94(%rbp)
  800421cde2:	00 00 00 
	        // PHYSZ - 1024 K(its 1 MB size, not a page or something)  this part may have a high addressas nonzero  
		    mmap_list[2].size = 20;
  800421cde5:	c7 85 70 ff ff ff 14 	movl   $0x14,-0x90(%rbp)
  800421cdec:	00 00 00 
		    mmap_list[2].base_addr_low = 0x100000;
  800421cdef:	c7 85 74 ff ff ff 00 	movl   $0x100000,-0x8c(%rbp)
  800421cdf6:	00 10 00 
		    mmap_list[2].base_addr_high = 0x0;
  800421cdf9:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%rbp)
  800421ce00:	00 00 00 
			length_low = gInfo->phys_sz - 0x100000;
  800421ce03:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  800421ce0a:	48 8b 00             	mov    (%rax),%rax
  800421ce0d:	48 2d 00 00 10 00    	sub    $0x100000,%rax
  800421ce13:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		    mmap_list[2].length_low = (uint32_t)((length_low <<32)>>32);
  800421ce17:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ce1b:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
		    mmap_list[2].length_high =(uint32_t)(length_low >> 32);
  800421ce21:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421ce25:	48 c1 e8 20          	shr    $0x20,%rax
  800421ce29:	89 45 80             	mov    %eax,-0x80(%rbp)
		    mmap_list[2].type = MB_TYPE_USABLE;
  800421ce2c:	c7 45 84 01 00 00 00 	movl   $0x1,-0x7c(%rbp)

		    mbinfo.flags = MB_FLAG_MMAP;// the 7th bit(flag[6]) represents the mmap addr and length fields enabled
  800421ce33:	c7 45 90 40 00 00 00 	movl   $0x40,-0x70(%rbp)
		    mbinfo.mmap_length = sizeof(mmap_list);
  800421ce3a:	c7 45 bc 48 00 00 00 	movl   $0x48,-0x44(%rbp)
		    mbinfo.mmap_addr =  multiboot_map_addr + sizeof(multiboot_info_t);
  800421ce41:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421ce45:	83 c0 34             	add    $0x34,%eax
  800421ce48:	89 45 c0             	mov    %eax,-0x40(%rbp)
		    // Once the map is ready, find the kernel virtual address of the guest page (if present),
		    //   or allocate one and map it at the multiboot_map_addr (0x6000).
			
	  		pp = page_alloc(ALLOC_ZERO);
  800421ce4b:	bf 01 00 00 00       	mov    $0x1,%edi
  800421ce50:	48 b8 54 2f 20 04 80 	movabs $0x8004202f54,%rax
  800421ce57:	00 00 00 
  800421ce5a:	ff d0                	callq  *%rax
  800421ce5c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		    if ( pp == NULL)
  800421ce60:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800421ce65:	75 0a                	jne    800421ce71 <handle_vmcall+0x189>
		    	return false;
  800421ce67:	b8 00 00 00 00       	mov    $0x0,%eax
  800421ce6c:	e9 73 03 00 00       	jmpq   800421d1e4 <handle_vmcall+0x4fc>
		    
		    pp->pp_ref++;
  800421ce71:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421ce75:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800421ce79:	8d 50 01             	lea    0x1(%rax),%edx
  800421ce7c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421ce80:	66 89 50 08          	mov    %dx,0x8(%rax)
		    host_addr = (uint64_t)page2kva(pp);
  800421ce84:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421ce88:	48 89 c7             	mov    %rax,%rdi
  800421ce8b:	48 b8 f2 c3 21 04 80 	movabs $0x800421c3f2,%rax
  800421ce92:	00 00 00 
  800421ce95:	ff d0                	callq  *%rax
  800421ce97:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

		    // Copy the mbinfo and memory_map_t (segment descriptions) into the guest page, and return
		    //   a pointer to this region in rbx (as a guest physical address).
			
			memcpy((void *)host_addr,(void *)& mbinfo, (size_t)sizeof(multiboot_info_t)); 
  800421ce9b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421ce9f:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800421cea3:	ba 34 00 00 00       	mov    $0x34,%edx
  800421cea8:	48 89 ce             	mov    %rcx,%rsi
  800421ceab:	48 89 c7             	mov    %rax,%rdi
  800421ceae:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  800421ceb5:	00 00 00 
  800421ceb8:	ff d0                	callq  *%rax
			memcpy(((void *)host_addr + sizeof(multiboot_info_t)), (void *)mmap_list,sizeof(mmap_list));
  800421ceba:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421cebe:	48 83 c0 34          	add    $0x34,%rax
  800421cec2:	48 8d 8d 40 ff ff ff 	lea    -0xc0(%rbp),%rcx
  800421cec9:	ba 48 00 00 00       	mov    $0x48,%edx
  800421cece:	48 89 ce             	mov    %rcx,%rsi
  800421ced1:	48 89 c7             	mov    %rax,%rdi
  800421ced4:	48 b8 2e 0d 21 04 80 	movabs $0x8004210d2e,%rax
  800421cedb:	00 00 00 
  800421cede:	ff d0                	callq  *%rax
			// yupp, overwrite it.
			ept_map_hva2gpa((epte_t*) eptrt, (void *) host_addr, (void *)multiboot_map_addr, __EPTE_FULL, 1);	
  800421cee0:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421cee4:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421cee8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800421ceef:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  800421cef5:	b9 07 00 00 00       	mov    $0x7,%ecx
  800421cefa:	48 89 c7             	mov    %rax,%rdi
  800421cefd:	48 b8 88 94 21 04 80 	movabs $0x8004219488,%rax
  800421cf04:	00 00 00 
  800421cf07:	ff d0                	callq  *%rax
		    tf->tf_regs.reg_rbx = (uint64_t) multiboot_map_addr;
  800421cf09:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421cf10:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421cf14:	48 89 50 68          	mov    %rdx,0x68(%rax)
		    /* Your code here */
		    cprintf("e820 map hypercall done\n");	    
  800421cf18:	48 bf e4 06 22 04 80 	movabs $0x80042206e4,%rdi
  800421cf1f:	00 00 00 
  800421cf22:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cf27:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421cf2e:	00 00 00 
  800421cf31:	ff d2                	callq  *%rdx
		    handled = true;
  800421cf33:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
		    break;
  800421cf37:	e9 7c 02 00 00       	jmpq   800421d1b8 <handle_vmcall+0x4d0>
				   "S" (a5)
				 : "cc", "memory");

		*/
	    {
	    struct Env  * env_store = NULL;
  800421cf3c:	48 c7 85 38 ff ff ff 	movq   $0x0,-0xc8(%rbp)
  800421cf43:	00 00 00 00 
		envid_t envId = tf->tf_regs.reg_rdx;
  800421cf47:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421cf4e:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421cf52:	89 45 cc             	mov    %eax,-0x34(%rbp)
		envid2env(envId,&env_store,0);
  800421cf55:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800421cf5c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421cf5f:	ba 00 00 00 00       	mov    $0x0,%edx
  800421cf64:	48 89 ce             	mov    %rcx,%rsi
  800421cf67:	89 c7                	mov    %eax,%edi
  800421cf69:	48 b8 7d 78 20 04 80 	movabs $0x800420787d,%rax
  800421cf70:	00 00 00 
  800421cf73:	ff d0                	callq  *%rax
		cprintf("sys ipc try send : [%d]",result);
  800421cf75:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421cf78:	89 c6                	mov    %eax,%esi
  800421cf7a:	48 bf fd 06 22 04 80 	movabs $0x80042206fd,%rdi
  800421cf81:	00 00 00 
  800421cf84:	b8 00 00 00 00       	mov    $0x0,%eax
  800421cf89:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421cf90:	00 00 00 
  800421cf93:	ff d2                	callq  *%rdx
		if((env_store)&&(env_store->env_type ==ENV_TYPE_FS) &&(curenv->env_type == ENV_TYPE_GUEST)){
  800421cf95:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800421cf9c:	48 85 c0             	test   %rax,%rax
  800421cf9f:	0f 84 97 00 00 00    	je     800421d03c <handle_vmcall+0x354>
  800421cfa5:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  800421cfac:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421cfb2:	83 f8 01             	cmp    $0x1,%eax
  800421cfb5:	0f 85 81 00 00 00    	jne    800421d03c <handle_vmcall+0x354>
  800421cfbb:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421cfc2:	00 00 00 
  800421cfc5:	ff d0                	callq  *%rax
  800421cfc7:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421cfce:	00 00 00 
  800421cfd1:	48 98                	cltq   
  800421cfd3:	48 c1 e0 03          	shl    $0x3,%rax
  800421cfd7:	48 89 c1             	mov    %rax,%rcx
  800421cfda:	48 c1 e1 04          	shl    $0x4,%rcx
  800421cfde:	48 01 c8             	add    %rcx,%rax
  800421cfe1:	48 01 d0             	add    %rdx,%rax
  800421cfe4:	48 83 c0 08          	add    $0x8,%rax
  800421cfe8:	48 8b 00             	mov    (%rax),%rax
  800421cfeb:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  800421cff1:	83 f8 03             	cmp    $0x3,%eax
  800421cff4:	75 46                	jne    800421d03c <handle_vmcall+0x354>
			result = syscall(SYS_ipc_try_send,(uint64_t) envId, (uint64_t)tf->tf_regs.reg_rcx,
  800421cff6:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421cffd:	48 8b 70 48          	mov    0x48(%rax),%rsi
  800421d001:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d008:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800421d00c:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d013:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800421d017:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800421d01a:	48 98                	cltq   
  800421d01c:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421d022:	49 89 f0             	mov    %rsi,%r8
  800421d025:	48 89 c6             	mov    %rax,%rsi
  800421d028:	bf 0c 00 00 00       	mov    $0xc,%edi
  800421d02d:	48 b8 ba ed 20 04 80 	movabs $0x800420edba,%rax
  800421d034:	00 00 00 
  800421d037:	ff d0                	callq  *%rax
  800421d039:	89 45 f8             	mov    %eax,-0x8(%rbp)
									(uint64_t)tf->tf_regs.reg_rbx, (uint64_t)tf->tf_regs.reg_rdi,0);
		}
		tf->tf_regs.reg_rax = result;
  800421d03c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421d03f:	48 63 d0             	movslq %eax,%rdx
  800421d042:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d049:	48 89 50 70          	mov    %rdx,0x70(%rax)
		cprintf("sys ipc try send : [%d]",result);
  800421d04d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421d050:	89 c6                	mov    %eax,%esi
  800421d052:	48 bf fd 06 22 04 80 	movabs $0x80042206fd,%rdi
  800421d059:	00 00 00 
  800421d05c:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d061:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421d068:	00 00 00 
  800421d06b:	ff d2                	callq  *%rdx
	    handled = true;
  800421d06d:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
            break;
  800421d071:	90                   	nop
  800421d072:	e9 41 01 00 00       	jmpq   800421d1b8 <handle_vmcall+0x4d0>
	    // NB: because recv can call schedule, clobbering the VMCS, 
	    // you should go ahead and increment rip before this call.
	    /* Your code here */
	   	   // cprintf("IPC recv hypercall not implemented\n");	

			tf->tf_rip +=instr_length;
  800421d077:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d07e:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800421d085:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421d088:	48 01 c2             	add    %rax,%rdx
  800421d08b:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d092:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	   	    tf->tf_regs.reg_rax = syscall(SYS_ipc_recv, (uint64_t)tf->tf_regs.reg_rdx,0,0,0,0);
  800421d099:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d0a0:	48 8b 40 58          	mov    0x58(%rax),%rax
  800421d0a4:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800421d0aa:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800421d0b0:	b9 00 00 00 00       	mov    $0x0,%ecx
  800421d0b5:	ba 00 00 00 00       	mov    $0x0,%edx
  800421d0ba:	48 89 c6             	mov    %rax,%rsi
  800421d0bd:	bf 0d 00 00 00       	mov    $0xd,%edi
  800421d0c2:	48 b8 ba ed 20 04 80 	movabs $0x800420edba,%rax
  800421d0c9:	00 00 00 
  800421d0cc:	ff d0                	callq  *%rax
  800421d0ce:	48 89 c2             	mov    %rax,%rdx
  800421d0d1:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d0d8:	48 89 50 70          	mov    %rdx,0x70(%rax)
			cprintf("sys ipc try recv : [%d]",tf->tf_regs.reg_rax);
  800421d0dc:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d0e3:	48 8b 40 70          	mov    0x70(%rax),%rax
  800421d0e7:	48 89 c6             	mov    %rax,%rsi
  800421d0ea:	48 bf 15 07 22 04 80 	movabs $0x8004220715,%rdi
  800421d0f1:	00 00 00 
  800421d0f4:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d0f9:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421d100:	00 00 00 
  800421d103:	ff d2                	callq  *%rdx
            handled = true;
  800421d105:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
            break;
  800421d109:	e9 aa 00 00 00       	jmpq   800421d1b8 <handle_vmcall+0x4d0>
        case VMX_VMCALL_LAPICEOI:
        	lapic_eoi();
  800421d10e:	48 b8 cf 7b 21 04 80 	movabs $0x8004217bcf,%rax
  800421d115:	00 00 00 
  800421d118:	ff d0                	callq  *%rax
        	handled = true;
  800421d11a:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
        	break;
  800421d11e:	e9 95 00 00 00       	jmpq   800421d1b8 <handle_vmcall+0x4d0>
        case VMX_VMCALL_BACKTOHOST:
        	cprintf("Now back to the host, VM halt in the background, run vmmanager to resume the VM.\n");
  800421d123:	48 bf 30 07 22 04 80 	movabs $0x8004220730,%rdi
  800421d12a:	00 00 00 
  800421d12d:	b8 00 00 00 00       	mov    $0x0,%eax
  800421d132:	48 ba 1a 96 20 04 80 	movabs $0x800420961a,%rdx
  800421d139:	00 00 00 
  800421d13c:	ff d2                	callq  *%rdx
        	curenv->env_status = ENV_NOT_RUNNABLE;	//mark the guest not runable
  800421d13e:	48 b8 9a 7b 21 04 80 	movabs $0x8004217b9a,%rax
  800421d145:	00 00 00 
  800421d148:	ff d0                	callq  *%rax
  800421d14a:	48 ba 20 00 3b 04 80 	movabs $0x80043b0020,%rdx
  800421d151:	00 00 00 
  800421d154:	48 98                	cltq   
  800421d156:	48 c1 e0 03          	shl    $0x3,%rax
  800421d15a:	48 89 c1             	mov    %rax,%rcx
  800421d15d:	48 c1 e1 04          	shl    $0x4,%rcx
  800421d161:	48 01 c8             	add    %rcx,%rax
  800421d164:	48 01 d0             	add    %rdx,%rax
  800421d167:	48 83 c0 08          	add    $0x8,%rax
  800421d16b:	48 8b 00             	mov    (%rax),%rax
  800421d16e:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800421d175:	00 00 00 
        	ENV_CREATE(user_sh, ENV_TYPE_USER);	//create a new host shell
  800421d178:	be 00 00 00 00       	mov    $0x0,%esi
  800421d17d:	48 bf f6 1f 39 04 80 	movabs $0x8004391ff6,%rdi
  800421d184:	00 00 00 
  800421d187:	48 b8 56 88 20 04 80 	movabs $0x8004208856,%rax
  800421d18e:	00 00 00 
  800421d191:	ff d0                	callq  *%rax
        	handled = true;
  800421d193:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
        	break;	
  800421d197:	eb 1f                	jmp    800421d1b8 <handle_vmcall+0x4d0>
        case VMX_VMCALL_GETDISKIMGNUM:	//alloc a number to guest
        	tf->tf_regs.reg_rax = vmdisk_number;
  800421d199:	48 b8 68 e7 3a 04 80 	movabs $0x80043ae768,%rax
  800421d1a0:	00 00 00 
  800421d1a3:	8b 00                	mov    (%rax),%eax
  800421d1a5:	48 63 d0             	movslq %eax,%rdx
  800421d1a8:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d1af:	48 89 50 70          	mov    %rdx,0x70(%rax)
        	handled = true;
  800421d1b3:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
        	break;
  800421d1b7:	90                   	nop
         
    }
    if(handled) {
  800421d1b8:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800421d1bc:	74 22                	je     800421d1e0 <handle_vmcall+0x4f8>
	    /* Advance the program counter by the length of the vmcall instruction. 
	     * 
	     * Hint: The TA solution does not hard-code the length of the vmcall instruction.
	     */
	    /* Your code here */
		tf->tf_rip += instr_length;
  800421d1be:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d1c5:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800421d1cc:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421d1cf:	48 01 c2             	add    %rax,%rdx
  800421d1d2:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421d1d9:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
    }
    return handled;
  800421d1e0:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
}
  800421d1e4:	c9                   	leaveq 
  800421d1e5:	c3                   	retq   
