
vmm/guest/obj/kern/kernel:     file format elf64-x86-64


Disassembly of section .bootstrap:

0000000000100000 <_head64>:
_head64:

# Save multiboot_info addr passed by bootloader
#ifdef VMM_GUEST
// VMCALL to the VMM to get a multiboot map.
    movl $VMX_VMCALL_MBMAP, %eax
  100000:	b8 01 00 00 00       	mov    $0x1,%eax
    vmcall
  100005:	0f 01 c1             	vmcall 
#endif

    movl $multiboot_info, %eax
  100008:	b8 00 70 10 00       	mov    $0x107000,%eax
    movl %ebx, (%eax)
  10000d:	89 18                	mov    %ebx,(%rax)
#ifndef VMM_GUEST
    movw $0x1234,0x472			# warm boot
#endif

# Reset the stack pointer in case we didn't come from the loader
    movl $0x7c00,%esp
  10000f:	bc 00 7c 00 00       	mov    $0x7c00,%esp

    call verify_cpu   #check if CPU supports long mode
  100014:	e8 cc 00 00 00       	callq  1000e5 <verify_cpu>
#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
  100019:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif
    movl %eax,%cr4
  10001e:	0f 22 e0             	mov    %rax,%cr4

# build an early boot pml4 at physical address pml4phys 

    #initializing the page tables
    movl $pml4,%edi
  100021:	bf 00 20 10 00       	mov    $0x102000,%edi
    xorl %eax,%eax
  100026:	31 c0                	xor    %eax,%eax
    movl $((4096/4)*5),%ecx  # moving these many words to the 6 pages with 4 second level pages + 1 3rd level + 1 4th level pages 
  100028:	b9 00 14 00 00       	mov    $0x1400,%ecx
    rep stosl
  10002d:	f3 ab                	rep stos %eax,%es:(%rdi)
    # creating a 4G boot page table
    # setting the 4th level page table only the second entry needed (PML4)
    movl $pml4,%eax
  10002f:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl $pdpt1, %ebx
  100034:	bb 00 30 10 00       	mov    $0x103000,%ebx
    orl $PTE_P,%ebx
  100039:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10003c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%eax)
  10003f:	89 18                	mov    %ebx,(%rax)

    movl $pdpt2, %ebx
  100041:	bb 00 40 10 00       	mov    $0x104000,%ebx
    orl $PTE_P,%ebx
  100046:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  100049:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,0x8(%eax)
  10004c:	89 58 08             	mov    %ebx,0x8(%rax)

    # setting the 3rd level page table (PDPE)
    # 4 entries (counter in ecx), point to the next four physical pages (pgdirs)
    # pgdirs in 0xa0000--0xd000
    movl $pdpt1,%edi
  10004f:	bf 00 30 10 00       	mov    $0x103000,%edi
    movl $pde1,%ebx
  100054:	bb 00 50 10 00       	mov    $0x105000,%ebx
    orl $PTE_P,%ebx
  100059:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10005c:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  10005f:	89 1f                	mov    %ebx,(%rdi)

    movl $pdpt2,%edi
  100061:	bf 00 40 10 00       	mov    $0x104000,%edi
    movl $pde2,%ebx
  100066:	bb 00 60 10 00       	mov    $0x106000,%ebx
    orl $PTE_P,%ebx
  10006b:	83 cb 01             	or     $0x1,%ebx
    orl $PTE_W,%ebx
  10006e:	83 cb 02             	or     $0x2,%ebx
    movl %ebx,(%edi)
  100071:	89 1f                	mov    %ebx,(%rdi)
    
    # setting the pgdir so that the LA=PA
    # mapping first 1G of mem at KERNBASE
    movl $128,%ecx
  100073:	b9 80 00 00 00       	mov    $0x80,%ecx
    # Start at the end and work backwards
    #leal (pml4 + 5*0x1000 - 0x8),%edi
    movl $pde1,%edi
  100078:	bf 00 50 10 00       	mov    $0x105000,%edi
    movl $pde2,%ebx
  10007d:	bb 00 60 10 00       	mov    $0x106000,%ebx
    #64th entry - 0x8004000000
    addl $256,%ebx 
  100082:	81 c3 00 01 00 00    	add    $0x100,%ebx
    # PTE_P|PTE_W|PTE_MBZ
    movl $0x00000183,%eax
  100088:	b8 83 01 00 00       	mov    $0x183,%eax
  1:
     movl %eax,(%edi)
  10008d:	89 07                	mov    %eax,(%rdi)
     movl %eax,(%ebx)
  10008f:	89 03                	mov    %eax,(%rbx)
     addl $0x8,%edi
  100091:	83 c7 08             	add    $0x8,%edi
     addl $0x8,%ebx
  100094:	83 c3 08             	add    $0x8,%ebx
     addl $0x00200000,%eax
  100097:	05 00 00 20 00       	add    $0x200000,%eax
     subl $1,%ecx
  10009c:	83 e9 01             	sub    $0x1,%ecx
     cmp $0x0,%ecx
  10009f:	83 f9 00             	cmp    $0x0,%ecx
     jne 1b
  1000a2:	75 e9                	jne    10008d <_head64+0x8d>
 /*    subl $1,%ecx */
 /*    cmp $0x0,%ecx */
 /*    jne 1b */

    # set the cr3 register
    movl $pml4,%eax
  1000a4:	b8 00 20 10 00       	mov    $0x102000,%eax
    movl %eax, %cr3
  1000a9:	0f 22 d8             	mov    %rax,%cr3

	
    # enable the long mode in MSR
    movl $EFER_MSR,%ecx
  1000ac:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
    rdmsr
  1000b1:	0f 32                	rdmsr  
    btsl $EFER_LME,%eax
  1000b3:	0f ba e8 08          	bts    $0x8,%eax
    wrmsr
  1000b7:	0f 30                	wrmsr  
    
    # enable paging 
    movl %cr0,%eax
  1000b9:	0f 20 c0             	mov    %cr0,%rax
    orl $CR0_PE,%eax
  1000bc:	83 c8 01             	or     $0x1,%eax
    orl $CR0_PG,%eax
  1000bf:	0d 00 00 00 80       	or     $0x80000000,%eax
    orl $CR0_AM,%eax
  1000c4:	0d 00 00 04 00       	or     $0x40000,%eax
    orl $CR0_WP,%eax
  1000c9:	0d 00 00 01 00       	or     $0x10000,%eax
    orl $CR0_MP,%eax
  1000ce:	83 c8 02             	or     $0x2,%eax
    movl %eax,%cr0
  1000d1:	0f 22 c0             	mov    %rax,%cr0
    #jump to long mode with CS=0 and

    movl $gdtdesc_64,%eax
  1000d4:	b8 18 10 10 00       	mov    $0x101018,%eax
    lgdt (%eax)
  1000d9:	0f 01 10             	lgdt   (%rax)
    pushl $0x8
  1000dc:	6a 08                	pushq  $0x8
    movl $_start,%eax
  1000de:	b8 0c 00 20 00       	mov    $0x20000c,%eax
    pushl %eax
  1000e3:	50                   	push   %rax

00000000001000e4 <jumpto_longmode>:
    
    .globl jumpto_longmode
    .type jumpto_longmode,@function
jumpto_longmode:
    lret
  1000e4:	cb                   	lret   

00000000001000e5 <verify_cpu>:
/*     movabs $_back_from_head64, %rax */
/*     pushq %rax */
/*     lretq */

verify_cpu:
    pushfl                   # get eflags in eax -- standardard way to check for cpuid
  1000e5:	9c                   	pushfq 
    popl %eax
  1000e6:	58                   	pop    %rax
    movl %eax,%ecx
  1000e7:	89 c1                	mov    %eax,%ecx
    xorl $0x200000, %eax
  1000e9:	35 00 00 20 00       	xor    $0x200000,%eax
    pushl %eax
  1000ee:	50                   	push   %rax
    popfl
  1000ef:	9d                   	popfq  
    pushfl
  1000f0:	9c                   	pushfq 
    popl %eax
  1000f1:	58                   	pop    %rax
    cmpl %eax,%ebx
  1000f2:	39 c3                	cmp    %eax,%ebx
    jz verify_cpu_no_longmode   # no cpuid -- no long mode
  1000f4:	74 1c                	je     100112 <verify_cpu_no_longmode>

    movl $0x0,%eax              # see if cpuid 1 is implemented
  1000f6:	b8 00 00 00 00       	mov    $0x0,%eax
    cpuid
  1000fb:	0f a2                	cpuid  
    cmpl $0x1,%eax
  1000fd:	83 f8 01             	cmp    $0x1,%eax
    jb verify_cpu_no_longmode    # cpuid 1 is not implemented
  100100:	72 10                	jb     100112 <verify_cpu_no_longmode>


    mov $0x80000001, %eax
  100102:	b8 01 00 00 80       	mov    $0x80000001,%eax
    cpuid                 
  100107:	0f a2                	cpuid  
    test $(1 << 29),%edx                 #Test if the LM-bit, is set or not.
  100109:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
    jz verify_cpu_no_longmode
  10010f:	74 01                	je     100112 <verify_cpu_no_longmode>

    ret
  100111:	c3                   	retq   

0000000000100112 <verify_cpu_no_longmode>:

verify_cpu_no_longmode:
    jmp verify_cpu_no_longmode
  100112:	eb fe                	jmp    100112 <verify_cpu_no_longmode>
  100114:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10011b:	00 00 00 
  10011e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100125:	00 00 00 
  100128:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10012f:	00 00 00 
  100132:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100139:	00 00 00 
  10013c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100143:	00 00 00 
  100146:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10014d:	00 00 00 
  100150:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100157:	00 00 00 
  10015a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100161:	00 00 00 
  100164:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10016b:	00 00 00 
  10016e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100175:	00 00 00 
  100178:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10017f:	00 00 00 
  100182:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100189:	00 00 00 
  10018c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100193:	00 00 00 
  100196:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10019d:	00 00 00 
  1001a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001a7:	00 00 00 
  1001aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001b1:	00 00 00 
  1001b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001bb:	00 00 00 
  1001be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001c5:	00 00 00 
  1001c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001cf:	00 00 00 
  1001d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001d9:	00 00 00 
  1001dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001e3:	00 00 00 
  1001e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001ed:	00 00 00 
  1001f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1001f7:	00 00 00 
  1001fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100201:	00 00 00 
  100204:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10020b:	00 00 00 
  10020e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100215:	00 00 00 
  100218:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10021f:	00 00 00 
  100222:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100229:	00 00 00 
  10022c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100233:	00 00 00 
  100236:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10023d:	00 00 00 
  100240:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100247:	00 00 00 
  10024a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100251:	00 00 00 
  100254:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10025b:	00 00 00 
  10025e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100265:	00 00 00 
  100268:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10026f:	00 00 00 
  100272:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100279:	00 00 00 
  10027c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100283:	00 00 00 
  100286:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10028d:	00 00 00 
  100290:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100297:	00 00 00 
  10029a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002a1:	00 00 00 
  1002a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002ab:	00 00 00 
  1002ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002b5:	00 00 00 
  1002b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002bf:	00 00 00 
  1002c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002c9:	00 00 00 
  1002cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002d3:	00 00 00 
  1002d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002dd:	00 00 00 
  1002e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002e7:	00 00 00 
  1002ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002f1:	00 00 00 
  1002f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1002fb:	00 00 00 
  1002fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100305:	00 00 00 
  100308:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10030f:	00 00 00 
  100312:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100319:	00 00 00 
  10031c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100323:	00 00 00 
  100326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10032d:	00 00 00 
  100330:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100337:	00 00 00 
  10033a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100341:	00 00 00 
  100344:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10034b:	00 00 00 
  10034e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100355:	00 00 00 
  100358:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10035f:	00 00 00 
  100362:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100369:	00 00 00 
  10036c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100373:	00 00 00 
  100376:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10037d:	00 00 00 
  100380:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100387:	00 00 00 
  10038a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100391:	00 00 00 
  100394:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10039b:	00 00 00 
  10039e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003a5:	00 00 00 
  1003a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003af:	00 00 00 
  1003b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003b9:	00 00 00 
  1003bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003c3:	00 00 00 
  1003c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003cd:	00 00 00 
  1003d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003d7:	00 00 00 
  1003da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003e1:	00 00 00 
  1003e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003eb:	00 00 00 
  1003ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003f5:	00 00 00 
  1003f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1003ff:	00 00 00 
  100402:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100409:	00 00 00 
  10040c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100413:	00 00 00 
  100416:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10041d:	00 00 00 
  100420:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100427:	00 00 00 
  10042a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100431:	00 00 00 
  100434:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10043b:	00 00 00 
  10043e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100445:	00 00 00 
  100448:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10044f:	00 00 00 
  100452:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100459:	00 00 00 
  10045c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100463:	00 00 00 
  100466:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10046d:	00 00 00 
  100470:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100477:	00 00 00 
  10047a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100481:	00 00 00 
  100484:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10048b:	00 00 00 
  10048e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100495:	00 00 00 
  100498:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10049f:	00 00 00 
  1004a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004a9:	00 00 00 
  1004ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004b3:	00 00 00 
  1004b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004bd:	00 00 00 
  1004c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004c7:	00 00 00 
  1004ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004d1:	00 00 00 
  1004d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004db:	00 00 00 
  1004de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004e5:	00 00 00 
  1004e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004ef:	00 00 00 
  1004f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1004f9:	00 00 00 
  1004fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100503:	00 00 00 
  100506:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10050d:	00 00 00 
  100510:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100517:	00 00 00 
  10051a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100521:	00 00 00 
  100524:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10052b:	00 00 00 
  10052e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100535:	00 00 00 
  100538:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10053f:	00 00 00 
  100542:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100549:	00 00 00 
  10054c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100553:	00 00 00 
  100556:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10055d:	00 00 00 
  100560:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100567:	00 00 00 
  10056a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100571:	00 00 00 
  100574:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10057b:	00 00 00 
  10057e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100585:	00 00 00 
  100588:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10058f:	00 00 00 
  100592:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100599:	00 00 00 
  10059c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005a3:	00 00 00 
  1005a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005ad:	00 00 00 
  1005b0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005b7:	00 00 00 
  1005ba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005c1:	00 00 00 
  1005c4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005cb:	00 00 00 
  1005ce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005d5:	00 00 00 
  1005d8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005df:	00 00 00 
  1005e2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005e9:	00 00 00 
  1005ec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005f3:	00 00 00 
  1005f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1005fd:	00 00 00 
  100600:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100607:	00 00 00 
  10060a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100611:	00 00 00 
  100614:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10061b:	00 00 00 
  10061e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100625:	00 00 00 
  100628:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10062f:	00 00 00 
  100632:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100639:	00 00 00 
  10063c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100643:	00 00 00 
  100646:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10064d:	00 00 00 
  100650:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100657:	00 00 00 
  10065a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100661:	00 00 00 
  100664:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10066b:	00 00 00 
  10066e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100675:	00 00 00 
  100678:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10067f:	00 00 00 
  100682:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100689:	00 00 00 
  10068c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100693:	00 00 00 
  100696:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10069d:	00 00 00 
  1006a0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006a7:	00 00 00 
  1006aa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006b1:	00 00 00 
  1006b4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006bb:	00 00 00 
  1006be:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006c5:	00 00 00 
  1006c8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006cf:	00 00 00 
  1006d2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006d9:	00 00 00 
  1006dc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006e3:	00 00 00 
  1006e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006ed:	00 00 00 
  1006f0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1006f7:	00 00 00 
  1006fa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100701:	00 00 00 
  100704:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10070b:	00 00 00 
  10070e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100715:	00 00 00 
  100718:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10071f:	00 00 00 
  100722:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100729:	00 00 00 
  10072c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100733:	00 00 00 
  100736:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10073d:	00 00 00 
  100740:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100747:	00 00 00 
  10074a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100751:	00 00 00 
  100754:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10075b:	00 00 00 
  10075e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100765:	00 00 00 
  100768:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10076f:	00 00 00 
  100772:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100779:	00 00 00 
  10077c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100783:	00 00 00 
  100786:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10078d:	00 00 00 
  100790:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100797:	00 00 00 
  10079a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007a1:	00 00 00 
  1007a4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007ab:	00 00 00 
  1007ae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007b5:	00 00 00 
  1007b8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007bf:	00 00 00 
  1007c2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007c9:	00 00 00 
  1007cc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007d3:	00 00 00 
  1007d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007dd:	00 00 00 
  1007e0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007e7:	00 00 00 
  1007ea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007f1:	00 00 00 
  1007f4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1007fb:	00 00 00 
  1007fe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100805:	00 00 00 
  100808:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10080f:	00 00 00 
  100812:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100819:	00 00 00 
  10081c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100823:	00 00 00 
  100826:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10082d:	00 00 00 
  100830:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100837:	00 00 00 
  10083a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100841:	00 00 00 
  100844:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10084b:	00 00 00 
  10084e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100855:	00 00 00 
  100858:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10085f:	00 00 00 
  100862:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100869:	00 00 00 
  10086c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100873:	00 00 00 
  100876:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10087d:	00 00 00 
  100880:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100887:	00 00 00 
  10088a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100891:	00 00 00 
  100894:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10089b:	00 00 00 
  10089e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008a5:	00 00 00 
  1008a8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008af:	00 00 00 
  1008b2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008b9:	00 00 00 
  1008bc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008c3:	00 00 00 
  1008c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008cd:	00 00 00 
  1008d0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008d7:	00 00 00 
  1008da:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008e1:	00 00 00 
  1008e4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008eb:	00 00 00 
  1008ee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008f5:	00 00 00 
  1008f8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1008ff:	00 00 00 
  100902:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100909:	00 00 00 
  10090c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100913:	00 00 00 
  100916:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10091d:	00 00 00 
  100920:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100927:	00 00 00 
  10092a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100931:	00 00 00 
  100934:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10093b:	00 00 00 
  10093e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100945:	00 00 00 
  100948:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10094f:	00 00 00 
  100952:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100959:	00 00 00 
  10095c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100963:	00 00 00 
  100966:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10096d:	00 00 00 
  100970:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100977:	00 00 00 
  10097a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100981:	00 00 00 
  100984:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10098b:	00 00 00 
  10098e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100995:	00 00 00 
  100998:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  10099f:	00 00 00 
  1009a2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009a9:	00 00 00 
  1009ac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009b3:	00 00 00 
  1009b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009bd:	00 00 00 
  1009c0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009c7:	00 00 00 
  1009ca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009d1:	00 00 00 
  1009d4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009db:	00 00 00 
  1009de:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009e5:	00 00 00 
  1009e8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009ef:	00 00 00 
  1009f2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  1009f9:	00 00 00 
  1009fc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a03:	00 00 00 
  100a06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a0d:	00 00 00 
  100a10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a17:	00 00 00 
  100a1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a21:	00 00 00 
  100a24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a2b:	00 00 00 
  100a2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a35:	00 00 00 
  100a38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a3f:	00 00 00 
  100a42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a49:	00 00 00 
  100a4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a53:	00 00 00 
  100a56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a5d:	00 00 00 
  100a60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a67:	00 00 00 
  100a6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a71:	00 00 00 
  100a74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a7b:	00 00 00 
  100a7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a85:	00 00 00 
  100a88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a8f:	00 00 00 
  100a92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100a99:	00 00 00 
  100a9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aa3:	00 00 00 
  100aa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100aad:	00 00 00 
  100ab0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ab7:	00 00 00 
  100aba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ac1:	00 00 00 
  100ac4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100acb:	00 00 00 
  100ace:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ad5:	00 00 00 
  100ad8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100adf:	00 00 00 
  100ae2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ae9:	00 00 00 
  100aec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100af3:	00 00 00 
  100af6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100afd:	00 00 00 
  100b00:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b07:	00 00 00 
  100b0a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b11:	00 00 00 
  100b14:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b1b:	00 00 00 
  100b1e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b25:	00 00 00 
  100b28:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b2f:	00 00 00 
  100b32:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b39:	00 00 00 
  100b3c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b43:	00 00 00 
  100b46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b4d:	00 00 00 
  100b50:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b57:	00 00 00 
  100b5a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b61:	00 00 00 
  100b64:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b6b:	00 00 00 
  100b6e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b75:	00 00 00 
  100b78:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b7f:	00 00 00 
  100b82:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b89:	00 00 00 
  100b8c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b93:	00 00 00 
  100b96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100b9d:	00 00 00 
  100ba0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ba7:	00 00 00 
  100baa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bb1:	00 00 00 
  100bb4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bbb:	00 00 00 
  100bbe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bc5:	00 00 00 
  100bc8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bcf:	00 00 00 
  100bd2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bd9:	00 00 00 
  100bdc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100be3:	00 00 00 
  100be6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bed:	00 00 00 
  100bf0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100bf7:	00 00 00 
  100bfa:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c01:	00 00 00 
  100c04:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c0b:	00 00 00 
  100c0e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c15:	00 00 00 
  100c18:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c1f:	00 00 00 
  100c22:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c29:	00 00 00 
  100c2c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c33:	00 00 00 
  100c36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c3d:	00 00 00 
  100c40:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c47:	00 00 00 
  100c4a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c51:	00 00 00 
  100c54:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c5b:	00 00 00 
  100c5e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c65:	00 00 00 
  100c68:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c6f:	00 00 00 
  100c72:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c79:	00 00 00 
  100c7c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c83:	00 00 00 
  100c86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c8d:	00 00 00 
  100c90:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100c97:	00 00 00 
  100c9a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ca1:	00 00 00 
  100ca4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cab:	00 00 00 
  100cae:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cb5:	00 00 00 
  100cb8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cbf:	00 00 00 
  100cc2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cc9:	00 00 00 
  100ccc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cd3:	00 00 00 
  100cd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cdd:	00 00 00 
  100ce0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ce7:	00 00 00 
  100cea:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cf1:	00 00 00 
  100cf4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100cfb:	00 00 00 
  100cfe:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d05:	00 00 00 
  100d08:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d0f:	00 00 00 
  100d12:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d19:	00 00 00 
  100d1c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d23:	00 00 00 
  100d26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d2d:	00 00 00 
  100d30:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d37:	00 00 00 
  100d3a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d41:	00 00 00 
  100d44:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d4b:	00 00 00 
  100d4e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d55:	00 00 00 
  100d58:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d5f:	00 00 00 
  100d62:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d69:	00 00 00 
  100d6c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d73:	00 00 00 
  100d76:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d7d:	00 00 00 
  100d80:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d87:	00 00 00 
  100d8a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d91:	00 00 00 
  100d94:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100d9b:	00 00 00 
  100d9e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100da5:	00 00 00 
  100da8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100daf:	00 00 00 
  100db2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100db9:	00 00 00 
  100dbc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dc3:	00 00 00 
  100dc6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dcd:	00 00 00 
  100dd0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dd7:	00 00 00 
  100dda:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100de1:	00 00 00 
  100de4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100deb:	00 00 00 
  100dee:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100df5:	00 00 00 
  100df8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100dff:	00 00 00 
  100e02:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e09:	00 00 00 
  100e0c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e13:	00 00 00 
  100e16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e1d:	00 00 00 
  100e20:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e27:	00 00 00 
  100e2a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e31:	00 00 00 
  100e34:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e3b:	00 00 00 
  100e3e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e45:	00 00 00 
  100e48:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e4f:	00 00 00 
  100e52:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e59:	00 00 00 
  100e5c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e63:	00 00 00 
  100e66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e6d:	00 00 00 
  100e70:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e77:	00 00 00 
  100e7a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e81:	00 00 00 
  100e84:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e8b:	00 00 00 
  100e8e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e95:	00 00 00 
  100e98:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100e9f:	00 00 00 
  100ea2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ea9:	00 00 00 
  100eac:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eb3:	00 00 00 
  100eb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ebd:	00 00 00 
  100ec0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ec7:	00 00 00 
  100eca:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ed1:	00 00 00 
  100ed4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100edb:	00 00 00 
  100ede:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ee5:	00 00 00 
  100ee8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100eef:	00 00 00 
  100ef2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ef9:	00 00 00 
  100efc:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f03:	00 00 00 
  100f06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f0d:	00 00 00 
  100f10:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f17:	00 00 00 
  100f1a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f21:	00 00 00 
  100f24:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f2b:	00 00 00 
  100f2e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f35:	00 00 00 
  100f38:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f3f:	00 00 00 
  100f42:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f49:	00 00 00 
  100f4c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f53:	00 00 00 
  100f56:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f5d:	00 00 00 
  100f60:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f67:	00 00 00 
  100f6a:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f71:	00 00 00 
  100f74:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f7b:	00 00 00 
  100f7e:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f85:	00 00 00 
  100f88:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f8f:	00 00 00 
  100f92:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100f99:	00 00 00 
  100f9c:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fa3:	00 00 00 
  100fa6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fad:	00 00 00 
  100fb0:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fb7:	00 00 00 
  100fba:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fc1:	00 00 00 
  100fc4:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fcb:	00 00 00 
  100fce:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fd5:	00 00 00 
  100fd8:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fdf:	00 00 00 
  100fe2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100fe9:	00 00 00 
  100fec:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ff3:	00 00 00 
  100ff6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  100ffd:	00 00 00 

0000000000101000 <gdt_64>:
	...
  101008:	ff                   	(bad)  
  101009:	ff 00                	incl   (%rax)
  10100b:	00 00                	add    %al,(%rax)
  10100d:	9a                   	(bad)  
  10100e:	af                   	scas   %es:(%rdi),%eax
  10100f:	00 ff                	add    %bh,%bh
  101011:	ff 00                	incl   (%rax)
  101013:	00 00                	add    %al,(%rax)
  101015:	92                   	xchg   %eax,%edx
  101016:	cf                   	iret   
	...

0000000000101018 <gdtdesc_64>:
  101018:	17                   	(bad)  
  101019:	00 00                	add    %al,(%rax)
  10101b:	10 10                	adc    %dl,(%rax)
	...

0000000000102000 <pml4phys>:
	...

0000000000103000 <pdpt1>:
	...

0000000000104000 <pdpt2>:
	...

0000000000105000 <pde1>:
	...

0000000000106000 <pde2>:
	...

0000000000107000 <multiboot_info>:
  107000:	00 00                	add    %al,(%rax)
	...

Disassembly of section .text:

0000008004200000 <_start+0x8003fffff4>:
  8004200000:	02 b0 ad 1b 00 00    	add    0x1bad(%rax),%dh
  8004200006:	00 00                	add    %al,(%rax)
  8004200008:	fe 4f 52             	decb   0x52(%rdi)
  800420000b:	e4 48                	in     $0x48,%al

000000800420000c <entry>:
entry:

/* .globl _back_from_head64 */
/* _back_from_head64: */

    movabs   $gdtdesc_64,%rax
  800420000c:	48 b8 38 b0 22 04 80 	movabs $0x800422b038,%rax
  8004200013:	00 00 00 
    lgdt     (%rax)
  8004200016:	0f 01 10             	lgdt   (%rax)
    movw    $DATA_SEL,%ax
  8004200019:	66 b8 10 00          	mov    $0x10,%ax
    movw    %ax,%ds
  800420001d:	8e d8                	mov    %eax,%ds
    movw    %ax,%ss
  800420001f:	8e d0                	mov    %eax,%ss
    movw    %ax,%fs
  8004200021:	8e e0                	mov    %eax,%fs
    movw    %ax,%gs
  8004200023:	8e e8                	mov    %eax,%gs
    movw    %ax,%es
  8004200025:	8e c0                	mov    %eax,%es
    pushq   $CODE_SEL
  8004200027:	6a 08                	pushq  $0x8
    movabs  $relocated,%rax
  8004200029:	48 b8 36 00 20 04 80 	movabs $0x8004200036,%rax
  8004200030:	00 00 00 
    pushq   %rax
  8004200033:	50                   	push   %rax
    lretq
  8004200034:	48 cb                	lretq  

0000008004200036 <relocated>:
relocated:

	# Clear the frame pointer register (RBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movq	$0x0,%rbp			# nuke frame pointer
  8004200036:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Set the stack pointer
	movabs	$(bootstacktop),%rax
  800420003d:	48 b8 00 b0 22 04 80 	movabs $0x800422b000,%rax
  8004200044:	00 00 00 
	movq  %rax,%rsp
  8004200047:	48 89 c4             	mov    %rax,%rsp

	# now to C code
    movabs $i386_init, %rax
  800420004a:	48 b8 22 02 20 04 80 	movabs $0x8004200222,%rax
  8004200051:	00 00 00 
	call *%rax
  8004200054:	ff d0                	callq  *%rax

0000008004200056 <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
  8004200056:	eb fe                	jmp    8004200056 <spin>

0000008004200058 <cpuid>:

#define read_rip(var) __asm __volatile("leaq (%%rip), %0" : "=r" (var)::"cc","memory")

static __inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
  8004200058:	55                   	push   %rbp
  8004200059:	48 89 e5             	mov    %rsp,%rbp
  800420005c:	53                   	push   %rbx
  800420005d:	48 83 ec 38          	sub    $0x38,%rsp
  8004200061:	89 7d e4             	mov    %edi,-0x1c(%rbp)
  8004200064:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  8004200068:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420006c:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8004200070:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid" 
  8004200074:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200077:	0f a2                	cpuid  
  8004200079:	89 de                	mov    %ebx,%esi
  800420007b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  800420007e:	89 75 f0             	mov    %esi,-0x10(%rbp)
  8004200081:	89 4d ec             	mov    %ecx,-0x14(%rbp)
  8004200084:	89 55 e8             	mov    %edx,-0x18(%rbp)
		     : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
		     : "a" (info));
	if (eaxp)
  8004200087:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420008c:	74 09                	je     8004200097 <cpuid+0x3f>
		*eaxp = eax;
  800420008e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004200092:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004200095:	89 10                	mov    %edx,(%rax)
	if (ebxp)
  8004200097:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420009c:	74 09                	je     80042000a7 <cpuid+0x4f>
		*ebxp = ebx;
  800420009e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042000a2:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042000a5:	89 10                	mov    %edx,(%rax)
	if (ecxp)
  80042000a7:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042000ac:	74 09                	je     80042000b7 <cpuid+0x5f>
		*ecxp = ecx;
  80042000ae:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042000b2:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042000b5:	89 10                	mov    %edx,(%rax)
	if (edxp)
  80042000b7:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042000bc:	74 09                	je     80042000c7 <cpuid+0x6f>
		*edxp = edx;
  80042000be:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042000c2:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042000c5:	89 10                	mov    %edx,(%rax)
}
  80042000c7:	48 83 c4 38          	add    $0x38,%rsp
  80042000cb:	5b                   	pop    %rbx
  80042000cc:	5d                   	pop    %rbp
  80042000cd:	c3                   	retq   

00000080042000ce <xchg>:

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  80042000ce:	55                   	push   %rbp
  80042000cf:	48 89 e5             	mov    %rsp,%rbp
  80042000d2:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042000d6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042000da:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  80042000dd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042000e1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042000e4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042000e8:	f0 87 02             	lock xchg %eax,(%rdx)
  80042000eb:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  80042000ee:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042000f1:	c9                   	leaveq 
  80042000f2:	c3                   	retq   

00000080042000f3 <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  80042000f3:	55                   	push   %rbp
  80042000f4:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  80042000f7:	48 bf 40 b7 22 04 80 	movabs $0x800422b740,%rdi
  80042000fe:	00 00 00 
  8004200101:	48 b8 15 6e 21 04 80 	movabs $0x8004216e15,%rax
  8004200108:	00 00 00 
  800420010b:	ff d0                	callq  *%rax
}
  800420010d:	5d                   	pop    %rbp
  800420010e:	c3                   	retq   

000000800420010f <vmcall>:
#ifdef VMM_GUEST

static void boot_virtual_aps(void);

int64_t vmcall(int num, int check, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420010f:	55                   	push   %rbp
  8004200110:	48 89 e5             	mov    %rsp,%rbp
  8004200113:	53                   	push   %rbx
  8004200114:	48 83 ec 48          	sub    $0x48,%rsp
  8004200118:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420011b:	89 75 d8             	mov    %esi,-0x28(%rbp)
  800420011e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004200122:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  8004200126:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
  800420012a:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
    int64_t ret;
    asm volatile("vmcall\n" : "=a" (ret) : "a" (num), "d" (a1), "c" (a2), "b" (a3), "D" (a4), "S" (a5) : "cc", "memory");
  800420012e:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200131:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004200135:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  8004200139:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
  800420013d:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  8004200141:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  8004200145:	4c 89 c3             	mov    %r8,%rbx
  8004200148:	0f 01 c1             	vmcall 
  800420014b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    if(check && ret > 0) panic("vmcall %d returned %d (> 0)", num, ret);
  800420014f:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  8004200153:	74 3e                	je     8004200193 <vmcall+0x84>
  8004200155:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420015a:	7e 37                	jle    8004200193 <vmcall+0x84>
  800420015c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004200160:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200163:	49 89 d0             	mov    %rdx,%r8
  8004200166:	89 c1                	mov    %eax,%ecx
  8004200168:	48 ba e0 7c 21 04 80 	movabs $0x8004217ce0,%rdx
  800420016f:	00 00 00 
  8004200172:	be 2a 00 00 00       	mov    $0x2a,%esi
  8004200177:	48 bf fc 7c 21 04 80 	movabs $0x8004217cfc,%rdi
  800420017e:	00 00 00 
  8004200181:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200186:	49 b9 59 06 20 04 80 	movabs $0x8004200659,%r9
  800420018d:	00 00 00 
  8004200190:	41 ff d1             	callq  *%r9
    return ret;
  8004200193:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004200197:	48 83 c4 48          	add    $0x48,%rsp
  800420019b:	5b                   	pop    %rbx
  800420019c:	5d                   	pop    %rbp
  800420019d:	c3                   	retq   

000000800420019e <test_backtrace>:


// Test the stack backtrace function (lab 1 only)
void
test_backtrace(int x)
{
  800420019e:	55                   	push   %rbp
  800420019f:	48 89 e5             	mov    %rsp,%rbp
  80042001a2:	48 83 ec 10          	sub    $0x10,%rsp
  80042001a6:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cprintf("entering test_backtrace %d\n", x);
  80042001a9:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042001ac:	89 c6                	mov    %eax,%esi
  80042001ae:	48 bf 08 7d 21 04 80 	movabs $0x8004217d08,%rdi
  80042001b5:	00 00 00 
  80042001b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042001bd:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042001c4:	00 00 00 
  80042001c7:	ff d2                	callq  *%rdx
	if (x > 0)
  80042001c9:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042001cd:	7e 16                	jle    80042001e5 <test_backtrace+0x47>
		test_backtrace(x-1);
  80042001cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042001d2:	83 e8 01             	sub    $0x1,%eax
  80042001d5:	89 c7                	mov    %eax,%edi
  80042001d7:	48 b8 9e 01 20 04 80 	movabs $0x800420019e,%rax
  80042001de:	00 00 00 
  80042001e1:	ff d0                	callq  *%rax
  80042001e3:	eb 1b                	jmp    8004200200 <test_backtrace+0x62>
	else
		mon_backtrace(0, 0, 0);
  80042001e5:	ba 00 00 00 00       	mov    $0x0,%edx
  80042001ea:	be 00 00 00 00       	mov    $0x0,%esi
  80042001ef:	bf 00 00 00 00       	mov    $0x0,%edi
  80042001f4:	48 b8 b2 17 20 04 80 	movabs $0x80042017b2,%rax
  80042001fb:	00 00 00 
  80042001fe:	ff d0                	callq  *%rax
	cprintf("leaving test_backtrace %d\n", x);
  8004200200:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004200203:	89 c6                	mov    %eax,%esi
  8004200205:	48 bf 24 7d 21 04 80 	movabs $0x8004217d24,%rdi
  800420020c:	00 00 00 
  800420020f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200214:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420021b:	00 00 00 
  800420021e:	ff d2                	callq  *%rdx
}
  8004200220:	c9                   	leaveq 
  8004200221:	c3                   	retq   

0000008004200222 <i386_init>:


void
i386_init(void)
{
  8004200222:	55                   	push   %rbp
  8004200223:	48 89 e5             	mov    %rsp,%rbp
  8004200226:	48 83 ec 10          	sub    $0x10,%rsp
	extern char edata[], end[];

	// Before doing anything else, complete the ELF loading process.
	// Clear the uninitialized global data (BSS) section of our program.
	// This ensures that all static/global variables start out zero.
	memset(edata, 0, end - edata);
  800420022a:	48 ba 10 c0 3b 04 80 	movabs $0x80043bc010,%rdx
  8004200231:	00 00 00 
  8004200234:	48 b8 99 7d 37 04 80 	movabs $0x8004377d99,%rax
  800420023b:	00 00 00 
  800420023e:	48 29 c2             	sub    %rax,%rdx
  8004200241:	48 89 d0             	mov    %rdx,%rax
  8004200244:	48 89 c2             	mov    %rax,%rdx
  8004200247:	be 00 00 00 00       	mov    $0x0,%esi
  800420024c:	48 bf 99 7d 37 04 80 	movabs $0x8004377d99,%rdi
  8004200253:	00 00 00 
  8004200256:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  800420025d:	00 00 00 
  8004200260:	ff d0                	callq  *%rax

	// Initialize the console.
	// Can't call cprintf until after we do this!
	cons_init();
  8004200262:	48 b8 56 13 20 04 80 	movabs $0x8004201356,%rax
  8004200269:	00 00 00 
  800420026c:	ff d0                	callq  *%rax

	cprintf("6828 decimal is %o octal!\n", 6828);
  800420026e:	be ac 1a 00 00       	mov    $0x1aac,%esi
  8004200273:	48 bf 3f 7d 21 04 80 	movabs $0x8004217d3f,%rdi
  800420027a:	00 00 00 
  800420027d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200282:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004200289:	00 00 00 
  800420028c:	ff d2                	callq  *%rdx

#ifdef VMM_GUEST
	/* Guest VMX extension exposure check */
	{
		uint32_t ecx = 0;
  800420028e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		cpuid(0x1, NULL, NULL, &ecx, NULL);
  8004200295:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004200299:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420029f:	48 89 c1             	mov    %rax,%rcx
  80042002a2:	ba 00 00 00 00       	mov    $0x0,%edx
  80042002a7:	be 00 00 00 00       	mov    $0x0,%esi
  80042002ac:	bf 01 00 00 00       	mov    $0x1,%edi
  80042002b1:	48 b8 58 00 20 04 80 	movabs $0x8004200058,%rax
  80042002b8:	00 00 00 
  80042002bb:	ff d0                	callq  *%rax
		if (ecx & 0x20)
  80042002bd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042002c0:	83 e0 20             	and    $0x20,%eax
  80042002c3:	85 c0                	test   %eax,%eax
  80042002c5:	74 2a                	je     80042002f1 <i386_init+0xcf>
			panic("[ERR] VMX extension exposed to guest.\n");
  80042002c7:	48 ba 60 7d 21 04 80 	movabs $0x8004217d60,%rdx
  80042002ce:	00 00 00 
  80042002d1:	be 57 00 00 00       	mov    $0x57,%esi
  80042002d6:	48 bf fc 7c 21 04 80 	movabs $0x8004217cfc,%rdi
  80042002dd:	00 00 00 
  80042002e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042002e5:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  80042002ec:	00 00 00 
  80042002ef:	ff d1                	callq  *%rcx
		else
			cprintf("VMX extension hidden from guest.\n");
  80042002f1:	48 bf 88 7d 21 04 80 	movabs $0x8004217d88,%rdi
  80042002f8:	00 00 00 
  80042002fb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200300:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004200307:	00 00 00 
  800420030a:	ff d2                	callq  *%rdx
	extern char end[];
	end_debug = read_section_headers((0x10000+KERNBASE), (uintptr_t)end); 
#endif

	// Lab 2 memory management initialization functions
	x64_vm_init();
  800420030c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200311:	48 ba 6a 28 20 04 80 	movabs $0x800420286a,%rdx
  8004200318:	00 00 00 
  800420031b:	ff d2                	callq  *%rdx

	// Lab 3 user environment initialization functions
	env_init();
  800420031d:	48 b8 1e 7b 20 04 80 	movabs $0x8004207b1e,%rax
  8004200324:	00 00 00 
  8004200327:	ff d0                	callq  *%rax
	trap_init();
  8004200329:	48 b8 d7 90 20 04 80 	movabs $0x80042090d7,%rax
  8004200330:	00 00 00 
  8004200333:	ff d0                	callq  *%rax
	mp_init();
	lapic_init();
#endif

	// Lab 4 multitasking initialization functions
	pic_init();
  8004200335:	48 b8 5f 8c 20 04 80 	movabs $0x8004208c5f,%rax
  800420033c:	00 00 00 
  800420033f:	ff d0                	callq  *%rax

	// Lab 6 hardware initialization functions
	time_init();
  8004200341:	48 b8 30 7c 21 04 80 	movabs $0x8004217c30,%rax
  8004200348:	00 00 00 
  800420034b:	ff d0                	callq  *%rax
	pci_init();
  800420034d:	48 b8 f4 7b 21 04 80 	movabs $0x8004217bf4,%rax
  8004200354:	00 00 00 
  8004200357:	ff d0                	callq  *%rax

	// Acquire the big kernel lock before waking up APs
	// Your code here:
	lock_kernel();
  8004200359:	48 b8 f3 00 20 04 80 	movabs $0x80042000f3,%rax
  8004200360:	00 00 00 
  8004200363:	ff d0                	callq  *%rax

#ifndef VMM_GUEST
	// Start fs.
	ENV_CREATE(fs_fs, ENV_TYPE_FS);
#else
	ENV_CREATE(user_hello, ENV_TYPE_USER);
  8004200365:	be 00 00 00 00       	mov    $0x0,%esi
  800420036a:	48 bf 38 b8 22 04 80 	movabs $0x800422b838,%rdi
  8004200371:	00 00 00 
  8004200374:	48 b8 c8 81 20 04 80 	movabs $0x80042081c8,%rax
  800420037b:	00 00 00 
  800420037e:	ff d0                	callq  *%rax
	//ENV_CREATE(user_testkbd, ENV_TYPE_USER);


#endif // TEST*
	// Schedule and run the first user environment!
	sched_yield();
  8004200380:	48 b8 3d d0 20 04 80 	movabs $0x800420d03d,%rax
  8004200387:	00 00 00 
  800420038a:	ff d0                	callq  *%rax

000000800420038c <boot_aps>:
void *mpentry_kstack;

// Start the non-boot (AP) processors.
static void
boot_aps(void)
{
  800420038c:	55                   	push   %rbp
  800420038d:	48 89 e5             	mov    %rsp,%rbp
  8004200390:	48 83 ec 30          	sub    $0x30,%rsp
	extern unsigned char mpentry_start[], mpentry_end[];
	void *code;
	struct CpuInfo *c;

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
  8004200394:	48 c7 45 f0 00 70 00 	movq   $0x7000,-0x10(%rbp)
  800420039b:	00 
  800420039c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042003a0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042003a4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  80042003a7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042003aa:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042003b1:	00 00 00 
  80042003b4:	48 8b 00             	mov    (%rax),%rax
  80042003b7:	48 39 c2             	cmp    %rax,%rdx
  80042003ba:	72 32                	jb     80042003ee <boot_aps+0x62>
  80042003bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042003c0:	48 89 c1             	mov    %rax,%rcx
  80042003c3:	48 ba b0 7d 21 04 80 	movabs $0x8004217db0,%rdx
  80042003ca:	00 00 00 
  80042003cd:	be b4 00 00 00       	mov    $0xb4,%esi
  80042003d2:	48 bf fc 7c 21 04 80 	movabs $0x8004217cfc,%rdi
  80042003d9:	00 00 00 
  80042003dc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042003e1:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042003e8:	00 00 00 
  80042003eb:	41 ff d0             	callq  *%r8
  80042003ee:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042003f5:	00 00 00 
  80042003f8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042003fc:	48 01 d0             	add    %rdx,%rax
  80042003ff:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
  8004200403:	48 ba 5e 5f 21 04 80 	movabs $0x8004215f5e,%rdx
  800420040a:	00 00 00 
  800420040d:	48 b8 78 5e 21 04 80 	movabs $0x8004215e78,%rax
  8004200414:	00 00 00 
  8004200417:	48 29 c2             	sub    %rax,%rdx
  800420041a:	48 89 d0             	mov    %rdx,%rax
  800420041d:	48 89 c2             	mov    %rax,%rdx
  8004200420:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004200424:	48 be 78 5e 21 04 80 	movabs $0x8004215e78,%rsi
  800420042b:	00 00 00 
  800420042e:	48 89 c7             	mov    %rax,%rdi
  8004200431:	48 b8 08 fb 20 04 80 	movabs $0x800420fb08,%rax
  8004200438:	00 00 00 
  800420043b:	ff d0                	callq  *%rax
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  800420043d:	48 b8 20 b0 37 04 80 	movabs $0x800437b020,%rax
  8004200444:	00 00 00 
  8004200447:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420044b:	e9 0e 01 00 00       	jmpq   800420055e <boot_aps+0x1d2>
		if (c == cpus + cpunum())  // We've started already.
  8004200450:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004200457:	00 00 00 
  800420045a:	ff d0                	callq  *%rax
  800420045c:	48 98                	cltq   
  800420045e:	48 c1 e0 03          	shl    $0x3,%rax
  8004200462:	48 89 c2             	mov    %rax,%rdx
  8004200465:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200469:	48 01 c2             	add    %rax,%rdx
  800420046c:	48 b8 20 b0 37 04 80 	movabs $0x800437b020,%rax
  8004200473:	00 00 00 
  8004200476:	48 01 d0             	add    %rdx,%rax
  8004200479:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420047d:	75 05                	jne    8004200484 <boot_aps+0xf8>
			continue;
  800420047f:	e9 d2 00 00 00       	jmpq   8004200556 <boot_aps+0x1ca>

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
  8004200484:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200488:	48 b8 20 b0 37 04 80 	movabs $0x800437b020,%rax
  800420048f:	00 00 00 
  8004200492:	48 29 c2             	sub    %rax,%rdx
  8004200495:	48 89 d0             	mov    %rdx,%rax
  8004200498:	48 c1 f8 03          	sar    $0x3,%rax
  800420049c:	48 89 c2             	mov    %rax,%rdx
  800420049f:	48 b8 f1 f0 f0 f0 f0 	movabs $0xf0f0f0f0f0f0f0f1,%rax
  80042004a6:	f0 f0 f0 
  80042004a9:	48 0f af c2          	imul   %rdx,%rax
  80042004ad:	48 83 c0 01          	add    $0x1,%rax
  80042004b1:	48 c1 e0 10          	shl    $0x10,%rax
  80042004b5:	48 89 c2             	mov    %rax,%rdx
  80042004b8:	48 b8 00 c0 37 04 80 	movabs $0x800437c000,%rax
  80042004bf:	00 00 00 
  80042004c2:	48 01 c2             	add    %rax,%rdx
  80042004c5:	48 b8 78 97 37 04 80 	movabs $0x8004379778,%rax
  80042004cc:	00 00 00 
  80042004cf:	48 89 10             	mov    %rdx,(%rax)
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
  80042004d2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042004d6:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042004da:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042004e1:	00 00 00 
  80042004e4:	48 39 45 d8          	cmp    %rax,-0x28(%rbp)
  80042004e8:	77 32                	ja     800420051c <boot_aps+0x190>
  80042004ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042004ee:	48 89 c1             	mov    %rax,%rcx
  80042004f1:	48 ba d8 7d 21 04 80 	movabs $0x8004217dd8,%rdx
  80042004f8:	00 00 00 
  80042004fb:	be be 00 00 00       	mov    $0xbe,%esi
  8004200500:	48 bf fc 7c 21 04 80 	movabs $0x8004217cfc,%rdi
  8004200507:	00 00 00 
  800420050a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420050f:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004200516:	00 00 00 
  8004200519:	41 ff d0             	callq  *%r8
  800420051c:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004200523:	ff ff ff 
  8004200526:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420052a:	48 01 d0             	add    %rdx,%rax
  800420052d:	89 c2                	mov    %eax,%edx
  800420052f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200533:	0f b6 00             	movzbl (%rax),%eax
  8004200536:	0f b6 c0             	movzbl %al,%eax
  8004200539:	89 d6                	mov    %edx,%esi
  800420053b:	89 c7                	mov    %eax,%edi
  800420053d:	48 b8 fa 6a 21 04 80 	movabs $0x8004216afa,%rax
  8004200544:	00 00 00 
  8004200547:	ff d0                	callq  *%rax
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
  8004200549:	90                   	nop
  800420054a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420054e:	8b 40 04             	mov    0x4(%rax),%eax
  8004200551:	83 f8 01             	cmp    $0x1,%eax
  8004200554:	75 f4                	jne    800420054a <boot_aps+0x1be>

	// Write entry code to unused memory at MPENTRY_PADDR
	code = KADDR(MPENTRY_PADDR);
	memmove(code, mpentry_start, mpentry_end - mpentry_start);
	// Boot each AP one at a time
	for (c = cpus; c < cpus + ncpu; c++) {
  8004200556:	48 81 45 f8 88 00 00 	addq   $0x88,-0x8(%rbp)
  800420055d:	00 
  800420055e:	48 b8 48 b2 37 04 80 	movabs $0x800437b248,%rax
  8004200565:	00 00 00 
  8004200568:	8b 00                	mov    (%rax),%eax
  800420056a:	48 98                	cltq   
  800420056c:	48 c1 e0 03          	shl    $0x3,%rax
  8004200570:	48 89 c2             	mov    %rax,%rdx
  8004200573:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200577:	48 01 c2             	add    %rax,%rdx
  800420057a:	48 b8 20 b0 37 04 80 	movabs $0x800437b020,%rax
  8004200581:	00 00 00 
  8004200584:	48 01 d0             	add    %rdx,%rax
  8004200587:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420058b:	0f 87 bf fe ff ff    	ja     8004200450 <boot_aps+0xc4>
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
}
  8004200591:	c9                   	leaveq 
  8004200592:	c3                   	retq   

0000008004200593 <mp_main>:

// Setup code for APs
void
mp_main(void)
{
  8004200593:	55                   	push   %rbp
  8004200594:	48 89 e5             	mov    %rsp,%rbp
  8004200597:	48 83 ec 10          	sub    $0x10,%rsp
	// We are in high EIP now, safe to switch to kern_pgdir 
	lcr3(boot_cr3);
  800420059b:	48 b8 80 97 37 04 80 	movabs $0x8004379780,%rax
  80042005a2:	00 00 00 
  80042005a5:	48 8b 00             	mov    (%rax),%rax
  80042005a8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  80042005ac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042005b0:	0f 22 d8             	mov    %rax,%cr3
	cprintf("SMP: CPU %d starting\n", cpunum());
  80042005b3:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  80042005ba:	00 00 00 
  80042005bd:	ff d0                	callq  *%rax
  80042005bf:	89 c6                	mov    %eax,%esi
  80042005c1:	48 bf fc 7d 21 04 80 	movabs $0x8004217dfc,%rdi
  80042005c8:	00 00 00 
  80042005cb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042005d0:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042005d7:	00 00 00 
  80042005da:	ff d2                	callq  *%rdx

	lapic_init();
  80042005dc:	48 b8 93 68 21 04 80 	movabs $0x8004216893,%rax
  80042005e3:	00 00 00 
  80042005e6:	ff d0                	callq  *%rax
	env_init_percpu();
  80042005e8:	48 b8 f5 7b 20 04 80 	movabs $0x8004207bf5,%rax
  80042005ef:	00 00 00 
  80042005f2:	ff d0                	callq  *%rax
	trap_init_percpu();
  80042005f4:	48 b8 87 b8 20 04 80 	movabs $0x800420b887,%rax
  80042005fb:	00 00 00 
  80042005fe:	ff d0                	callq  *%rax
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
  8004200600:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004200607:	00 00 00 
  800420060a:	ff d0                	callq  *%rax
  800420060c:	48 98                	cltq   
  800420060e:	48 c1 e0 03          	shl    $0x3,%rax
  8004200612:	48 89 c2             	mov    %rax,%rdx
  8004200615:	48 c1 e2 04          	shl    $0x4,%rdx
  8004200619:	48 01 d0             	add    %rdx,%rax
  800420061c:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004200623:	00 00 00 
  8004200626:	48 01 d0             	add    %rdx,%rax
  8004200629:	48 83 c0 04          	add    $0x4,%rax
  800420062d:	be 01 00 00 00       	mov    $0x1,%esi
  8004200632:	48 89 c7             	mov    %rax,%rdi
  8004200635:	48 b8 ce 00 20 04 80 	movabs $0x80042000ce,%rax
  800420063c:	00 00 00 
  800420063f:	ff d0                	callq  *%rax
	// Now that we have finished some basic setup, call sched_yield()
	// to start running processes on this CPU.  But make sure that
	// only one CPU can enter the scheduler at a time!
	//
	// Your code here:
	lock_kernel();
  8004200641:	48 b8 f3 00 20 04 80 	movabs $0x80042000f3,%rax
  8004200648:	00 00 00 
  800420064b:	ff d0                	callq  *%rax
	sched_yield();
  800420064d:	48 b8 3d d0 20 04 80 	movabs $0x800420d03d,%rax
  8004200654:	00 00 00 
  8004200657:	ff d0                	callq  *%rax

0000008004200659 <_panic>:
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", and then enters the kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  8004200659:	55                   	push   %rbp
  800420065a:	48 89 e5             	mov    %rsp,%rbp
  800420065d:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  8004200664:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420066b:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  8004200671:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004200678:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420067f:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004200686:	84 c0                	test   %al,%al
  8004200688:	74 20                	je     80042006aa <_panic+0x51>
  800420068a:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420068e:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004200692:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004200696:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420069a:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420069e:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042006a2:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042006a6:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042006aa:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	if (panicstr)
  80042006b1:	48 b8 70 97 37 04 80 	movabs $0x8004379770,%rax
  80042006b8:	00 00 00 
  80042006bb:	48 8b 00             	mov    (%rax),%rax
  80042006be:	48 85 c0             	test   %rax,%rax
  80042006c1:	74 05                	je     80042006c8 <_panic+0x6f>
		goto dead;
  80042006c3:	e9 b5 00 00 00       	jmpq   800420077d <_panic+0x124>
	panicstr = fmt;
  80042006c8:	48 b8 70 97 37 04 80 	movabs $0x8004379770,%rax
  80042006cf:	00 00 00 
  80042006d2:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  80042006d9:	48 89 10             	mov    %rdx,(%rax)

	// Be extra sure that the machine is in as reasonable state
	__asm __volatile("cli; cld");
  80042006dc:	fa                   	cli    
  80042006dd:	fc                   	cld    

	va_start(ap, fmt);
  80042006de:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042006e5:	00 00 00 
  80042006e8:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042006ef:	00 00 00 
  80042006f2:	48 8d 45 10          	lea    0x10(%rbp),%rax
  80042006f6:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042006fd:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004200704:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel panic on CPU %d at %s:%d: ", cpunum(), file, line);
  800420070b:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004200712:	00 00 00 
  8004200715:	ff d0                	callq  *%rax
  8004200717:	8b 8d 24 ff ff ff    	mov    -0xdc(%rbp),%ecx
  800420071d:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004200724:	89 c6                	mov    %eax,%esi
  8004200726:	48 bf 18 7e 21 04 80 	movabs $0x8004217e18,%rdi
  800420072d:	00 00 00 
  8004200730:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200735:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  800420073c:	00 00 00 
  800420073f:	41 ff d0             	callq  *%r8
	vcprintf(fmt, ap);
  8004200742:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200749:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004200750:	48 89 d6             	mov    %rdx,%rsi
  8004200753:	48 89 c7             	mov    %rax,%rdi
  8004200756:	48 b8 00 8f 20 04 80 	movabs $0x8004208f00,%rax
  800420075d:	00 00 00 
  8004200760:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200762:	48 bf 3a 7e 21 04 80 	movabs $0x8004217e3a,%rdi
  8004200769:	00 00 00 
  800420076c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200771:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004200778:	00 00 00 
  800420077b:	ff d2                	callq  *%rdx
	va_end(ap);

dead:
	/* break into the kernel monitor */
	while (1)
		monitor(NULL);
  800420077d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004200782:	48 b8 90 1c 20 04 80 	movabs $0x8004201c90,%rax
  8004200789:	00 00 00 
  800420078c:	ff d0                	callq  *%rax
  800420078e:	eb ed                	jmp    800420077d <_panic+0x124>

0000008004200790 <_warn>:
}

/* like panic, but don't */
void
_warn(const char *file, int line, const char *fmt,...)
{
  8004200790:	55                   	push   %rbp
  8004200791:	48 89 e5             	mov    %rsp,%rbp
  8004200794:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420079b:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  80042007a2:	89 b5 24 ff ff ff    	mov    %esi,-0xdc(%rbp)
  80042007a8:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  80042007af:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  80042007b6:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  80042007bd:	84 c0                	test   %al,%al
  80042007bf:	74 20                	je     80042007e1 <_warn+0x51>
  80042007c1:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  80042007c5:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  80042007c9:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  80042007cd:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  80042007d1:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  80042007d5:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  80042007d9:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  80042007dd:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  80042007e1:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  80042007e8:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  80042007ef:	00 00 00 
  80042007f2:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  80042007f9:	00 00 00 
  80042007fc:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004200800:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004200807:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420080e:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	cprintf("kernel warning at %s:%d: ", file, line);
  8004200815:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  800420081b:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004200822:	48 89 c6             	mov    %rax,%rsi
  8004200825:	48 bf 3c 7e 21 04 80 	movabs $0x8004217e3c,%rdi
  800420082c:	00 00 00 
  800420082f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200834:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  800420083b:	00 00 00 
  800420083e:	ff d1                	callq  *%rcx
	vcprintf(fmt, ap);
  8004200840:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
  8004200847:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420084e:	48 89 d6             	mov    %rdx,%rsi
  8004200851:	48 89 c7             	mov    %rax,%rdi
  8004200854:	48 b8 00 8f 20 04 80 	movabs $0x8004208f00,%rax
  800420085b:	00 00 00 
  800420085e:	ff d0                	callq  *%rax
	cprintf("\n");
  8004200860:	48 bf 3a 7e 21 04 80 	movabs $0x8004217e3a,%rdi
  8004200867:	00 00 00 
  800420086a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420086f:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004200876:	00 00 00 
  8004200879:	ff d2                	callq  *%rdx
	va_end(ap);
}
  800420087b:	c9                   	leaveq 
  800420087c:	c3                   	retq   

000000800420087d <delay>:
static void cons_putc(int c);

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
  800420087d:	55                   	push   %rbp
  800420087e:	48 89 e5             	mov    %rsp,%rbp
  8004200881:	48 83 ec 20          	sub    $0x20,%rsp
  8004200885:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  800420088c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420088f:	89 c2                	mov    %eax,%edx
  8004200891:	ec                   	in     (%dx),%al
  8004200892:	88 45 fb             	mov    %al,-0x5(%rbp)
  8004200895:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%rbp)
  800420089c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420089f:	89 c2                	mov    %eax,%edx
  80042008a1:	ec                   	in     (%dx),%al
  80042008a2:	88 45 f3             	mov    %al,-0xd(%rbp)
  80042008a5:	c7 45 ec 84 00 00 00 	movl   $0x84,-0x14(%rbp)
  80042008ac:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042008af:	89 c2                	mov    %eax,%edx
  80042008b1:	ec                   	in     (%dx),%al
  80042008b2:	88 45 eb             	mov    %al,-0x15(%rbp)
  80042008b5:	c7 45 e4 84 00 00 00 	movl   $0x84,-0x1c(%rbp)
  80042008bc:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042008bf:	89 c2                	mov    %eax,%edx
  80042008c1:	ec                   	in     (%dx),%al
  80042008c2:	88 45 e3             	mov    %al,-0x1d(%rbp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
  80042008c5:	c9                   	leaveq 
  80042008c6:	c3                   	retq   

00000080042008c7 <serial_proc_data>:

static bool serial_exists;

static int
serial_proc_data(void)
{
  80042008c7:	55                   	push   %rbp
  80042008c8:	48 89 e5             	mov    %rsp,%rbp
  80042008cb:	48 83 ec 10          	sub    $0x10,%rsp
  80042008cf:	c7 45 fc fd 03 00 00 	movl   $0x3fd,-0x4(%rbp)
  80042008d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042008d9:	89 c2                	mov    %eax,%edx
  80042008db:	ec                   	in     (%dx),%al
  80042008dc:	88 45 fb             	mov    %al,-0x5(%rbp)
    return data;
  80042008df:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
  80042008e3:	0f b6 c0             	movzbl %al,%eax
  80042008e6:	83 e0 01             	and    $0x1,%eax
  80042008e9:	85 c0                	test   %eax,%eax
  80042008eb:	75 07                	jne    80042008f4 <serial_proc_data+0x2d>
		return -1;
  80042008ed:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042008f2:	eb 17                	jmp    800420090b <serial_proc_data+0x44>
  80042008f4:	c7 45 f4 f8 03 00 00 	movl   $0x3f8,-0xc(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  80042008fb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042008fe:	89 c2                	mov    %eax,%edx
  8004200900:	ec                   	in     (%dx),%al
  8004200901:	88 45 f3             	mov    %al,-0xd(%rbp)
    return data;
  8004200904:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(COM1+COM_RX);
  8004200908:	0f b6 c0             	movzbl %al,%eax
}
  800420090b:	c9                   	leaveq 
  800420090c:	c3                   	retq   

000000800420090d <serial_intr>:

void
serial_intr(void)
{
  800420090d:	55                   	push   %rbp
  800420090e:	48 89 e5             	mov    %rsp,%rbp
	if (serial_exists)
  8004200911:	48 b8 00 80 37 04 80 	movabs $0x8004378000,%rax
  8004200918:	00 00 00 
  800420091b:	0f b6 00             	movzbl (%rax),%eax
  800420091e:	84 c0                	test   %al,%al
  8004200920:	74 16                	je     8004200938 <serial_intr+0x2b>
		cons_intr(serial_proc_data);
  8004200922:	48 bf c7 08 20 04 80 	movabs $0x80042008c7,%rdi
  8004200929:	00 00 00 
  800420092c:	48 b8 d9 11 20 04 80 	movabs $0x80042011d9,%rax
  8004200933:	00 00 00 
  8004200936:	ff d0                	callq  *%rax
}
  8004200938:	5d                   	pop    %rbp
  8004200939:	c3                   	retq   

000000800420093a <serial_putc>:

static void
serial_putc(int c)
{
  800420093a:	55                   	push   %rbp
  800420093b:	48 89 e5             	mov    %rsp,%rbp
  800420093e:	48 83 ec 28          	sub    $0x28,%rsp
  8004200942:	89 7d dc             	mov    %edi,-0x24(%rbp)
	int i;

	for (i = 0;
  8004200945:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420094c:	eb 10                	jmp    800420095e <serial_putc+0x24>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
		delay();
  800420094e:	48 b8 7d 08 20 04 80 	movabs $0x800420087d,%rax
  8004200955:	00 00 00 
  8004200958:	ff d0                	callq  *%rax
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
	     i++)
  800420095a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420095e:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200965:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200968:	89 c2                	mov    %eax,%edx
  800420096a:	ec                   	in     (%dx),%al
  800420096b:	88 45 f7             	mov    %al,-0x9(%rbp)
    return data;
  800420096e:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
serial_putc(int c)
{
	int i;

	for (i = 0;
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  8004200972:	0f b6 c0             	movzbl %al,%eax
  8004200975:	83 e0 20             	and    $0x20,%eax
static void
serial_putc(int c)
{
	int i;

	for (i = 0;
  8004200978:	85 c0                	test   %eax,%eax
  800420097a:	75 09                	jne    8004200985 <serial_putc+0x4b>
	     !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800;
  800420097c:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200983:	7e c9                	jle    800420094e <serial_putc+0x14>
	     i++)
		delay();

	outb(COM1 + COM_TX, c);
  8004200985:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004200988:	0f b6 c0             	movzbl %al,%eax
  800420098b:	c7 45 f0 f8 03 00 00 	movl   $0x3f8,-0x10(%rbp)
  8004200992:	88 45 ef             	mov    %al,-0x11(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200995:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200999:	8b 55 f0             	mov    -0x10(%rbp),%edx
  800420099c:	ee                   	out    %al,(%dx)
}
  800420099d:	c9                   	leaveq 
  800420099e:	c3                   	retq   

000000800420099f <serial_init>:

static void
serial_init(void)
{
  800420099f:	55                   	push   %rbp
  80042009a0:	48 89 e5             	mov    %rsp,%rbp
  80042009a3:	48 83 ec 50          	sub    $0x50,%rsp
  80042009a7:	c7 45 fc fa 03 00 00 	movl   $0x3fa,-0x4(%rbp)
  80042009ae:	c6 45 fb 00          	movb   $0x0,-0x5(%rbp)
  80042009b2:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042009b6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  80042009b9:	ee                   	out    %al,(%dx)
  80042009ba:	c7 45 f4 fb 03 00 00 	movl   $0x3fb,-0xc(%rbp)
  80042009c1:	c6 45 f3 80          	movb   $0x80,-0xd(%rbp)
  80042009c5:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  80042009c9:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042009cc:	ee                   	out    %al,(%dx)
  80042009cd:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%rbp)
  80042009d4:	c6 45 eb 0c          	movb   $0xc,-0x15(%rbp)
  80042009d8:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  80042009dc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042009df:	ee                   	out    %al,(%dx)
  80042009e0:	c7 45 e4 f9 03 00 00 	movl   $0x3f9,-0x1c(%rbp)
  80042009e7:	c6 45 e3 00          	movb   $0x0,-0x1d(%rbp)
  80042009eb:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  80042009ef:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042009f2:	ee                   	out    %al,(%dx)
  80042009f3:	c7 45 dc fb 03 00 00 	movl   $0x3fb,-0x24(%rbp)
  80042009fa:	c6 45 db 03          	movb   $0x3,-0x25(%rbp)
  80042009fe:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200a02:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200a05:	ee                   	out    %al,(%dx)
  8004200a06:	c7 45 d4 fc 03 00 00 	movl   $0x3fc,-0x2c(%rbp)
  8004200a0d:	c6 45 d3 00          	movb   $0x0,-0x2d(%rbp)
  8004200a11:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200a15:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004200a18:	ee                   	out    %al,(%dx)
  8004200a19:	c7 45 cc f9 03 00 00 	movl   $0x3f9,-0x34(%rbp)
  8004200a20:	c6 45 cb 01          	movb   $0x1,-0x35(%rbp)
  8004200a24:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004200a28:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004200a2b:	ee                   	out    %al,(%dx)
  8004200a2c:	c7 45 c4 fd 03 00 00 	movl   $0x3fd,-0x3c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a33:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004200a36:	89 c2                	mov    %eax,%edx
  8004200a38:	ec                   	in     (%dx),%al
  8004200a39:	88 45 c3             	mov    %al,-0x3d(%rbp)
    return data;
  8004200a3c:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
  8004200a40:	3c ff                	cmp    $0xff,%al
  8004200a42:	0f 95 c2             	setne  %dl
  8004200a45:	48 b8 00 80 37 04 80 	movabs $0x8004378000,%rax
  8004200a4c:	00 00 00 
  8004200a4f:	88 10                	mov    %dl,(%rax)
  8004200a51:	c7 45 bc fa 03 00 00 	movl   $0x3fa,-0x44(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200a58:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004200a5b:	89 c2                	mov    %eax,%edx
  8004200a5d:	ec                   	in     (%dx),%al
  8004200a5e:	88 45 bb             	mov    %al,-0x45(%rbp)
  8004200a61:	c7 45 b4 f8 03 00 00 	movl   $0x3f8,-0x4c(%rbp)
  8004200a68:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004200a6b:	89 c2                	mov    %eax,%edx
  8004200a6d:	ec                   	in     (%dx),%al
  8004200a6e:	88 45 b3             	mov    %al,-0x4d(%rbp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	// Enable serial interrupts
	if (serial_exists)
  8004200a71:	48 b8 00 80 37 04 80 	movabs $0x8004378000,%rax
  8004200a78:	00 00 00 
  8004200a7b:	0f b6 00             	movzbl (%rax),%eax
  8004200a7e:	84 c0                	test   %al,%al
  8004200a80:	74 23                	je     8004200aa5 <serial_init+0x106>
		irq_setmask_8259A(irq_mask_8259A & ~(1<<4));
  8004200a82:	48 b8 52 b6 22 04 80 	movabs $0x800422b652,%rax
  8004200a89:	00 00 00 
  8004200a8c:	0f b7 00             	movzwl (%rax),%eax
  8004200a8f:	0f b7 c0             	movzwl %ax,%eax
  8004200a92:	25 ef ff 00 00       	and    $0xffef,%eax
  8004200a97:	89 c7                	mov    %eax,%edi
  8004200a99:	48 b8 b1 8d 20 04 80 	movabs $0x8004208db1,%rax
  8004200aa0:	00 00 00 
  8004200aa3:	ff d0                	callq  *%rax
}
  8004200aa5:	c9                   	leaveq 
  8004200aa6:	c3                   	retq   

0000008004200aa7 <lpt_putc>:
// For information on PC parallel port programming, see the class References
// page.

static void
lpt_putc(int c)
{
  8004200aa7:	55                   	push   %rbp
  8004200aa8:	48 89 e5             	mov    %rsp,%rbp
  8004200aab:	48 83 ec 38          	sub    $0x38,%rsp
  8004200aaf:	89 7d cc             	mov    %edi,-0x34(%rbp)
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200ab2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004200ab9:	eb 10                	jmp    8004200acb <lpt_putc+0x24>
		delay();
  8004200abb:	48 b8 7d 08 20 04 80 	movabs $0x800420087d,%rax
  8004200ac2:	00 00 00 
  8004200ac5:	ff d0                	callq  *%rax
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 12800; i++)
  8004200ac7:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200acb:	c7 45 f8 79 03 00 00 	movl   $0x379,-0x8(%rbp)
  8004200ad2:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004200ad5:	89 c2                	mov    %eax,%edx
  8004200ad7:	ec                   	in     (%dx),%al
  8004200ad8:	88 45 f7             	mov    %al,-0x9(%rbp)
    return data;
  8004200adb:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200adf:	84 c0                	test   %al,%al
  8004200ae1:	78 09                	js     8004200aec <lpt_putc+0x45>
  8004200ae3:	81 7d fc ff 31 00 00 	cmpl   $0x31ff,-0x4(%rbp)
  8004200aea:	7e cf                	jle    8004200abb <lpt_putc+0x14>
		delay();
	outb(0x378+0, c);
  8004200aec:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200aef:	0f b6 c0             	movzbl %al,%eax
  8004200af2:	c7 45 f0 78 03 00 00 	movl   $0x378,-0x10(%rbp)
  8004200af9:	88 45 ef             	mov    %al,-0x11(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200afc:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200b00:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200b03:	ee                   	out    %al,(%dx)
  8004200b04:	c7 45 e8 7a 03 00 00 	movl   $0x37a,-0x18(%rbp)
  8004200b0b:	c6 45 e7 0d          	movb   $0xd,-0x19(%rbp)
  8004200b0f:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200b13:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200b16:	ee                   	out    %al,(%dx)
  8004200b17:	c7 45 e0 7a 03 00 00 	movl   $0x37a,-0x20(%rbp)
  8004200b1e:	c6 45 df 08          	movb   $0x8,-0x21(%rbp)
  8004200b22:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200b26:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200b29:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
  8004200b2a:	c9                   	leaveq 
  8004200b2b:	c3                   	retq   

0000008004200b2c <cga_init>:
static uint16_t *crt_buf;
static uint16_t crt_pos;

static void
cga_init(void)
{
  8004200b2c:	55                   	push   %rbp
  8004200b2d:	48 89 e5             	mov    %rsp,%rbp
  8004200b30:	48 83 ec 30          	sub    $0x30,%rsp
	volatile uint16_t *cp;
	uint16_t was;
	unsigned pos;

	cp = (uint16_t*) (KERNBASE + CGA_BUF);
  8004200b34:	48 b8 00 80 0b 04 80 	movabs $0x80040b8000,%rax
  8004200b3b:	00 00 00 
  8004200b3e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	was = *cp;
  8004200b42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200b46:	0f b7 00             	movzwl (%rax),%eax
  8004200b49:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
	*cp = (uint16_t) 0xA55A;
  8004200b4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200b51:	66 c7 00 5a a5       	movw   $0xa55a,(%rax)
	if (*cp != 0xA55A) {
  8004200b56:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200b5a:	0f b7 00             	movzwl (%rax),%eax
  8004200b5d:	66 3d 5a a5          	cmp    $0xa55a,%ax
  8004200b61:	74 20                	je     8004200b83 <cga_init+0x57>
		cp = (uint16_t*) (KERNBASE + MONO_BUF);
  8004200b63:	48 b8 00 00 0b 04 80 	movabs $0x80040b0000,%rax
  8004200b6a:	00 00 00 
  8004200b6d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		addr_6845 = MONO_BASE;
  8004200b71:	48 b8 04 80 37 04 80 	movabs $0x8004378004,%rax
  8004200b78:	00 00 00 
  8004200b7b:	c7 00 b4 03 00 00    	movl   $0x3b4,(%rax)
  8004200b81:	eb 1b                	jmp    8004200b9e <cga_init+0x72>
	} else {
		*cp = was;
  8004200b83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004200b87:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004200b8b:	66 89 10             	mov    %dx,(%rax)
		addr_6845 = CGA_BASE;
  8004200b8e:	48 b8 04 80 37 04 80 	movabs $0x8004378004,%rax
  8004200b95:	00 00 00 
  8004200b98:	c7 00 d4 03 00 00    	movl   $0x3d4,(%rax)
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
  8004200b9e:	48 b8 04 80 37 04 80 	movabs $0x8004378004,%rax
  8004200ba5:	00 00 00 
  8004200ba8:	8b 00                	mov    (%rax),%eax
  8004200baa:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004200bad:	c6 45 eb 0e          	movb   $0xe,-0x15(%rbp)
  8004200bb1:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004200bb5:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004200bb8:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
  8004200bb9:	48 b8 04 80 37 04 80 	movabs $0x8004378004,%rax
  8004200bc0:	00 00 00 
  8004200bc3:	8b 00                	mov    (%rax),%eax
  8004200bc5:	83 c0 01             	add    $0x1,%eax
  8004200bc8:	89 45 e4             	mov    %eax,-0x1c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200bcb:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004200bce:	89 c2                	mov    %eax,%edx
  8004200bd0:	ec                   	in     (%dx),%al
  8004200bd1:	88 45 e3             	mov    %al,-0x1d(%rbp)
    return data;
  8004200bd4:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004200bd8:	0f b6 c0             	movzbl %al,%eax
  8004200bdb:	c1 e0 08             	shl    $0x8,%eax
  8004200bde:	89 45 f0             	mov    %eax,-0x10(%rbp)
	outb(addr_6845, 15);
  8004200be1:	48 b8 04 80 37 04 80 	movabs $0x8004378004,%rax
  8004200be8:	00 00 00 
  8004200beb:	8b 00                	mov    (%rax),%eax
  8004200bed:	89 45 dc             	mov    %eax,-0x24(%rbp)
  8004200bf0:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200bf4:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004200bf8:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004200bfb:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
  8004200bfc:	48 b8 04 80 37 04 80 	movabs $0x8004378004,%rax
  8004200c03:	00 00 00 
  8004200c06:	8b 00                	mov    (%rax),%eax
  8004200c08:	83 c0 01             	add    $0x1,%eax
  8004200c0b:	89 45 d4             	mov    %eax,-0x2c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200c0e:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  8004200c11:	89 c2                	mov    %eax,%edx
  8004200c13:	ec                   	in     (%dx),%al
  8004200c14:	88 45 d3             	mov    %al,-0x2d(%rbp)
    return data;
  8004200c17:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004200c1b:	0f b6 c0             	movzbl %al,%eax
  8004200c1e:	09 45 f0             	or     %eax,-0x10(%rbp)

	crt_buf = (uint16_t*) cp;
  8004200c21:	48 b8 08 80 37 04 80 	movabs $0x8004378008,%rax
  8004200c28:	00 00 00 
  8004200c2b:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004200c2f:	48 89 10             	mov    %rdx,(%rax)
	crt_pos = pos;
  8004200c32:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200c35:	89 c2                	mov    %eax,%edx
  8004200c37:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200c3e:	00 00 00 
  8004200c41:	66 89 10             	mov    %dx,(%rax)
}
  8004200c44:	c9                   	leaveq 
  8004200c45:	c3                   	retq   

0000008004200c46 <cga_putc>:



static void
cga_putc(int c)
{
  8004200c46:	55                   	push   %rbp
  8004200c47:	48 89 e5             	mov    %rsp,%rbp
  8004200c4a:	48 83 ec 40          	sub    $0x40,%rsp
  8004200c4e:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// if no attribute given, then use black on white
	if (!(c & ~0xFF))
  8004200c51:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200c54:	b0 00                	mov    $0x0,%al
  8004200c56:	85 c0                	test   %eax,%eax
  8004200c58:	75 07                	jne    8004200c61 <cga_putc+0x1b>
		c |= 0x0700;
  8004200c5a:	81 4d cc 00 07 00 00 	orl    $0x700,-0x34(%rbp)

	switch (c & 0xff) {
  8004200c61:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200c64:	0f b6 c0             	movzbl %al,%eax
  8004200c67:	83 f8 09             	cmp    $0x9,%eax
  8004200c6a:	0f 84 f6 00 00 00    	je     8004200d66 <cga_putc+0x120>
  8004200c70:	83 f8 09             	cmp    $0x9,%eax
  8004200c73:	7f 0a                	jg     8004200c7f <cga_putc+0x39>
  8004200c75:	83 f8 08             	cmp    $0x8,%eax
  8004200c78:	74 18                	je     8004200c92 <cga_putc+0x4c>
  8004200c7a:	e9 3e 01 00 00       	jmpq   8004200dbd <cga_putc+0x177>
  8004200c7f:	83 f8 0a             	cmp    $0xa,%eax
  8004200c82:	74 75                	je     8004200cf9 <cga_putc+0xb3>
  8004200c84:	83 f8 0d             	cmp    $0xd,%eax
  8004200c87:	0f 84 89 00 00 00    	je     8004200d16 <cga_putc+0xd0>
  8004200c8d:	e9 2b 01 00 00       	jmpq   8004200dbd <cga_putc+0x177>
	case '\b':
		if (crt_pos > 0) {
  8004200c92:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200c99:	00 00 00 
  8004200c9c:	0f b7 00             	movzwl (%rax),%eax
  8004200c9f:	66 85 c0             	test   %ax,%ax
  8004200ca2:	74 50                	je     8004200cf4 <cga_putc+0xae>
			crt_pos--;
  8004200ca4:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200cab:	00 00 00 
  8004200cae:	0f b7 00             	movzwl (%rax),%eax
  8004200cb1:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004200cb4:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200cbb:	00 00 00 
  8004200cbe:	66 89 10             	mov    %dx,(%rax)
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
  8004200cc1:	48 b8 08 80 37 04 80 	movabs $0x8004378008,%rax
  8004200cc8:	00 00 00 
  8004200ccb:	48 8b 10             	mov    (%rax),%rdx
  8004200cce:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200cd5:	00 00 00 
  8004200cd8:	0f b7 00             	movzwl (%rax),%eax
  8004200cdb:	0f b7 c0             	movzwl %ax,%eax
  8004200cde:	48 01 c0             	add    %rax,%rax
  8004200ce1:	48 01 c2             	add    %rax,%rdx
  8004200ce4:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200ce7:	b0 00                	mov    $0x0,%al
  8004200ce9:	83 c8 20             	or     $0x20,%eax
  8004200cec:	66 89 02             	mov    %ax,(%rdx)
		}
		break;
  8004200cef:	e9 04 01 00 00       	jmpq   8004200df8 <cga_putc+0x1b2>
  8004200cf4:	e9 ff 00 00 00       	jmpq   8004200df8 <cga_putc+0x1b2>
	case '\n':
		crt_pos += CRT_COLS;
  8004200cf9:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200d00:	00 00 00 
  8004200d03:	0f b7 00             	movzwl (%rax),%eax
  8004200d06:	8d 50 50             	lea    0x50(%rax),%edx
  8004200d09:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200d10:	00 00 00 
  8004200d13:	66 89 10             	mov    %dx,(%rax)
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
  8004200d16:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200d1d:	00 00 00 
  8004200d20:	0f b7 30             	movzwl (%rax),%esi
  8004200d23:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200d2a:	00 00 00 
  8004200d2d:	0f b7 08             	movzwl (%rax),%ecx
  8004200d30:	0f b7 c1             	movzwl %cx,%eax
  8004200d33:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
  8004200d39:	c1 e8 10             	shr    $0x10,%eax
  8004200d3c:	89 c2                	mov    %eax,%edx
  8004200d3e:	66 c1 ea 06          	shr    $0x6,%dx
  8004200d42:	89 d0                	mov    %edx,%eax
  8004200d44:	c1 e0 02             	shl    $0x2,%eax
  8004200d47:	01 d0                	add    %edx,%eax
  8004200d49:	c1 e0 04             	shl    $0x4,%eax
  8004200d4c:	29 c1                	sub    %eax,%ecx
  8004200d4e:	89 ca                	mov    %ecx,%edx
  8004200d50:	29 d6                	sub    %edx,%esi
  8004200d52:	89 f2                	mov    %esi,%edx
  8004200d54:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200d5b:	00 00 00 
  8004200d5e:	66 89 10             	mov    %dx,(%rax)
		break;
  8004200d61:	e9 92 00 00 00       	jmpq   8004200df8 <cga_putc+0x1b2>
	case '\t':
		cons_putc(' ');
  8004200d66:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d6b:	48 b8 16 13 20 04 80 	movabs $0x8004201316,%rax
  8004200d72:	00 00 00 
  8004200d75:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d77:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d7c:	48 b8 16 13 20 04 80 	movabs $0x8004201316,%rax
  8004200d83:	00 00 00 
  8004200d86:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d88:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d8d:	48 b8 16 13 20 04 80 	movabs $0x8004201316,%rax
  8004200d94:	00 00 00 
  8004200d97:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200d99:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200d9e:	48 b8 16 13 20 04 80 	movabs $0x8004201316,%rax
  8004200da5:	00 00 00 
  8004200da8:	ff d0                	callq  *%rax
		cons_putc(' ');
  8004200daa:	bf 20 00 00 00       	mov    $0x20,%edi
  8004200daf:	48 b8 16 13 20 04 80 	movabs $0x8004201316,%rax
  8004200db6:	00 00 00 
  8004200db9:	ff d0                	callq  *%rax
		break;
  8004200dbb:	eb 3b                	jmp    8004200df8 <cga_putc+0x1b2>
	default:
		crt_buf[crt_pos++] = c;		/* write the character */
  8004200dbd:	48 b8 08 80 37 04 80 	movabs $0x8004378008,%rax
  8004200dc4:	00 00 00 
  8004200dc7:	48 8b 30             	mov    (%rax),%rsi
  8004200dca:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200dd1:	00 00 00 
  8004200dd4:	0f b7 00             	movzwl (%rax),%eax
  8004200dd7:	8d 48 01             	lea    0x1(%rax),%ecx
  8004200dda:	48 ba 10 80 37 04 80 	movabs $0x8004378010,%rdx
  8004200de1:	00 00 00 
  8004200de4:	66 89 0a             	mov    %cx,(%rdx)
  8004200de7:	0f b7 c0             	movzwl %ax,%eax
  8004200dea:	48 01 c0             	add    %rax,%rax
  8004200ded:	48 8d 14 06          	lea    (%rsi,%rax,1),%rdx
  8004200df1:	8b 45 cc             	mov    -0x34(%rbp),%eax
  8004200df4:	66 89 02             	mov    %ax,(%rdx)
		break;
  8004200df7:	90                   	nop
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
  8004200df8:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200dff:	00 00 00 
  8004200e02:	0f b7 00             	movzwl (%rax),%eax
  8004200e05:	66 3d cf 07          	cmp    $0x7cf,%ax
  8004200e09:	0f 86 89 00 00 00    	jbe    8004200e98 <cga_putc+0x252>
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
  8004200e0f:	48 b8 08 80 37 04 80 	movabs $0x8004378008,%rax
  8004200e16:	00 00 00 
  8004200e19:	48 8b 00             	mov    (%rax),%rax
  8004200e1c:	48 8d 88 a0 00 00 00 	lea    0xa0(%rax),%rcx
  8004200e23:	48 b8 08 80 37 04 80 	movabs $0x8004378008,%rax
  8004200e2a:	00 00 00 
  8004200e2d:	48 8b 00             	mov    (%rax),%rax
  8004200e30:	ba 00 0f 00 00       	mov    $0xf00,%edx
  8004200e35:	48 89 ce             	mov    %rcx,%rsi
  8004200e38:	48 89 c7             	mov    %rax,%rdi
  8004200e3b:	48 b8 08 fb 20 04 80 	movabs $0x800420fb08,%rax
  8004200e42:	00 00 00 
  8004200e45:	ff d0                	callq  *%rax
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200e47:	c7 45 fc 80 07 00 00 	movl   $0x780,-0x4(%rbp)
  8004200e4e:	eb 22                	jmp    8004200e72 <cga_putc+0x22c>
			crt_buf[i] = 0x0700 | ' ';
  8004200e50:	48 b8 08 80 37 04 80 	movabs $0x8004378008,%rax
  8004200e57:	00 00 00 
  8004200e5a:	48 8b 00             	mov    (%rax),%rax
  8004200e5d:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004200e60:	48 63 d2             	movslq %edx,%rdx
  8004200e63:	48 01 d2             	add    %rdx,%rdx
  8004200e66:	48 01 d0             	add    %rdx,%rax
  8004200e69:	66 c7 00 20 07       	movw   $0x720,(%rax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
  8004200e6e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004200e72:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%rbp)
  8004200e79:	7e d5                	jle    8004200e50 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
  8004200e7b:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200e82:	00 00 00 
  8004200e85:	0f b7 00             	movzwl (%rax),%eax
  8004200e88:	8d 50 b0             	lea    -0x50(%rax),%edx
  8004200e8b:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200e92:	00 00 00 
  8004200e95:	66 89 10             	mov    %dx,(%rax)
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
  8004200e98:	48 b8 04 80 37 04 80 	movabs $0x8004378004,%rax
  8004200e9f:	00 00 00 
  8004200ea2:	8b 00                	mov    (%rax),%eax
  8004200ea4:	89 45 f8             	mov    %eax,-0x8(%rbp)
  8004200ea7:	c6 45 f7 0e          	movb   $0xe,-0x9(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004200eab:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004200eaf:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004200eb2:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
  8004200eb3:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200eba:	00 00 00 
  8004200ebd:	0f b7 00             	movzwl (%rax),%eax
  8004200ec0:	66 c1 e8 08          	shr    $0x8,%ax
  8004200ec4:	0f b6 c0             	movzbl %al,%eax
  8004200ec7:	48 ba 04 80 37 04 80 	movabs $0x8004378004,%rdx
  8004200ece:	00 00 00 
  8004200ed1:	8b 12                	mov    (%rdx),%edx
  8004200ed3:	83 c2 01             	add    $0x1,%edx
  8004200ed6:	89 55 f0             	mov    %edx,-0x10(%rbp)
  8004200ed9:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004200edc:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004200ee0:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004200ee3:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
  8004200ee4:	48 b8 04 80 37 04 80 	movabs $0x8004378004,%rax
  8004200eeb:	00 00 00 
  8004200eee:	8b 00                	mov    (%rax),%eax
  8004200ef0:	89 45 e8             	mov    %eax,-0x18(%rbp)
  8004200ef3:	c6 45 e7 0f          	movb   $0xf,-0x19(%rbp)
  8004200ef7:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004200efb:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004200efe:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
  8004200eff:	48 b8 10 80 37 04 80 	movabs $0x8004378010,%rax
  8004200f06:	00 00 00 
  8004200f09:	0f b7 00             	movzwl (%rax),%eax
  8004200f0c:	0f b6 c0             	movzbl %al,%eax
  8004200f0f:	48 ba 04 80 37 04 80 	movabs $0x8004378004,%rdx
  8004200f16:	00 00 00 
  8004200f19:	8b 12                	mov    (%rdx),%edx
  8004200f1b:	83 c2 01             	add    $0x1,%edx
  8004200f1e:	89 55 e0             	mov    %edx,-0x20(%rbp)
  8004200f21:	88 45 df             	mov    %al,-0x21(%rbp)
  8004200f24:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004200f28:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004200f2b:	ee                   	out    %al,(%dx)
}
  8004200f2c:	c9                   	leaveq 
  8004200f2d:	c3                   	retq   

0000008004200f2e <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
  8004200f2e:	55                   	push   %rbp
  8004200f2f:	48 89 e5             	mov    %rsp,%rbp
  8004200f32:	48 83 ec 30          	sub    $0x30,%rsp
  8004200f36:	c7 45 f0 64 00 00 00 	movl   $0x64,-0x10(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200f3d:	8b 45 f0             	mov    -0x10(%rbp),%eax
  8004200f40:	89 c2                	mov    %eax,%edx
  8004200f42:	ec                   	in     (%dx),%al
  8004200f43:	88 45 ef             	mov    %al,-0x11(%rbp)
    return data;
  8004200f46:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
	int c;
	uint8_t data;
	static uint32_t shift;
	int r;
	if ((inb(KBSTATP) & KBS_DIB) == 0)
  8004200f4a:	0f b6 c0             	movzbl %al,%eax
  8004200f4d:	83 e0 01             	and    $0x1,%eax
  8004200f50:	85 c0                	test   %eax,%eax
  8004200f52:	75 0a                	jne    8004200f5e <kbd_proc_data+0x30>
		return -1;
  8004200f54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004200f59:	e9 28 02 00 00       	jmpq   8004201186 <kbd_proc_data+0x258>
  8004200f5e:	c7 45 e8 60 00 00 00 	movl   $0x60,-0x18(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004200f65:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004200f68:	89 c2                	mov    %eax,%edx
  8004200f6a:	ec                   	in     (%dx),%al
  8004200f6b:	88 45 e7             	mov    %al,-0x19(%rbp)
    return data;
  8004200f6e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax

	data = inb(KBDATAP);
  8004200f72:	88 45 fb             	mov    %al,-0x5(%rbp)

	if (data == 0xE0) {
  8004200f75:	80 7d fb e0          	cmpb   $0xe0,-0x5(%rbp)
  8004200f79:	75 27                	jne    8004200fa2 <kbd_proc_data+0x74>
		// E0 escape character
		shift |= E0ESC;
  8004200f7b:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  8004200f82:	00 00 00 
  8004200f85:	8b 00                	mov    (%rax),%eax
  8004200f87:	83 c8 40             	or     $0x40,%eax
  8004200f8a:	89 c2                	mov    %eax,%edx
  8004200f8c:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  8004200f93:	00 00 00 
  8004200f96:	89 10                	mov    %edx,(%rax)
		return 0;
  8004200f98:	b8 00 00 00 00       	mov    $0x0,%eax
  8004200f9d:	e9 e4 01 00 00       	jmpq   8004201186 <kbd_proc_data+0x258>
	} else if (data & 0x80) {
  8004200fa2:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200fa6:	84 c0                	test   %al,%al
  8004200fa8:	79 65                	jns    800420100f <kbd_proc_data+0xe1>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
  8004200faa:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  8004200fb1:	00 00 00 
  8004200fb4:	8b 00                	mov    (%rax),%eax
  8004200fb6:	83 e0 40             	and    $0x40,%eax
  8004200fb9:	85 c0                	test   %eax,%eax
  8004200fbb:	75 09                	jne    8004200fc6 <kbd_proc_data+0x98>
  8004200fbd:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200fc1:	83 e0 7f             	and    $0x7f,%eax
  8004200fc4:	eb 04                	jmp    8004200fca <kbd_proc_data+0x9c>
  8004200fc6:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200fca:	88 45 fb             	mov    %al,-0x5(%rbp)
		shift &= ~(shiftcode[data] | E0ESC);
  8004200fcd:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004200fd1:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  8004200fd8:	00 00 00 
  8004200fdb:	48 98                	cltq   
  8004200fdd:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004200fe1:	83 c8 40             	or     $0x40,%eax
  8004200fe4:	0f b6 c0             	movzbl %al,%eax
  8004200fe7:	f7 d0                	not    %eax
  8004200fe9:	89 c2                	mov    %eax,%edx
  8004200feb:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  8004200ff2:	00 00 00 
  8004200ff5:	8b 00                	mov    (%rax),%eax
  8004200ff7:	21 c2                	and    %eax,%edx
  8004200ff9:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  8004201000:	00 00 00 
  8004201003:	89 10                	mov    %edx,(%rax)
		return 0;
  8004201005:	b8 00 00 00 00       	mov    $0x0,%eax
  800420100a:	e9 77 01 00 00       	jmpq   8004201186 <kbd_proc_data+0x258>
	} else if (shift & E0ESC) {
  800420100f:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  8004201016:	00 00 00 
  8004201019:	8b 00                	mov    (%rax),%eax
  800420101b:	83 e0 40             	and    $0x40,%eax
  800420101e:	85 c0                	test   %eax,%eax
  8004201020:	74 21                	je     8004201043 <kbd_proc_data+0x115>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
  8004201022:	80 4d fb 80          	orb    $0x80,-0x5(%rbp)
		shift &= ~E0ESC;
  8004201026:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  800420102d:	00 00 00 
  8004201030:	8b 00                	mov    (%rax),%eax
  8004201032:	83 e0 bf             	and    $0xffffffbf,%eax
  8004201035:	89 c2                	mov    %eax,%edx
  8004201037:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  800420103e:	00 00 00 
  8004201041:	89 10                	mov    %edx,(%rax)
	}

	shift |= shiftcode[data];
  8004201043:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004201047:	48 ba 60 b0 22 04 80 	movabs $0x800422b060,%rdx
  800420104e:	00 00 00 
  8004201051:	48 98                	cltq   
  8004201053:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201057:	0f b6 d0             	movzbl %al,%edx
  800420105a:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  8004201061:	00 00 00 
  8004201064:	8b 00                	mov    (%rax),%eax
  8004201066:	09 c2                	or     %eax,%edx
  8004201068:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  800420106f:	00 00 00 
  8004201072:	89 10                	mov    %edx,(%rax)
	shift ^= togglecode[data];
  8004201074:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004201078:	48 ba 60 b1 22 04 80 	movabs $0x800422b160,%rdx
  800420107f:	00 00 00 
  8004201082:	48 98                	cltq   
  8004201084:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  8004201088:	0f b6 d0             	movzbl %al,%edx
  800420108b:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  8004201092:	00 00 00 
  8004201095:	8b 00                	mov    (%rax),%eax
  8004201097:	31 c2                	xor    %eax,%edx
  8004201099:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  80042010a0:	00 00 00 
  80042010a3:	89 10                	mov    %edx,(%rax)

	c = charcode[shift & (CTL | SHIFT)][data];
  80042010a5:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  80042010ac:	00 00 00 
  80042010af:	8b 00                	mov    (%rax),%eax
  80042010b1:	83 e0 03             	and    $0x3,%eax
  80042010b4:	89 c2                	mov    %eax,%edx
  80042010b6:	48 b8 60 b5 22 04 80 	movabs $0x800422b560,%rax
  80042010bd:	00 00 00 
  80042010c0:	89 d2                	mov    %edx,%edx
  80042010c2:	48 8b 14 d0          	mov    (%rax,%rdx,8),%rdx
  80042010c6:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  80042010ca:	48 01 d0             	add    %rdx,%rax
  80042010cd:	0f b6 00             	movzbl (%rax),%eax
  80042010d0:	0f b6 c0             	movzbl %al,%eax
  80042010d3:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (shift & CAPSLOCK) {
  80042010d6:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  80042010dd:	00 00 00 
  80042010e0:	8b 00                	mov    (%rax),%eax
  80042010e2:	83 e0 08             	and    $0x8,%eax
  80042010e5:	85 c0                	test   %eax,%eax
  80042010e7:	74 22                	je     800420110b <kbd_proc_data+0x1dd>
		if ('a' <= c && c <= 'z')
  80042010e9:	83 7d fc 60          	cmpl   $0x60,-0x4(%rbp)
  80042010ed:	7e 0c                	jle    80042010fb <kbd_proc_data+0x1cd>
  80042010ef:	83 7d fc 7a          	cmpl   $0x7a,-0x4(%rbp)
  80042010f3:	7f 06                	jg     80042010fb <kbd_proc_data+0x1cd>
			c += 'A' - 'a';
  80042010f5:	83 6d fc 20          	subl   $0x20,-0x4(%rbp)
  80042010f9:	eb 10                	jmp    800420110b <kbd_proc_data+0x1dd>
		else if ('A' <= c && c <= 'Z')
  80042010fb:	83 7d fc 40          	cmpl   $0x40,-0x4(%rbp)
  80042010ff:	7e 0a                	jle    800420110b <kbd_proc_data+0x1dd>
  8004201101:	83 7d fc 5a          	cmpl   $0x5a,-0x4(%rbp)
  8004201105:	7f 04                	jg     800420110b <kbd_proc_data+0x1dd>
			c += 'a' - 'A';
  8004201107:	83 45 fc 20          	addl   $0x20,-0x4(%rbp)
	}

	// Process special keys
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
  800420110b:	48 b8 28 82 37 04 80 	movabs $0x8004378228,%rax
  8004201112:	00 00 00 
  8004201115:	8b 00                	mov    (%rax),%eax
  8004201117:	f7 d0                	not    %eax
  8004201119:	83 e0 06             	and    $0x6,%eax
  800420111c:	85 c0                	test   %eax,%eax
  800420111e:	75 37                	jne    8004201157 <kbd_proc_data+0x229>
  8004201120:	81 7d fc e9 00 00 00 	cmpl   $0xe9,-0x4(%rbp)
  8004201127:	75 2e                	jne    8004201157 <kbd_proc_data+0x229>
		cprintf("Rebooting!\n");
  8004201129:	48 bf 56 7e 21 04 80 	movabs $0x8004217e56,%rdi
  8004201130:	00 00 00 
  8004201133:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201138:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420113f:	00 00 00 
  8004201142:	ff d2                	callq  *%rdx
  8004201144:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%rbp)
  800420114b:	c6 45 df 03          	movb   $0x3,-0x21(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  800420114f:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004201153:	8b 55 e0             	mov    -0x20(%rbp),%edx
  8004201156:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}
#ifdef VMM_GUEST
	if (c == 0x1b) {
  8004201157:	83 7d fc 1b          	cmpl   $0x1b,-0x4(%rbp)
  800420115b:	75 26                	jne    8004201183 <kbd_proc_data+0x255>
		cprintf("ESC pressed\n");
  800420115d:	48 bf 62 7e 21 04 80 	movabs $0x8004217e62,%rdi
  8004201164:	00 00 00 
  8004201167:	b8 00 00 00 00       	mov    $0x0,%eax
  800420116c:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201173:	00 00 00 
  8004201176:	ff d2                	callq  *%rdx
		asm("vmcall":"=a"(r): "0"(VMX_VMCALL_BACKTOHOST));
  8004201178:	b8 05 00 00 00       	mov    $0x5,%eax
  800420117d:	0f 01 c1             	vmcall 
  8004201180:	89 45 f4             	mov    %eax,-0xc(%rbp)
	}
#endif
	return c;
  8004201183:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004201186:	c9                   	leaveq 
  8004201187:	c3                   	retq   

0000008004201188 <kbd_intr>:

void
kbd_intr(void)
{
  8004201188:	55                   	push   %rbp
  8004201189:	48 89 e5             	mov    %rsp,%rbp
	cons_intr(kbd_proc_data);
  800420118c:	48 bf 2e 0f 20 04 80 	movabs $0x8004200f2e,%rdi
  8004201193:	00 00 00 
  8004201196:	48 b8 d9 11 20 04 80 	movabs $0x80042011d9,%rax
  800420119d:	00 00 00 
  80042011a0:	ff d0                	callq  *%rax
}
  80042011a2:	5d                   	pop    %rbp
  80042011a3:	c3                   	retq   

00000080042011a4 <kbd_init>:

static void
kbd_init(void)
{
  80042011a4:	55                   	push   %rbp
  80042011a5:	48 89 e5             	mov    %rsp,%rbp
	// Drain the kbd buffer so that Bochs generates interrupts.
	kbd_intr();
  80042011a8:	48 b8 88 11 20 04 80 	movabs $0x8004201188,%rax
  80042011af:	00 00 00 
  80042011b2:	ff d0                	callq  *%rax
	irq_setmask_8259A(irq_mask_8259A & ~(1<<1));
  80042011b4:	48 b8 52 b6 22 04 80 	movabs $0x800422b652,%rax
  80042011bb:	00 00 00 
  80042011be:	0f b7 00             	movzwl (%rax),%eax
  80042011c1:	0f b7 c0             	movzwl %ax,%eax
  80042011c4:	25 fd ff 00 00       	and    $0xfffd,%eax
  80042011c9:	89 c7                	mov    %eax,%edi
  80042011cb:	48 b8 b1 8d 20 04 80 	movabs $0x8004208db1,%rax
  80042011d2:	00 00 00 
  80042011d5:	ff d0                	callq  *%rax
}
  80042011d7:	5d                   	pop    %rbp
  80042011d8:	c3                   	retq   

00000080042011d9 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
static void
cons_intr(int (*proc)(void))
{
  80042011d9:	55                   	push   %rbp
  80042011da:	48 89 e5             	mov    %rsp,%rbp
  80042011dd:	48 83 ec 20          	sub    $0x20,%rsp
  80042011e1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int c;

	while ((c = (*proc)()) != -1) {
  80042011e5:	eb 6a                	jmp    8004201251 <cons_intr+0x78>
		if (c == 0)
  80042011e7:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042011eb:	75 02                	jne    80042011ef <cons_intr+0x16>
			continue;
  80042011ed:	eb 62                	jmp    8004201251 <cons_intr+0x78>
		cons.buf[cons.wpos++] = c;
  80042011ef:	48 b8 20 80 37 04 80 	movabs $0x8004378020,%rax
  80042011f6:	00 00 00 
  80042011f9:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042011ff:	8d 48 01             	lea    0x1(%rax),%ecx
  8004201202:	48 ba 20 80 37 04 80 	movabs $0x8004378020,%rdx
  8004201209:	00 00 00 
  800420120c:	89 8a 04 02 00 00    	mov    %ecx,0x204(%rdx)
  8004201212:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004201215:	89 d1                	mov    %edx,%ecx
  8004201217:	48 ba 20 80 37 04 80 	movabs $0x8004378020,%rdx
  800420121e:	00 00 00 
  8004201221:	89 c0                	mov    %eax,%eax
  8004201223:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
		if (cons.wpos == CONSBUFSIZE)
  8004201226:	48 b8 20 80 37 04 80 	movabs $0x8004378020,%rax
  800420122d:	00 00 00 
  8004201230:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  8004201236:	3d 00 02 00 00       	cmp    $0x200,%eax
  800420123b:	75 14                	jne    8004201251 <cons_intr+0x78>
			cons.wpos = 0;
  800420123d:	48 b8 20 80 37 04 80 	movabs $0x8004378020,%rax
  8004201244:	00 00 00 
  8004201247:	c7 80 04 02 00 00 00 	movl   $0x0,0x204(%rax)
  800420124e:	00 00 00 
static void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
  8004201251:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201255:	ff d0                	callq  *%rax
  8004201257:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420125a:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  800420125e:	75 87                	jne    80042011e7 <cons_intr+0xe>
			continue;
		cons.buf[cons.wpos++] = c;
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;
	}
}
  8004201260:	c9                   	leaveq 
  8004201261:	c3                   	retq   

0000008004201262 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
  8004201262:	55                   	push   %rbp
  8004201263:	48 89 e5             	mov    %rsp,%rbp
  8004201266:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
  800420126a:	48 b8 0d 09 20 04 80 	movabs $0x800420090d,%rax
  8004201271:	00 00 00 
  8004201274:	ff d0                	callq  *%rax
	kbd_intr();
  8004201276:	48 b8 88 11 20 04 80 	movabs $0x8004201188,%rax
  800420127d:	00 00 00 
  8004201280:	ff d0                	callq  *%rax

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
  8004201282:	48 b8 20 80 37 04 80 	movabs $0x8004378020,%rax
  8004201289:	00 00 00 
  800420128c:	8b 90 00 02 00 00    	mov    0x200(%rax),%edx
  8004201292:	48 b8 20 80 37 04 80 	movabs $0x8004378020,%rax
  8004201299:	00 00 00 
  800420129c:	8b 80 04 02 00 00    	mov    0x204(%rax),%eax
  80042012a2:	39 c2                	cmp    %eax,%edx
  80042012a4:	74 69                	je     800420130f <cons_getc+0xad>
		c = cons.buf[cons.rpos++];
  80042012a6:	48 b8 20 80 37 04 80 	movabs $0x8004378020,%rax
  80042012ad:	00 00 00 
  80042012b0:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042012b6:	8d 48 01             	lea    0x1(%rax),%ecx
  80042012b9:	48 ba 20 80 37 04 80 	movabs $0x8004378020,%rdx
  80042012c0:	00 00 00 
  80042012c3:	89 8a 00 02 00 00    	mov    %ecx,0x200(%rdx)
  80042012c9:	48 ba 20 80 37 04 80 	movabs $0x8004378020,%rdx
  80042012d0:	00 00 00 
  80042012d3:	89 c0                	mov    %eax,%eax
  80042012d5:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  80042012d9:	0f b6 c0             	movzbl %al,%eax
  80042012dc:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if (cons.rpos == CONSBUFSIZE)
  80042012df:	48 b8 20 80 37 04 80 	movabs $0x8004378020,%rax
  80042012e6:	00 00 00 
  80042012e9:	8b 80 00 02 00 00    	mov    0x200(%rax),%eax
  80042012ef:	3d 00 02 00 00       	cmp    $0x200,%eax
  80042012f4:	75 14                	jne    800420130a <cons_getc+0xa8>
			cons.rpos = 0;
  80042012f6:	48 b8 20 80 37 04 80 	movabs $0x8004378020,%rax
  80042012fd:	00 00 00 
  8004201300:	c7 80 00 02 00 00 00 	movl   $0x0,0x200(%rax)
  8004201307:	00 00 00 
		return c;
  800420130a:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420130d:	eb 05                	jmp    8004201314 <cons_getc+0xb2>
	}
	return 0;
  800420130f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201314:	c9                   	leaveq 
  8004201315:	c3                   	retq   

0000008004201316 <cons_putc>:

// output a character to the console
static void
cons_putc(int c)
{
  8004201316:	55                   	push   %rbp
  8004201317:	48 89 e5             	mov    %rsp,%rbp
  800420131a:	48 83 ec 10          	sub    $0x10,%rsp
  800420131e:	89 7d fc             	mov    %edi,-0x4(%rbp)
	serial_putc(c);
  8004201321:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201324:	89 c7                	mov    %eax,%edi
  8004201326:	48 b8 3a 09 20 04 80 	movabs $0x800420093a,%rax
  800420132d:	00 00 00 
  8004201330:	ff d0                	callq  *%rax
	lpt_putc(c);
  8004201332:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201335:	89 c7                	mov    %eax,%edi
  8004201337:	48 b8 a7 0a 20 04 80 	movabs $0x8004200aa7,%rax
  800420133e:	00 00 00 
  8004201341:	ff d0                	callq  *%rax
	cga_putc(c);
  8004201343:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201346:	89 c7                	mov    %eax,%edi
  8004201348:	48 b8 46 0c 20 04 80 	movabs $0x8004200c46,%rax
  800420134f:	00 00 00 
  8004201352:	ff d0                	callq  *%rax
}
  8004201354:	c9                   	leaveq 
  8004201355:	c3                   	retq   

0000008004201356 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
  8004201356:	55                   	push   %rbp
  8004201357:	48 89 e5             	mov    %rsp,%rbp
	cga_init();
  800420135a:	48 b8 2c 0b 20 04 80 	movabs $0x8004200b2c,%rax
  8004201361:	00 00 00 
  8004201364:	ff d0                	callq  *%rax
	kbd_init();
  8004201366:	48 b8 a4 11 20 04 80 	movabs $0x80042011a4,%rax
  800420136d:	00 00 00 
  8004201370:	ff d0                	callq  *%rax
	serial_init();
  8004201372:	48 b8 9f 09 20 04 80 	movabs $0x800420099f,%rax
  8004201379:	00 00 00 
  800420137c:	ff d0                	callq  *%rax

	if (!serial_exists)
  800420137e:	48 b8 00 80 37 04 80 	movabs $0x8004378000,%rax
  8004201385:	00 00 00 
  8004201388:	0f b6 00             	movzbl (%rax),%eax
  800420138b:	83 f0 01             	xor    $0x1,%eax
  800420138e:	84 c0                	test   %al,%al
  8004201390:	74 1b                	je     80042013ad <cons_init+0x57>
		cprintf("Serial port does not exist!\n");
  8004201392:	48 bf 6f 7e 21 04 80 	movabs $0x8004217e6f,%rdi
  8004201399:	00 00 00 
  800420139c:	b8 00 00 00 00       	mov    $0x0,%eax
  80042013a1:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042013a8:	00 00 00 
  80042013ab:	ff d2                	callq  *%rdx
}
  80042013ad:	5d                   	pop    %rbp
  80042013ae:	c3                   	retq   

00000080042013af <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf.

void
cputchar(int c)
{
  80042013af:	55                   	push   %rbp
  80042013b0:	48 89 e5             	mov    %rsp,%rbp
  80042013b3:	48 83 ec 10          	sub    $0x10,%rsp
  80042013b7:	89 7d fc             	mov    %edi,-0x4(%rbp)
	cons_putc(c);
  80042013ba:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042013bd:	89 c7                	mov    %eax,%edi
  80042013bf:	48 b8 16 13 20 04 80 	movabs $0x8004201316,%rax
  80042013c6:	00 00 00 
  80042013c9:	ff d0                	callq  *%rax
}
  80042013cb:	c9                   	leaveq 
  80042013cc:	c3                   	retq   

00000080042013cd <getchar>:

int
getchar(void)
{
  80042013cd:	55                   	push   %rbp
  80042013ce:	48 89 e5             	mov    %rsp,%rbp
  80042013d1:	48 83 ec 10          	sub    $0x10,%rsp
	int c;

	while ((c = cons_getc()) == 0)
  80042013d5:	48 b8 62 12 20 04 80 	movabs $0x8004201262,%rax
  80042013dc:	00 00 00 
  80042013df:	ff d0                	callq  *%rax
  80042013e1:	89 45 fc             	mov    %eax,-0x4(%rbp)
  80042013e4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042013e8:	74 eb                	je     80042013d5 <getchar+0x8>
		/* do nothing */;
	return c;
  80042013ea:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042013ed:	c9                   	leaveq 
  80042013ee:	c3                   	retq   

00000080042013ef <iscons>:

int
iscons(int fdnum)
{
  80042013ef:	55                   	push   %rbp
  80042013f0:	48 89 e5             	mov    %rsp,%rbp
  80042013f3:	48 83 ec 04          	sub    $0x4,%rsp
  80042013f7:	89 7d fc             	mov    %edi,-0x4(%rbp)
	// used by readline
	return 1;
  80042013fa:	b8 01 00 00 00       	mov    $0x1,%eax
}
  80042013ff:	c9                   	leaveq 
  8004201400:	c3                   	retq   

0000008004201401 <mon_help>:

/***** Implementations of basic kernel monitor commands *****/

int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
  8004201401:	55                   	push   %rbp
  8004201402:	48 89 e5             	mov    %rsp,%rbp
  8004201405:	48 83 ec 30          	sub    $0x30,%rsp
  8004201409:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420140c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004201410:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201414:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420141b:	eb 6c                	jmp    8004201489 <mon_help+0x88>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
  800420141d:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  8004201424:	00 00 00 
  8004201427:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420142a:	48 63 d0             	movslq %eax,%rdx
  800420142d:	48 89 d0             	mov    %rdx,%rax
  8004201430:	48 01 c0             	add    %rax,%rax
  8004201433:	48 01 d0             	add    %rdx,%rax
  8004201436:	48 c1 e0 03          	shl    $0x3,%rax
  800420143a:	48 01 c8             	add    %rcx,%rax
  800420143d:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004201441:	48 be 80 b5 22 04 80 	movabs $0x800422b580,%rsi
  8004201448:	00 00 00 
  800420144b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420144e:	48 63 d0             	movslq %eax,%rdx
  8004201451:	48 89 d0             	mov    %rdx,%rax
  8004201454:	48 01 c0             	add    %rax,%rax
  8004201457:	48 01 d0             	add    %rdx,%rax
  800420145a:	48 c1 e0 03          	shl    $0x3,%rax
  800420145e:	48 01 f0             	add    %rsi,%rax
  8004201461:	48 8b 00             	mov    (%rax),%rax
  8004201464:	48 89 ca             	mov    %rcx,%rdx
  8004201467:	48 89 c6             	mov    %rax,%rsi
  800420146a:	48 bf 0a 7f 21 04 80 	movabs $0x8004217f0a,%rdi
  8004201471:	00 00 00 
  8004201474:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201479:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  8004201480:	00 00 00 
  8004201483:	ff d1                	callq  *%rcx
int
mon_help(int argc, char **argv, struct Trapframe *tf)
{
	int i;

	for (i = 0; i < NCOMMANDS; i++)
  8004201485:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004201489:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420148c:	83 f8 02             	cmp    $0x2,%eax
  800420148f:	76 8c                	jbe    800420141d <mon_help+0x1c>
		cprintf("%s - %s\n", commands[i].name, commands[i].desc);
	cprintf("%d",sizeof(int));	
  8004201491:	be 04 00 00 00       	mov    $0x4,%esi
  8004201496:	48 bf 13 7f 21 04 80 	movabs $0x8004217f13,%rdi
  800420149d:	00 00 00 
  80042014a0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014a5:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042014ac:	00 00 00 
  80042014af:	ff d2                	callq  *%rdx
	return 0;
  80042014b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042014b6:	c9                   	leaveq 
  80042014b7:	c3                   	retq   

00000080042014b8 <mon_kerninfo>:

int
mon_kerninfo(int argc, char **argv, struct Trapframe *tf)
{
  80042014b8:	55                   	push   %rbp
  80042014b9:	48 89 e5             	mov    %rsp,%rbp
  80042014bc:	48 83 ec 30          	sub    $0x30,%rsp
  80042014c0:	89 7d ec             	mov    %edi,-0x14(%rbp)
  80042014c3:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042014c7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	extern char _start[], entry[], etext[], edata[], end[];

	cprintf("Special kernel symbols:\n");
  80042014cb:	48 bf 16 7f 21 04 80 	movabs $0x8004217f16,%rdi
  80042014d2:	00 00 00 
  80042014d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014da:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042014e1:	00 00 00 
  80042014e4:	ff d2                	callq  *%rdx
	cprintf("  _start                  %08x (phys)\n", _start);
  80042014e6:	48 be 0c 00 20 00 00 	movabs $0x20000c,%rsi
  80042014ed:	00 00 00 
  80042014f0:	48 bf 30 7f 21 04 80 	movabs $0x8004217f30,%rdi
  80042014f7:	00 00 00 
  80042014fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042014ff:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201506:	00 00 00 
  8004201509:	ff d2                	callq  *%rdx
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
  800420150b:	48 ba 0c 00 20 00 00 	movabs $0x20000c,%rdx
  8004201512:	00 00 00 
  8004201515:	48 be 0c 00 20 04 80 	movabs $0x800420000c,%rsi
  800420151c:	00 00 00 
  800420151f:	48 bf 58 7f 21 04 80 	movabs $0x8004217f58,%rdi
  8004201526:	00 00 00 
  8004201529:	b8 00 00 00 00       	mov    $0x0,%eax
  800420152e:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  8004201535:	00 00 00 
  8004201538:	ff d1                	callq  *%rcx
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
  800420153a:	48 ba d3 7c 21 00 00 	movabs $0x217cd3,%rdx
  8004201541:	00 00 00 
  8004201544:	48 be d3 7c 21 04 80 	movabs $0x8004217cd3,%rsi
  800420154b:	00 00 00 
  800420154e:	48 bf 80 7f 21 04 80 	movabs $0x8004217f80,%rdi
  8004201555:	00 00 00 
  8004201558:	b8 00 00 00 00       	mov    $0x0,%eax
  800420155d:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  8004201564:	00 00 00 
  8004201567:	ff d1                	callq  *%rcx
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
  8004201569:	48 ba 99 7d 37 00 00 	movabs $0x377d99,%rdx
  8004201570:	00 00 00 
  8004201573:	48 be 99 7d 37 04 80 	movabs $0x8004377d99,%rsi
  800420157a:	00 00 00 
  800420157d:	48 bf a8 7f 21 04 80 	movabs $0x8004217fa8,%rdi
  8004201584:	00 00 00 
  8004201587:	b8 00 00 00 00       	mov    $0x0,%eax
  800420158c:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  8004201593:	00 00 00 
  8004201596:	ff d1                	callq  *%rcx
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
  8004201598:	48 ba 10 c0 3b 00 00 	movabs $0x3bc010,%rdx
  800420159f:	00 00 00 
  80042015a2:	48 be 10 c0 3b 04 80 	movabs $0x80043bc010,%rsi
  80042015a9:	00 00 00 
  80042015ac:	48 bf d0 7f 21 04 80 	movabs $0x8004217fd0,%rdi
  80042015b3:	00 00 00 
  80042015b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042015bb:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  80042015c2:	00 00 00 
  80042015c5:	ff d1                	callq  *%rcx
	cprintf("Kernel executable memory footprint: %dKB\n",
		ROUNDUP(end - entry, 1024) / 1024);
  80042015c7:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  80042015ce:	00 
  80042015cf:	48 b8 0c 00 20 04 80 	movabs $0x800420000c,%rax
  80042015d6:	00 00 00 
  80042015d9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042015dd:	48 29 c2             	sub    %rax,%rdx
  80042015e0:	48 b8 10 c0 3b 04 80 	movabs $0x80043bc010,%rax
  80042015e7:	00 00 00 
  80042015ea:	48 83 e8 01          	sub    $0x1,%rax
  80042015ee:	48 01 d0             	add    %rdx,%rax
  80042015f1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042015f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042015f9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042015fe:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004201602:	48 89 d0             	mov    %rdx,%rax
  8004201605:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004201609:	48 29 c2             	sub    %rax,%rdx
  800420160c:	48 89 d0             	mov    %rdx,%rax
	cprintf("  _start                  %08x (phys)\n", _start);
	cprintf("  entry  %08x (virt)  %08x (phys)\n", entry, entry - KERNBASE);
	cprintf("  etext  %08x (virt)  %08x (phys)\n", etext, etext - KERNBASE);
	cprintf("  edata  %08x (virt)  %08x (phys)\n", edata, edata - KERNBASE);
	cprintf("  end    %08x (virt)  %08x (phys)\n", end, end - KERNBASE);
	cprintf("Kernel executable memory footprint: %dKB\n",
  800420160f:	48 8d 90 ff 03 00 00 	lea    0x3ff(%rax),%rdx
  8004201616:	48 85 c0             	test   %rax,%rax
  8004201619:	48 0f 48 c2          	cmovs  %rdx,%rax
  800420161d:	48 c1 f8 0a          	sar    $0xa,%rax
  8004201621:	48 89 c6             	mov    %rax,%rsi
  8004201624:	48 bf f8 7f 21 04 80 	movabs $0x8004217ff8,%rdi
  800420162b:	00 00 00 
  800420162e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201633:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420163a:	00 00 00 
  800420163d:	ff d2                	callq  *%rdx
		ROUNDUP(end - entry, 1024) / 1024);
	return 0;
  800420163f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201644:	c9                   	leaveq 
  8004201645:	c3                   	retq   

0000008004201646 <printArgList>:

void printArgList(uint64_t* prbp, struct Ripdebuginfo *info)
{
  8004201646:	55                   	push   %rbp
  8004201647:	48 89 e5             	mov    %rsp,%rbp
  800420164a:	48 83 ec 30          	sub    $0x30,%rsp
  800420164e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004201652:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t* tprbp = (uint64_t*)(prbp - 4);
  8004201656:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420165a:	48 83 e8 20          	sub    $0x20,%rax
  800420165e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	int numberArg = info->rip_fn_narg;
  8004201662:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004201666:	8b 40 28             	mov    0x28(%rax),%eax
  8004201669:	89 45 f4             	mov    %eax,-0xc(%rbp)
	int i = 0;
  800420166c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
	uint64_t size = 0;
  8004201673:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800420167a:	00 
	if(numberArg <= 0)
  800420167b:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420167f:	7f 20                	jg     80042016a1 <printArgList+0x5b>
	{
		cprintf("\n");
  8004201681:	48 bf 22 80 21 04 80 	movabs $0x8004218022,%rdi
  8004201688:	00 00 00 
  800420168b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201690:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201697:	00 00 00 
  800420169a:	ff d2                	callq  *%rdx
		return;
  800420169c:	e9 0f 01 00 00       	jmpq   80042017b0 <printArgList+0x16a>
	}
	
	while(numberArg > 0)
  80042016a1:	e9 e5 00 00 00       	jmpq   800420178b <printArgList+0x145>
	{
		//cprintf("size of argument %d is %d %x",i, info->size_fn_arg[i],*prbp);
		size = info->size_fn_arg[i];
  80042016a6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042016aa:	8b 55 f0             	mov    -0x10(%rbp),%edx
  80042016ad:	48 63 d2             	movslq %edx,%rdx
  80042016b0:	48 83 c2 08          	add    $0x8,%rdx
  80042016b4:	8b 44 90 0c          	mov    0xc(%rax,%rdx,4),%eax
  80042016b8:	48 98                	cltq   
  80042016ba:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		cprintf(" ");
  80042016be:	48 bf 24 80 21 04 80 	movabs $0x8004218024,%rdi
  80042016c5:	00 00 00 
  80042016c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042016cd:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042016d4:	00 00 00 
  80042016d7:	ff d2                	callq  *%rdx
		switch(size)
  80042016d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042016dd:	48 83 f8 04          	cmp    $0x4,%rax
  80042016e1:	74 43                	je     8004201726 <printArgList+0xe0>
  80042016e3:	48 83 f8 08          	cmp    $0x8,%rax
  80042016e7:	74 6b                	je     8004201754 <printArgList+0x10e>
  80042016e9:	48 83 f8 01          	cmp    $0x1,%rax
  80042016ed:	74 05                	je     80042016f4 <printArgList+0xae>
			case 8:
				cprintf("%016x",*(tprbp -1));
				tprbp = tprbp - 1;
				break;
			default:
				break;
  80042016ef:	e9 8f 00 00 00       	jmpq   8004201783 <printArgList+0x13d>
		size = info->size_fn_arg[i];
		cprintf(" ");
		switch(size)
		{
			case 1:
				cprintf("%016x",*((char*)tprbp -1));
  80042016f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042016f8:	48 83 e8 01          	sub    $0x1,%rax
  80042016fc:	0f b6 00             	movzbl (%rax),%eax
  80042016ff:	0f be c0             	movsbl %al,%eax
  8004201702:	89 c6                	mov    %eax,%esi
  8004201704:	48 bf 26 80 21 04 80 	movabs $0x8004218026,%rdi
  800420170b:	00 00 00 
  800420170e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201713:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420171a:	00 00 00 
  800420171d:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((char*)tprbp - 1);
  800420171f:	48 83 6d f8 01       	subq   $0x1,-0x8(%rbp)
				break;
  8004201724:	eb 5d                	jmp    8004201783 <printArgList+0x13d>
			case 4:
				cprintf("%016x",*((int*)tprbp -1));
  8004201726:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420172a:	48 83 e8 04          	sub    $0x4,%rax
  800420172e:	8b 00                	mov    (%rax),%eax
  8004201730:	89 c6                	mov    %eax,%esi
  8004201732:	48 bf 26 80 21 04 80 	movabs $0x8004218026,%rdi
  8004201739:	00 00 00 
  800420173c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201741:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201748:	00 00 00 
  800420174b:	ff d2                	callq  *%rdx
				tprbp = (uint64_t*)((int*)tprbp - 1);
  800420174d:	48 83 6d f8 04       	subq   $0x4,-0x8(%rbp)
				break;
  8004201752:	eb 2f                	jmp    8004201783 <printArgList+0x13d>
			case 8:
				cprintf("%016x",*(tprbp -1));
  8004201754:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201758:	48 83 e8 08          	sub    $0x8,%rax
  800420175c:	48 8b 00             	mov    (%rax),%rax
  800420175f:	48 89 c6             	mov    %rax,%rsi
  8004201762:	48 bf 26 80 21 04 80 	movabs $0x8004218026,%rdi
  8004201769:	00 00 00 
  800420176c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201771:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201778:	00 00 00 
  800420177b:	ff d2                	callq  *%rdx
				tprbp = tprbp - 1;
  800420177d:	48 83 6d f8 08       	subq   $0x8,-0x8(%rbp)
				break;
  8004201782:	90                   	nop
			default:
				break;
		}
		i++;
  8004201783:	83 45 f0 01          	addl   $0x1,-0x10(%rbp)
		numberArg--;
  8004201787:	83 6d f4 01          	subl   $0x1,-0xc(%rbp)
	{
		cprintf("\n");
		return;
	}
	
	while(numberArg > 0)
  800420178b:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420178f:	0f 8f 11 ff ff ff    	jg     80042016a6 <printArgList+0x60>
				break;
		}
		i++;
		numberArg--;
	}
	cprintf("\n");
  8004201795:	48 bf 22 80 21 04 80 	movabs $0x8004218022,%rdi
  800420179c:	00 00 00 
  800420179f:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017a4:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042017ab:	00 00 00 
  80042017ae:	ff d2                	callq  *%rdx
}
  80042017b0:	c9                   	leaveq 
  80042017b1:	c3                   	retq   

00000080042017b2 <mon_backtrace>:

int
mon_backtrace(int argc, char **argv, struct Trapframe *tf)
{
  80042017b2:	55                   	push   %rbp
  80042017b3:	48 89 e5             	mov    %rsp,%rbp
  80042017b6:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  80042017bd:	89 bd fc fa ff ff    	mov    %edi,-0x504(%rbp)
  80042017c3:	48 89 b5 f0 fa ff ff 	mov    %rsi,-0x510(%rbp)
  80042017ca:	48 89 95 e8 fa ff ff 	mov    %rdx,-0x518(%rbp)
	// Your code here.
	uint64_t rbp = 0x0;
  80042017d1:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042017d8:	00 
	uint64_t rip = 0x0;
  80042017d9:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042017e0:	00 
	uint64_t* prbp = NULL;
  80042017e1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042017e8:	00 

	struct Ripdebuginfo info;

	cprintf("Stack backtrace:\n");
  80042017e9:	48 bf 2c 80 21 04 80 	movabs $0x800421802c,%rdi
  80042017f0:	00 00 00 
  80042017f3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042017f8:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042017ff:	00 00 00 
  8004201802:	ff d2                	callq  *%rdx

    static __inline uint64_t
read_rbp(void)
{
    uint64_t rbp;
    __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004201804:	48 89 e8             	mov    %rbp,%rax
  8004201807:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    return rbp;
  800420180b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
	rbp = read_rbp();
  800420180f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	read_rip(rip);
  8004201813:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 800420181a <mon_backtrace+0x68>
  800420181a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if(rbp == 0x0 || rip == 0x0)
  800420181e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004201823:	74 07                	je     800420182c <mon_backtrace+0x7a>
  8004201825:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420182a:	75 25                	jne    8004201851 <mon_backtrace+0x9f>
	{
		cprintf("Not able to show backtrace");
  800420182c:	48 bf 3e 80 21 04 80 	movabs $0x800421803e,%rdi
  8004201833:	00 00 00 
  8004201836:	b8 00 00 00 00       	mov    $0x0,%eax
  800420183b:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201842:	00 00 00 
  8004201845:	ff d2                	callq  *%rdx
		return -1;
  8004201847:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420184c:	e9 2c 02 00 00       	jmpq   8004201a7d <mon_backtrace+0x2cb>
	}
	prbp = (uint64_t*)(rbp);
  8004201851:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004201855:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("    rbp %016x  rip %016x\n", prbp, rip);
  8004201859:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420185d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201861:	48 89 c6             	mov    %rax,%rsi
  8004201864:	48 bf 59 80 21 04 80 	movabs $0x8004218059,%rdi
  800420186b:	00 00 00 
  800420186e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201873:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  800420187a:	00 00 00 
  800420187d:	ff d1                	callq  *%rcx
	debuginfo_rip(rip ,&info);
  800420187f:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201886:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420188a:	48 89 d6             	mov    %rdx,%rsi
  800420188d:	48 89 c7             	mov    %rax,%rdi
  8004201890:	48 b8 e9 e6 20 04 80 	movabs $0x800420e6e9,%rax
  8004201897:	00 00 00 
  800420189a:	ff d0                	callq  *%rax
	
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  800420189c:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  80042018a2:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  80042018a9:	48 89 c6             	mov    %rax,%rsi
  80042018ac:	48 bf 73 80 21 04 80 	movabs $0x8004218073,%rdi
  80042018b3:	00 00 00 
  80042018b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018bb:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  80042018c2:	00 00 00 
  80042018c5:	ff d1                	callq  *%rcx
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  80042018c7:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  80042018ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042018d2:	48 89 d1             	mov    %rdx,%rcx
  80042018d5:	48 29 c1             	sub    %rax,%rcx
  80042018d8:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  80042018df:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  80042018e5:	89 c6                	mov    %eax,%esi
  80042018e7:	48 bf 83 80 21 04 80 	movabs $0x8004218083,%rdi
  80042018ee:	00 00 00 
  80042018f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042018f6:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  80042018fd:	00 00 00 
  8004201900:	41 ff d0             	callq  *%r8
	cprintf(" args:%d", info.rip_fn_narg);
  8004201903:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  8004201909:	89 c6                	mov    %eax,%esi
  800420190b:	48 bf 8e 80 21 04 80 	movabs $0x800421808e,%rdi
  8004201912:	00 00 00 
  8004201915:	b8 00 00 00 00       	mov    $0x0,%eax
  800420191a:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201921:	00 00 00 
  8004201924:	ff d2                	callq  *%rdx
	printArgList(prbp, &info);
  8004201926:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  800420192d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201931:	48 89 d6             	mov    %rdx,%rsi
  8004201934:	48 89 c7             	mov    %rax,%rdi
  8004201937:	48 b8 46 16 20 04 80 	movabs $0x8004201646,%rax
  800420193e:	00 00 00 
  8004201941:	ff d0                	callq  *%rax

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  8004201943:	e9 09 01 00 00       	jmpq   8004201a51 <mon_backtrace+0x29f>
	{
		cprintf("    rbp %016x  rip %016x\n",*(prbp),*((prbp) +1));
  8004201948:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420194c:	48 83 c0 08          	add    $0x8,%rax
  8004201950:	48 8b 10             	mov    (%rax),%rdx
  8004201953:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201957:	48 8b 00             	mov    (%rax),%rax
  800420195a:	48 89 c6             	mov    %rax,%rsi
  800420195d:	48 bf 59 80 21 04 80 	movabs $0x8004218059,%rdi
  8004201964:	00 00 00 
  8004201967:	b8 00 00 00 00       	mov    $0x0,%eax
  800420196c:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  8004201973:	00 00 00 
  8004201976:	ff d1                	callq  *%rcx
		debuginfo_rip(*(prbp+1) ,&info);
  8004201978:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420197c:	48 83 c0 08          	add    $0x8,%rax
  8004201980:	48 8b 00             	mov    (%rax),%rax
  8004201983:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  800420198a:	48 89 d6             	mov    %rdx,%rsi
  800420198d:	48 89 c7             	mov    %rax,%rdi
  8004201990:	48 b8 e9 e6 20 04 80 	movabs $0x800420e6e9,%rax
  8004201997:	00 00 00 
  800420199a:	ff d0                	callq  *%rax

		cprintf("        %s:%d: ",info.rip_file, info.rip_line);
  800420199c:	8b 95 08 fb ff ff    	mov    -0x4f8(%rbp),%edx
  80042019a2:	48 8b 85 00 fb ff ff 	mov    -0x500(%rbp),%rax
  80042019a9:	48 89 c6             	mov    %rax,%rsi
  80042019ac:	48 bf 73 80 21 04 80 	movabs $0x8004218073,%rdi
  80042019b3:	00 00 00 
  80042019b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019bb:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  80042019c2:	00 00 00 
  80042019c5:	ff d1                	callq  *%rcx
		cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
  80042019c7:	48 8b 85 20 fb ff ff 	mov    -0x4e0(%rbp),%rax
  80042019ce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042019d2:	48 89 d1             	mov    %rdx,%rcx
  80042019d5:	48 29 c1             	sub    %rax,%rcx
  80042019d8:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  80042019df:	8b 85 18 fb ff ff    	mov    -0x4e8(%rbp),%eax
  80042019e5:	89 c6                	mov    %eax,%esi
  80042019e7:	48 bf 83 80 21 04 80 	movabs $0x8004218083,%rdi
  80042019ee:	00 00 00 
  80042019f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042019f6:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  80042019fd:	00 00 00 
  8004201a00:	41 ff d0             	callq  *%r8
		cprintf(" args:%d", info.rip_fn_narg);
  8004201a03:	8b 85 28 fb ff ff    	mov    -0x4d8(%rbp),%eax
  8004201a09:	89 c6                	mov    %eax,%esi
  8004201a0b:	48 bf 8e 80 21 04 80 	movabs $0x800421808e,%rdi
  8004201a12:	00 00 00 
  8004201a15:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201a1a:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201a21:	00 00 00 
  8004201a24:	ff d2                	callq  *%rdx
		printArgList((uint64_t*)(*(prbp)), &info);
  8004201a26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a2a:	48 8b 00             	mov    (%rax),%rax
  8004201a2d:	48 8d 95 00 fb ff ff 	lea    -0x500(%rbp),%rdx
  8004201a34:	48 89 d6             	mov    %rdx,%rsi
  8004201a37:	48 89 c7             	mov    %rax,%rdi
  8004201a3a:	48 b8 46 16 20 04 80 	movabs $0x8004201646,%rax
  8004201a41:	00 00 00 
  8004201a44:	ff d0                	callq  *%rax
		
		prbp = (uint64_t*)(*(prbp)); 
  8004201a46:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a4a:	48 8b 00             	mov    (%rax),%rax
  8004201a4d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	cprintf("        %s:%d: ",info.rip_file, info.rip_line);
	cprintf("%.*s+%016x",info.rip_fn_namelen, info.rip_fn_name, (rip - info.rip_fn_addr));
	cprintf(" args:%d", info.rip_fn_narg);
	printArgList(prbp, &info);

	while(prbp && *(prbp) != 0x0 && *(prbp+1) != 0x0)
  8004201a51:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201a56:	74 20                	je     8004201a78 <mon_backtrace+0x2c6>
  8004201a58:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a5c:	48 8b 00             	mov    (%rax),%rax
  8004201a5f:	48 85 c0             	test   %rax,%rax
  8004201a62:	74 14                	je     8004201a78 <mon_backtrace+0x2c6>
  8004201a64:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201a68:	48 83 c0 08          	add    $0x8,%rax
  8004201a6c:	48 8b 00             	mov    (%rax),%rax
  8004201a6f:	48 85 c0             	test   %rax,%rax
  8004201a72:	0f 85 d0 fe ff ff    	jne    8004201948 <mon_backtrace+0x196>
		cprintf(" args:%d", info.rip_fn_narg);
		printArgList((uint64_t*)(*(prbp)), &info);
		
		prbp = (uint64_t*)(*(prbp)); 
	}
	return 0;
  8004201a78:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201a7d:	c9                   	leaveq 
  8004201a7e:	c3                   	retq   

0000008004201a7f <runcmd>:
#define WHITESPACE "\t\r\n "
#define MAXARGS 16

static int
runcmd(char *buf, struct Trapframe *tf)
{
  8004201a7f:	55                   	push   %rbp
  8004201a80:	48 89 e5             	mov    %rsp,%rbp
  8004201a83:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004201a8a:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004201a91:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
	int argc;
	char *argv[MAXARGS];
	int i;

	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
  8004201a98:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	argv[argc] = 0;
  8004201a9f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201aa2:	48 98                	cltq   
  8004201aa4:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201aab:	ff 00 00 00 00 
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201ab0:	eb 15                	jmp    8004201ac7 <runcmd+0x48>
			*buf++ = 0;
  8004201ab2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201ab9:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004201abd:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
  8004201ac4:	c6 00 00             	movb   $0x0,(%rax)
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201ac7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201ace:	0f b6 00             	movzbl (%rax),%eax
  8004201ad1:	84 c0                	test   %al,%al
  8004201ad3:	74 2a                	je     8004201aff <runcmd+0x80>
  8004201ad5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201adc:	0f b6 00             	movzbl (%rax),%eax
  8004201adf:	0f be c0             	movsbl %al,%eax
  8004201ae2:	89 c6                	mov    %eax,%esi
  8004201ae4:	48 bf 97 80 21 04 80 	movabs $0x8004218097,%rdi
  8004201aeb:	00 00 00 
  8004201aee:	48 b8 0a fa 20 04 80 	movabs $0x800420fa0a,%rax
  8004201af5:	00 00 00 
  8004201af8:	ff d0                	callq  *%rax
  8004201afa:	48 85 c0             	test   %rax,%rax
  8004201afd:	75 b3                	jne    8004201ab2 <runcmd+0x33>
			*buf++ = 0;
		if (*buf == 0)
  8004201aff:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201b06:	0f b6 00             	movzbl (%rax),%eax
  8004201b09:	84 c0                	test   %al,%al
  8004201b0b:	75 21                	jne    8004201b2e <runcmd+0xaf>
			break;
  8004201b0d:	90                   	nop
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
			buf++;
	}
	argv[argc] = 0;
  8004201b0e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201b11:	48 98                	cltq   
  8004201b13:	48 c7 84 c5 70 ff ff 	movq   $0x0,-0x90(%rbp,%rax,8)
  8004201b1a:	ff 00 00 00 00 

	// Lookup and invoke the command
	if (argc == 0)
  8004201b1f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004201b23:	0f 85 a1 00 00 00    	jne    8004201bca <runcmd+0x14b>
  8004201b29:	e9 92 00 00 00       	jmpq   8004201bc0 <runcmd+0x141>
			*buf++ = 0;
		if (*buf == 0)
			break;

		// save and scan past next arg
		if (argc == MAXARGS-1) {
  8004201b2e:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004201b32:	75 2a                	jne    8004201b5e <runcmd+0xdf>
			cprintf("Too many arguments (max %d)\n", MAXARGS);
  8004201b34:	be 10 00 00 00       	mov    $0x10,%esi
  8004201b39:	48 bf 9c 80 21 04 80 	movabs $0x800421809c,%rdi
  8004201b40:	00 00 00 
  8004201b43:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b48:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201b4f:	00 00 00 
  8004201b52:	ff d2                	callq  *%rdx
			return 0;
  8004201b54:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201b59:	e9 30 01 00 00       	jmpq   8004201c8e <runcmd+0x20f>
		}
		argv[argc++] = buf;
  8004201b5e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004201b61:	8d 50 01             	lea    0x1(%rax),%edx
  8004201b64:	89 55 fc             	mov    %edx,-0x4(%rbp)
  8004201b67:	48 98                	cltq   
  8004201b69:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004201b70:	48 89 94 c5 70 ff ff 	mov    %rdx,-0x90(%rbp,%rax,8)
  8004201b77:	ff 
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201b78:	eb 08                	jmp    8004201b82 <runcmd+0x103>
			buf++;
  8004201b7a:	48 83 85 68 ff ff ff 	addq   $0x1,-0x98(%rbp)
  8004201b81:	01 
		if (argc == MAXARGS-1) {
			cprintf("Too many arguments (max %d)\n", MAXARGS);
			return 0;
		}
		argv[argc++] = buf;
		while (*buf && !strchr(WHITESPACE, *buf))
  8004201b82:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201b89:	0f b6 00             	movzbl (%rax),%eax
  8004201b8c:	84 c0                	test   %al,%al
  8004201b8e:	74 2a                	je     8004201bba <runcmd+0x13b>
  8004201b90:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004201b97:	0f b6 00             	movzbl (%rax),%eax
  8004201b9a:	0f be c0             	movsbl %al,%eax
  8004201b9d:	89 c6                	mov    %eax,%esi
  8004201b9f:	48 bf 97 80 21 04 80 	movabs $0x8004218097,%rdi
  8004201ba6:	00 00 00 
  8004201ba9:	48 b8 0a fa 20 04 80 	movabs $0x800420fa0a,%rax
  8004201bb0:	00 00 00 
  8004201bb3:	ff d0                	callq  *%rax
  8004201bb5:	48 85 c0             	test   %rax,%rax
  8004201bb8:	74 c0                	je     8004201b7a <runcmd+0xfb>
			buf++;
	}
  8004201bba:	90                   	nop
	// Parse the command buffer into whitespace-separated arguments
	argc = 0;
	argv[argc] = 0;
	while (1) {
		// gobble whitespace
		while (*buf && strchr(WHITESPACE, *buf))
  8004201bbb:	e9 07 ff ff ff       	jmpq   8004201ac7 <runcmd+0x48>
	}
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
  8004201bc0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201bc5:	e9 c4 00 00 00       	jmpq   8004201c8e <runcmd+0x20f>
	for (i = 0; i < NCOMMANDS; i++) {
  8004201bca:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004201bd1:	e9 82 00 00 00       	jmpq   8004201c58 <runcmd+0x1d9>
		if (strcmp(argv[0], commands[i].name) == 0)
  8004201bd6:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  8004201bdd:	00 00 00 
  8004201be0:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201be3:	48 63 d0             	movslq %eax,%rdx
  8004201be6:	48 89 d0             	mov    %rdx,%rax
  8004201be9:	48 01 c0             	add    %rax,%rax
  8004201bec:	48 01 d0             	add    %rdx,%rax
  8004201bef:	48 c1 e0 03          	shl    $0x3,%rax
  8004201bf3:	48 01 c8             	add    %rcx,%rax
  8004201bf6:	48 8b 10             	mov    (%rax),%rdx
  8004201bf9:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201c00:	48 89 d6             	mov    %rdx,%rsi
  8004201c03:	48 89 c7             	mov    %rax,%rdi
  8004201c06:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  8004201c0d:	00 00 00 
  8004201c10:	ff d0                	callq  *%rax
  8004201c12:	85 c0                	test   %eax,%eax
  8004201c14:	75 3e                	jne    8004201c54 <runcmd+0x1d5>
			return commands[i].func(argc, argv, tf);
  8004201c16:	48 b9 80 b5 22 04 80 	movabs $0x800422b580,%rcx
  8004201c1d:	00 00 00 
  8004201c20:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201c23:	48 63 d0             	movslq %eax,%rdx
  8004201c26:	48 89 d0             	mov    %rdx,%rax
  8004201c29:	48 01 c0             	add    %rax,%rax
  8004201c2c:	48 01 d0             	add    %rdx,%rax
  8004201c2f:	48 c1 e0 03          	shl    $0x3,%rax
  8004201c33:	48 01 c8             	add    %rcx,%rax
  8004201c36:	48 83 c0 10          	add    $0x10,%rax
  8004201c3a:	48 8b 00             	mov    (%rax),%rax
  8004201c3d:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004201c44:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
  8004201c4b:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004201c4e:	89 cf                	mov    %ecx,%edi
  8004201c50:	ff d0                	callq  *%rax
  8004201c52:	eb 3a                	jmp    8004201c8e <runcmd+0x20f>
	argv[argc] = 0;

	// Lookup and invoke the command
	if (argc == 0)
		return 0;
	for (i = 0; i < NCOMMANDS; i++) {
  8004201c54:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  8004201c58:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004201c5b:	83 f8 02             	cmp    $0x2,%eax
  8004201c5e:	0f 86 72 ff ff ff    	jbe    8004201bd6 <runcmd+0x157>
		if (strcmp(argv[0], commands[i].name) == 0)
			return commands[i].func(argc, argv, tf);
	}
	cprintf("Unknown command '%s'\n", argv[0]);
  8004201c64:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004201c6b:	48 89 c6             	mov    %rax,%rsi
  8004201c6e:	48 bf b9 80 21 04 80 	movabs $0x80042180b9,%rdi
  8004201c75:	00 00 00 
  8004201c78:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201c7d:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201c84:	00 00 00 
  8004201c87:	ff d2                	callq  *%rdx
	return 0;
  8004201c89:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004201c8e:	c9                   	leaveq 
  8004201c8f:	c3                   	retq   

0000008004201c90 <monitor>:

void
monitor(struct Trapframe *tf)
{
  8004201c90:	55                   	push   %rbp
  8004201c91:	48 89 e5             	mov    %rsp,%rbp
  8004201c94:	48 83 ec 20          	sub    $0x20,%rsp
  8004201c98:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	char *buf;

	cprintf("Welcome to the JOS kernel monitor!\n");
  8004201c9c:	48 bf d0 80 21 04 80 	movabs $0x80042180d0,%rdi
  8004201ca3:	00 00 00 
  8004201ca6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201cab:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201cb2:	00 00 00 
  8004201cb5:	ff d2                	callq  *%rdx
	cprintf("Type 'help' for a list of commands.\n");
  8004201cb7:	48 bf f8 80 21 04 80 	movabs $0x80042180f8,%rdi
  8004201cbe:	00 00 00 
  8004201cc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201cc6:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201ccd:	00 00 00 
  8004201cd0:	ff d2                	callq  *%rdx

	if (tf != NULL)
  8004201cd2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004201cd7:	74 13                	je     8004201cec <monitor+0x5c>
		print_trapframe(tf);
  8004201cd9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201cdd:	48 89 c7             	mov    %rax,%rdi
  8004201ce0:	48 b8 55 bf 20 04 80 	movabs $0x800420bf55,%rax
  8004201ce7:	00 00 00 
  8004201cea:	ff d0                	callq  *%rax

	while (1) {
		buf = readline("K> ");
  8004201cec:	48 bf 1d 81 21 04 80 	movabs $0x800421811d,%rdi
  8004201cf3:	00 00 00 
  8004201cf6:	48 b8 23 f6 20 04 80 	movabs $0x800420f623,%rax
  8004201cfd:	00 00 00 
  8004201d00:	ff d0                	callq  *%rax
  8004201d02:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (buf != NULL)
  8004201d06:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004201d0b:	74 20                	je     8004201d2d <monitor+0x9d>
			if (runcmd(buf, tf) < 0)
  8004201d0d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004201d11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d15:	48 89 d6             	mov    %rdx,%rsi
  8004201d18:	48 89 c7             	mov    %rax,%rdi
  8004201d1b:	48 b8 7f 1a 20 04 80 	movabs $0x8004201a7f,%rax
  8004201d22:	00 00 00 
  8004201d25:	ff d0                	callq  *%rax
  8004201d27:	85 c0                	test   %eax,%eax
  8004201d29:	79 02                	jns    8004201d2d <monitor+0x9d>
				break;
  8004201d2b:	eb 02                	jmp    8004201d2f <monitor+0x9f>
	}
  8004201d2d:	eb bd                	jmp    8004201cec <monitor+0x5c>
}
  8004201d2f:	c9                   	leaveq 
  8004201d30:	c3                   	retq   

0000008004201d31 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004201d31:	55                   	push   %rbp
  8004201d32:	48 89 e5             	mov    %rsp,%rbp
  8004201d35:	48 83 ec 08          	sub    $0x8,%rsp
  8004201d39:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004201d3d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201d41:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004201d48:	00 00 00 
  8004201d4b:	48 8b 00             	mov    (%rax),%rax
  8004201d4e:	48 29 c2             	sub    %rax,%rdx
  8004201d51:	48 89 d0             	mov    %rdx,%rax
  8004201d54:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004201d58:	c9                   	leaveq 
  8004201d59:	c3                   	retq   

0000008004201d5a <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004201d5a:	55                   	push   %rbp
  8004201d5b:	48 89 e5             	mov    %rsp,%rbp
  8004201d5e:	48 83 ec 08          	sub    $0x8,%rsp
  8004201d62:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  8004201d66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d6a:	48 89 c7             	mov    %rax,%rdi
  8004201d6d:	48 b8 31 1d 20 04 80 	movabs $0x8004201d31,%rax
  8004201d74:	00 00 00 
  8004201d77:	ff d0                	callq  *%rax
  8004201d79:	48 c1 e0 0c          	shl    $0xc,%rax
}
  8004201d7d:	c9                   	leaveq 
  8004201d7e:	c3                   	retq   

0000008004201d7f <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  8004201d7f:	55                   	push   %rbp
  8004201d80:	48 89 e5             	mov    %rsp,%rbp
  8004201d83:	48 83 ec 10          	sub    $0x10,%rsp
  8004201d87:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  8004201d8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201d8f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201d93:	48 89 c2             	mov    %rax,%rdx
  8004201d96:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004201d9d:	00 00 00 
  8004201da0:	48 8b 00             	mov    (%rax),%rax
  8004201da3:	48 39 c2             	cmp    %rax,%rdx
  8004201da6:	72 2a                	jb     8004201dd2 <pa2page+0x53>
		panic("pa2page called with invalid pa");
  8004201da8:	48 ba 28 81 21 04 80 	movabs $0x8004218128,%rdx
  8004201daf:	00 00 00 
  8004201db2:	be 54 00 00 00       	mov    $0x54,%esi
  8004201db7:	48 bf 47 81 21 04 80 	movabs $0x8004218147,%rdi
  8004201dbe:	00 00 00 
  8004201dc1:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201dc6:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  8004201dcd:	00 00 00 
  8004201dd0:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  8004201dd2:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004201dd9:	00 00 00 
  8004201ddc:	48 8b 00             	mov    (%rax),%rax
  8004201ddf:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004201de3:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004201de7:	48 c1 e2 04          	shl    $0x4,%rdx
  8004201deb:	48 01 d0             	add    %rdx,%rax
}
  8004201dee:	c9                   	leaveq 
  8004201def:	c3                   	retq   

0000008004201df0 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004201df0:	55                   	push   %rbp
  8004201df1:	48 89 e5             	mov    %rsp,%rbp
  8004201df4:	48 83 ec 20          	sub    $0x20,%rsp
  8004201df8:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004201dfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004201e00:	48 89 c7             	mov    %rax,%rdi
  8004201e03:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004201e0a:	00 00 00 
  8004201e0d:	ff d0                	callq  *%rax
  8004201e0f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004201e13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201e17:	48 c1 e8 0c          	shr    $0xc,%rax
  8004201e1b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004201e1e:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004201e21:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004201e28:	00 00 00 
  8004201e2b:	48 8b 00             	mov    (%rax),%rax
  8004201e2e:	48 39 c2             	cmp    %rax,%rdx
  8004201e31:	72 32                	jb     8004201e65 <page2kva+0x75>
  8004201e33:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201e37:	48 89 c1             	mov    %rax,%rcx
  8004201e3a:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004201e41:	00 00 00 
  8004201e44:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004201e49:	48 bf 47 81 21 04 80 	movabs $0x8004218147,%rdi
  8004201e50:	00 00 00 
  8004201e53:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201e58:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004201e5f:	00 00 00 
  8004201e62:	41 ff d0             	callq  *%r8
  8004201e65:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004201e6c:	00 00 00 
  8004201e6f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004201e73:	48 01 d0             	add    %rdx,%rax
}
  8004201e76:	c9                   	leaveq 
  8004201e77:	c3                   	retq   

0000008004201e78 <restrictive_type>:
   uint32_t length_low;
   uint32_t length_high;
   uint32_t type;
 } memory_map_t;

static __inline uint32_t restrictive_type(uint32_t t1, uint32_t t2) {
  8004201e78:	55                   	push   %rbp
  8004201e79:	48 89 e5             	mov    %rsp,%rbp
  8004201e7c:	48 83 ec 08          	sub    $0x8,%rsp
  8004201e80:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004201e83:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(t1==MB_TYPE_BAD || t2==MB_TYPE_BAD)
  8004201e86:	83 7d fc 05          	cmpl   $0x5,-0x4(%rbp)
  8004201e8a:	74 06                	je     8004201e92 <restrictive_type+0x1a>
  8004201e8c:	83 7d f8 05          	cmpl   $0x5,-0x8(%rbp)
  8004201e90:	75 07                	jne    8004201e99 <restrictive_type+0x21>
    return MB_TYPE_BAD;
  8004201e92:	b8 05 00 00 00       	mov    $0x5,%eax
  8004201e97:	eb 3e                	jmp    8004201ed7 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_NVS || t2==MB_TYPE_ACPI_NVS)
  8004201e99:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004201e9d:	74 06                	je     8004201ea5 <restrictive_type+0x2d>
  8004201e9f:	83 7d f8 04          	cmpl   $0x4,-0x8(%rbp)
  8004201ea3:	75 07                	jne    8004201eac <restrictive_type+0x34>
    return MB_TYPE_ACPI_NVS;
  8004201ea5:	b8 04 00 00 00       	mov    $0x4,%eax
  8004201eaa:	eb 2b                	jmp    8004201ed7 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_RESERVED || t2==MB_TYPE_RESERVED)
  8004201eac:	83 7d fc 02          	cmpl   $0x2,-0x4(%rbp)
  8004201eb0:	74 06                	je     8004201eb8 <restrictive_type+0x40>
  8004201eb2:	83 7d f8 02          	cmpl   $0x2,-0x8(%rbp)
  8004201eb6:	75 07                	jne    8004201ebf <restrictive_type+0x47>
    return MB_TYPE_RESERVED;
  8004201eb8:	b8 02 00 00 00       	mov    $0x2,%eax
  8004201ebd:	eb 18                	jmp    8004201ed7 <restrictive_type+0x5f>
  else if(t1==MB_TYPE_ACPI_RECLM || t2==MB_TYPE_ACPI_RECLM)
  8004201ebf:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004201ec3:	74 06                	je     8004201ecb <restrictive_type+0x53>
  8004201ec5:	83 7d f8 03          	cmpl   $0x3,-0x8(%rbp)
  8004201ec9:	75 07                	jne    8004201ed2 <restrictive_type+0x5a>
    return MB_TYPE_ACPI_RECLM;
  8004201ecb:	b8 03 00 00 00       	mov    $0x3,%eax
  8004201ed0:	eb 05                	jmp    8004201ed7 <restrictive_type+0x5f>

  return MB_TYPE_USABLE;
  8004201ed2:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004201ed7:	c9                   	leaveq 
  8004201ed8:	c3                   	retq   

0000008004201ed9 <nvram_read>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
  8004201ed9:	55                   	push   %rbp
  8004201eda:	48 89 e5             	mov    %rsp,%rbp
  8004201edd:	53                   	push   %rbx
  8004201ede:	48 83 ec 18          	sub    $0x18,%rsp
  8004201ee2:	89 7d ec             	mov    %edi,-0x14(%rbp)
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
  8004201ee5:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201ee8:	89 c7                	mov    %eax,%edi
  8004201eea:	48 b8 e3 8b 20 04 80 	movabs $0x8004208be3,%rax
  8004201ef1:	00 00 00 
  8004201ef4:	ff d0                	callq  *%rax
  8004201ef6:	89 c3                	mov    %eax,%ebx
  8004201ef8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201efb:	83 c0 01             	add    $0x1,%eax
  8004201efe:	89 c7                	mov    %eax,%edi
  8004201f00:	48 b8 e3 8b 20 04 80 	movabs $0x8004208be3,%rax
  8004201f07:	00 00 00 
  8004201f0a:	ff d0                	callq  *%rax
  8004201f0c:	c1 e0 08             	shl    $0x8,%eax
  8004201f0f:	09 d8                	or     %ebx,%eax
}
  8004201f11:	48 83 c4 18          	add    $0x18,%rsp
  8004201f15:	5b                   	pop    %rbx
  8004201f16:	5d                   	pop    %rbp
  8004201f17:	c3                   	retq   

0000008004201f18 <multiboot_read>:

static void
multiboot_read(multiboot_info_t* mbinfo, size_t* basemem, size_t* extmem) {
  8004201f18:	55                   	push   %rbp
  8004201f19:	48 89 e5             	mov    %rsp,%rbp
  8004201f1c:	41 54                	push   %r12
  8004201f1e:	53                   	push   %rbx
  8004201f1f:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004201f26:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
  8004201f2d:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
  8004201f34:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
  8004201f3b:	48 89 e0             	mov    %rsp,%rax
  8004201f3e:	49 89 c4             	mov    %rax,%r12
	int i;

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
  8004201f41:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201f48:	8b 40 30             	mov    0x30(%rax),%eax
  8004201f4b:	89 c0                	mov    %eax,%eax
  8004201f4d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];
  8004201f51:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004201f58:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004201f5b:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004201f60:	f7 e2                	mul    %edx
  8004201f62:	89 d0                	mov    %edx,%eax
  8004201f64:	c1 e8 04             	shr    $0x4,%eax
  8004201f67:	89 c0                	mov    %eax,%eax
  8004201f69:	48 89 c2             	mov    %rax,%rdx
  8004201f6c:	48 83 ea 01          	sub    $0x1,%rdx
  8004201f70:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004201f74:	49 89 c0             	mov    %rax,%r8
  8004201f77:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004201f7d:	48 89 c1             	mov    %rax,%rcx
  8004201f80:	bb 00 00 00 00       	mov    $0x0,%ebx
  8004201f85:	48 c1 e0 03          	shl    $0x3,%rax
  8004201f89:	48 8d 50 07          	lea    0x7(%rax),%rdx
  8004201f8d:	b8 10 00 00 00       	mov    $0x10,%eax
  8004201f92:	48 83 e8 01          	sub    $0x1,%rax
  8004201f96:	48 01 d0             	add    %rdx,%rax
  8004201f99:	bb 10 00 00 00       	mov    $0x10,%ebx
  8004201f9e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004201fa3:	48 f7 f3             	div    %rbx
  8004201fa6:	48 6b c0 10          	imul   $0x10,%rax,%rax
  8004201faa:	48 29 c4             	sub    %rax,%rsp
  8004201fad:	48 89 e0             	mov    %rsp,%rax
  8004201fb0:	48 83 c0 07          	add    $0x7,%rax
  8004201fb4:	48 c1 e8 03          	shr    $0x3,%rax
  8004201fb8:	48 c1 e0 03          	shl    $0x3,%rax
  8004201fbc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	cprintf("\ne820 MEMORY MAP\n");
  8004201fc0:	48 bf 7b 81 21 04 80 	movabs $0x800421817b,%rdi
  8004201fc7:	00 00 00 
  8004201fca:	b8 00 00 00 00       	mov    $0x0,%eax
  8004201fcf:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004201fd6:	00 00 00 
  8004201fd9:	ff d2                	callq  *%rdx
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004201fdb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004201fe2:	e9 6c 01 00 00       	jmpq   8004202153 <multiboot_read+0x23b>
		memory_map_t* mmap = &mmap_base[i];
  8004201fe7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004201fea:	48 63 d0             	movslq %eax,%rdx
  8004201fed:	48 89 d0             	mov    %rdx,%rax
  8004201ff0:	48 01 c0             	add    %rax,%rax
  8004201ff3:	48 01 d0             	add    %rdx,%rax
  8004201ff6:	48 c1 e0 03          	shl    $0x3,%rax
  8004201ffa:	48 89 c2             	mov    %rax,%rdx
  8004201ffd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202001:	48 01 d0             	add    %rdx,%rax
  8004202004:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

		uint64_t addr = APPEND_HILO(mmap->base_addr_high, mmap->base_addr_low);
  8004202008:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420200c:	8b 40 08             	mov    0x8(%rax),%eax
  800420200f:	89 c0                	mov    %eax,%eax
  8004202011:	48 c1 e0 20          	shl    $0x20,%rax
  8004202015:	48 89 c2             	mov    %rax,%rdx
  8004202018:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420201c:	8b 40 04             	mov    0x4(%rax),%eax
  800420201f:	89 c0                	mov    %eax,%eax
  8004202021:	48 01 d0             	add    %rdx,%rax
  8004202024:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		uint64_t len = APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202028:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420202c:	8b 40 10             	mov    0x10(%rax),%eax
  800420202f:	89 c0                	mov    %eax,%eax
  8004202031:	48 c1 e0 20          	shl    $0x20,%rax
  8004202035:	48 89 c2             	mov    %rax,%rdx
  8004202038:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420203c:	8b 40 0c             	mov    0xc(%rax),%eax
  800420203f:	89 c0                	mov    %eax,%eax
  8004202041:	48 01 d0             	add    %rdx,%rax
  8004202044:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        
		cprintf("size: %d, address: 0x%016x, length: 0x%016x, type: %x\n", mmap->size, 
  8004202048:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420204c:	8b 70 14             	mov    0x14(%rax),%esi
  800420204f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202053:	8b 00                	mov    (%rax),%eax
  8004202055:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004202059:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420205d:	41 89 f0             	mov    %esi,%r8d
  8004202060:	89 c6                	mov    %eax,%esi
  8004202062:	48 bf 90 81 21 04 80 	movabs $0x8004218190,%rdi
  8004202069:	00 00 00 
  800420206c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202071:	49 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%r9
  8004202078:	00 00 00 
  800420207b:	41 ff d1             	callq  *%r9
			addr, len, mmap->type);

		if(mmap->type > 5 || mmap->type < 1)
  800420207e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202082:	8b 40 14             	mov    0x14(%rax),%eax
  8004202085:	83 f8 05             	cmp    $0x5,%eax
  8004202088:	77 0b                	ja     8004202095 <multiboot_read+0x17d>
  800420208a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420208e:	8b 40 14             	mov    0x14(%rax),%eax
  8004202091:	85 c0                	test   %eax,%eax
  8004202093:	75 0b                	jne    80042020a0 <multiboot_read+0x188>
			mmap->type = MB_TYPE_RESERVED;
  8004202095:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202099:	c7 40 14 02 00 00 00 	movl   $0x2,0x14(%rax)
       
		//Insert into the sorted list
		int j = 0;
  80042020a0:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
		for(;j<i;j++) {
  80042020a7:	e9 85 00 00 00       	jmpq   8004202131 <multiboot_read+0x219>
			memory_map_t* this = mmap_list[j];
  80042020ac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042020b0:	8b 55 e8             	mov    -0x18(%rbp),%edx
  80042020b3:	48 63 d2             	movslq %edx,%rdx
  80042020b6:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042020ba:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  80042020be:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042020c2:	8b 40 08             	mov    0x8(%rax),%eax
  80042020c5:	89 c0                	mov    %eax,%eax
  80042020c7:	48 c1 e0 20          	shl    $0x20,%rax
  80042020cb:	48 89 c2             	mov    %rax,%rdx
  80042020ce:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042020d2:	8b 40 04             	mov    0x4(%rax),%eax
  80042020d5:	89 c0                	mov    %eax,%eax
  80042020d7:	48 01 d0             	add    %rdx,%rax
  80042020da:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
			if(this_addr > addr) {
  80042020de:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042020e2:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  80042020e6:	76 45                	jbe    800420212d <multiboot_read+0x215>
				int last = i+1;
  80042020e8:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042020eb:	83 c0 01             	add    $0x1,%eax
  80042020ee:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				while(last != j) {
  80042020f1:	eb 30                	jmp    8004202123 <multiboot_read+0x20b>
					*(mmap_list + last) = *(mmap_list + last - 1);
  80042020f3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042020f7:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  80042020fa:	48 63 d2             	movslq %edx,%rdx
  80042020fd:	48 c1 e2 03          	shl    $0x3,%rdx
  8004202101:	48 01 c2             	add    %rax,%rdx
  8004202104:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202108:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420210b:	48 63 c9             	movslq %ecx,%rcx
  800420210e:	48 c1 e1 03          	shl    $0x3,%rcx
  8004202112:	48 83 e9 08          	sub    $0x8,%rcx
  8004202116:	48 01 c8             	add    %rcx,%rax
  8004202119:	48 8b 00             	mov    (%rax),%rax
  800420211c:	48 89 02             	mov    %rax,(%rdx)
					last--;
  800420211f:	83 6d e4 01          	subl   $0x1,-0x1c(%rbp)
		for(;j<i;j++) {
			memory_map_t* this = mmap_list[j];
			uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
			if(this_addr > addr) {
				int last = i+1;
				while(last != j) {
  8004202123:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004202126:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  8004202129:	75 c8                	jne    80042020f3 <multiboot_read+0x1db>
					*(mmap_list + last) = *(mmap_list + last - 1);
					last--;
				}
				break; 
  800420212b:	eb 10                	jmp    800420213d <multiboot_read+0x225>
		if(mmap->type > 5 || mmap->type < 1)
			mmap->type = MB_TYPE_RESERVED;
       
		//Insert into the sorted list
		int j = 0;
		for(;j<i;j++) {
  800420212d:	83 45 e8 01          	addl   $0x1,-0x18(%rbp)
  8004202131:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004202134:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004202137:	0f 8c 6f ff ff ff    	jl     80042020ac <multiboot_read+0x194>
					last--;
				}
				break; 
			}
		}
		mmap_list[j] = mmap;  
  800420213d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202141:	8b 55 e8             	mov    -0x18(%rbp),%edx
  8004202144:	48 63 d2             	movslq %edx,%rdx
  8004202147:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420214b:	48 89 0c d0          	mov    %rcx,(%rax,%rdx,8)

	memory_map_t* mmap_base = (memory_map_t*)(uintptr_t)mbinfo->mmap_addr;
 	memory_map_t* mmap_list[mbinfo->mmap_length/ (sizeof(memory_map_t))];

	cprintf("\ne820 MEMORY MAP\n");
	for(i = 0; i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420214f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202153:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202156:	48 63 c8             	movslq %eax,%rcx
  8004202159:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202160:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202163:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202168:	f7 e2                	mul    %edx
  800420216a:	89 d0                	mov    %edx,%eax
  800420216c:	c1 e8 04             	shr    $0x4,%eax
  800420216f:	89 c0                	mov    %eax,%eax
  8004202171:	48 39 c1             	cmp    %rax,%rcx
  8004202174:	0f 82 6d fe ff ff    	jb     8004201fe7 <multiboot_read+0xcf>
				break; 
			}
		}
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
  800420217a:	48 bf c7 81 21 04 80 	movabs $0x80042181c7,%rdi
  8004202181:	00 00 00 
  8004202184:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202189:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004202190:	00 00 00 
  8004202193:	ff d2                	callq  *%rdx
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202195:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
  800420219c:	e9 93 01 00 00       	jmpq   8004202334 <multiboot_read+0x41c>
		memory_map_t* prev = mmap_list[i-1];
  80042021a1:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042021a4:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042021a7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042021ab:	48 63 d2             	movslq %edx,%rdx
  80042021ae:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042021b2:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		memory_map_t* this = mmap_list[i];
  80042021b6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042021ba:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042021bd:	48 63 d2             	movslq %edx,%rdx
  80042021c0:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  80042021c4:	48 89 45 90          	mov    %rax,-0x70(%rbp)

		uint64_t this_addr = APPEND_HILO(this->base_addr_high, this->base_addr_low);
  80042021c8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021cc:	8b 40 08             	mov    0x8(%rax),%eax
  80042021cf:	89 c0                	mov    %eax,%eax
  80042021d1:	48 c1 e0 20          	shl    $0x20,%rax
  80042021d5:	48 89 c2             	mov    %rax,%rdx
  80042021d8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042021dc:	8b 40 04             	mov    0x4(%rax),%eax
  80042021df:	89 c0                	mov    %eax,%eax
  80042021e1:	48 01 d0             	add    %rdx,%rax
  80042021e4:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		uint64_t prev_addr = APPEND_HILO(prev->base_addr_high, prev->base_addr_low);
  80042021e8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021ec:	8b 40 08             	mov    0x8(%rax),%eax
  80042021ef:	89 c0                	mov    %eax,%eax
  80042021f1:	48 c1 e0 20          	shl    $0x20,%rax
  80042021f5:	48 89 c2             	mov    %rax,%rdx
  80042021f8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042021fc:	8b 40 04             	mov    0x4(%rax),%eax
  80042021ff:	89 c0                	mov    %eax,%eax
  8004202201:	48 01 d0             	add    %rdx,%rax
  8004202204:	48 89 45 80          	mov    %rax,-0x80(%rbp)
		uint64_t prev_length = APPEND_HILO(prev->length_high, prev->length_low);
  8004202208:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420220c:	8b 40 10             	mov    0x10(%rax),%eax
  800420220f:	89 c0                	mov    %eax,%eax
  8004202211:	48 c1 e0 20          	shl    $0x20,%rax
  8004202215:	48 89 c2             	mov    %rax,%rdx
  8004202218:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420221c:	8b 40 0c             	mov    0xc(%rax),%eax
  800420221f:	89 c0                	mov    %eax,%eax
  8004202221:	48 01 d0             	add    %rdx,%rax
  8004202224:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
		uint64_t this_length = APPEND_HILO(this->length_high, this->length_low);
  800420222b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420222f:	8b 40 10             	mov    0x10(%rax),%eax
  8004202232:	89 c0                	mov    %eax,%eax
  8004202234:	48 c1 e0 20          	shl    $0x20,%rax
  8004202238:	48 89 c2             	mov    %rax,%rdx
  800420223b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420223f:	8b 40 0c             	mov    0xc(%rax),%eax
  8004202242:	89 c0                	mov    %eax,%eax
  8004202244:	48 01 d0             	add    %rdx,%rax
  8004202247:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)

		// Merge adjacent regions with same type
		if(prev_addr + prev_length == this_addr && prev->type == this->type) {
  800420224e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004202255:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004202259:	48 01 d0             	add    %rdx,%rax
  800420225c:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  8004202260:	75 7c                	jne    80042022de <multiboot_read+0x3c6>
  8004202262:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004202266:	8b 50 14             	mov    0x14(%rax),%edx
  8004202269:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420226d:	8b 40 14             	mov    0x14(%rax),%eax
  8004202270:	39 c2                	cmp    %eax,%edx
  8004202272:	75 6a                	jne    80042022de <multiboot_read+0x3c6>
			this->length_low = (uint32_t)prev_length + this_length;
  8004202274:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420227b:	89 c2                	mov    %eax,%edx
  800420227d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202284:	01 c2                	add    %eax,%edx
  8004202286:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420228a:	89 50 0c             	mov    %edx,0xc(%rax)
			this->length_high = (uint32_t)((prev_length + this_length)>>32);
  800420228d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004202294:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800420229b:	48 01 d0             	add    %rdx,%rax
  800420229e:	48 c1 e8 20          	shr    $0x20,%rax
  80042022a2:	89 c2                	mov    %eax,%edx
  80042022a4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042022a8:	89 50 10             	mov    %edx,0x10(%rax)
			this->base_addr_low = prev->base_addr_low;
  80042022ab:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042022af:	8b 50 04             	mov    0x4(%rax),%edx
  80042022b2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042022b6:	89 50 04             	mov    %edx,0x4(%rax)
			this->base_addr_high = prev->base_addr_high;
  80042022b9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042022bd:	8b 50 08             	mov    0x8(%rax),%edx
  80042022c0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042022c4:	89 50 08             	mov    %edx,0x8(%rax)
			mmap_list[i-1] = NULL;
  80042022c7:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042022ca:	8d 50 ff             	lea    -0x1(%rax),%edx
  80042022cd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042022d1:	48 63 d2             	movslq %edx,%rdx
  80042022d4:	48 c7 04 d0 00 00 00 	movq   $0x0,(%rax,%rdx,8)
  80042022db:	00 
  80042022dc:	eb 52                	jmp    8004202330 <multiboot_read+0x418>
		} else if(prev_addr + prev_length > this_addr) {
  80042022de:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042022e5:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  80042022e9:	48 01 d0             	add    %rdx,%rax
  80042022ec:	48 3b 45 88          	cmp    -0x78(%rbp),%rax
  80042022f0:	76 3e                	jbe    8004202330 <multiboot_read+0x418>
			//Overlapping regions
			uint32_t type = restrictive_type(prev->type, this->type);
  80042022f2:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042022f6:	8b 50 14             	mov    0x14(%rax),%edx
  80042022f9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042022fd:	8b 40 14             	mov    0x14(%rax),%eax
  8004202300:	89 d6                	mov    %edx,%esi
  8004202302:	89 c7                	mov    %eax,%edi
  8004202304:	48 b8 78 1e 20 04 80 	movabs $0x8004201e78,%rax
  800420230b:	00 00 00 
  800420230e:	ff d0                	callq  *%rax
  8004202310:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
			prev->type = type;
  8004202316:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420231a:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  8004202320:	89 50 14             	mov    %edx,0x14(%rax)
			this->type = type;
  8004202323:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004202327:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
  800420232d:	89 50 14             	mov    %edx,0x14(%rax)
		mmap_list[j] = mmap;  
	}
	cprintf("\n");
    
	// Sanitize the list
	for(i=1;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  8004202330:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202334:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202337:	48 63 c8             	movslq %eax,%rcx
  800420233a:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202341:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202344:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202349:	f7 e2                	mul    %edx
  800420234b:	89 d0                	mov    %edx,%eax
  800420234d:	c1 e8 04             	shr    $0x4,%eax
  8004202350:	89 c0                	mov    %eax,%eax
  8004202352:	48 39 c1             	cmp    %rax,%rcx
  8004202355:	0f 82 46 fe ff ff    	jb     80042021a1 <multiboot_read+0x289>
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420235b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004202362:	e9 dc 00 00 00       	jmpq   8004202443 <multiboot_read+0x52b>
		memory_map_t* mmap = mmap_list[i];
  8004202367:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420236b:	8b 55 ec             	mov    -0x14(%rbp),%edx
  800420236e:	48 63 d2             	movslq %edx,%rdx
  8004202371:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004202375:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
		if(mmap) {
  800420237c:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004202383:	00 
  8004202384:	0f 84 b5 00 00 00    	je     800420243f <multiboot_read+0x527>
			if(mmap->type == MB_TYPE_USABLE || mmap->type == MB_TYPE_ACPI_RECLM) {
  800420238a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202391:	8b 40 14             	mov    0x14(%rax),%eax
  8004202394:	83 f8 01             	cmp    $0x1,%eax
  8004202397:	74 13                	je     80042023ac <multiboot_read+0x494>
  8004202399:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042023a0:	8b 40 14             	mov    0x14(%rax),%eax
  80042023a3:	83 f8 03             	cmp    $0x3,%eax
  80042023a6:	0f 85 93 00 00 00    	jne    800420243f <multiboot_read+0x527>
				if(mmap->base_addr_low < 0x100000 && mmap->base_addr_high == 0)
  80042023ac:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042023b3:	8b 40 04             	mov    0x4(%rax),%eax
  80042023b6:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  80042023bb:	77 49                	ja     8004202406 <multiboot_read+0x4ee>
  80042023bd:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042023c4:	8b 40 08             	mov    0x8(%rax),%eax
  80042023c7:	85 c0                	test   %eax,%eax
  80042023c9:	75 3b                	jne    8004202406 <multiboot_read+0x4ee>
					*basemem += APPEND_HILO(mmap->length_high, mmap->length_low);
  80042023cb:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042023d2:	48 8b 10             	mov    (%rax),%rdx
  80042023d5:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042023dc:	8b 40 10             	mov    0x10(%rax),%eax
  80042023df:	89 c0                	mov    %eax,%eax
  80042023e1:	48 c1 e0 20          	shl    $0x20,%rax
  80042023e5:	48 89 c1             	mov    %rax,%rcx
  80042023e8:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  80042023ef:	8b 40 0c             	mov    0xc(%rax),%eax
  80042023f2:	89 c0                	mov    %eax,%eax
  80042023f4:	48 01 c8             	add    %rcx,%rax
  80042023f7:	48 01 c2             	add    %rax,%rdx
  80042023fa:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004202401:	48 89 10             	mov    %rdx,(%rax)
  8004202404:	eb 39                	jmp    800420243f <multiboot_read+0x527>
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
  8004202406:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420240d:	48 8b 10             	mov    (%rax),%rdx
  8004202410:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004202417:	8b 40 10             	mov    0x10(%rax),%eax
  800420241a:	89 c0                	mov    %eax,%eax
  800420241c:	48 c1 e0 20          	shl    $0x20,%rax
  8004202420:	48 89 c1             	mov    %rax,%rcx
  8004202423:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  800420242a:	8b 40 0c             	mov    0xc(%rax),%eax
  800420242d:	89 c0                	mov    %eax,%eax
  800420242f:	48 01 c8             	add    %rcx,%rax
  8004202432:	48 01 c2             	add    %rax,%rdx
  8004202435:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800420243c:	48 89 10             	mov    %rdx,(%rax)
			prev->type = type;
			this->type = type;
		}
	}

	for(i=0;i < (mbinfo->mmap_length / (sizeof(memory_map_t))); i++) {
  800420243f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004202443:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004202446:	48 63 c8             	movslq %eax,%rcx
  8004202449:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004202450:	8b 40 2c             	mov    0x2c(%rax),%eax
  8004202453:	ba ab aa aa aa       	mov    $0xaaaaaaab,%edx
  8004202458:	f7 e2                	mul    %edx
  800420245a:	89 d0                	mov    %edx,%eax
  800420245c:	c1 e8 04             	shr    $0x4,%eax
  800420245f:	89 c0                	mov    %eax,%eax
  8004202461:	48 39 c1             	cmp    %rax,%rcx
  8004202464:	0f 82 fd fe ff ff    	jb     8004202367 <multiboot_read+0x44f>
  800420246a:	4c 89 e4             	mov    %r12,%rsp
				else
					*extmem += APPEND_HILO(mmap->length_high, mmap->length_low);
			}
		}
	}
}
  800420246d:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
  8004202471:	5b                   	pop    %rbx
  8004202472:	41 5c                	pop    %r12
  8004202474:	5d                   	pop    %rbp
  8004202475:	c3                   	retq   

0000008004202476 <i386_detect_memory>:

static void
i386_detect_memory(void)
{
  8004202476:	55                   	push   %rbp
  8004202477:	48 89 e5             	mov    %rsp,%rbp
  800420247a:	48 83 ec 50          	sub    $0x50,%rsp
	size_t npages_extmem;
	size_t basemem = 0;
  800420247e:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  8004202485:	00 
	size_t extmem = 0;
  8004202486:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  800420248d:	00 

	// Check if the bootloader passed us a multiboot structure
	extern char multiboot_info[];
	uintptr_t* mbp = (uintptr_t*)multiboot_info;
  800420248e:	48 b8 00 70 10 00 00 	movabs $0x107000,%rax
  8004202495:	00 00 00 
  8004202498:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	multiboot_info_t * mbinfo = (multiboot_info_t*)*mbp;
  800420249c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042024a0:	48 8b 00             	mov    (%rax),%rax
  80042024a3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if(mbinfo && (mbinfo->flags & MB_FLAG_MMAP)) {
  80042024a7:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042024ac:	74 2d                	je     80042024db <i386_detect_memory+0x65>
  80042024ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042024b2:	8b 00                	mov    (%rax),%eax
  80042024b4:	83 e0 40             	and    $0x40,%eax
  80042024b7:	85 c0                	test   %eax,%eax
  80042024b9:	74 20                	je     80042024db <i386_detect_memory+0x65>
		multiboot_read(mbinfo, &basemem, &extmem);
  80042024bb:	48 8d 55 b8          	lea    -0x48(%rbp),%rdx
  80042024bf:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
  80042024c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042024c7:	48 89 ce             	mov    %rcx,%rsi
  80042024ca:	48 89 c7             	mov    %rax,%rdi
  80042024cd:	48 b8 18 1f 20 04 80 	movabs $0x8004201f18,%rax
  80042024d4:	00 00 00 
  80042024d7:	ff d0                	callq  *%rax
  80042024d9:	eb 34                	jmp    800420250f <i386_detect_memory+0x99>
	} else {
		basemem = (nvram_read(NVRAM_BASELO) * 1024);
  80042024db:	bf 15 00 00 00       	mov    $0x15,%edi
  80042024e0:	48 b8 d9 1e 20 04 80 	movabs $0x8004201ed9,%rax
  80042024e7:	00 00 00 
  80042024ea:	ff d0                	callq  *%rax
  80042024ec:	c1 e0 0a             	shl    $0xa,%eax
  80042024ef:	48 98                	cltq   
  80042024f1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		extmem = (nvram_read(NVRAM_EXTLO) * 1024);
  80042024f5:	bf 17 00 00 00       	mov    $0x17,%edi
  80042024fa:	48 b8 d9 1e 20 04 80 	movabs $0x8004201ed9,%rax
  8004202501:	00 00 00 
  8004202504:	ff d0                	callq  *%rax
  8004202506:	c1 e0 0a             	shl    $0xa,%eax
  8004202509:	48 98                	cltq   
  800420250b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	}

	assert(basemem);
  800420250f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202513:	48 85 c0             	test   %rax,%rax
  8004202516:	75 35                	jne    800420254d <i386_detect_memory+0xd7>
  8004202518:	48 b9 c9 81 21 04 80 	movabs $0x80042181c9,%rcx
  800420251f:	00 00 00 
  8004202522:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004202529:	00 00 00 
  800420252c:	be 89 00 00 00       	mov    $0x89,%esi
  8004202531:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202538:	00 00 00 
  800420253b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202540:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202547:	00 00 00 
  800420254a:	41 ff d0             	callq  *%r8

	npages_basemem = basemem / PGSIZE;
  800420254d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202551:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202555:	48 89 c2             	mov    %rax,%rdx
  8004202558:	48 b8 30 82 37 04 80 	movabs $0x8004378230,%rax
  800420255f:	00 00 00 
  8004202562:	48 89 10             	mov    %rdx,(%rax)
	npages_extmem = extmem / PGSIZE;
  8004202565:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004202569:	48 c1 e8 0c          	shr    $0xc,%rax
  800420256d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	
	if(nvram_read(NVRAM_EXTLO) == 0xffff) {
  8004202571:	bf 17 00 00 00       	mov    $0x17,%edi
  8004202576:	48 b8 d9 1e 20 04 80 	movabs $0x8004201ed9,%rax
  800420257d:	00 00 00 
  8004202580:	ff d0                	callq  *%rax
  8004202582:	3d ff ff 00 00       	cmp    $0xffff,%eax
  8004202587:	75 2c                	jne    80042025b5 <i386_detect_memory+0x13f>
		// EXTMEM > 16M in blocks of 64k
		size_t pextmem = nvram_read(NVRAM_EXTGT16LO) * (64 * 1024);
  8004202589:	bf 34 00 00 00       	mov    $0x34,%edi
  800420258e:	48 b8 d9 1e 20 04 80 	movabs $0x8004201ed9,%rax
  8004202595:	00 00 00 
  8004202598:	ff d0                	callq  *%rax
  800420259a:	c1 e0 10             	shl    $0x10,%eax
  800420259d:	48 98                	cltq   
  800420259f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		npages_extmem = ((16 * 1024 * 1024) + pextmem - (1 * 1024 * 1024)) / PGSIZE;
  80042025a3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042025a7:	48 05 00 00 f0 00    	add    $0xf00000,%rax
  80042025ad:	48 c1 e8 0c          	shr    $0xc,%rax
  80042025b1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	}
	
	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (npages_extmem)
  80042025b5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042025ba:	74 1a                	je     80042025d6 <i386_detect_memory+0x160>
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
  80042025bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042025c0:	48 8d 90 00 01 00 00 	lea    0x100(%rax),%rdx
  80042025c7:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042025ce:	00 00 00 
  80042025d1:	48 89 10             	mov    %rdx,(%rax)
  80042025d4:	eb 1a                	jmp    80042025f0 <i386_detect_memory+0x17a>
	else
		npages = npages_basemem;
  80042025d6:	48 b8 30 82 37 04 80 	movabs $0x8004378230,%rax
  80042025dd:	00 00 00 
  80042025e0:	48 8b 10             	mov    (%rax),%rdx
  80042025e3:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042025ea:	00 00 00 
  80042025ed:	48 89 10             	mov    %rdx,(%rax)

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  80042025f0:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042025f7:	00 00 00 
  80042025fa:	48 8b 30             	mov    (%rax),%rsi
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
		npages_extmem * PGSIZE / 1024,
  80042025fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202601:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202605:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202609:	48 89 c1             	mov    %rax,%rcx
		npages * PGSIZE / (1024 * 1024),
		npages_basemem * PGSIZE / 1024,
  800420260c:	48 b8 30 82 37 04 80 	movabs $0x8004378230,%rax
  8004202613:	00 00 00 
  8004202616:	48 8b 00             	mov    (%rax),%rax
  8004202619:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  800420261d:	48 c1 e8 0a          	shr    $0xa,%rax
  8004202621:	48 89 c2             	mov    %rax,%rdx
		npages * PGSIZE / (1024 * 1024),
  8004202624:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  800420262b:	00 00 00 
  800420262e:	48 8b 00             	mov    (%rax),%rax
  8004202631:	48 c1 e0 0c          	shl    $0xc,%rax
	if (npages_extmem)
		npages = (EXTPHYSMEM / PGSIZE) + npages_extmem;
	else
		npages = npages_basemem;

	cprintf("Physical memory: %uM available, base = %uK, extended = %uK, npages = %d\n",
  8004202635:	48 c1 e8 14          	shr    $0x14,%rax
  8004202639:	49 89 f0             	mov    %rsi,%r8
  800420263c:	48 89 c6             	mov    %rax,%rsi
  800420263f:	48 bf f8 81 21 04 80 	movabs $0x80042181f8,%rdi
  8004202646:	00 00 00 
  8004202649:	b8 00 00 00 00       	mov    $0x0,%eax
  800420264e:	49 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%r9
  8004202655:	00 00 00 
  8004202658:	41 ff d1             	callq  *%r9
	//JOS 64 pages are limited by the size of both the UPAGES
	//  virtual address space, and the range from KERNBASE to UVPT.
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
  800420265b:	48 c7 45 d8 00 00 32 	movq   $0x320000,-0x28(%rbp)
  8004202662:	00 
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
  8004202663:	48 c7 45 d0 00 c0 ff 	movq   $0x7ffc000,-0x30(%rbp)
  800420266a:	07 
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
  800420266b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420266f:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004202673:	48 c1 e8 14          	shr    $0x14,%rax
  8004202677:	48 89 c1             	mov    %rax,%rcx
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
  800420267a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420267e:	48 c1 e0 0c          	shl    $0xc,%rax
	//
	// NB: qemu seems to have a bug that crashes the host system on 13.10 if you try to 
	//     max out memory.
	uint64_t upages_max = (ULIM - UPAGES) / sizeof(struct PageInfo);
	uint64_t kern_mem_max = (UVPT - KERNBASE) / PGSIZE;
	cprintf("Pages limited to %llu by upage address range (%uMB), Pages limited to %llu by remapped phys mem (%uMB)\n", 
  8004202682:	48 c1 e8 14          	shr    $0x14,%rax
  8004202686:	48 89 c6             	mov    %rax,%rsi
  8004202689:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420268d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202691:	49 89 c8             	mov    %rcx,%r8
  8004202694:	48 89 d1             	mov    %rdx,%rcx
  8004202697:	48 89 f2             	mov    %rsi,%rdx
  800420269a:	48 89 c6             	mov    %rax,%rsi
  800420269d:	48 bf 48 82 21 04 80 	movabs $0x8004218248,%rdi
  80042026a4:	00 00 00 
  80042026a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042026ac:	49 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%r9
  80042026b3:	00 00 00 
  80042026b6:	41 ff d1             	callq  *%r9
		upages_max, ((upages_max * PGSIZE) / (1024 * 1024)),
		kern_mem_max, kern_mem_max * PGSIZE / (1024 * 1024));
	uint64_t max_npages = upages_max < kern_mem_max ? upages_max : kern_mem_max;
  80042026b9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042026bd:	48 39 45 d0          	cmp    %rax,-0x30(%rbp)
  80042026c1:	48 0f 46 45 d0       	cmovbe -0x30(%rbp),%rax
  80042026c6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if(npages > max_npages) {
  80042026ca:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042026d1:	00 00 00 
  80042026d4:	48 8b 00             	mov    (%rax),%rax
  80042026d7:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  80042026db:	76 3a                	jbe    8004202717 <i386_detect_memory+0x2a1>
		npages = max_npages - 1024;
  80042026dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042026e1:	48 8d 90 00 fc ff ff 	lea    -0x400(%rax),%rdx
  80042026e8:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042026ef:	00 00 00 
  80042026f2:	48 89 10             	mov    %rdx,(%rax)
		cprintf("Using only %uK of the available memory.\n", max_npages);
  80042026f5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042026f9:	48 89 c6             	mov    %rax,%rsi
  80042026fc:	48 bf b0 82 21 04 80 	movabs $0x80042182b0,%rdi
  8004202703:	00 00 00 
  8004202706:	b8 00 00 00 00       	mov    $0x0,%eax
  800420270b:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004202712:	00 00 00 
  8004202715:	ff d2                	callq  *%rdx
	}
}
  8004202717:	c9                   	leaveq 
  8004202718:	c3                   	retq   

0000008004202719 <boot_alloc>:
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
  8004202719:	55                   	push   %rbp
  800420271a:	48 89 e5             	mov    %rsp,%rbp
  800420271d:	48 83 ec 40          	sub    $0x40,%rsp
  8004202721:	89 7d cc             	mov    %edi,-0x34(%rbp)
	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
  8004202724:	48 b8 48 82 37 04 80 	movabs $0x8004378248,%rax
  800420272b:	00 00 00 
  800420272e:	48 8b 00             	mov    (%rax),%rax
  8004202731:	48 85 c0             	test   %rax,%rax
  8004202734:	75 4b                	jne    8004202781 <boot_alloc+0x68>
#ifdef VMM_GUEST
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
  8004202736:	48 c7 45 f8 00 10 00 	movq   $0x1000,-0x8(%rbp)
  800420273d:	00 
  800420273e:	48 b8 10 c0 3b 04 80 	movabs $0x80043bc010,%rax
  8004202745:	00 00 00 
  8004202748:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420274c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202750:	48 01 d0             	add    %rdx,%rax
  8004202753:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004202757:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420275b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004202760:	48 f7 75 f8          	divq   -0x8(%rbp)
  8004202764:	48 89 d0             	mov    %rdx,%rax
  8004202767:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420276b:	48 29 c2             	sub    %rax,%rdx
  800420276e:	48 89 d0             	mov    %rdx,%rax
  8004202771:	48 89 c2             	mov    %rax,%rdx
  8004202774:	48 b8 48 82 37 04 80 	movabs $0x8004378248,%rax
  800420277b:	00 00 00 
  800420277e:	48 89 10             	mov    %rdx,(%rax)
	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
	if (n == 0) 
  8004202781:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  8004202785:	75 12                	jne    8004202799 <boot_alloc+0x80>
		return nextfree;
  8004202787:	48 b8 48 82 37 04 80 	movabs $0x8004378248,%rax
  800420278e:	00 00 00 
  8004202791:	48 8b 00             	mov    (%rax),%rax
  8004202794:	e9 cf 00 00 00       	jmpq   8004202868 <boot_alloc+0x14f>
	result = nextfree;
  8004202799:	48 b8 48 82 37 04 80 	movabs $0x8004378248,%rax
  80042027a0:	00 00 00 
  80042027a3:	48 8b 00             	mov    (%rax),%rax
  80042027a6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	nextfree = nextfree + n;
  80042027aa:	48 b8 48 82 37 04 80 	movabs $0x8004378248,%rax
  80042027b1:	00 00 00 
  80042027b4:	48 8b 10             	mov    (%rax),%rdx
  80042027b7:	8b 45 cc             	mov    -0x34(%rbp),%eax
  80042027ba:	48 01 c2             	add    %rax,%rdx
  80042027bd:	48 b8 48 82 37 04 80 	movabs $0x8004378248,%rax
  80042027c4:	00 00 00 
  80042027c7:	48 89 10             	mov    %rdx,(%rax)
	nextfree = ROUNDUP(nextfree, PGSIZE);
  80042027ca:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  80042027d1:	00 
  80042027d2:	48 b8 48 82 37 04 80 	movabs $0x8004378248,%rax
  80042027d9:	00 00 00 
  80042027dc:	48 8b 00             	mov    (%rax),%rax
  80042027df:	48 89 c2             	mov    %rax,%rdx
  80042027e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042027e6:	48 01 d0             	add    %rdx,%rax
  80042027e9:	48 83 e8 01          	sub    $0x1,%rax
  80042027ed:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042027f1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042027f5:	ba 00 00 00 00       	mov    $0x0,%edx
  80042027fa:	48 f7 75 e0          	divq   -0x20(%rbp)
  80042027fe:	48 89 d0             	mov    %rdx,%rax
  8004202801:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004202805:	48 29 c2             	sub    %rax,%rdx
  8004202808:	48 89 d0             	mov    %rdx,%rax
  800420280b:	48 89 c2             	mov    %rax,%rdx
  800420280e:	48 b8 48 82 37 04 80 	movabs $0x8004378248,%rax
  8004202815:	00 00 00 
  8004202818:	48 89 10             	mov    %rdx,(%rax)
	//process memory wrap arounds on memory full
	if((uint64_t)nextfree < (uint64_t)end)
  800420281b:	48 b8 48 82 37 04 80 	movabs $0x8004378248,%rax
  8004202822:	00 00 00 
  8004202825:	48 8b 00             	mov    (%rax),%rax
  8004202828:	48 89 c2             	mov    %rax,%rdx
  800420282b:	48 b8 10 c0 3b 04 80 	movabs $0x80043bc010,%rax
  8004202832:	00 00 00 
  8004202835:	48 39 c2             	cmp    %rax,%rdx
  8004202838:	73 2a                	jae    8004202864 <boot_alloc+0x14b>
	{
		panic("we're out of memory");
  800420283a:	48 ba d9 82 21 04 80 	movabs $0x80042182d9,%rdx
  8004202841:	00 00 00 
  8004202844:	be ee 00 00 00       	mov    $0xee,%esi
  8004202849:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202850:	00 00 00 
  8004202853:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202858:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  800420285f:	00 00 00 
  8004202862:	ff d1                	callq  *%rcx
	}
	return result;
  8004202864:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004202868:	c9                   	leaveq 
  8004202869:	c3                   	retq   

000000800420286a <x64_vm_init>:
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
x64_vm_init(void)
{
  800420286a:	55                   	push   %rbp
  800420286b:	48 89 e5             	mov    %rsp,%rbp
  800420286e:	48 83 ec 60          	sub    $0x60,%rsp
	pml4e_t* pml4e;
	uint32_t cr0;
	uint64_t n;
	int r;
	struct Env *env;
	i386_detect_memory();
  8004202872:	48 b8 76 24 20 04 80 	movabs $0x8004202476,%rax
  8004202879:	00 00 00 
  800420287c:	ff d0                	callq  *%rax
	//panic("i386_vm_init: This function is not finished\n");
	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	//panic("x64_vm_init: this function is not finished\n");
	pml4e = boot_alloc(PGSIZE);
  800420287e:	bf 00 10 00 00       	mov    $0x1000,%edi
  8004202883:	48 b8 19 27 20 04 80 	movabs $0x8004202719,%rax
  800420288a:	00 00 00 
  800420288d:	ff d0                	callq  *%rax
  800420288f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(pml4e, 0, PGSIZE);
  8004202893:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202897:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420289c:	be 00 00 00 00       	mov    $0x0,%esi
  80042028a1:	48 89 c7             	mov    %rax,%rdi
  80042028a4:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  80042028ab:	00 00 00 
  80042028ae:	ff d0                	callq  *%rax
	boot_pml4e = pml4e;
  80042028b0:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042028b7:	00 00 00 
  80042028ba:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042028be:	48 89 10             	mov    %rdx,(%rax)
	boot_cr3 = PADDR(pml4e);
  80042028c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042028c5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  80042028c9:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  80042028d0:	00 00 00 
  80042028d3:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  80042028d7:	77 32                	ja     800420290b <x64_vm_init+0xa1>
  80042028d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042028dd:	48 89 c1             	mov    %rax,%rcx
  80042028e0:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  80042028e7:	00 00 00 
  80042028ea:	be 0c 01 00 00       	mov    $0x10c,%esi
  80042028ef:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042028f6:	00 00 00 
  80042028f9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042028fe:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202905:	00 00 00 
  8004202908:	41 ff d0             	callq  *%r8
  800420290b:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202912:	ff ff ff 
  8004202915:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202919:	48 01 c2             	add    %rax,%rdx
  800420291c:	48 b8 80 97 37 04 80 	movabs $0x8004379780,%rax
  8004202923:	00 00 00 
  8004202926:	48 89 10             	mov    %rdx,(%rax)
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.
	// Your code goes here:
	pages = (struct PageInfo*)boot_alloc(npages * sizeof(struct PageInfo));
  8004202929:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004202930:	00 00 00 
  8004202933:	48 8b 00             	mov    (%rax),%rax
  8004202936:	c1 e0 04             	shl    $0x4,%eax
  8004202939:	89 c7                	mov    %eax,%edi
  800420293b:	48 b8 19 27 20 04 80 	movabs $0x8004202719,%rax
  8004202942:	00 00 00 
  8004202945:	ff d0                	callq  *%rax
  8004202947:	48 ba 98 97 37 04 80 	movabs $0x8004379798,%rdx
  800420294e:	00 00 00 
  8004202951:	48 89 02             	mov    %rax,(%rdx)

	//////////////////////////////////////////////////////////////////////
	// Make 'envs' point to an array of size 'NENV' of 'struct Env'.
	// LAB 3: Your code here.
	
	envs = (struct Env*)boot_alloc(NENV * sizeof(struct Env));
  8004202954:	bf 00 a0 05 00       	mov    $0x5a000,%edi
  8004202959:	48 b8 19 27 20 04 80 	movabs $0x8004202719,%rax
  8004202960:	00 00 00 
  8004202963:	ff d0                	callq  *%rax
  8004202965:	48 ba 58 82 37 04 80 	movabs $0x8004378258,%rdx
  800420296c:	00 00 00 
  800420296f:	48 89 02             	mov    %rax,(%rdx)
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region or page_insert
	page_init();
  8004202972:	48 b8 de 2c 20 04 80 	movabs $0x8004202cde,%rax
  8004202979:	00 00 00 
  800420297c:	ff d0                	callq  *%rax
	// Permissions:
	//    - the new image at UPAGES -- kernel R, us/er R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:
    boot_map_region(pml4e, UPAGES, npages * sizeof(struct PageInfo), PADDR(pages), PTE_U|PTE_P);
  800420297e:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004202985:	00 00 00 
  8004202988:	48 8b 00             	mov    (%rax),%rax
  800420298b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420298f:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202996:	00 00 00 
  8004202999:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420299d:	77 32                	ja     80042029d1 <x64_vm_init+0x167>
  800420299f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042029a3:	48 89 c1             	mov    %rax,%rcx
  80042029a6:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  80042029ad:	00 00 00 
  80042029b0:	be 2b 01 00 00       	mov    $0x12b,%esi
  80042029b5:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042029bc:	00 00 00 
  80042029bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042029c4:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042029cb:	00 00 00 
  80042029ce:	41 ff d0             	callq  *%r8
  80042029d1:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  80042029d8:	ff ff ff 
  80042029db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042029df:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  80042029e3:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042029ea:	00 00 00 
  80042029ed:	48 8b 00             	mov    (%rax),%rax
  80042029f0:	48 c1 e0 04          	shl    $0x4,%rax
  80042029f4:	48 89 c2             	mov    %rax,%rdx
  80042029f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042029fb:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202a01:	48 be 00 00 a0 00 80 	movabs $0x8000a00000,%rsi
  8004202a08:	00 00 00 
  8004202a0b:	48 89 c7             	mov    %rax,%rdi
  8004202a0e:	48 b8 5e 38 20 04 80 	movabs $0x800420385e,%rax
  8004202a15:	00 00 00 
  8004202a18:	ff d0                	callq  *%rax
	// (ie. perm = PTE_U | PTE_P).
	// Permissions:
	//    - the new image at UENVS  -- kernel R, user R
	//    - envs itself -- kernel RW, user NONE
	// LAB 3: Your code here.
	boot_map_region(pml4e, UENVS, NENV * sizeof(struct Env), PADDR(envs), PTE_U|PTE_P);
  8004202a1a:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  8004202a21:	00 00 00 
  8004202a24:	48 8b 00             	mov    (%rax),%rax
  8004202a27:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202a2b:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202a32:	00 00 00 
  8004202a35:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202a39:	77 32                	ja     8004202a6d <x64_vm_init+0x203>
  8004202a3b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202a3f:	48 89 c1             	mov    %rax,%rcx
  8004202a42:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  8004202a49:	00 00 00 
  8004202a4c:	be 34 01 00 00       	mov    $0x134,%esi
  8004202a51:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202a58:	00 00 00 
  8004202a5b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202a60:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202a67:	00 00 00 
  8004202a6a:	41 ff d0             	callq  *%r8
  8004202a6d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202a74:	ff ff ff 
  8004202a77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202a7b:	48 01 c2             	add    %rax,%rdx
  8004202a7e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202a82:	41 b8 05 00 00 00    	mov    $0x5,%r8d
  8004202a88:	48 89 d1             	mov    %rdx,%rcx
  8004202a8b:	ba 00 a0 05 00       	mov    $0x5a000,%edx
  8004202a90:	48 be 00 00 80 00 80 	movabs $0x8000800000,%rsi
  8004202a97:	00 00 00 
  8004202a9a:	48 89 c7             	mov    %rax,%rdi
  8004202a9d:	48 b8 5e 38 20 04 80 	movabs $0x800420385e,%rax
  8004202aa4:	00 00 00 
  8004202aa7:	ff d0                	callq  *%rax
	//      the PA range [0, npages*PGSIZE)
	// Permissions: kernel RW, user NONE
	// Your code goes here: 
	// Check that the initial page directory has been set up correctly.
	// Initialize the SMP-related parts of the memory map
	mem_init_mp();
  8004202aa9:	48 b8 ff 2b 20 04 80 	movabs $0x8004202bff,%rax
  8004202ab0:	00 00 00 
  8004202ab3:	ff d0                	callq  *%rax
	boot_map_region(pml4e, KERNBASE, npages*PGSIZE, 0, PTE_P|PTE_W);
  8004202ab5:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004202abc:	00 00 00 
  8004202abf:	48 8b 00             	mov    (%rax),%rax
  8004202ac2:	48 c1 e0 0c          	shl    $0xc,%rax
  8004202ac6:	48 89 c2             	mov    %rax,%rdx
  8004202ac9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202acd:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202ad3:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004202ad8:	48 be 00 00 00 04 80 	movabs $0x8004000000,%rsi
  8004202adf:	00 00 00 
  8004202ae2:	48 89 c7             	mov    %rax,%rdi
  8004202ae5:	48 b8 5e 38 20 04 80 	movabs $0x800420385e,%rax
  8004202aec:	00 00 00 
  8004202aef:	ff d0                	callq  *%rax
	//check_boot_pml4e(boot_pml4e);

	//////////////////////////////////////////////////////////////////////
	// Permissions: kernel RW, user NONE

	pdpe_t *pdpe = KADDR(PTE_ADDR(pml4e[1]));
  8004202af1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004202af5:	48 83 c0 08          	add    $0x8,%rax
  8004202af9:	48 8b 00             	mov    (%rax),%rax
  8004202afc:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202b02:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004202b06:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202b0a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b0e:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  8004202b11:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004202b14:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004202b1b:	00 00 00 
  8004202b1e:	48 8b 00             	mov    (%rax),%rax
  8004202b21:	48 39 c2             	cmp    %rax,%rdx
  8004202b24:	72 32                	jb     8004202b58 <x64_vm_init+0x2ee>
  8004202b26:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202b2a:	48 89 c1             	mov    %rax,%rcx
  8004202b2d:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004202b34:	00 00 00 
  8004202b37:	be 54 01 00 00       	mov    $0x154,%esi
  8004202b3c:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202b43:	00 00 00 
  8004202b46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202b4b:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202b52:	00 00 00 
  8004202b55:	41 ff d0             	callq  *%r8
  8004202b58:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202b5f:	00 00 00 
  8004202b62:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004202b66:	48 01 d0             	add    %rdx,%rax
  8004202b69:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	pde_t *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004202b6d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004202b71:	48 8b 00             	mov    (%rax),%rax
  8004202b74:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004202b7a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202b7e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202b82:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202b86:	89 45 bc             	mov    %eax,-0x44(%rbp)
  8004202b89:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004202b8c:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004202b93:	00 00 00 
  8004202b96:	48 8b 00             	mov    (%rax),%rax
  8004202b99:	48 39 c2             	cmp    %rax,%rdx
  8004202b9c:	72 32                	jb     8004202bd0 <x64_vm_init+0x366>
  8004202b9e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202ba2:	48 89 c1             	mov    %rax,%rcx
  8004202ba5:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004202bac:	00 00 00 
  8004202baf:	be 55 01 00 00       	mov    $0x155,%esi
  8004202bb4:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202bbb:	00 00 00 
  8004202bbe:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202bc3:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202bca:	00 00 00 
  8004202bcd:	41 ff d0             	callq  *%r8
  8004202bd0:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202bd7:	00 00 00 
  8004202bda:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202bde:	48 01 d0             	add    %rdx,%rax
  8004202be1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	lcr3(boot_cr3);
  8004202be5:	48 b8 80 97 37 04 80 	movabs $0x8004379780,%rax
  8004202bec:	00 00 00 
  8004202bef:	48 8b 00             	mov    (%rax),%rax
  8004202bf2:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  8004202bf6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004202bfa:	0f 22 d8             	mov    %rax,%cr3

	/* check_page_free_list(1); */
	/* check_page_alloc(); */
	/* page_check(); */
	/* check_page_free_list(0); */
}
  8004202bfd:	c9                   	leaveq 
  8004202bfe:	c3                   	retq   

0000008004202bff <mem_init_mp>:
// Modify mappings in boot_pml4e to support SMP
//   - Map the per-CPU stacks in the region [KSTACKTOP-PTSIZE, KSTACKTOP)
//
static void
mem_init_mp(void)
{
  8004202bff:	55                   	push   %rbp
  8004202c00:	48 89 e5             	mov    %rsp,%rbp
  8004202c03:	48 83 ec 20          	sub    $0x20,%rsp
	//             it will fault rather than overwrite another CPU's stack.
	//             Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
  8004202c07:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	uint64_t la = KSTACKTOP;
  8004202c0e:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  8004202c15:	00 00 00 
  8004202c18:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for(; i < NCPU; i++)
  8004202c1c:	e9 b1 00 00 00       	jmpq   8004202cd2 <mem_init_mp+0xd3>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
  8004202c21:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004202c24:	48 98                	cltq   
  8004202c26:	48 c1 e0 10          	shl    $0x10,%rax
  8004202c2a:	48 89 c2             	mov    %rax,%rdx
  8004202c2d:	48 b8 00 c0 37 04 80 	movabs $0x800437c000,%rax
  8004202c34:	00 00 00 
  8004202c37:	48 01 d0             	add    %rdx,%rax
  8004202c3a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004202c3e:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202c45:	00 00 00 
  8004202c48:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004202c4c:	77 32                	ja     8004202c80 <mem_init_mp+0x81>
  8004202c4e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c52:	48 89 c1             	mov    %rax,%rcx
  8004202c55:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  8004202c5c:	00 00 00 
  8004202c5f:	be 7a 01 00 00       	mov    $0x17a,%esi
  8004202c64:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202c6b:	00 00 00 
  8004202c6e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202c73:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202c7a:	00 00 00 
  8004202c7d:	41 ff d0             	callq  *%r8
  8004202c80:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202c87:	ff ff ff 
  8004202c8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004202c8e:	48 01 c2             	add    %rax,%rdx
  8004202c91:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202c95:	48 8d b0 00 00 ff ff 	lea    -0x10000(%rax),%rsi
  8004202c9c:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004202ca3:	00 00 00 
  8004202ca6:	48 8b 00             	mov    (%rax),%rax
  8004202ca9:	41 b8 03 00 00 00    	mov    $0x3,%r8d
  8004202caf:	48 89 d1             	mov    %rdx,%rcx
  8004202cb2:	ba 00 00 01 00       	mov    $0x10000,%edx
  8004202cb7:	48 89 c7             	mov    %rax,%rdi
  8004202cba:	48 b8 5e 38 20 04 80 	movabs $0x800420385e,%rax
  8004202cc1:	00 00 00 
  8004202cc4:	ff d0                	callq  *%rax
		la -= (KSTKSIZE + KSTKGAP);
  8004202cc6:	48 81 6d f0 00 80 01 	subq   $0x18000,-0x10(%rbp)
  8004202ccd:	00 
	//     Permissions: kernel RW, user NONE
	//
	// LAB 4: Your code here:
	int i = 0;
	uint64_t la = KSTACKTOP;
	for(; i < NCPU; i++)
  8004202cce:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004202cd2:	83 7d fc 03          	cmpl   $0x3,-0x4(%rbp)
  8004202cd6:	0f 8e 45 ff ff ff    	jle    8004202c21 <mem_init_mp+0x22>
	{
		//cprintf("\npercpu_kstacks %x", PADDR(percpu_kstacks[i]));
		boot_map_region(boot_pml4e, la - KSTKSIZE, KSTKSIZE, PADDR(percpu_kstacks[i]), PTE_W|PTE_P);
		la -= (KSTKSIZE + KSTKGAP);
	}
}
  8004202cdc:	c9                   	leaveq 
  8004202cdd:	c3                   	retq   

0000008004202cde <page_init>:
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
  8004202cde:	55                   	push   %rbp
  8004202cdf:	48 89 e5             	mov    %rsp,%rbp
  8004202ce2:	48 83 ec 70          	sub    $0x70,%rsp
	// NB: Make sure you preserve the direction in which your page_free_list 
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
  8004202ce6:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004202ced:	00 
	for (i = 0; i < npages; i++) {
  8004202cee:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004202cf5:	00 
  8004202cf6:	e9 ab 00 00 00       	jmpq   8004202da6 <page_init+0xc8>
		pages[i].pp_ref = 0;
  8004202cfb:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004202d02:	00 00 00 
  8004202d05:	48 8b 00             	mov    (%rax),%rax
  8004202d08:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202d0c:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202d10:	48 01 d0             	add    %rdx,%rax
  8004202d13:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
		pages[i].pp_link = NULL;
  8004202d19:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004202d20:	00 00 00 
  8004202d23:	48 8b 00             	mov    (%rax),%rax
  8004202d26:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202d2a:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202d2e:	48 01 d0             	add    %rdx,%rax
  8004202d31:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if(last)
  8004202d38:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004202d3d:	74 21                	je     8004202d60 <page_init+0x82>
			last->pp_link = &pages[i];
  8004202d3f:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004202d46:	00 00 00 
  8004202d49:	48 8b 00             	mov    (%rax),%rax
  8004202d4c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202d50:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202d54:	48 01 c2             	add    %rax,%rdx
  8004202d57:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004202d5b:	48 89 10             	mov    %rdx,(%rax)
  8004202d5e:	eb 25                	jmp    8004202d85 <page_init+0xa7>
		else
			page_free_list = &pages[i];
  8004202d60:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004202d67:	00 00 00 
  8004202d6a:	48 8b 00             	mov    (%rax),%rax
  8004202d6d:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202d71:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202d75:	48 01 c2             	add    %rax,%rdx
  8004202d78:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004202d7f:	00 00 00 
  8004202d82:	48 89 10             	mov    %rdx,(%rax)
		last = &pages[i];
  8004202d85:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004202d8c:	00 00 00 
  8004202d8f:	48 8b 00             	mov    (%rax),%rax
  8004202d92:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004202d96:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202d9a:	48 01 d0             	add    %rdx,%rax
  8004202d9d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is constructed
	// NB: Remember to mark the memory used for initial boot page table i.e (va>=BOOT_PAGE_TABLE_START && va < BOOT_PAGE_TABLE_END) as in-use (not free)

	size_t i, holeS, kernE, bootPTS, bootPTE;
	struct PageInfo* last = NULL;
	for (i = 0; i < npages; i++) {
  8004202da1:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004202da6:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004202dad:	00 00 00 
  8004202db0:	48 8b 00             	mov    (%rax),%rax
  8004202db3:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004202db7:	0f 82 3e ff ff ff    	jb     8004202cfb <page_init+0x1d>
		else
			page_free_list = &pages[i];
		last = &pages[i];
	}
	//remove page 0 from page list
	page_free_list = page_free_list->pp_link;
  8004202dbd:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004202dc4:	00 00 00 
  8004202dc7:	48 8b 00             	mov    (%rax),%rax
  8004202dca:	48 8b 10             	mov    (%rax),%rdx
  8004202dcd:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004202dd4:	00 00 00 
  8004202dd7:	48 89 10             	mov    %rdx,(%rax)

	//remove entries of holes till current kernel available memory pointer
	holeS = IOPHYSMEM/PGSIZE;
  8004202dda:	48 c7 45 e8 a0 00 00 	movq   $0xa0,-0x18(%rbp)
  8004202de1:	00 
	kernE = PADDR(boot_alloc(0))/PGSIZE;
  8004202de2:	bf 00 00 00 00       	mov    $0x0,%edi
  8004202de7:	48 b8 19 27 20 04 80 	movabs $0x8004202719,%rax
  8004202dee:	00 00 00 
  8004202df1:	ff d0                	callq  *%rax
  8004202df3:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004202df7:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202dfe:	00 00 00 
  8004202e01:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  8004202e05:	77 32                	ja     8004202e39 <page_init+0x15b>
  8004202e07:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202e0b:	48 89 c1             	mov    %rax,%rcx
  8004202e0e:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  8004202e15:	00 00 00 
  8004202e18:	be b7 01 00 00       	mov    $0x1b7,%esi
  8004202e1d:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202e24:	00 00 00 
  8004202e27:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202e2c:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202e33:	00 00 00 
  8004202e36:	41 ff d0             	callq  *%r8
  8004202e39:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202e40:	ff ff ff 
  8004202e43:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004202e47:	48 01 d0             	add    %rdx,%rax
  8004202e4a:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e4e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	pages[holeS - 1].pp_link = &pages[kernE];
  8004202e52:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004202e59:	00 00 00 
  8004202e5c:	48 8b 00             	mov    (%rax),%rax
  8004202e5f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004202e63:	48 c1 e2 04          	shl    $0x4,%rdx
  8004202e67:	48 83 ea 10          	sub    $0x10,%rdx
  8004202e6b:	48 01 c2             	add    %rax,%rdx
  8004202e6e:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004202e75:	00 00 00 
  8004202e78:	48 8b 00             	mov    (%rax),%rax
  8004202e7b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004202e7f:	48 c1 e1 04          	shl    $0x4,%rcx
  8004202e83:	48 01 c8             	add    %rcx,%rax
  8004202e86:	48 89 02             	mov    %rax,(%rdx)

	bootPTS = PADDR(BOOT_PAGE_TABLE_START)/PGSIZE;	
  8004202e89:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202e90:	00 00 00 
  8004202e93:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004202e97:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202e9b:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202e9f:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004202ea2:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004202ea5:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004202eac:	00 00 00 
  8004202eaf:	48 8b 00             	mov    (%rax),%rax
  8004202eb2:	48 39 c2             	cmp    %rax,%rdx
  8004202eb5:	72 32                	jb     8004202ee9 <page_init+0x20b>
  8004202eb7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202ebb:	48 89 c1             	mov    %rax,%rcx
  8004202ebe:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004202ec5:	00 00 00 
  8004202ec8:	be ba 01 00 00       	mov    $0x1ba,%esi
  8004202ecd:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202ed4:	00 00 00 
  8004202ed7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202edc:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202ee3:	00 00 00 
  8004202ee6:	41 ff d0             	callq  *%r8
  8004202ee9:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202ef0:	00 00 00 
  8004202ef3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004202ef7:	48 01 d0             	add    %rdx,%rax
  8004202efa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004202efe:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202f05:	00 00 00 
  8004202f08:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  8004202f0c:	77 32                	ja     8004202f40 <page_init+0x262>
  8004202f0e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202f12:	48 89 c1             	mov    %rax,%rcx
  8004202f15:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  8004202f1c:	00 00 00 
  8004202f1f:	be ba 01 00 00       	mov    $0x1ba,%esi
  8004202f24:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202f2b:	00 00 00 
  8004202f2e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202f33:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202f3a:	00 00 00 
  8004202f3d:	41 ff d0             	callq  *%r8
  8004202f40:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004202f47:	ff ff ff 
  8004202f4a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004202f4e:	48 01 d0             	add    %rdx,%rax
  8004202f51:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202f55:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	bootPTE = PADDR(BOOT_PAGE_TABLE_END - 1)/PGSIZE;
  8004202f59:	48 b8 00 20 10 00 00 	movabs $0x102000,%rax
  8004202f60:	00 00 00 
  8004202f63:	48 05 00 50 00 00    	add    $0x5000,%rax
  8004202f69:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004202f6d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202f71:	48 c1 e8 0c          	shr    $0xc,%rax
  8004202f75:	89 45 ac             	mov    %eax,-0x54(%rbp)
  8004202f78:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004202f7b:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004202f82:	00 00 00 
  8004202f85:	48 8b 00             	mov    (%rax),%rax
  8004202f88:	48 39 c2             	cmp    %rax,%rdx
  8004202f8b:	72 32                	jb     8004202fbf <page_init+0x2e1>
  8004202f8d:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202f91:	48 89 c1             	mov    %rax,%rcx
  8004202f94:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004202f9b:	00 00 00 
  8004202f9e:	be bb 01 00 00       	mov    $0x1bb,%esi
  8004202fa3:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004202faa:	00 00 00 
  8004202fad:	b8 00 00 00 00       	mov    $0x0,%eax
  8004202fb2:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004202fb9:	00 00 00 
  8004202fbc:	41 ff d0             	callq  *%r8
  8004202fbf:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004202fc6:	00 00 00 
  8004202fc9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004202fcd:	48 01 d0             	add    %rdx,%rax
  8004202fd0:	48 83 e8 01          	sub    $0x1,%rax
  8004202fd4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  8004202fd8:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  8004202fdf:	00 00 00 
  8004202fe2:	48 39 45 a0          	cmp    %rax,-0x60(%rbp)
  8004202fe6:	77 32                	ja     800420301a <page_init+0x33c>
  8004202fe8:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004202fec:	48 89 c1             	mov    %rax,%rcx
  8004202fef:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  8004202ff6:	00 00 00 
  8004202ff9:	be bb 01 00 00       	mov    $0x1bb,%esi
  8004202ffe:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004203005:	00 00 00 
  8004203008:	b8 00 00 00 00       	mov    $0x0,%eax
  800420300d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004203014:	00 00 00 
  8004203017:	41 ff d0             	callq  *%r8
  800420301a:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  8004203021:	ff ff ff 
  8004203024:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004203028:	48 01 d0             	add    %rdx,%rax
  800420302b:	48 c1 e8 0c          	shr    $0xc,%rax
  800420302f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pages[bootPTS - 1].pp_link = &pages[bootPTE + 1];
  8004203033:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  800420303a:	00 00 00 
  800420303d:	48 8b 00             	mov    (%rax),%rax
  8004203040:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004203044:	48 c1 e2 04          	shl    $0x4,%rdx
  8004203048:	48 83 ea 10          	sub    $0x10,%rdx
  800420304c:	48 01 c2             	add    %rax,%rdx
  800420304f:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004203056:	00 00 00 
  8004203059:	48 8b 00             	mov    (%rax),%rax
  800420305c:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
  8004203060:	48 83 c1 01          	add    $0x1,%rcx
  8004203064:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203068:	48 01 c8             	add    %rcx,%rax
  800420306b:	48 89 02             	mov    %rax,(%rdx)

	//marking page at MPENTRY_PADDR as being used 
	pages[MPENTRY_PADDR / PGSIZE - 1].pp_link = &pages[MPENTRY_PADDR / PGSIZE + 1];
  800420306e:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004203075:	00 00 00 
  8004203078:	48 8b 00             	mov    (%rax),%rax
  800420307b:	48 8d 50 60          	lea    0x60(%rax),%rdx
  800420307f:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004203086:	00 00 00 
  8004203089:	48 8b 00             	mov    (%rax),%rax
  800420308c:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004203090:	48 89 02             	mov    %rax,(%rdx)
}
  8004203093:	c9                   	leaveq 
  8004203094:	c3                   	retq   

0000008004203095 <page_alloc>:
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
  8004203095:	55                   	push   %rbp
  8004203096:	48 89 e5             	mov    %rsp,%rbp
  8004203099:	48 83 ec 20          	sub    $0x20,%rsp
  800420309d:	89 7d ec             	mov    %edi,-0x14(%rbp)
	// Fill this function in
	struct PageInfo * page = NULL;
  80042030a0:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042030a7:	00 
	if(page_free_list)
  80042030a8:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  80042030af:	00 00 00 
  80042030b2:	48 8b 00             	mov    (%rax),%rax
  80042030b5:	48 85 c0             	test   %rax,%rax
  80042030b8:	74 6f                	je     8004203129 <page_alloc+0x94>
	{
		page = page_free_list;
  80042030ba:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  80042030c1:	00 00 00 
  80042030c4:	48 8b 00             	mov    (%rax),%rax
  80042030c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		page_free_list = page_free_list->pp_link;
  80042030cb:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  80042030d2:	00 00 00 
  80042030d5:	48 8b 00             	mov    (%rax),%rax
  80042030d8:	48 8b 10             	mov    (%rax),%rdx
  80042030db:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  80042030e2:	00 00 00 
  80042030e5:	48 89 10             	mov    %rdx,(%rax)
		page->pp_link = NULL;
  80042030e8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042030ec:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
//		cprintf("Umesh: physical addresses =[%x]\n",page);
		if(alloc_flags & ALLOC_ZERO)
  80042030f3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042030f6:	83 e0 01             	and    $0x1,%eax
  80042030f9:	85 c0                	test   %eax,%eax
  80042030fb:	74 2c                	je     8004203129 <page_alloc+0x94>
		{
			memset(page2kva(page), '\0', PGSIZE);
  80042030fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203101:	48 89 c7             	mov    %rax,%rdi
  8004203104:	48 b8 f0 1d 20 04 80 	movabs $0x8004201df0,%rax
  800420310b:	00 00 00 
  800420310e:	ff d0                	callq  *%rax
  8004203110:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004203115:	be 00 00 00 00       	mov    $0x0,%esi
  800420311a:	48 89 c7             	mov    %rax,%rdi
  800420311d:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004203124:	00 00 00 
  8004203127:	ff d0                	callq  *%rax
		}
	}
	else{
		//cprintf("page alloc failed\n");
	}
	return page;
  8004203129:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420312d:	c9                   	leaveq 
  800420312e:	c3                   	retq   

000000800420312f <page_initpp>:
// The result has null links and 0 refcount.
// Note that the corresponding physical page is NOT initialized!
//
static void
page_initpp(struct PageInfo *pp)
{
  800420312f:	55                   	push   %rbp
  8004203130:	48 89 e5             	mov    %rsp,%rbp
  8004203133:	48 83 ec 10          	sub    $0x10,%rsp
  8004203137:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	memset(pp, 0, sizeof(*pp));
  800420313b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420313f:	ba 10 00 00 00       	mov    $0x10,%edx
  8004203144:	be 00 00 00 00       	mov    $0x0,%esi
  8004203149:	48 89 c7             	mov    %rax,%rdi
  800420314c:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004203153:	00 00 00 
  8004203156:	ff d0                	callq  *%rax
}
  8004203158:	c9                   	leaveq 
  8004203159:	c3                   	retq   

000000800420315a <insertAtBegining>:

void insertAtBegining(struct PageInfo ** list, struct PageInfo * node)
{
  800420315a:	55                   	push   %rbp
  800420315b:	48 89 e5             	mov    %rsp,%rbp
  800420315e:	48 83 ec 10          	sub    $0x10,%rsp
  8004203162:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203166:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	if(*list == NULL)
  800420316a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420316e:	48 8b 00             	mov    (%rax),%rax
  8004203171:	48 85 c0             	test   %rax,%rax
  8004203174:	75 0d                	jne    8004203183 <insertAtBegining+0x29>
	{
		*list = node;
  8004203176:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420317a:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420317e:	48 89 10             	mov    %rdx,(%rax)
  8004203181:	eb 2c                	jmp    80042031af <insertAtBegining+0x55>
	}
	else if(*list != NULL && node != NULL)
  8004203183:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203187:	48 8b 00             	mov    (%rax),%rax
  800420318a:	48 85 c0             	test   %rax,%rax
  800420318d:	74 20                	je     80042031af <insertAtBegining+0x55>
  800420318f:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203194:	74 19                	je     80042031af <insertAtBegining+0x55>
	{
		node->pp_link = *list;
  8004203196:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420319a:	48 8b 10             	mov    (%rax),%rdx
  800420319d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042031a1:	48 89 10             	mov    %rdx,(%rax)
		*list = node;
  80042031a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031a8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042031ac:	48 89 10             	mov    %rdx,(%rax)
	}
}
  80042031af:	c9                   	leaveq 
  80042031b0:	c3                   	retq   

00000080042031b1 <page_free>:
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
  80042031b1:	55                   	push   %rbp
  80042031b2:	48 89 e5             	mov    %rsp,%rbp
  80042031b5:	48 83 ec 10          	sub    $0x10,%rsp
  80042031b9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if(pp->pp_ref != 0)
  80042031bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031c1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042031c5:	66 85 c0             	test   %ax,%ax
  80042031c8:	74 2a                	je     80042031f4 <page_free+0x43>
	{	
		panic("pp->pp_ref is nonzero");
  80042031ca:	48 ba 14 83 21 04 80 	movabs $0x8004218314,%rdx
  80042031d1:	00 00 00 
  80042031d4:	be 08 02 00 00       	mov    $0x208,%esi
  80042031d9:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042031e0:	00 00 00 
  80042031e3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042031e8:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  80042031ef:	00 00 00 
  80042031f2:	ff d1                	callq  *%rcx
	}
	else if(pp->pp_link)
  80042031f4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042031f8:	48 8b 00             	mov    (%rax),%rax
  80042031fb:	48 85 c0             	test   %rax,%rax
  80042031fe:	74 2a                	je     800420322a <page_free+0x79>
	{
		panic("pp->pp_link is not NULL");
  8004203200:	48 ba 2a 83 21 04 80 	movabs $0x800421832a,%rdx
  8004203207:	00 00 00 
  800420320a:	be 0c 02 00 00       	mov    $0x20c,%esi
  800420320f:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004203216:	00 00 00 
  8004203219:	b8 00 00 00 00       	mov    $0x0,%eax
  800420321e:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  8004203225:	00 00 00 
  8004203228:	ff d1                	callq  *%rcx
	}
	else
	{
		//insert node to be freed at the begining of free node list
		insertAtBegining(&page_free_list, pp);
  800420322a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420322e:	48 89 c6             	mov    %rax,%rsi
  8004203231:	48 bf 38 82 37 04 80 	movabs $0x8004378238,%rdi
  8004203238:	00 00 00 
  800420323b:	48 b8 5a 31 20 04 80 	movabs $0x800420315a,%rax
  8004203242:	00 00 00 
  8004203245:	ff d0                	callq  *%rax
	}
}
  8004203247:	c9                   	leaveq 
  8004203248:	c3                   	retq   

0000008004203249 <page_decref>:
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
  8004203249:	55                   	push   %rbp
  800420324a:	48 89 e5             	mov    %rsp,%rbp
  800420324d:	48 83 ec 10          	sub    $0x10,%rsp
  8004203251:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (--pp->pp_ref == 0)
  8004203255:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203259:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420325d:	8d 50 ff             	lea    -0x1(%rax),%edx
  8004203260:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203264:	66 89 50 08          	mov    %dx,0x8(%rax)
  8004203268:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420326c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203270:	66 85 c0             	test   %ax,%ax
  8004203273:	75 13                	jne    8004203288 <page_decref+0x3f>
		page_free(pp);
  8004203275:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203279:	48 89 c7             	mov    %rax,%rdi
  800420327c:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004203283:	00 00 00 
  8004203286:	ff d0                	callq  *%rax
}
  8004203288:	c9                   	leaveq 
  8004203289:	c3                   	retq   

000000800420328a <pml4e_walk>:
// table, page directory,page directory pointer and pml4 entries.
//

pte_t *
pml4e_walk(pml4e_t *pml4e, const void *va, int create)
{
  800420328a:	55                   	push   %rbp
  800420328b:	48 89 e5             	mov    %rsp,%rbp
  800420328e:	53                   	push   %rbx
  800420328f:	48 83 ec 58          	sub    $0x58,%rsp
  8004203293:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004203297:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  800420329b:	89 55 ac             	mov    %edx,-0x54(%rbp)
	//Need to return
	pte_t * pml4eIndexPtr = NULL;
  800420329e:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  80042032a5:	00 
	int pml4eIndex;
	int pdpeIndex;
	uint64_t temp;
	struct PageInfo * page = NULL;
  80042032a6:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042032ad:	00 
	if(pml4e == NULL)
  80042032ae:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042032b3:	75 0a                	jne    80042032bf <pml4e_walk+0x35>
	{
		return NULL;
  80042032b5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032ba:	e9 c5 01 00 00       	jmpq   8004203484 <pml4e_walk+0x1fa>
	}
	pml4eIndex = PML4(va);
  80042032bf:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042032c3:	48 c1 e8 27          	shr    $0x27,%rax
  80042032c7:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042032cc:	89 45 dc             	mov    %eax,-0x24(%rbp)

	if((uint64_t*)pml4e[pml4eIndex] == NULL && create == false)
  80042032cf:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042032d2:	48 98                	cltq   
  80042032d4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042032db:	00 
  80042032dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042032e0:	48 01 d0             	add    %rdx,%rax
  80042032e3:	48 8b 00             	mov    (%rax),%rax
  80042032e6:	48 85 c0             	test   %rax,%rax
  80042032e9:	75 10                	jne    80042032fb <pml4e_walk+0x71>
  80042032eb:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  80042032ef:	75 0a                	jne    80042032fb <pml4e_walk+0x71>
	{
		return NULL;
  80042032f1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042032f6:	e9 89 01 00 00       	jmpq   8004203484 <pml4e_walk+0x1fa>
	}
	else if((uint64_t*)pml4e[pml4eIndex] == NULL && create == true)
  80042032fb:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042032fe:	48 98                	cltq   
  8004203300:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203307:	00 
  8004203308:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420330c:	48 01 d0             	add    %rdx,%rax
  800420330f:	48 8b 00             	mov    (%rax),%rax
  8004203312:	48 85 c0             	test   %rax,%rax
  8004203315:	75 7a                	jne    8004203391 <pml4e_walk+0x107>
  8004203317:	83 7d ac 01          	cmpl   $0x1,-0x54(%rbp)
  800420331b:	75 74                	jne    8004203391 <pml4e_walk+0x107>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  800420331d:	c7 45 d8 07 00 00 00 	movl   $0x7,-0x28(%rbp)
		page = page_alloc(ALLOC_ZERO);
  8004203324:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203329:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004203330:	00 00 00 
  8004203333:	ff d0                	callq  *%rax
  8004203335:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		if(!page)
  8004203339:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420333e:	75 0a                	jne    800420334a <pml4e_walk+0xc0>
			return NULL;
  8004203340:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203345:	e9 3a 01 00 00       	jmpq   8004203484 <pml4e_walk+0x1fa>
		page->pp_ref++;
  800420334a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420334e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203352:	8d 50 01             	lea    0x1(%rax),%edx
  8004203355:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203359:	66 89 50 08          	mov    %dx,0x8(%rax)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
		pml4e[pml4eIndex] = page2pa(page) | perm;
  800420335d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203360:	48 98                	cltq   
  8004203362:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203369:	00 
  800420336a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420336e:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203372:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203376:	48 89 c7             	mov    %rax,%rdi
  8004203379:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004203380:	00 00 00 
  8004203383:	ff d0                	callq  *%rax
  8004203385:	8b 55 d8             	mov    -0x28(%rbp),%edx
  8004203388:	48 63 d2             	movslq %edx,%rdx
  800420338b:	48 09 d0             	or     %rdx,%rax
  800420338e:	48 89 03             	mov    %rax,(%rbx)
		//cprintf("pml4eIndex = [%d], pml4e[pml4eIndex] = %d", pml4eIndex, pml4e[pml4eIndex]);
	}
	//pml4e entry with last 12 bits permissions
	temp = pml4e[pml4eIndex];
  8004203391:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203394:	48 98                	cltq   
  8004203396:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420339d:	00 
  800420339e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042033a2:	48 01 d0             	add    %rdx,%rax
  80042033a5:	48 8b 00             	mov    (%rax),%rax
  80042033a8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  80042033ac:	48 81 65 d0 00 f0 ff 	andq   $0xfffffffffffff000,-0x30(%rbp)
  80042033b3:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  80042033b4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042033b8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042033bc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042033c0:	48 c1 e8 0c          	shr    $0xc,%rax
  80042033c4:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042033c7:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042033ca:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042033d1:	00 00 00 
  80042033d4:	48 8b 00             	mov    (%rax),%rax
  80042033d7:	48 39 c2             	cmp    %rax,%rdx
  80042033da:	72 32                	jb     800420340e <pml4e_walk+0x184>
  80042033dc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042033e0:	48 89 c1             	mov    %rax,%rcx
  80042033e3:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  80042033ea:	00 00 00 
  80042033ed:	be 5c 02 00 00       	mov    $0x25c,%esi
  80042033f2:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042033f9:	00 00 00 
  80042033fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203401:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004203408:	00 00 00 
  800420340b:	41 ff d0             	callq  *%r8
  800420340e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203415:	00 00 00 
  8004203418:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420341c:	48 01 d0             	add    %rdx,%rax
  800420341f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//increase pgtable index to get index pointer in page table
	pml4eIndexPtr = (pte_t *)pdpe_walk((pte_t *)temp, va, create); 
  8004203423:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203427:	8b 55 ac             	mov    -0x54(%rbp),%edx
  800420342a:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  800420342e:	48 89 ce             	mov    %rcx,%rsi
  8004203431:	48 89 c7             	mov    %rax,%rdi
  8004203434:	48 b8 8b 34 20 04 80 	movabs $0x800420348b,%rax
  800420343b:	00 00 00 
  800420343e:	ff d0                	callq  *%rax
  8004203440:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	//Null check
	if(pml4eIndexPtr == NULL && page != NULL)
  8004203444:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203449:	75 35                	jne    8004203480 <pml4e_walk+0x1f6>
  800420344b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203450:	74 2e                	je     8004203480 <pml4e_walk+0x1f6>
	{
		page_decref(page);
  8004203452:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203456:	48 89 c7             	mov    %rax,%rdi
  8004203459:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  8004203460:	00 00 00 
  8004203463:	ff d0                	callq  *%rax
        pml4e[pml4eIndex] = 0;
  8004203465:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004203468:	48 98                	cltq   
  800420346a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203471:	00 
  8004203472:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203476:	48 01 d0             	add    %rdx,%rax
  8004203479:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	return pml4eIndexPtr;
  8004203480:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004203484:	48 83 c4 58          	add    $0x58,%rsp
  8004203488:	5b                   	pop    %rbx
  8004203489:	5d                   	pop    %rbp
  800420348a:	c3                   	retq   

000000800420348b <pdpe_walk>:
// The programming logic in this function is similar to pml4e_walk.
// It calls the pgdir_walk which returns the page_table entry pointer.
// Hints are the same as in pml4e_walk
pte_t *
pdpe_walk(pdpe_t *pdpe,const void *va,int create)
{
  800420348b:	55                   	push   %rbp
  800420348c:	48 89 e5             	mov    %rsp,%rbp
  800420348f:	53                   	push   %rbx
  8004203490:	48 83 ec 68          	sub    $0x68,%rsp
  8004203494:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004203498:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420349c:	89 55 9c             	mov    %edx,-0x64(%rbp)
	//Need to return
	pte_t * pdpeIndexPtr = NULL;
  800420349f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042034a6:	00 
	int pdpeIndex = 0;
  80042034a7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
	int pgdirIndex = 0;
  80042034ae:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
	uint64_t temp;
	struct PageInfo * page = NULL;
  80042034b5:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80042034bc:	00 
	if(pdpe == NULL)
  80042034bd:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80042034c2:	75 0a                	jne    80042034ce <pdpe_walk+0x43>
	{
		return NULL;
  80042034c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042034c9:	e9 c5 01 00 00       	jmpq   8004203693 <pdpe_walk+0x208>
	}
	pdpeIndex = PDPE(va);
  80042034ce:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042034d2:	48 c1 e8 1e          	shr    $0x1e,%rax
  80042034d6:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042034db:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if(!(uint64_t*)pdpe[pdpeIndex] && create == false)
  80042034de:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042034e1:	48 98                	cltq   
  80042034e3:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042034ea:	00 
  80042034eb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042034ef:	48 01 d0             	add    %rdx,%rax
  80042034f2:	48 8b 00             	mov    (%rax),%rax
  80042034f5:	48 85 c0             	test   %rax,%rax
  80042034f8:	75 10                	jne    800420350a <pdpe_walk+0x7f>
  80042034fa:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  80042034fe:	75 0a                	jne    800420350a <pdpe_walk+0x7f>
	{
		return NULL;
  8004203500:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203505:	e9 89 01 00 00       	jmpq   8004203693 <pdpe_walk+0x208>
	}
	else if((uint64_t*)pdpe[pdpeIndex] == NULL && create == true)
  800420350a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420350d:	48 98                	cltq   
  800420350f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203516:	00 
  8004203517:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420351b:	48 01 d0             	add    %rdx,%rax
  800420351e:	48 8b 00             	mov    (%rax),%rax
  8004203521:	48 85 c0             	test   %rax,%rax
  8004203524:	75 7a                	jne    80042035a0 <pdpe_walk+0x115>
  8004203526:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  800420352a:	75 74                	jne    80042035a0 <pdpe_walk+0x115>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  800420352c:	c7 45 d4 07 00 00 00 	movl   $0x7,-0x2c(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  8004203533:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203538:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  800420353f:	00 00 00 
  8004203542:	ff d0                	callq  *%rax
  8004203544:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		if(!page)
  8004203548:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420354d:	75 0a                	jne    8004203559 <pdpe_walk+0xce>
			return NULL;
  800420354f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203554:	e9 3a 01 00 00       	jmpq   8004203693 <pdpe_walk+0x208>
		page->pp_ref++;
  8004203559:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420355d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203561:	8d 50 01             	lea    0x1(%rax),%edx
  8004203564:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203568:	66 89 50 08          	mov    %dx,0x8(%rax)
		pdpe[pdpeIndex] = page2pa(page) | perm;
  800420356c:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420356f:	48 98                	cltq   
  8004203571:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203578:	00 
  8004203579:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420357d:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004203581:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203585:	48 89 c7             	mov    %rax,%rdi
  8004203588:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  800420358f:	00 00 00 
  8004203592:	ff d0                	callq  *%rax
  8004203594:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203597:	48 63 d2             	movslq %edx,%rdx
  800420359a:	48 09 d0             	or     %rdx,%rax
  800420359d:	48 89 03             	mov    %rax,(%rbx)
	}
	//pdpe entry with last 12 bits permissions
	temp = pdpe[pdpeIndex];
  80042035a0:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042035a3:	48 98                	cltq   
  80042035a5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042035ac:	00 
  80042035ad:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042035b1:	48 01 d0             	add    %rdx,%rax
  80042035b4:	48 8b 00             	mov    (%rax),%rax
  80042035b7:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  80042035bb:	48 81 65 c0 00 f0 ff 	andq   $0xfffffffffffff000,-0x40(%rbp)
  80042035c2:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  80042035c3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042035c7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  80042035cb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042035cf:	48 c1 e8 0c          	shr    $0xc,%rax
  80042035d3:	89 45 b4             	mov    %eax,-0x4c(%rbp)
  80042035d6:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  80042035d9:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042035e0:	00 00 00 
  80042035e3:	48 8b 00             	mov    (%rax),%rax
  80042035e6:	48 39 c2             	cmp    %rax,%rdx
  80042035e9:	72 32                	jb     800420361d <pdpe_walk+0x192>
  80042035eb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042035ef:	48 89 c1             	mov    %rax,%rcx
  80042035f2:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  80042035f9:	00 00 00 
  80042035fc:	be 8d 02 00 00       	mov    $0x28d,%esi
  8004203601:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004203608:	00 00 00 
  800420360b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203610:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004203617:	00 00 00 
  800420361a:	41 ff d0             	callq  *%r8
  800420361d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004203624:	00 00 00 
  8004203627:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420362b:	48 01 d0             	add    %rdx,%rax
  800420362e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	//increase pgtable index to get index pointer in page table
	pdpeIndexPtr = (pte_t *)pgdir_walk((pte_t *)temp, va, create);
  8004203632:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203636:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004203639:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420363d:	48 89 ce             	mov    %rcx,%rsi
  8004203640:	48 89 c7             	mov    %rax,%rdi
  8004203643:	48 b8 9a 36 20 04 80 	movabs $0x800420369a,%rax
  800420364a:	00 00 00 
  800420364d:	ff d0                	callq  *%rax
  800420364f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//Null check
	if(pdpeIndexPtr == NULL && page != NULL)
  8004203653:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203658:	75 35                	jne    800420368f <pdpe_walk+0x204>
  800420365a:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420365f:	74 2e                	je     800420368f <pdpe_walk+0x204>
	{
        page_decref(page);
  8004203661:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203665:	48 89 c7             	mov    %rax,%rdi
  8004203668:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  800420366f:	00 00 00 
  8004203672:	ff d0                	callq  *%rax
        pdpe[pdpeIndex] = 0;
  8004203674:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203677:	48 98                	cltq   
  8004203679:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203680:	00 
  8004203681:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203685:	48 01 d0             	add    %rdx,%rax
  8004203688:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	}
	
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR(pdpe[pdpeIndex]), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pdpeIndexPtr;
  800420368f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004203693:	48 83 c4 68          	add    $0x68,%rsp
  8004203697:	5b                   	pop    %rbx
  8004203698:	5d                   	pop    %rbp
  8004203699:	c3                   	retq   

000000800420369a <pgdir_walk>:
// The programming logic and the hints are the same as pml4e_walk
// and pdpe_walk.

pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
  800420369a:	55                   	push   %rbp
  800420369b:	48 89 e5             	mov    %rsp,%rbp
  800420369e:	53                   	push   %rbx
  800420369f:	48 83 ec 68          	sub    $0x68,%rsp
  80042036a3:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  80042036a7:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  80042036ab:	89 55 9c             	mov    %edx,-0x64(%rbp)
	// Fill this function in
	//Need to return
	pte_t * pgTblIndexPtr = NULL;
  80042036ae:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042036b5:	00 
	int dirIndex;
	int pgTblIndex;
	uint64_t temp;
	if(pgdir == NULL)
  80042036b6:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  80042036bb:	75 0a                	jne    80042036c7 <pgdir_walk+0x2d>
	{
		return NULL;
  80042036bd:	b8 00 00 00 00       	mov    $0x0,%eax
  80042036c2:	e9 90 01 00 00       	jmpq   8004203857 <pgdir_walk+0x1bd>
	}
	dirIndex = PDX(va);
  80042036c7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042036cb:	48 c1 e8 15          	shr    $0x15,%rax
  80042036cf:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036d4:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	pgTblIndex = PTX(va);
  80042036d7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042036db:	48 c1 e8 0c          	shr    $0xc,%rax
  80042036df:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042036e4:	89 45 e0             	mov    %eax,-0x20(%rbp)
	if((uint64_t*)pgdir[dirIndex] == NULL && create == false)
  80042036e7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042036ea:	48 98                	cltq   
  80042036ec:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042036f3:	00 
  80042036f4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042036f8:	48 01 d0             	add    %rdx,%rax
  80042036fb:	48 8b 00             	mov    (%rax),%rax
  80042036fe:	48 85 c0             	test   %rax,%rax
  8004203701:	75 10                	jne    8004203713 <pgdir_walk+0x79>
  8004203703:	83 7d 9c 00          	cmpl   $0x0,-0x64(%rbp)
  8004203707:	75 0a                	jne    8004203713 <pgdir_walk+0x79>
	{
		return NULL;
  8004203709:	b8 00 00 00 00       	mov    $0x0,%eax
  800420370e:	e9 44 01 00 00       	jmpq   8004203857 <pgdir_walk+0x1bd>
	}
	else if((uint64_t*)pgdir[dirIndex] == NULL && create == true)
  8004203713:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203716:	48 98                	cltq   
  8004203718:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420371f:	00 
  8004203720:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203724:	48 01 d0             	add    %rdx,%rax
  8004203727:	48 8b 00             	mov    (%rax),%rax
  800420372a:	48 85 c0             	test   %rax,%rax
  800420372d:	75 7a                	jne    80042037a9 <pgdir_walk+0x10f>
  800420372f:	83 7d 9c 01          	cmpl   $0x1,-0x64(%rbp)
  8004203733:	75 74                	jne    80042037a9 <pgdir_walk+0x10f>
	{
		int perm = PTE_W | PTE_U | PTE_P;	
  8004203735:	c7 45 dc 07 00 00 00 	movl   $0x7,-0x24(%rbp)
		struct PageInfo * page = page_alloc(ALLOC_ZERO);
  800420373c:	bf 01 00 00 00       	mov    $0x1,%edi
  8004203741:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004203748:	00 00 00 
  800420374b:	ff d0                	callq  *%rax
  800420374d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!page)
  8004203751:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004203756:	75 0a                	jne    8004203762 <pgdir_walk+0xc8>
			return NULL;
  8004203758:	b8 00 00 00 00       	mov    $0x0,%eax
  800420375d:	e9 f5 00 00 00       	jmpq   8004203857 <pgdir_walk+0x1bd>
		page->pp_ref++;
  8004203762:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203766:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420376a:	8d 50 01             	lea    0x1(%rax),%edx
  800420376d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203771:	66 89 50 08          	mov    %dx,0x8(%rax)
		pgdir[dirIndex] = page2pa(page) | perm;
  8004203775:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203778:	48 98                	cltq   
  800420377a:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203781:	00 
  8004203782:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004203786:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420378a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420378e:	48 89 c7             	mov    %rax,%rdi
  8004203791:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004203798:	00 00 00 
  800420379b:	ff d0                	callq  *%rax
  800420379d:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042037a0:	48 63 d2             	movslq %edx,%rdx
  80042037a3:	48 09 d0             	or     %rdx,%rax
  80042037a6:	48 89 03             	mov    %rax,(%rbx)
	}
	//pgdir entry with last 12 bits permissions
	temp = pgdir[dirIndex];
  80042037a9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042037ac:	48 98                	cltq   
  80042037ae:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042037b5:	00 
  80042037b6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042037ba:	48 01 d0             	add    %rdx,%rax
  80042037bd:	48 8b 00             	mov    (%rax),%rax
  80042037c0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//remove permission bits
	temp = PTE_ADDR(temp);
  80042037c4:	48 81 65 c8 00 f0 ff 	andq   $0xfffffffffffff000,-0x38(%rbp)
  80042037cb:	ff 
	//physical to virtual mapping
	temp = (uint64_t)KADDR(temp);
  80042037cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042037d0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042037d4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042037d8:	48 c1 e8 0c          	shr    $0xc,%rax
  80042037dc:	89 45 bc             	mov    %eax,-0x44(%rbp)
  80042037df:	8b 55 bc             	mov    -0x44(%rbp),%edx
  80042037e2:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042037e9:	00 00 00 
  80042037ec:	48 8b 00             	mov    (%rax),%rax
  80042037ef:	48 39 c2             	cmp    %rax,%rdx
  80042037f2:	72 32                	jb     8004203826 <pgdir_walk+0x18c>
  80042037f4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042037f8:	48 89 c1             	mov    %rax,%rcx
  80042037fb:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004203802:	00 00 00 
  8004203805:	be c0 02 00 00       	mov    $0x2c0,%esi
  800420380a:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004203811:	00 00 00 
  8004203814:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203819:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004203820:	00 00 00 
  8004203823:	41 ff d0             	callq  *%r8
  8004203826:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420382d:	00 00 00 
  8004203830:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203834:	48 01 d0             	add    %rdx,%rax
  8004203837:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//increase pgtable index to get index pointer in page table
	pgTblIndexPtr = (pte_t *)temp + pgTblIndex;
  800420383b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800420383e:	48 98                	cltq   
  8004203840:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004203847:	00 
  8004203848:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420384c:	48 01 d0             	add    %rdx,%rax
  800420384f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("Address is %x  value is %x \n", (uint64_t)KADDR((uint64_t)(pgdir + dirIndex)), (uint64_t)KADDR(PTE_ADDR(pgdir[dirIndex])));
	return pgTblIndexPtr;
  8004203853:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  8004203857:	48 83 c4 68          	add    $0x68,%rsp
  800420385b:	5b                   	pop    %rbx
  800420385c:	5d                   	pop    %rbp
  800420385d:	c3                   	retq   

000000800420385e <boot_map_region>:
// mapped pages.
//
// Hint: the TA solution uses pml4e_walk
static void
boot_map_region(pml4e_t *pml4e, uintptr_t la, size_t size, physaddr_t pa, int perm)
{
  800420385e:	55                   	push   %rbp
  800420385f:	48 89 e5             	mov    %rsp,%rbp
  8004203862:	48 83 ec 50          	sub    $0x50,%rsp
  8004203866:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420386a:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420386e:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004203872:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004203876:	44 89 45 bc          	mov    %r8d,-0x44(%rbp)
        // Fill this function in
        pte_t *pte_store = NULL;
  800420387a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203881:	00 
        pte_t * pgTblIndexPtr = NULL;
  8004203882:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203889:	00 

        int i = 0;
  800420388a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
        if(pml4e == NULL)
  8004203891:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203896:	75 05                	jne    800420389d <boot_map_region+0x3f>
        {
                return;
  8004203898:	e9 82 00 00 00       	jmpq   800420391f <boot_map_region+0xc1>
        }

        for(; i < size / PGSIZE; i++)
  800420389d:	eb 6e                	jmp    800420390d <boot_map_region+0xaf>
        {
        	pgTblIndexPtr = pml4e_walk(pml4e, (void *)la , 1);
  800420389f:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  80042038a3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042038a7:	ba 01 00 00 00       	mov    $0x1,%edx
  80042038ac:	48 89 ce             	mov    %rcx,%rsi
  80042038af:	48 89 c7             	mov    %rax,%rdi
  80042038b2:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  80042038b9:	00 00 00 
  80042038bc:	ff d0                	callq  *%rax
  80042038be:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        	if(pgTblIndexPtr == NULL)
  80042038c2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042038c7:	75 1d                	jne    80042038e6 <boot_map_region+0x88>
        	{
        		cprintf("Error: could not bootmap");
  80042038c9:	48 bf 42 83 21 04 80 	movabs $0x8004218342,%rdi
  80042038d0:	00 00 00 
  80042038d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042038d8:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042038df:	00 00 00 
  80042038e2:	ff d2                	callq  *%rdx
        	    continue;
  80042038e4:	eb 23                	jmp    8004203909 <boot_map_region+0xab>
        	}
            *pgTblIndexPtr = pa | perm;
  80042038e6:	8b 45 bc             	mov    -0x44(%rbp),%eax
  80042038e9:	48 98                	cltq   
  80042038eb:	48 0b 45 c0          	or     -0x40(%rbp),%rax
  80042038ef:	48 89 c2             	mov    %rax,%rdx
  80042038f2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042038f6:	48 89 10             	mov    %rdx,(%rax)
            pa += PGSIZE;
  80042038f9:	48 81 45 c0 00 10 00 	addq   $0x1000,-0x40(%rbp)
  8004203900:	00 
            la += PGSIZE;
  8004203901:	48 81 45 d0 00 10 00 	addq   $0x1000,-0x30(%rbp)
  8004203908:	00 
        if(pml4e == NULL)
        {
                return;
        }

        for(; i < size / PGSIZE; i++)
  8004203909:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420390d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004203910:	48 98                	cltq   
  8004203912:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004203916:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420391a:	48 39 d0             	cmp    %rdx,%rax
  800420391d:	72 80                	jb     800420389f <boot_map_region+0x41>
        	}
            *pgTblIndexPtr = pa | perm;
            pa += PGSIZE;
            la += PGSIZE;
        }
}
  800420391f:	c9                   	leaveq 
  8004203920:	c3                   	retq   

0000008004203921 <page_insert>:
// Hint: The TA solution is implemented using pml4e_walk, page_remove,
// and page2pa.
//
int
page_insert(pml4e_t *pml4e, struct PageInfo *pp, void *va, int perm)
{
  8004203921:	55                   	push   %rbp
  8004203922:	48 89 e5             	mov    %rsp,%rbp
  8004203925:	48 83 ec 30          	sub    $0x30,%rsp
  8004203929:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420392d:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203931:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004203935:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	if(pml4e == NULL || pp == NULL)
  8004203938:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420393d:	74 07                	je     8004203946 <page_insert+0x25>
  800420393f:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004203944:	75 0a                	jne    8004203950 <page_insert+0x2f>
	{
		return 0;
  8004203946:	b8 00 00 00 00       	mov    $0x0,%eax
  800420394b:	e9 2c 01 00 00       	jmpq   8004203a7c <page_insert+0x15b>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  8004203950:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203954:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203958:	ba 01 00 00 00       	mov    $0x1,%edx
  800420395d:	48 89 ce             	mov    %rcx,%rsi
  8004203960:	48 89 c7             	mov    %rax,%rdi
  8004203963:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  800420396a:	00 00 00 
  800420396d:	ff d0                	callq  *%rax
  800420396f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//cprintf("pgTblIndexPtr %p %x\n", pgTblIndexPtr, pgTblIndexPtr);
	if(!pgTblIndexPtr)
  8004203973:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203978:	75 0a                	jne    8004203984 <page_insert+0x63>
	{
		return 	-E_NO_MEM;
  800420397a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420397f:	e9 f8 00 00 00       	jmpq   8004203a7c <page_insert+0x15b>
	}
	//set present bit
	perm = perm|PTE_P;
  8004203984:	83 4d d4 01          	orl    $0x1,-0x2c(%rbp)
	bool present = *pgTblIndexPtr & PTE_P;
  8004203988:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420398c:	48 8b 00             	mov    (%rax),%rax
  800420398f:	83 e0 01             	and    $0x1,%eax
  8004203992:	48 85 c0             	test   %rax,%rax
  8004203995:	0f 95 c0             	setne  %al
  8004203998:	88 45 f7             	mov    %al,-0x9(%rbp)
	if(present &&pa2page(PTE_ADDR(*pgTblIndexPtr)) == pp)
  800420399b:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  800420399f:	74 66                	je     8004203a07 <page_insert+0xe6>
  80042039a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039a5:	48 8b 00             	mov    (%rax),%rax
  80042039a8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042039ae:	48 89 c7             	mov    %rax,%rdi
  80042039b1:	48 b8 7f 1d 20 04 80 	movabs $0x8004201d7f,%rax
  80042039b8:	00 00 00 
  80042039bb:	ff d0                	callq  *%rax
  80042039bd:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  80042039c1:	75 44                	jne    8004203a07 <page_insert+0xe6>
	{		
		*pgTblIndexPtr = (page2pa(pp) | perm);
  80042039c3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042039c7:	48 89 c7             	mov    %rax,%rdi
  80042039ca:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  80042039d1:	00 00 00 
  80042039d4:	ff d0                	callq  *%rax
  80042039d6:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  80042039d9:	48 63 d2             	movslq %edx,%rdx
  80042039dc:	48 09 c2             	or     %rax,%rdx
  80042039df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042039e3:	48 89 10             	mov    %rdx,(%rax)
		tlb_invalidate(pml4e, va);
  80042039e6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042039ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042039ee:	48 89 d6             	mov    %rdx,%rsi
  80042039f1:	48 89 c7             	mov    %rax,%rdi
  80042039f4:	48 b8 a6 3b 20 04 80 	movabs $0x8004203ba6,%rax
  80042039fb:	00 00 00 
  80042039fe:	ff d0                	callq  *%rax
		return 0;
  8004203a00:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203a05:	eb 75                	jmp    8004203a7c <page_insert+0x15b>
	}
	//check and remove previous existing page
	else if(present)
  8004203a07:	80 7d f7 00          	cmpb   $0x0,-0x9(%rbp)
  8004203a0b:	74 34                	je     8004203a41 <page_insert+0x120>
	{
		page_remove(pml4e, va);
  8004203a0d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203a11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a15:	48 89 d6             	mov    %rdx,%rsi
  8004203a18:	48 89 c7             	mov    %rax,%rdi
  8004203a1b:	48 b8 18 3b 20 04 80 	movabs $0x8004203b18,%rax
  8004203a22:	00 00 00 
  8004203a25:	ff d0                	callq  *%rax
		//invalidate tlb
		tlb_invalidate(pml4e, va);
  8004203a27:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004203a2b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203a2f:	48 89 d6             	mov    %rdx,%rsi
  8004203a32:	48 89 c7             	mov    %rax,%rdi
  8004203a35:	48 b8 a6 3b 20 04 80 	movabs $0x8004203ba6,%rax
  8004203a3c:	00 00 00 
  8004203a3f:	ff d0                	callq  *%rax
	}

	//add new page
	*pgTblIndexPtr = (page2pa(pp) | perm);
  8004203a41:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203a45:	48 89 c7             	mov    %rax,%rdi
  8004203a48:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004203a4f:	00 00 00 
  8004203a52:	ff d0                	callq  *%rax
  8004203a54:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004203a57:	48 63 d2             	movslq %edx,%rdx
  8004203a5a:	48 09 c2             	or     %rax,%rdx
  8004203a5d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203a61:	48 89 10             	mov    %rdx,(%rax)

	//increment reference
	pp->pp_ref += 1;
  8004203a64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203a68:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004203a6c:	8d 50 01             	lea    0x1(%rax),%edx
  8004203a6f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203a73:	66 89 50 08          	mov    %dx,0x8(%rax)

	return 0;
  8004203a77:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203a7c:	c9                   	leaveq 
  8004203a7d:	c3                   	retq   

0000008004203a7e <page_lookup>:
//
// Hint: the TA solution uses pml4e_walk and pa2page.
//
struct PageInfo *
page_lookup(pml4e_t *pml4e, void *va, pte_t **pte_store)
{
  8004203a7e:	55                   	push   %rbp
  8004203a7f:	48 89 e5             	mov    %rsp,%rbp
  8004203a82:	48 83 ec 30          	sub    $0x30,%rsp
  8004203a86:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203a8a:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004203a8e:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	// Fill this function in
	pte_t * pgTblIndexPtr;
	struct PageInfo * page = NULL;
  8004203a92:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203a99:	00 
	bool present;

	if(pml4e == NULL)
  8004203a9a:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203a9f:	75 06                	jne    8004203aa7 <page_lookup+0x29>
	{
		return page;
  8004203aa1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203aa5:	eb 6f                	jmp    8004203b16 <page_lookup+0x98>
	}
	
	pgTblIndexPtr =  pml4e_walk(pml4e, va, 1);
  8004203aa7:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203aab:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203aaf:	ba 01 00 00 00       	mov    $0x1,%edx
  8004203ab4:	48 89 ce             	mov    %rcx,%rsi
  8004203ab7:	48 89 c7             	mov    %rax,%rdi
  8004203aba:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  8004203ac1:	00 00 00 
  8004203ac4:	ff d0                	callq  *%rax
  8004203ac6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(pgTblIndexPtr == NULL)
  8004203aca:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004203acf:	75 06                	jne    8004203ad7 <page_lookup+0x59>
		return page;
  8004203ad1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ad5:	eb 3f                	jmp    8004203b16 <page_lookup+0x98>
	
	if(*pgTblIndexPtr & PTE_P)
  8004203ad7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203adb:	48 8b 00             	mov    (%rax),%rax
  8004203ade:	83 e0 01             	and    $0x1,%eax
  8004203ae1:	48 85 c0             	test   %rax,%rax
  8004203ae4:	74 2c                	je     8004203b12 <page_lookup+0x94>
	{
		page = pa2page(*pgTblIndexPtr);				
  8004203ae6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203aea:	48 8b 00             	mov    (%rax),%rax
  8004203aed:	48 89 c7             	mov    %rax,%rdi
  8004203af0:	48 b8 7f 1d 20 04 80 	movabs $0x8004201d7f,%rax
  8004203af7:	00 00 00 
  8004203afa:	ff d0                	callq  *%rax
  8004203afc:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if(pte_store)
  8004203b00:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004203b05:	74 0b                	je     8004203b12 <page_lookup+0x94>
		{
			*pte_store = pgTblIndexPtr;
  8004203b07:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004203b0b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004203b0f:	48 89 10             	mov    %rdx,(%rax)
		}
	}
	return page;
  8004203b12:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004203b16:	c9                   	leaveq 
  8004203b17:	c3                   	retq   

0000008004203b18 <page_remove>:
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pml4e_t *pml4e, void *va)
{
  8004203b18:	55                   	push   %rbp
  8004203b19:	48 89 e5             	mov    %rsp,%rbp
  8004203b1c:	48 83 ec 20          	sub    $0x20,%rsp
  8004203b20:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203b24:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Fill this function in
	
	pte_t *pte_store = NULL;
  8004203b28:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203b2f:	00 
	struct PageInfo* page_add = NULL;
  8004203b30:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004203b37:	00 
	if(pml4e == NULL)
  8004203b38:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203b3d:	75 02                	jne    8004203b41 <page_remove+0x29>
	{
		return;
  8004203b3f:	eb 63                	jmp    8004203ba4 <page_remove+0x8c>
	}
	
	page_add =  page_lookup(pml4e, va, &pte_store);
  8004203b41:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  8004203b45:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  8004203b49:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203b4d:	48 89 ce             	mov    %rcx,%rsi
  8004203b50:	48 89 c7             	mov    %rax,%rdi
  8004203b53:	48 b8 7e 3a 20 04 80 	movabs $0x8004203a7e,%rax
  8004203b5a:	00 00 00 
  8004203b5d:	ff d0                	callq  *%rax
  8004203b5f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if(page_add == NULL)
  8004203b63:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004203b68:	75 02                	jne    8004203b6c <page_remove+0x54>
		return;
  8004203b6a:	eb 38                	jmp    8004203ba4 <page_remove+0x8c>
	
	tlb_invalidate(pml4e, va);
  8004203b6c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203b70:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203b74:	48 89 d6             	mov    %rdx,%rsi
  8004203b77:	48 89 c7             	mov    %rax,%rdi
  8004203b7a:	48 b8 a6 3b 20 04 80 	movabs $0x8004203ba6,%rax
  8004203b81:	00 00 00 
  8004203b84:	ff d0                	callq  *%rax
	page_decref(page_add);
  8004203b86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203b8a:	48 89 c7             	mov    %rax,%rdi
  8004203b8d:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  8004203b94:	00 00 00 
  8004203b97:	ff d0                	callq  *%rax
	//The pg table entry corresponding to 'va' should be set to 0.
	*pte_store = 0;
  8004203b99:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203b9d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
}
  8004203ba4:	c9                   	leaveq 
  8004203ba5:	c3                   	retq   

0000008004203ba6 <tlb_invalidate>:
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pml4e_t *pml4e, void *va)
{
  8004203ba6:	55                   	push   %rbp
  8004203ba7:	48 89 e5             	mov    %rsp,%rbp
  8004203baa:	48 83 ec 20          	sub    $0x20,%rsp
  8004203bae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004203bb2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Flush the entry only if we're modifying the current address space.
	assert(pml4e!=NULL);
  8004203bb6:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004203bbb:	75 35                	jne    8004203bf2 <tlb_invalidate+0x4c>
  8004203bbd:	48 b9 5b 83 21 04 80 	movabs $0x800421835b,%rcx
  8004203bc4:	00 00 00 
  8004203bc7:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004203bce:	00 00 00 
  8004203bd1:	be 85 03 00 00       	mov    $0x385,%esi
  8004203bd6:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004203bdd:	00 00 00 
  8004203be0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203be5:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004203bec:	00 00 00 
  8004203bef:	41 ff d0             	callq  *%r8
	if (!curenv || curenv->env_pml4e == pml4e)
  8004203bf2:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004203bf9:	00 00 00 
  8004203bfc:	ff d0                	callq  *%rax
  8004203bfe:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004203c05:	00 00 00 
  8004203c08:	48 98                	cltq   
  8004203c0a:	48 c1 e0 03          	shl    $0x3,%rax
  8004203c0e:	48 89 c1             	mov    %rax,%rcx
  8004203c11:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203c15:	48 01 c8             	add    %rcx,%rax
  8004203c18:	48 01 d0             	add    %rdx,%rax
  8004203c1b:	48 83 c0 08          	add    $0x8,%rax
  8004203c1f:	48 8b 00             	mov    (%rax),%rax
  8004203c22:	48 85 c0             	test   %rax,%rax
  8004203c25:	74 3d                	je     8004203c64 <tlb_invalidate+0xbe>
  8004203c27:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004203c2e:	00 00 00 
  8004203c31:	ff d0                	callq  *%rax
  8004203c33:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004203c3a:	00 00 00 
  8004203c3d:	48 98                	cltq   
  8004203c3f:	48 c1 e0 03          	shl    $0x3,%rax
  8004203c43:	48 89 c1             	mov    %rax,%rcx
  8004203c46:	48 c1 e1 04          	shl    $0x4,%rcx
  8004203c4a:	48 01 c8             	add    %rcx,%rax
  8004203c4d:	48 01 d0             	add    %rdx,%rax
  8004203c50:	48 83 c0 08          	add    $0x8,%rax
  8004203c54:	48 8b 00             	mov    (%rax),%rax
  8004203c57:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203c5e:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004203c62:	75 0f                	jne    8004203c73 <tlb_invalidate+0xcd>
  8004203c64:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203c68:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

    static __inline void 
invlpg(void *addr)
{ 
    __asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
  8004203c6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203c70:	0f 01 38             	invlpg (%rax)
		invlpg(va);
}
  8004203c73:	c9                   	leaveq 
  8004203c74:	c3                   	retq   

0000008004203c75 <mmio_map_region>:
// location.  Return the base of the reserved region.  size does *not*
// have to be multiple of PGSIZE.
//
void *
mmio_map_region(physaddr_t pa, size_t size)
{
  8004203c75:	55                   	push   %rbp
  8004203c76:	48 89 e5             	mov    %rsp,%rbp
  8004203c79:	48 83 ec 30          	sub    $0x30,%rsp
  8004203c7d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004203c81:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	// beginning of the MMIO region.  Because this is static, its
	// value will be preserved between calls to mmio_map_region
	// (just like nextfree in boot_alloc).
	static uintptr_t base = MMIOBASE;
	uintptr_t base_prev;
	base_prev = base;
  8004203c85:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  8004203c8c:	00 00 00 
  8004203c8f:	48 8b 00             	mov    (%rax),%rax
  8004203c92:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	//
	// Hint: The staff solution uses boot_map_region.
	//
	// Your code here:
	/* check if base+size < MMIOLIM,roundpu size, do we need to round down/round up pa???? move base to new size,*/
	if((base+size) >= MMIOLIM){
  8004203c96:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  8004203c9d:	00 00 00 
  8004203ca0:	48 8b 10             	mov    (%rax),%rdx
  8004203ca3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203ca7:	48 01 c2             	add    %rax,%rdx
  8004203caa:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  8004203cb1:	00 00 00 
  8004203cb4:	48 39 c2             	cmp    %rax,%rdx
  8004203cb7:	76 2a                	jbe    8004203ce3 <mmio_map_region+0x6e>
			panic("Out of bound memory");
  8004203cb9:	48 ba 67 83 21 04 80 	movabs $0x8004218367,%rdx
  8004203cc0:	00 00 00 
  8004203cc3:	be ae 03 00 00       	mov    $0x3ae,%esi
  8004203cc8:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004203ccf:	00 00 00 
  8004203cd2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203cd7:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  8004203cde:	00 00 00 
  8004203ce1:	ff d1                	callq  *%rcx
	}
	size = ROUNDUP(size, PGSIZE);
  8004203ce3:	48 c7 45 f0 00 10 00 	movq   $0x1000,-0x10(%rbp)
  8004203cea:	00 
  8004203ceb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203cef:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203cf3:	48 01 d0             	add    %rdx,%rax
  8004203cf6:	48 83 e8 01          	sub    $0x1,%rax
  8004203cfa:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004203cfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203d02:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203d07:	48 f7 75 f0          	divq   -0x10(%rbp)
  8004203d0b:	48 89 d0             	mov    %rdx,%rax
  8004203d0e:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203d12:	48 29 c2             	sub    %rax,%rdx
  8004203d15:	48 89 d0             	mov    %rdx,%rax
  8004203d18:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	boot_map_region(boot_pml4e, base, size,  pa,  PTE_PCD|PTE_PWT|PTE_W|PTE_P);
  8004203d1c:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  8004203d23:	00 00 00 
  8004203d26:	48 8b 30             	mov    (%rax),%rsi
  8004203d29:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004203d30:	00 00 00 
  8004203d33:	48 8b 00             	mov    (%rax),%rax
  8004203d36:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004203d3a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004203d3e:	41 b8 1b 00 00 00    	mov    $0x1b,%r8d
  8004203d44:	48 89 c7             	mov    %rax,%rdi
  8004203d47:	48 b8 5e 38 20 04 80 	movabs $0x800420385e,%rax
  8004203d4e:	00 00 00 
  8004203d51:	ff d0                	callq  *%rax
	base+= size;
  8004203d53:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  8004203d5a:	00 00 00 
  8004203d5d:	48 8b 10             	mov    (%rax),%rdx
  8004203d60:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203d64:	48 01 c2             	add    %rax,%rdx
  8004203d67:	48 b8 c8 b5 22 04 80 	movabs $0x800422b5c8,%rax
  8004203d6e:	00 00 00 
  8004203d71:	48 89 10             	mov    %rdx,(%rax)
	return (void*)base_prev;
  8004203d74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	//panic("mmio_map_region not implemented");

}
  8004203d78:	c9                   	leaveq 
  8004203d79:	c3                   	retq   

0000008004203d7a <user_mem_check>:
// Returns 0 if the user program can access this range of addresses,
// and -E_FAULT otherwise.
//
int
user_mem_check(struct Env *env, const void *va, size_t len, int perm)
{
  8004203d7a:	55                   	push   %rbp
  8004203d7b:	48 89 e5             	mov    %rsp,%rbp
  8004203d7e:	48 83 ec 50          	sub    $0x50,%rsp
  8004203d82:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004203d86:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004203d8a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004203d8e:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
	// LAB 3: Your code here.
	struct PageInfo * page;
	pte_t *pte_store;
	void * vaT = (void*)va;
  8004203d91:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203d95:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
  8004203d99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203d9d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004203da1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004203da5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004203dab:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	vaE = ROUNDUP(vaT + len, PGSIZE);
  8004203daf:	48 c7 45 e8 00 10 00 	movq   $0x1000,-0x18(%rbp)
  8004203db6:	00 
  8004203db7:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004203dbb:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203dbf:	48 01 d0             	add    %rdx,%rax
  8004203dc2:	48 89 c2             	mov    %rax,%rdx
  8004203dc5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004203dc9:	48 01 d0             	add    %rdx,%rax
  8004203dcc:	48 83 e8 01          	sub    $0x1,%rax
  8004203dd0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004203dd4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004203dd8:	ba 00 00 00 00       	mov    $0x0,%edx
  8004203ddd:	48 f7 75 e8          	divq   -0x18(%rbp)
  8004203de1:	48 89 d0             	mov    %rdx,%rax
  8004203de4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004203de8:	48 29 c2             	sub    %rax,%rdx
  8004203deb:	48 89 d0             	mov    %rdx,%rax
  8004203dee:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203df2:	e9 8c 00 00 00       	jmpq   8004203e83 <user_mem_check+0x109>
	{
		if((uintptr_t)vaT >= ULIM || !page_lookup(env->env_pml4e, vaT, &pte_store) || !pte_store || !(*pte_store & perm))
  8004203df7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203dfb:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004203e02:	00 00 00 
  8004203e05:	48 39 c2             	cmp    %rax,%rdx
  8004203e08:	77 47                	ja     8004203e51 <user_mem_check+0xd7>
  8004203e0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004203e0e:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004203e15:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  8004203e19:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004203e1d:	48 89 ce             	mov    %rcx,%rsi
  8004203e20:	48 89 c7             	mov    %rax,%rdi
  8004203e23:	48 b8 7e 3a 20 04 80 	movabs $0x8004203a7e,%rax
  8004203e2a:	00 00 00 
  8004203e2d:	ff d0                	callq  *%rax
  8004203e2f:	48 85 c0             	test   %rax,%rax
  8004203e32:	74 1d                	je     8004203e51 <user_mem_check+0xd7>
  8004203e34:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203e38:	48 85 c0             	test   %rax,%rax
  8004203e3b:	74 14                	je     8004203e51 <user_mem_check+0xd7>
  8004203e3d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004203e41:	48 8b 10             	mov    (%rax),%rdx
  8004203e44:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004203e47:	48 98                	cltq   
  8004203e49:	48 21 d0             	and    %rdx,%rax
  8004203e4c:	48 85 c0             	test   %rax,%rax
  8004203e4f:	75 2a                	jne    8004203e7b <user_mem_check+0x101>
		{
			if(vaT < va){
  8004203e51:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e55:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004203e59:	73 08                	jae    8004203e63 <user_mem_check+0xe9>
				vaT = (void*)va;
  8004203e5b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004203e5f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			}
			user_mem_check_addr = (uintptr_t)vaT;
  8004203e63:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203e67:	48 b8 40 82 37 04 80 	movabs $0x8004378240,%rax
  8004203e6e:	00 00 00 
  8004203e71:	48 89 10             	mov    %rdx,(%rax)
			return -E_FAULT;		
  8004203e74:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
  8004203e79:	eb 1b                	jmp    8004203e96 <user_mem_check+0x11c>
	pte_t *pte_store;
	void * vaT = (void*)va;
	void *vaE;
	vaT = ROUNDDOWN(vaT,PGSIZE);
	vaE = ROUNDUP(vaT + len, PGSIZE);
	for(;vaT < vaE; vaT = vaT + PGSIZE)
  8004203e7b:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004203e82:	00 
  8004203e83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203e87:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004203e8b:	0f 82 66 ff ff ff    	jb     8004203df7 <user_mem_check+0x7d>
			}
			user_mem_check_addr = (uintptr_t)vaT;
			return -E_FAULT;		
		}
	}
	return 0;
  8004203e91:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004203e96:	c9                   	leaveq 
  8004203e97:	c3                   	retq   

0000008004203e98 <user_mem_assert>:
// If it cannot, 'env' is destroyed and, if env is the current
// environment, this function will not return.
//
void
user_mem_assert(struct Env *env, const void *va, size_t len, int perm)
{
  8004203e98:	55                   	push   %rbp
  8004203e99:	48 89 e5             	mov    %rsp,%rbp
  8004203e9c:	48 83 ec 20          	sub    $0x20,%rsp
  8004203ea0:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004203ea4:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  8004203ea8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004203eac:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
	if (user_mem_check(env, va, len, perm | PTE_U) < 0) {
  8004203eaf:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203eb2:	83 c8 04             	or     $0x4,%eax
  8004203eb5:	89 c1                	mov    %eax,%ecx
  8004203eb7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004203ebb:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  8004203ebf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ec3:	48 89 c7             	mov    %rax,%rdi
  8004203ec6:	48 b8 7a 3d 20 04 80 	movabs $0x8004203d7a,%rax
  8004203ecd:	00 00 00 
  8004203ed0:	ff d0                	callq  *%rax
  8004203ed2:	85 c0                	test   %eax,%eax
  8004203ed4:	79 47                	jns    8004203f1d <user_mem_assert+0x85>
		cprintf("[%08x] user_mem_check assertion failure for "
  8004203ed6:	48 b8 40 82 37 04 80 	movabs $0x8004378240,%rax
  8004203edd:	00 00 00 
  8004203ee0:	48 8b 10             	mov    (%rax),%rdx
  8004203ee3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203ee7:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004203eed:	89 c6                	mov    %eax,%esi
  8004203eef:	48 bf 80 83 21 04 80 	movabs $0x8004218380,%rdi
  8004203ef6:	00 00 00 
  8004203ef9:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203efe:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  8004203f05:	00 00 00 
  8004203f08:	ff d1                	callq  *%rcx
			"va %08x\n", env->env_id, user_mem_check_addr);
		env_destroy(env);	// may not return
  8004203f0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203f0e:	48 89 c7             	mov    %rax,%rdi
  8004203f11:	48 b8 f1 86 20 04 80 	movabs $0x80042086f1,%rax
  8004203f18:	00 00 00 
  8004203f1b:	ff d0                	callq  *%rax
	}
}
  8004203f1d:	c9                   	leaveq 
  8004203f1e:	c3                   	retq   

0000008004203f1f <check_page_free_list>:
// Check that the pages on the page_free_list are reasonable.
//

static void
check_page_free_list(bool only_low_memory)
{
  8004203f1f:	55                   	push   %rbp
  8004203f20:	48 89 e5             	mov    %rsp,%rbp
  8004203f23:	48 83 ec 60          	sub    $0x60,%rsp
  8004203f27:	89 f8                	mov    %edi,%eax
  8004203f29:	88 45 ac             	mov    %al,-0x54(%rbp)
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
  8004203f2c:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203f30:	74 07                	je     8004203f39 <check_page_free_list+0x1a>
  8004203f32:	b8 01 00 00 00       	mov    $0x1,%eax
  8004203f37:	eb 05                	jmp    8004203f3e <check_page_free_list+0x1f>
  8004203f39:	b8 00 02 00 00       	mov    $0x200,%eax
  8004203f3e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	uint64_t nfree_basemem = 0, nfree_extmem = 0;
  8004203f41:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004203f48:	00 
  8004203f49:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004203f50:	00 
	char *first_free_page;

	if (!page_free_list)
  8004203f51:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004203f58:	00 00 00 
  8004203f5b:	48 8b 00             	mov    (%rax),%rax
  8004203f5e:	48 85 c0             	test   %rax,%rax
  8004203f61:	75 2a                	jne    8004203f8d <check_page_free_list+0x6e>
		panic("'page_free_list' is a null pointer!");
  8004203f63:	48 ba b8 83 21 04 80 	movabs $0x80042183b8,%rdx
  8004203f6a:	00 00 00 
  8004203f6d:	be 07 04 00 00       	mov    $0x407,%esi
  8004203f72:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004203f79:	00 00 00 
  8004203f7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004203f81:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  8004203f88:	00 00 00 
  8004203f8b:	ff d1                	callq  *%rcx

	if (only_low_memory) {
  8004203f8d:	80 7d ac 00          	cmpb   $0x0,-0x54(%rbp)
  8004203f91:	0f 84 a9 00 00 00    	je     8004204040 <check_page_free_list+0x121>
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
  8004203f97:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  8004203f9b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  8004203f9f:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
  8004203fa3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004203fa7:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004203fae:	00 00 00 
  8004203fb1:	48 8b 00             	mov    (%rax),%rax
  8004203fb4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004203fb8:	eb 58                	jmp    8004204012 <check_page_free_list+0xf3>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
  8004203fba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004203fbe:	48 89 c7             	mov    %rax,%rdi
  8004203fc1:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004203fc8:	00 00 00 
  8004203fcb:	ff d0                	callq  *%rax
  8004203fcd:	48 c1 e8 15          	shr    $0x15,%rax
  8004203fd1:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004203fd6:	48 89 c2             	mov    %rax,%rdx
  8004203fd9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004203fdc:	48 39 c2             	cmp    %rax,%rdx
  8004203fdf:	0f 93 c0             	setae  %al
  8004203fe2:	0f b6 c0             	movzbl %al,%eax
  8004203fe5:	89 45 e0             	mov    %eax,-0x20(%rbp)
			*tp[pagetype] = pp;
  8004203fe8:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004203feb:	48 98                	cltq   
  8004203fed:	48 8b 44 c5 b0       	mov    -0x50(%rbp,%rax,8),%rax
  8004203ff2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203ff6:	48 89 10             	mov    %rdx,(%rax)
			tp[pagetype] = &pp->pp_link;
  8004203ff9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004203ffd:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004204000:	48 98                	cltq   
  8004204002:	48 89 54 c5 b0       	mov    %rdx,-0x50(%rbp,%rax,8)
	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
		for (pp = page_free_list; pp; pp = pp->pp_link) {
  8004204007:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420400b:	48 8b 00             	mov    (%rax),%rax
  800420400e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204012:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204017:	75 a1                	jne    8004203fba <check_page_free_list+0x9b>
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
  8004204019:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420401d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		*tp[0] = pp2;
  8004204024:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004204028:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420402c:	48 89 10             	mov    %rdx,(%rax)
		page_free_list = pp1;
  800420402f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204033:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  800420403a:	00 00 00 
  800420403d:	48 89 10             	mov    %rdx,(%rax)
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  8004204040:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004204047:	00 00 00 
  800420404a:	48 8b 00             	mov    (%rax),%rax
  800420404d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204051:	eb 5e                	jmp    80042040b1 <check_page_free_list+0x192>
		if (PDX(page2pa(pp)) < pdx_limit)
  8004204053:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204057:	48 89 c7             	mov    %rax,%rdi
  800420405a:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004204061:	00 00 00 
  8004204064:	ff d0                	callq  *%rax
  8004204066:	48 c1 e8 15          	shr    $0x15,%rax
  800420406a:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420406f:	48 89 c2             	mov    %rax,%rdx
  8004204072:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004204075:	48 39 c2             	cmp    %rax,%rdx
  8004204078:	73 2c                	jae    80042040a6 <check_page_free_list+0x187>
			memset(page2kva(pp), 0x97, 128);
  800420407a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420407e:	48 89 c7             	mov    %rax,%rdi
  8004204081:	48 b8 f0 1d 20 04 80 	movabs $0x8004201df0,%rax
  8004204088:	00 00 00 
  800420408b:	ff d0                	callq  *%rax
  800420408d:	ba 80 00 00 00       	mov    $0x80,%edx
  8004204092:	be 97 00 00 00       	mov    $0x97,%esi
  8004204097:	48 89 c7             	mov    %rax,%rdi
  800420409a:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  80042040a1:	00 00 00 
  80042040a4:	ff d0                	callq  *%rax
		page_free_list = pp1;
	}

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
	for (pp = page_free_list; pp; pp = pp->pp_link)
  80042040a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042040aa:	48 8b 00             	mov    (%rax),%rax
  80042040ad:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042040b1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042040b6:	75 9b                	jne    8004204053 <check_page_free_list+0x134>
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
  80042040b8:	bf 00 00 00 00       	mov    $0x0,%edi
  80042040bd:	48 b8 19 27 20 04 80 	movabs $0x8004202719,%rax
  80042040c4:	00 00 00 
  80042040c7:	ff d0                	callq  *%rax
  80042040c9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042040cd:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  80042040d4:	00 00 00 
  80042040d7:	48 8b 00             	mov    (%rax),%rax
  80042040da:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042040de:	e9 20 03 00 00       	jmpq   8004204403 <check_page_free_list+0x4e4>
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
  80042040e3:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  80042040ea:	00 00 00 
  80042040ed:	48 8b 00             	mov    (%rax),%rax
  80042040f0:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042040f4:	73 35                	jae    800420412b <check_page_free_list+0x20c>
  80042040f6:	48 b9 dc 83 21 04 80 	movabs $0x80042183dc,%rcx
  80042040fd:	00 00 00 
  8004204100:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204107:	00 00 00 
  800420410a:	be 21 04 00 00       	mov    $0x421,%esi
  800420410f:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204116:	00 00 00 
  8004204119:	b8 00 00 00 00       	mov    $0x0,%eax
  800420411e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204125:	00 00 00 
  8004204128:	41 ff d0             	callq  *%r8
		assert(pp < pages + npages);
  800420412b:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004204132:	00 00 00 
  8004204135:	48 8b 10             	mov    (%rax),%rdx
  8004204138:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  800420413f:	00 00 00 
  8004204142:	48 8b 00             	mov    (%rax),%rax
  8004204145:	48 c1 e0 04          	shl    $0x4,%rax
  8004204149:	48 01 d0             	add    %rdx,%rax
  800420414c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204150:	77 35                	ja     8004204187 <check_page_free_list+0x268>
  8004204152:	48 b9 e8 83 21 04 80 	movabs $0x80042183e8,%rcx
  8004204159:	00 00 00 
  800420415c:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204163:	00 00 00 
  8004204166:	be 22 04 00 00       	mov    $0x422,%esi
  800420416b:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204172:	00 00 00 
  8004204175:	b8 00 00 00 00       	mov    $0x0,%eax
  800420417a:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204181:	00 00 00 
  8004204184:	41 ff d0             	callq  *%r8
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);
  8004204187:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420418b:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004204192:	00 00 00 
  8004204195:	48 8b 00             	mov    (%rax),%rax
  8004204198:	48 29 c2             	sub    %rax,%rdx
  800420419b:	48 89 d0             	mov    %rdx,%rax
  800420419e:	83 e0 0f             	and    $0xf,%eax
  80042041a1:	48 85 c0             	test   %rax,%rax
  80042041a4:	74 35                	je     80042041db <check_page_free_list+0x2bc>
  80042041a6:	48 b9 00 84 21 04 80 	movabs $0x8004218400,%rcx
  80042041ad:	00 00 00 
  80042041b0:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042041b7:	00 00 00 
  80042041ba:	be 23 04 00 00       	mov    $0x423,%esi
  80042041bf:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042041c6:	00 00 00 
  80042041c9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042041ce:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042041d5:	00 00 00 
  80042041d8:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
  80042041db:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042041df:	48 89 c7             	mov    %rax,%rdi
  80042041e2:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  80042041e9:	00 00 00 
  80042041ec:	ff d0                	callq  *%rax
  80042041ee:	48 85 c0             	test   %rax,%rax
  80042041f1:	75 35                	jne    8004204228 <check_page_free_list+0x309>
  80042041f3:	48 b9 32 84 21 04 80 	movabs $0x8004218432,%rcx
  80042041fa:	00 00 00 
  80042041fd:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204204:	00 00 00 
  8004204207:	be 26 04 00 00       	mov    $0x426,%esi
  800420420c:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204213:	00 00 00 
  8004204216:	b8 00 00 00 00       	mov    $0x0,%eax
  800420421b:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204222:	00 00 00 
  8004204225:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != IOPHYSMEM);
  8004204228:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420422c:	48 89 c7             	mov    %rax,%rdi
  800420422f:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004204236:	00 00 00 
  8004204239:	ff d0                	callq  *%rax
  800420423b:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  8004204241:	75 35                	jne    8004204278 <check_page_free_list+0x359>
  8004204243:	48 b9 43 84 21 04 80 	movabs $0x8004218443,%rcx
  800420424a:	00 00 00 
  800420424d:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204254:	00 00 00 
  8004204257:	be 27 04 00 00       	mov    $0x427,%esi
  800420425c:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204263:	00 00 00 
  8004204266:	b8 00 00 00 00       	mov    $0x0,%eax
  800420426b:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204272:	00 00 00 
  8004204275:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
  8004204278:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420427c:	48 89 c7             	mov    %rax,%rdi
  800420427f:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004204286:	00 00 00 
  8004204289:	ff d0                	callq  *%rax
  800420428b:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204291:	75 35                	jne    80042042c8 <check_page_free_list+0x3a9>
  8004204293:	48 b9 60 84 21 04 80 	movabs $0x8004218460,%rcx
  800420429a:	00 00 00 
  800420429d:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042042a4:	00 00 00 
  80042042a7:	be 28 04 00 00       	mov    $0x428,%esi
  80042042ac:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042042b3:	00 00 00 
  80042042b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042042bb:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042042c2:	00 00 00 
  80042042c5:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) != EXTPHYSMEM);
  80042042c8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042042cc:	48 89 c7             	mov    %rax,%rdi
  80042042cf:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  80042042d6:	00 00 00 
  80042042d9:	ff d0                	callq  *%rax
  80042042db:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  80042042e1:	75 35                	jne    8004204318 <check_page_free_list+0x3f9>
  80042042e3:	48 b9 83 84 21 04 80 	movabs $0x8004218483,%rcx
  80042042ea:	00 00 00 
  80042042ed:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042042f4:	00 00 00 
  80042042f7:	be 29 04 00 00       	mov    $0x429,%esi
  80042042fc:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204303:	00 00 00 
  8004204306:	b8 00 00 00 00       	mov    $0x0,%eax
  800420430b:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204312:	00 00 00 
  8004204315:	41 ff d0             	callq  *%r8
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);
  8004204318:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420431c:	48 89 c7             	mov    %rax,%rdi
  800420431f:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004204326:	00 00 00 
  8004204329:	ff d0                	callq  *%rax
  800420432b:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  8004204331:	76 4e                	jbe    8004204381 <check_page_free_list+0x462>
  8004204333:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204337:	48 89 c7             	mov    %rax,%rdi
  800420433a:	48 b8 f0 1d 20 04 80 	movabs $0x8004201df0,%rax
  8004204341:	00 00 00 
  8004204344:	ff d0                	callq  *%rax
  8004204346:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420434a:	73 35                	jae    8004204381 <check_page_free_list+0x462>
  800420434c:	48 b9 a0 84 21 04 80 	movabs $0x80042184a0,%rcx
  8004204353:	00 00 00 
  8004204356:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420435d:	00 00 00 
  8004204360:	be 2a 04 00 00       	mov    $0x42a,%esi
  8004204365:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420436c:	00 00 00 
  800420436f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204374:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420437b:	00 00 00 
  800420437e:	41 ff d0             	callq  *%r8
		// (new test for lab 4)
		assert(page2pa(pp) != MPENTRY_PADDR);
  8004204381:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204385:	48 89 c7             	mov    %rax,%rdi
  8004204388:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  800420438f:	00 00 00 
  8004204392:	ff d0                	callq  *%rax
  8004204394:	48 3d 00 70 00 00    	cmp    $0x7000,%rax
  800420439a:	75 35                	jne    80042043d1 <check_page_free_list+0x4b2>
  800420439c:	48 b9 e5 84 21 04 80 	movabs $0x80042184e5,%rcx
  80042043a3:	00 00 00 
  80042043a6:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042043ad:	00 00 00 
  80042043b0:	be 2c 04 00 00       	mov    $0x42c,%esi
  80042043b5:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042043bc:	00 00 00 
  80042043bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042043c4:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042043cb:	00 00 00 
  80042043ce:	41 ff d0             	callq  *%r8

		if (page2pa(pp) < EXTPHYSMEM)
  80042043d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042043d5:	48 89 c7             	mov    %rax,%rdi
  80042043d8:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  80042043df:	00 00 00 
  80042043e2:	ff d0                	callq  *%rax
  80042043e4:	48 3d ff ff 0f 00    	cmp    $0xfffff,%rax
  80042043ea:	77 07                	ja     80042043f3 <check_page_free_list+0x4d4>
			++nfree_basemem;
  80042043ec:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042043f1:	eb 05                	jmp    80042043f8 <check_page_free_list+0x4d9>
		else
			++nfree_extmem;
  80042043f3:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
			memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
	for (pp = page_free_list; pp; pp = pp->pp_link) {
  80042043f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042043fc:	48 8b 00             	mov    (%rax),%rax
  80042043ff:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204403:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204408:	0f 85 d5 fc ff ff    	jne    80042040e3 <check_page_free_list+0x1c4>
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_extmem > 0);
  800420440e:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204413:	75 35                	jne    800420444a <check_page_free_list+0x52b>
  8004204415:	48 b9 02 85 21 04 80 	movabs $0x8004218502,%rcx
  800420441c:	00 00 00 
  800420441f:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204426:	00 00 00 
  8004204429:	be 34 04 00 00       	mov    $0x434,%esi
  800420442e:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204435:	00 00 00 
  8004204438:	b8 00 00 00 00       	mov    $0x0,%eax
  800420443d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204444:	00 00 00 
  8004204447:	41 ff d0             	callq  *%r8
}
  800420444a:	c9                   	leaveq 
  800420444b:	c3                   	retq   

000000800420444c <check_page_alloc>:
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
  800420444c:	55                   	push   %rbp
  800420444d:	48 89 e5             	mov    %rsp,%rbp
  8004204450:	48 83 ec 40          	sub    $0x40,%rsp
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  8004204454:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  800420445b:	00 00 00 
  800420445e:	48 8b 00             	mov    (%rax),%rax
  8004204461:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204465:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  800420446c:	eb 37                	jmp    80042044a5 <check_page_alloc+0x59>
		memset(page2kva(pp0), 0x97, PGSIZE);
  800420446e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204472:	48 89 c7             	mov    %rax,%rdi
  8004204475:	48 b8 f0 1d 20 04 80 	movabs $0x8004201df0,%rax
  800420447c:	00 00 00 
  800420447f:	ff d0                	callq  *%rax
  8004204481:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204486:	be 97 00 00 00       	mov    $0x97,%esi
  800420448b:	48 89 c7             	mov    %rax,%rdi
  800420448e:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004204495:	00 00 00 
  8004204498:	ff d0                	callq  *%rax
	int i;

	// if there's a page that shouldn't be on
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  800420449a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420449e:	48 8b 00             	mov    (%rax),%rax
  80042044a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042044a5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042044aa:	75 c2                	jne    800420446e <check_page_alloc+0x22>
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042044ac:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  80042044b3:	00 00 00 
  80042044b6:	48 8b 00             	mov    (%rax),%rax
  80042044b9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042044bd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
  80042044c4:	e9 ec 01 00 00       	jmpq   80042046b5 <check_page_alloc+0x269>
		// check that we didn't corrupt the free list itself
		assert(pp0 >= pages);
  80042044c9:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  80042044d0:	00 00 00 
  80042044d3:	48 8b 00             	mov    (%rax),%rax
  80042044d6:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  80042044da:	73 35                	jae    8004204511 <check_page_alloc+0xc5>
  80042044dc:	48 b9 13 85 21 04 80 	movabs $0x8004218513,%rcx
  80042044e3:	00 00 00 
  80042044e6:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042044ed:	00 00 00 
  80042044f0:	be 4d 04 00 00       	mov    $0x44d,%esi
  80042044f5:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042044fc:	00 00 00 
  80042044ff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204504:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420450b:	00 00 00 
  800420450e:	41 ff d0             	callq  *%r8
		assert(pp0 < pages + npages);
  8004204511:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004204518:	00 00 00 
  800420451b:	48 8b 10             	mov    (%rax),%rdx
  800420451e:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004204525:	00 00 00 
  8004204528:	48 8b 00             	mov    (%rax),%rax
  800420452b:	48 c1 e0 04          	shl    $0x4,%rax
  800420452f:	48 01 d0             	add    %rdx,%rax
  8004204532:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204536:	77 35                	ja     800420456d <check_page_alloc+0x121>
  8004204538:	48 b9 20 85 21 04 80 	movabs $0x8004218520,%rcx
  800420453f:	00 00 00 
  8004204542:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204549:	00 00 00 
  800420454c:	be 4e 04 00 00       	mov    $0x44e,%esi
  8004204551:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204558:	00 00 00 
  800420455b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204560:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204567:	00 00 00 
  800420456a:	41 ff d0             	callq  *%r8

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp0) != 0);
  800420456d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204571:	48 89 c7             	mov    %rax,%rdi
  8004204574:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  800420457b:	00 00 00 
  800420457e:	ff d0                	callq  *%rax
  8004204580:	48 85 c0             	test   %rax,%rax
  8004204583:	75 35                	jne    80042045ba <check_page_alloc+0x16e>
  8004204585:	48 b9 35 85 21 04 80 	movabs $0x8004218535,%rcx
  800420458c:	00 00 00 
  800420458f:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204596:	00 00 00 
  8004204599:	be 51 04 00 00       	mov    $0x451,%esi
  800420459e:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042045a5:	00 00 00 
  80042045a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045ad:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042045b4:	00 00 00 
  80042045b7:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != IOPHYSMEM);
  80042045ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042045be:	48 89 c7             	mov    %rax,%rdi
  80042045c1:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  80042045c8:	00 00 00 
  80042045cb:	ff d0                	callq  *%rax
  80042045cd:	48 3d 00 00 0a 00    	cmp    $0xa0000,%rax
  80042045d3:	75 35                	jne    800420460a <check_page_alloc+0x1be>
  80042045d5:	48 b9 47 85 21 04 80 	movabs $0x8004218547,%rcx
  80042045dc:	00 00 00 
  80042045df:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042045e6:	00 00 00 
  80042045e9:	be 52 04 00 00       	mov    $0x452,%esi
  80042045ee:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042045f5:	00 00 00 
  80042045f8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042045fd:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204604:	00 00 00 
  8004204607:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
  800420460a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420460e:	48 89 c7             	mov    %rax,%rdi
  8004204611:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004204618:	00 00 00 
  800420461b:	ff d0                	callq  *%rax
  800420461d:	48 3d 00 f0 0f 00    	cmp    $0xff000,%rax
  8004204623:	75 35                	jne    800420465a <check_page_alloc+0x20e>
  8004204625:	48 b9 68 85 21 04 80 	movabs $0x8004218568,%rcx
  800420462c:	00 00 00 
  800420462f:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204636:	00 00 00 
  8004204639:	be 53 04 00 00       	mov    $0x453,%esi
  800420463e:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204645:	00 00 00 
  8004204648:	b8 00 00 00 00       	mov    $0x0,%eax
  800420464d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204654:	00 00 00 
  8004204657:	41 ff d0             	callq  *%r8
		assert(page2pa(pp0) != EXTPHYSMEM);
  800420465a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420465e:	48 89 c7             	mov    %rax,%rdi
  8004204661:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004204668:	00 00 00 
  800420466b:	ff d0                	callq  *%rax
  800420466d:	48 3d 00 00 10 00    	cmp    $0x100000,%rax
  8004204673:	75 35                	jne    80042046aa <check_page_alloc+0x25e>
  8004204675:	48 b9 8c 85 21 04 80 	movabs $0x800421858c,%rcx
  800420467c:	00 00 00 
  800420467f:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204686:	00 00 00 
  8004204689:	be 54 04 00 00       	mov    $0x454,%esi
  800420468e:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204695:	00 00 00 
  8004204698:	b8 00 00 00 00       	mov    $0x0,%eax
  800420469d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042046a4:	00 00 00 
  80042046a7:	41 ff d0             	callq  *%r8
	// the free list, try to make sure it
	// eventually causes trouble.
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
		memset(page2kva(pp0), 0x97, PGSIZE);
	}
	for (pp0 = page_free_list, nfree = 0; pp0; pp0 = pp0->pp_link) {
  80042046aa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042046ae:	48 8b 00             	mov    (%rax),%rax
  80042046b1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042046b5:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042046ba:	0f 85 09 fe ff ff    	jne    80042044c9 <check_page_alloc+0x7d>
		assert(page2pa(pp0) != IOPHYSMEM);
		assert(page2pa(pp0) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp0) != EXTPHYSMEM);
	}
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
  80042046c0:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  80042046c7:	00 
  80042046c8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042046cc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042046d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042046d4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  80042046d8:	bf 00 00 00 00       	mov    $0x0,%edi
  80042046dd:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  80042046e4:	00 00 00 
  80042046e7:	ff d0                	callq  *%rax
  80042046e9:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042046ed:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042046f2:	75 35                	jne    8004204729 <check_page_alloc+0x2dd>
  80042046f4:	48 b9 a7 85 21 04 80 	movabs $0x80042185a7,%rcx
  80042046fb:	00 00 00 
  80042046fe:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204705:	00 00 00 
  8004204708:	be 58 04 00 00       	mov    $0x458,%esi
  800420470d:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204714:	00 00 00 
  8004204717:	b8 00 00 00 00       	mov    $0x0,%eax
  800420471c:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204723:	00 00 00 
  8004204726:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204729:	bf 00 00 00 00       	mov    $0x0,%edi
  800420472e:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004204735:	00 00 00 
  8004204738:	ff d0                	callq  *%rax
  800420473a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420473e:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204743:	75 35                	jne    800420477a <check_page_alloc+0x32e>
  8004204745:	48 b9 bd 85 21 04 80 	movabs $0x80042185bd,%rcx
  800420474c:	00 00 00 
  800420474f:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204756:	00 00 00 
  8004204759:	be 59 04 00 00       	mov    $0x459,%esi
  800420475e:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204765:	00 00 00 
  8004204768:	b8 00 00 00 00       	mov    $0x0,%eax
  800420476d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204774:	00 00 00 
  8004204777:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  800420477a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420477f:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004204786:	00 00 00 
  8004204789:	ff d0                	callq  *%rax
  800420478b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420478f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204794:	75 35                	jne    80042047cb <check_page_alloc+0x37f>
  8004204796:	48 b9 d3 85 21 04 80 	movabs $0x80042185d3,%rcx
  800420479d:	00 00 00 
  80042047a0:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042047a7:	00 00 00 
  80042047aa:	be 5a 04 00 00       	mov    $0x45a,%esi
  80042047af:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042047b6:	00 00 00 
  80042047b9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047be:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042047c5:	00 00 00 
  80042047c8:	41 ff d0             	callq  *%r8
	assert(pp0);
  80042047cb:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042047d0:	75 35                	jne    8004204807 <check_page_alloc+0x3bb>
  80042047d2:	48 b9 e9 85 21 04 80 	movabs $0x80042185e9,%rcx
  80042047d9:	00 00 00 
  80042047dc:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042047e3:	00 00 00 
  80042047e6:	be 5b 04 00 00       	mov    $0x45b,%esi
  80042047eb:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042047f2:	00 00 00 
  80042047f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042047fa:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204801:	00 00 00 
  8004204804:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204807:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420480c:	74 0a                	je     8004204818 <check_page_alloc+0x3cc>
  800420480e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204812:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204816:	75 35                	jne    800420484d <check_page_alloc+0x401>
  8004204818:	48 b9 ed 85 21 04 80 	movabs $0x80042185ed,%rcx
  800420481f:	00 00 00 
  8004204822:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204829:	00 00 00 
  800420482c:	be 5c 04 00 00       	mov    $0x45c,%esi
  8004204831:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204838:	00 00 00 
  800420483b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204840:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204847:	00 00 00 
  800420484a:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  800420484d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204852:	74 14                	je     8004204868 <check_page_alloc+0x41c>
  8004204854:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204858:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800420485c:	74 0a                	je     8004204868 <check_page_alloc+0x41c>
  800420485e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204862:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204866:	75 35                	jne    800420489d <check_page_alloc+0x451>
  8004204868:	48 b9 00 86 21 04 80 	movabs $0x8004218600,%rcx
  800420486f:	00 00 00 
  8004204872:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204879:	00 00 00 
  800420487c:	be 5d 04 00 00       	mov    $0x45d,%esi
  8004204881:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204888:	00 00 00 
  800420488b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204890:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204897:	00 00 00 
  800420489a:	41 ff d0             	callq  *%r8
	assert(page2pa(pp0) < npages*PGSIZE);
  800420489d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042048a1:	48 89 c7             	mov    %rax,%rdi
  80042048a4:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  80042048ab:	00 00 00 
  80042048ae:	ff d0                	callq  *%rax
  80042048b0:	48 ba 90 97 37 04 80 	movabs $0x8004379790,%rdx
  80042048b7:	00 00 00 
  80042048ba:	48 8b 12             	mov    (%rdx),%rdx
  80042048bd:	48 c1 e2 0c          	shl    $0xc,%rdx
  80042048c1:	48 39 d0             	cmp    %rdx,%rax
  80042048c4:	72 35                	jb     80042048fb <check_page_alloc+0x4af>
  80042048c6:	48 b9 20 86 21 04 80 	movabs $0x8004218620,%rcx
  80042048cd:	00 00 00 
  80042048d0:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042048d7:	00 00 00 
  80042048da:	be 5e 04 00 00       	mov    $0x45e,%esi
  80042048df:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042048e6:	00 00 00 
  80042048e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042048ee:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042048f5:	00 00 00 
  80042048f8:	41 ff d0             	callq  *%r8
	assert(page2pa(pp1) < npages*PGSIZE);
  80042048fb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042048ff:	48 89 c7             	mov    %rax,%rdi
  8004204902:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004204909:	00 00 00 
  800420490c:	ff d0                	callq  *%rax
  800420490e:	48 ba 90 97 37 04 80 	movabs $0x8004379790,%rdx
  8004204915:	00 00 00 
  8004204918:	48 8b 12             	mov    (%rdx),%rdx
  800420491b:	48 c1 e2 0c          	shl    $0xc,%rdx
  800420491f:	48 39 d0             	cmp    %rdx,%rax
  8004204922:	72 35                	jb     8004204959 <check_page_alloc+0x50d>
  8004204924:	48 b9 3d 86 21 04 80 	movabs $0x800421863d,%rcx
  800420492b:	00 00 00 
  800420492e:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204935:	00 00 00 
  8004204938:	be 5f 04 00 00       	mov    $0x45f,%esi
  800420493d:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204944:	00 00 00 
  8004204947:	b8 00 00 00 00       	mov    $0x0,%eax
  800420494c:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204953:	00 00 00 
  8004204956:	41 ff d0             	callq  *%r8
	assert(page2pa(pp2) < npages*PGSIZE);
  8004204959:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420495d:	48 89 c7             	mov    %rax,%rdi
  8004204960:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004204967:	00 00 00 
  800420496a:	ff d0                	callq  *%rax
  800420496c:	48 ba 90 97 37 04 80 	movabs $0x8004379790,%rdx
  8004204973:	00 00 00 
  8004204976:	48 8b 12             	mov    (%rdx),%rdx
  8004204979:	48 c1 e2 0c          	shl    $0xc,%rdx
  800420497d:	48 39 d0             	cmp    %rdx,%rax
  8004204980:	72 35                	jb     80042049b7 <check_page_alloc+0x56b>
  8004204982:	48 b9 5a 86 21 04 80 	movabs $0x800421865a,%rcx
  8004204989:	00 00 00 
  800420498c:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204993:	00 00 00 
  8004204996:	be 60 04 00 00       	mov    $0x460,%esi
  800420499b:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042049a2:	00 00 00 
  80042049a5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042049aa:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042049b1:	00 00 00 
  80042049b4:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  80042049b7:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  80042049be:	00 00 00 
  80042049c1:	48 8b 00             	mov    (%rax),%rax
  80042049c4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	page_free_list = 0;
  80042049c8:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  80042049cf:	00 00 00 
  80042049d2:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  80042049d9:	bf 00 00 00 00       	mov    $0x0,%edi
  80042049de:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  80042049e5:	00 00 00 
  80042049e8:	ff d0                	callq  *%rax
  80042049ea:	48 85 c0             	test   %rax,%rax
  80042049ed:	74 35                	je     8004204a24 <check_page_alloc+0x5d8>
  80042049ef:	48 b9 77 86 21 04 80 	movabs $0x8004218677,%rcx
  80042049f6:	00 00 00 
  80042049f9:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204a00:	00 00 00 
  8004204a03:	be 67 04 00 00       	mov    $0x467,%esi
  8004204a08:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204a0f:	00 00 00 
  8004204a12:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204a17:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204a1e:	00 00 00 
  8004204a21:	41 ff d0             	callq  *%r8

	// free and re-allocate?
	page_free(pp0);
  8004204a24:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204a28:	48 89 c7             	mov    %rax,%rdi
  8004204a2b:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004204a32:	00 00 00 
  8004204a35:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204a37:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a3b:	48 89 c7             	mov    %rax,%rdi
  8004204a3e:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004204a45:	00 00 00 
  8004204a48:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204a4a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a4e:	48 89 c7             	mov    %rax,%rdi
  8004204a51:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004204a58:	00 00 00 
  8004204a5b:	ff d0                	callq  *%rax
	pp0 = pp1 = pp2 = 0;
  8004204a5d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004204a64:	00 
  8004204a65:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204a69:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204a6d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204a71:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert((pp0 = page_alloc(0)));
  8004204a75:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204a7a:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004204a81:	00 00 00 
  8004204a84:	ff d0                	callq  *%rax
  8004204a86:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004204a8a:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204a8f:	75 35                	jne    8004204ac6 <check_page_alloc+0x67a>
  8004204a91:	48 b9 a7 85 21 04 80 	movabs $0x80042185a7,%rcx
  8004204a98:	00 00 00 
  8004204a9b:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204aa2:	00 00 00 
  8004204aa5:	be 6e 04 00 00       	mov    $0x46e,%esi
  8004204aaa:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204ab1:	00 00 00 
  8004204ab4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204ab9:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204ac0:	00 00 00 
  8004204ac3:	41 ff d0             	callq  *%r8
	assert((pp1 = page_alloc(0)));
  8004204ac6:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204acb:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004204ad2:	00 00 00 
  8004204ad5:	ff d0                	callq  *%rax
  8004204ad7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004204adb:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204ae0:	75 35                	jne    8004204b17 <check_page_alloc+0x6cb>
  8004204ae2:	48 b9 bd 85 21 04 80 	movabs $0x80042185bd,%rcx
  8004204ae9:	00 00 00 
  8004204aec:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204af3:	00 00 00 
  8004204af6:	be 6f 04 00 00       	mov    $0x46f,%esi
  8004204afb:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204b02:	00 00 00 
  8004204b05:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b0a:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204b11:	00 00 00 
  8004204b14:	41 ff d0             	callq  *%r8
	assert((pp2 = page_alloc(0)));
  8004204b17:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204b1c:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004204b23:	00 00 00 
  8004204b26:	ff d0                	callq  *%rax
  8004204b28:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004204b2c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204b31:	75 35                	jne    8004204b68 <check_page_alloc+0x71c>
  8004204b33:	48 b9 d3 85 21 04 80 	movabs $0x80042185d3,%rcx
  8004204b3a:	00 00 00 
  8004204b3d:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204b44:	00 00 00 
  8004204b47:	be 70 04 00 00       	mov    $0x470,%esi
  8004204b4c:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204b53:	00 00 00 
  8004204b56:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b5b:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204b62:	00 00 00 
  8004204b65:	41 ff d0             	callq  *%r8
	assert(pp0);
  8004204b68:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004204b6d:	75 35                	jne    8004204ba4 <check_page_alloc+0x758>
  8004204b6f:	48 b9 e9 85 21 04 80 	movabs $0x80042185e9,%rcx
  8004204b76:	00 00 00 
  8004204b79:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204b80:	00 00 00 
  8004204b83:	be 71 04 00 00       	mov    $0x471,%esi
  8004204b88:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204b8f:	00 00 00 
  8004204b92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204b97:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204b9e:	00 00 00 
  8004204ba1:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004204ba4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004204ba9:	74 0a                	je     8004204bb5 <check_page_alloc+0x769>
  8004204bab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204baf:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204bb3:	75 35                	jne    8004204bea <check_page_alloc+0x79e>
  8004204bb5:	48 b9 ed 85 21 04 80 	movabs $0x80042185ed,%rcx
  8004204bbc:	00 00 00 
  8004204bbf:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204bc6:	00 00 00 
  8004204bc9:	be 72 04 00 00       	mov    $0x472,%esi
  8004204bce:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204bd5:	00 00 00 
  8004204bd8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204bdd:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204be4:	00 00 00 
  8004204be7:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004204bea:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004204bef:	74 14                	je     8004204c05 <check_page_alloc+0x7b9>
  8004204bf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204bf5:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004204bf9:	74 0a                	je     8004204c05 <check_page_alloc+0x7b9>
  8004204bfb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204bff:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004204c03:	75 35                	jne    8004204c3a <check_page_alloc+0x7ee>
  8004204c05:	48 b9 00 86 21 04 80 	movabs $0x8004218600,%rcx
  8004204c0c:	00 00 00 
  8004204c0f:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204c16:	00 00 00 
  8004204c19:	be 73 04 00 00       	mov    $0x473,%esi
  8004204c1e:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204c25:	00 00 00 
  8004204c28:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c2d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204c34:	00 00 00 
  8004204c37:	41 ff d0             	callq  *%r8
	assert(!page_alloc(0));
  8004204c3a:	bf 00 00 00 00       	mov    $0x0,%edi
  8004204c3f:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004204c46:	00 00 00 
  8004204c49:	ff d0                	callq  *%rax
  8004204c4b:	48 85 c0             	test   %rax,%rax
  8004204c4e:	74 35                	je     8004204c85 <check_page_alloc+0x839>
  8004204c50:	48 b9 77 86 21 04 80 	movabs $0x8004218677,%rcx
  8004204c57:	00 00 00 
  8004204c5a:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204c61:	00 00 00 
  8004204c64:	be 74 04 00 00       	mov    $0x474,%esi
  8004204c69:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204c70:	00 00 00 
  8004204c73:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204c78:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204c7f:	00 00 00 
  8004204c82:	41 ff d0             	callq  *%r8

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
  8004204c85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204c89:	48 89 c7             	mov    %rax,%rdi
  8004204c8c:	48 b8 f0 1d 20 04 80 	movabs $0x8004201df0,%rax
  8004204c93:	00 00 00 
  8004204c96:	ff d0                	callq  *%rax
  8004204c98:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004204c9d:	be 01 00 00 00       	mov    $0x1,%esi
  8004204ca2:	48 89 c7             	mov    %rax,%rdi
  8004204ca5:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004204cac:	00 00 00 
  8004204caf:	ff d0                	callq  *%rax
	page_free(pp0);
  8004204cb1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204cb5:	48 89 c7             	mov    %rax,%rdi
  8004204cb8:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004204cbf:	00 00 00 
  8004204cc2:	ff d0                	callq  *%rax
	assert((pp = page_alloc(ALLOC_ZERO)));
  8004204cc4:	bf 01 00 00 00       	mov    $0x1,%edi
  8004204cc9:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004204cd0:	00 00 00 
  8004204cd3:	ff d0                	callq  *%rax
  8004204cd5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004204cd9:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204cde:	75 35                	jne    8004204d15 <check_page_alloc+0x8c9>
  8004204ce0:	48 b9 86 86 21 04 80 	movabs $0x8004218686,%rcx
  8004204ce7:	00 00 00 
  8004204cea:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204cf1:	00 00 00 
  8004204cf4:	be 79 04 00 00       	mov    $0x479,%esi
  8004204cf9:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204d00:	00 00 00 
  8004204d03:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d08:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204d0f:	00 00 00 
  8004204d12:	41 ff d0             	callq  *%r8
	assert(pp && pp0 == pp);
  8004204d15:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004204d1a:	74 0a                	je     8004204d26 <check_page_alloc+0x8da>
  8004204d1c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204d20:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004204d24:	74 35                	je     8004204d5b <check_page_alloc+0x90f>
  8004204d26:	48 b9 a4 86 21 04 80 	movabs $0x80042186a4,%rcx
  8004204d2d:	00 00 00 
  8004204d30:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204d37:	00 00 00 
  8004204d3a:	be 7a 04 00 00       	mov    $0x47a,%esi
  8004204d3f:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204d46:	00 00 00 
  8004204d49:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204d4e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204d55:	00 00 00 
  8004204d58:	41 ff d0             	callq  *%r8
	c = page2kva(pp);
  8004204d5b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204d5f:	48 89 c7             	mov    %rax,%rdi
  8004204d62:	48 b8 f0 1d 20 04 80 	movabs $0x8004201df0,%rax
  8004204d69:	00 00 00 
  8004204d6c:	ff d0                	callq  *%rax
  8004204d6e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < PGSIZE; i++)
  8004204d72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004204d79:	eb 4d                	jmp    8004204dc8 <check_page_alloc+0x97c>
		assert(c[i] == 0);
  8004204d7b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004204d7e:	48 63 d0             	movslq %eax,%rdx
  8004204d81:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204d85:	48 01 d0             	add    %rdx,%rax
  8004204d88:	0f b6 00             	movzbl (%rax),%eax
  8004204d8b:	84 c0                	test   %al,%al
  8004204d8d:	74 35                	je     8004204dc4 <check_page_alloc+0x978>
  8004204d8f:	48 b9 b4 86 21 04 80 	movabs $0x80042186b4,%rcx
  8004204d96:	00 00 00 
  8004204d99:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204da0:	00 00 00 
  8004204da3:	be 7d 04 00 00       	mov    $0x47d,%esi
  8004204da8:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204daf:	00 00 00 
  8004204db2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204db7:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204dbe:	00 00 00 
  8004204dc1:	41 ff d0             	callq  *%r8
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
  8004204dc4:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004204dc8:	81 7d f4 ff 0f 00 00 	cmpl   $0xfff,-0xc(%rbp)
  8004204dcf:	7e aa                	jle    8004204d7b <check_page_alloc+0x92f>
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;
  8004204dd1:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004204dd8:	00 00 00 
  8004204ddb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204ddf:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_free(pp0);
  8004204de2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204de6:	48 89 c7             	mov    %rax,%rdi
  8004204de9:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004204df0:	00 00 00 
  8004204df3:	ff d0                	callq  *%rax
	page_free(pp1);
  8004204df5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204df9:	48 89 c7             	mov    %rax,%rdi
  8004204dfc:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004204e03:	00 00 00 
  8004204e06:	ff d0                	callq  *%rax
	page_free(pp2);
  8004204e08:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204e0c:	48 89 c7             	mov    %rax,%rdi
  8004204e0f:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004204e16:	00 00 00 
  8004204e19:	ff d0                	callq  *%rax

	cprintf("check_page_alloc() succeeded!\n");
  8004204e1b:	48 bf c0 86 21 04 80 	movabs $0x80042186c0,%rdi
  8004204e22:	00 00 00 
  8004204e25:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204e2a:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004204e31:	00 00 00 
  8004204e34:	ff d2                	callq  *%rdx
}
  8004204e36:	c9                   	leaveq 
  8004204e37:	c3                   	retq   

0000008004204e38 <check_boot_pml4e>:
// but it is a pretty good sanity check.
//

static void
check_boot_pml4e(pml4e_t *pml4e)
{
  8004204e38:	55                   	push   %rbp
  8004204e39:	48 89 e5             	mov    %rsp,%rbp
  8004204e3c:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
  8004204e43:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
	uint64_t i, n;

	pml4e = boot_pml4e;
  8004204e4a:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004204e51:	00 00 00 
  8004204e54:	48 8b 00             	mov    (%rax),%rax
  8004204e57:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
  8004204e5b:	48 c7 45 e0 00 10 00 	movq   $0x1000,-0x20(%rbp)
  8004204e62:	00 
  8004204e63:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004204e6a:	00 00 00 
  8004204e6d:	48 8b 00             	mov    (%rax),%rax
  8004204e70:	48 c1 e0 04          	shl    $0x4,%rax
  8004204e74:	48 89 c2             	mov    %rax,%rdx
  8004204e77:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004204e7b:	48 01 d0             	add    %rdx,%rax
  8004204e7e:	48 83 e8 01          	sub    $0x1,%rax
  8004204e82:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004204e86:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004204e8a:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204e8f:	48 f7 75 e0          	divq   -0x20(%rbp)
  8004204e93:	48 89 d0             	mov    %rdx,%rax
  8004204e96:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004204e9a:	48 29 c2             	sub    %rax,%rdx
  8004204e9d:	48 89 d0             	mov    %rdx,%rax
  8004204ea0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE) {
  8004204ea4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204eab:	00 
  8004204eac:	e9 d4 00 00 00       	jmpq   8004204f85 <check_boot_pml4e+0x14d>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
  8004204eb1:	48 ba 00 00 a0 00 80 	movabs $0x8000a00000,%rdx
  8004204eb8:	00 00 00 
  8004204ebb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204ebf:	48 01 c2             	add    %rax,%rdx
  8004204ec2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204ec6:	48 89 d6             	mov    %rdx,%rsi
  8004204ec9:	48 89 c7             	mov    %rax,%rdi
  8004204ecc:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  8004204ed3:	00 00 00 
  8004204ed6:	ff d0                	callq  *%rax
  8004204ed8:	48 ba 98 97 37 04 80 	movabs $0x8004379798,%rdx
  8004204edf:	00 00 00 
  8004204ee2:	48 8b 12             	mov    (%rdx),%rdx
  8004204ee5:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  8004204ee9:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004204ef0:	00 00 00 
  8004204ef3:	48 39 55 d0          	cmp    %rdx,-0x30(%rbp)
  8004204ef7:	77 32                	ja     8004204f2b <check_boot_pml4e+0xf3>
  8004204ef9:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004204efd:	48 89 c1             	mov    %rax,%rcx
  8004204f00:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  8004204f07:	00 00 00 
  8004204f0a:	be 9c 04 00 00       	mov    $0x49c,%esi
  8004204f0f:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204f16:	00 00 00 
  8004204f19:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f1e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204f25:	00 00 00 
  8004204f28:	41 ff d0             	callq  *%r8
  8004204f2b:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004204f32:	ff ff ff 
  8004204f35:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004204f39:	48 01 d1             	add    %rdx,%rcx
  8004204f3c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004204f40:	48 01 ca             	add    %rcx,%rdx
  8004204f43:	48 39 d0             	cmp    %rdx,%rax
  8004204f46:	74 35                	je     8004204f7d <check_boot_pml4e+0x145>
  8004204f48:	48 b9 e0 86 21 04 80 	movabs $0x80042186e0,%rcx
  8004204f4f:	00 00 00 
  8004204f52:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004204f59:	00 00 00 
  8004204f5c:	be 9c 04 00 00       	mov    $0x49c,%esi
  8004204f61:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004204f68:	00 00 00 
  8004204f6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004204f70:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004204f77:	00 00 00 
  8004204f7a:	41 ff d0             	callq  *%r8
	uint64_t i, n;

	pml4e = boot_pml4e;
	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE) {
  8004204f7d:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004204f84:	00 
  8004204f85:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204f89:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004204f8d:	0f 82 1e ff ff ff    	jb     8004204eb1 <check_boot_pml4e+0x79>
		 //cprintf("%x %x %x\n",i,check_va2pa(pml4e, UPAGES + i), PADDR(pages) + i);
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
  8004204f93:	48 c7 45 c8 00 10 00 	movq   $0x1000,-0x38(%rbp)
  8004204f9a:	00 
  8004204f9b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004204f9f:	48 05 ff 9f 05 00    	add    $0x59fff,%rax
  8004204fa5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004204fa9:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004204fad:	ba 00 00 00 00       	mov    $0x0,%edx
  8004204fb2:	48 f7 75 c8          	divq   -0x38(%rbp)
  8004204fb6:	48 89 d0             	mov    %rdx,%rax
  8004204fb9:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004204fbd:	48 29 c2             	sub    %rax,%rdx
  8004204fc0:	48 89 d0             	mov    %rdx,%rax
  8004204fc3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < n; i += PGSIZE)
  8004204fc7:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004204fce:	00 
  8004204fcf:	e9 d4 00 00 00       	jmpq   80042050a8 <check_boot_pml4e+0x270>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);
  8004204fd4:	48 ba 00 00 80 00 80 	movabs $0x8000800000,%rdx
  8004204fdb:	00 00 00 
  8004204fde:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004204fe2:	48 01 c2             	add    %rax,%rdx
  8004204fe5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004204fe9:	48 89 d6             	mov    %rdx,%rsi
  8004204fec:	48 89 c7             	mov    %rax,%rdi
  8004204fef:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  8004204ff6:	00 00 00 
  8004204ff9:	ff d0                	callq  *%rax
  8004204ffb:	48 ba 58 82 37 04 80 	movabs $0x8004378258,%rdx
  8004205002:	00 00 00 
  8004205005:	48 8b 12             	mov    (%rdx),%rdx
  8004205008:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420500c:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  8004205013:	00 00 00 
  8004205016:	48 39 55 b8          	cmp    %rdx,-0x48(%rbp)
  800420501a:	77 32                	ja     800420504e <check_boot_pml4e+0x216>
  800420501c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205020:	48 89 c1             	mov    %rax,%rcx
  8004205023:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  800420502a:	00 00 00 
  800420502d:	be a2 04 00 00       	mov    $0x4a2,%esi
  8004205032:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205039:	00 00 00 
  800420503c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205041:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205048:	00 00 00 
  800420504b:	41 ff d0             	callq  *%r8
  800420504e:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205055:	ff ff ff 
  8004205058:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420505c:	48 01 d1             	add    %rdx,%rcx
  800420505f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205063:	48 01 ca             	add    %rcx,%rdx
  8004205066:	48 39 d0             	cmp    %rdx,%rax
  8004205069:	74 35                	je     80042050a0 <check_boot_pml4e+0x268>
  800420506b:	48 b9 18 87 21 04 80 	movabs $0x8004218718,%rcx
  8004205072:	00 00 00 
  8004205075:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420507c:	00 00 00 
  800420507f:	be a2 04 00 00       	mov    $0x4a2,%esi
  8004205084:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420508b:	00 00 00 
  800420508e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205093:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420509a:	00 00 00 
  800420509d:	41 ff d0             	callq  *%r8
		assert(check_va2pa(pml4e, UPAGES + i) == PADDR(pages) + i);
	}

	// check envs array (new test for lab 3)
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
  80042050a0:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042050a7:	00 
  80042050a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050ac:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  80042050b0:	0f 82 1e ff ff ff    	jb     8004204fd4 <check_boot_pml4e+0x19c>
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  80042050b6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042050bd:	00 
  80042050be:	eb 6a                	jmp    800420512a <check_boot_pml4e+0x2f2>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);
  80042050c0:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042050c7:	00 00 00 
  80042050ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042050ce:	48 01 c2             	add    %rax,%rdx
  80042050d1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042050d5:	48 89 d6             	mov    %rdx,%rsi
  80042050d8:	48 89 c7             	mov    %rax,%rdi
  80042050db:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  80042050e2:	00 00 00 
  80042050e5:	ff d0                	callq  *%rax
  80042050e7:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042050eb:	74 35                	je     8004205122 <check_boot_pml4e+0x2ea>
  80042050ed:	48 b9 50 87 21 04 80 	movabs $0x8004218750,%rcx
  80042050f4:	00 00 00 
  80042050f7:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042050fe:	00 00 00 
  8004205101:	be a6 04 00 00       	mov    $0x4a6,%esi
  8004205106:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420510d:	00 00 00 
  8004205110:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205115:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420511c:	00 00 00 
  800420511f:	41 ff d0             	callq  *%r8
	n = ROUNDUP(NENV*sizeof(struct Env), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
		assert(check_va2pa(pml4e, UENVS + i) == PADDR(envs) + i);

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
  8004205122:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205129:	00 
  800420512a:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004205131:	00 00 00 
  8004205134:	48 8b 00             	mov    (%rax),%rax
  8004205137:	48 c1 e0 0c          	shl    $0xc,%rax
  800420513b:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420513f:	0f 87 7b ff ff ff    	ja     80042050c0 <check_boot_pml4e+0x288>
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  8004205145:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420514c:	00 
  800420514d:	e9 a1 01 00 00       	jmpq   80042052f3 <check_boot_pml4e+0x4bb>
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
  8004205152:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004205156:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420515a:	48 89 d0             	mov    %rdx,%rax
  800420515d:	48 01 c0             	add    %rax,%rax
  8004205160:	48 01 d0             	add    %rdx,%rax
  8004205163:	48 c1 e0 0f          	shl    $0xf,%rax
  8004205167:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420516e:	00 00 00 
  8004205171:	48 29 c2             	sub    %rax,%rdx
  8004205174:	48 89 d0             	mov    %rdx,%rax
  8004205177:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  800420517b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205182:	00 
  8004205183:	e9 e0 00 00 00       	jmpq   8004205268 <check_boot_pml4e+0x430>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
  8004205188:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420518c:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205190:	48 01 d0             	add    %rdx,%rax
  8004205193:	48 8d 90 00 80 00 00 	lea    0x8000(%rax),%rdx
  800420519a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420519e:	48 89 d6             	mov    %rdx,%rsi
  80042051a1:	48 89 c7             	mov    %rax,%rdi
  80042051a4:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  80042051ab:	00 00 00 
  80042051ae:	ff d0                	callq  *%rax
  80042051b0:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042051b4:	48 89 d1             	mov    %rdx,%rcx
  80042051b7:	48 c1 e1 10          	shl    $0x10,%rcx
  80042051bb:	48 ba 00 c0 37 04 80 	movabs $0x800437c000,%rdx
  80042051c2:	00 00 00 
  80042051c5:	48 01 ca             	add    %rcx,%rdx
  80042051c8:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  80042051cc:	48 ba ff ff ff 03 80 	movabs $0x8003ffffff,%rdx
  80042051d3:	00 00 00 
  80042051d6:	48 39 55 a8          	cmp    %rdx,-0x58(%rbp)
  80042051da:	77 32                	ja     800420520e <check_boot_pml4e+0x3d6>
  80042051dc:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042051e0:	48 89 c1             	mov    %rax,%rcx
  80042051e3:	48 ba f0 82 21 04 80 	movabs $0x80042182f0,%rdx
  80042051ea:	00 00 00 
  80042051ed:	be ae 04 00 00       	mov    $0x4ae,%esi
  80042051f2:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042051f9:	00 00 00 
  80042051fc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205201:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205208:	00 00 00 
  800420520b:	41 ff d0             	callq  *%r8
  800420520e:	48 b9 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rcx
  8004205215:	ff ff ff 
  8004205218:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800420521c:	48 01 d1             	add    %rdx,%rcx
  800420521f:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004205223:	48 01 ca             	add    %rcx,%rdx
  8004205226:	48 39 d0             	cmp    %rdx,%rax
  8004205229:	74 35                	je     8004205260 <check_boot_pml4e+0x428>
  800420522b:	48 b9 78 87 21 04 80 	movabs $0x8004218778,%rcx
  8004205232:	00 00 00 
  8004205235:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420523c:	00 00 00 
  800420523f:	be ae 04 00 00       	mov    $0x4ae,%esi
  8004205244:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420524b:	00 00 00 
  800420524e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205253:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420525a:	00 00 00 
  800420525d:	41 ff d0             	callq  *%r8

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
  8004205260:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004205267:	00 
  8004205268:	48 81 7d f8 ff ff 00 	cmpq   $0xffff,-0x8(%rbp)
  800420526f:	00 
  8004205270:	0f 86 12 ff ff ff    	jbe    8004205188 <check_boot_pml4e+0x350>
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  8004205276:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420527d:	00 
  800420527e:	eb 64                	jmp    80042052e4 <check_boot_pml4e+0x4ac>
			assert(check_va2pa(pml4e, base + i) == ~0);
  8004205280:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205284:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004205288:	48 01 c2             	add    %rax,%rdx
  800420528b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420528f:	48 89 d6             	mov    %rdx,%rsi
  8004205292:	48 89 c7             	mov    %rax,%rdi
  8004205295:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  800420529c:	00 00 00 
  800420529f:	ff d0                	callq  *%rax
  80042052a1:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042052a5:	74 35                	je     80042052dc <check_boot_pml4e+0x4a4>
  80042052a7:	48 b9 c0 87 21 04 80 	movabs $0x80042187c0,%rcx
  80042052ae:	00 00 00 
  80042052b1:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042052b8:	00 00 00 
  80042052bb:	be b0 04 00 00       	mov    $0x4b0,%esi
  80042052c0:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042052c7:	00 00 00 
  80042052ca:	b8 00 00 00 00       	mov    $0x0,%eax
  80042052cf:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042052d6:	00 00 00 
  80042052d9:	41 ff d0             	callq  *%r8
	for (n = 0; n < NCPU; n++) {
		uint64_t base = KSTACKTOP - (KSTKSIZE + KSTKGAP) * (n + 1);
		for (i = 0; i < KSTKSIZE; i += PGSIZE)
			assert(check_va2pa(pml4e, base + KSTKGAP + i)
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
  80042052dc:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  80042052e3:	00 
  80042052e4:	48 81 7d f8 ff 7f 00 	cmpq   $0x7fff,-0x8(%rbp)
  80042052eb:	00 
  80042052ec:	76 92                	jbe    8004205280 <check_boot_pml4e+0x448>
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
		assert(check_va2pa(pml4e, KERNBASE + i) == i);

	// check kernel stack
	// (updated in lab 4 to check per-CPU kernel stacks)
	for (n = 0; n < NCPU; n++) {
  80042052ee:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  80042052f3:	48 83 7d f0 03       	cmpq   $0x3,-0x10(%rbp)
  80042052f8:	0f 86 54 fe ff ff    	jbe    8004205152 <check_boot_pml4e+0x31a>
			       == PADDR(percpu_kstacks[n]) + i);
		for (i = 0; i < KSTKGAP; i += PGSIZE)
			assert(check_va2pa(pml4e, base + i) == ~0);
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
  80042052fe:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004205305:	00 00 00 
  8004205308:	48 8b 00             	mov    (%rax),%rax
  800420530b:	48 83 c0 08          	add    $0x8,%rax
  800420530f:	48 8b 00             	mov    (%rax),%rax
  8004205312:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205318:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800420531c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205320:	48 c1 e8 0c          	shr    $0xc,%rax
  8004205324:	89 45 9c             	mov    %eax,-0x64(%rbp)
  8004205327:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420532a:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004205331:	00 00 00 
  8004205334:	48 8b 00             	mov    (%rax),%rax
  8004205337:	48 39 c2             	cmp    %rax,%rdx
  800420533a:	72 32                	jb     800420536e <check_boot_pml4e+0x536>
  800420533c:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205340:	48 89 c1             	mov    %rax,%rcx
  8004205343:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  800420534a:	00 00 00 
  800420534d:	be b3 04 00 00       	mov    $0x4b3,%esi
  8004205352:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205359:	00 00 00 
  800420535c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205361:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205368:	00 00 00 
  800420536b:	41 ff d0             	callq  *%r8
  800420536e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205375:	00 00 00 
  8004205378:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420537c:	48 01 d0             	add    %rdx,%rax
  800420537f:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
  8004205383:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004205387:	48 8b 00             	mov    (%rax),%rax
  800420538a:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205390:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004205394:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004205398:	48 c1 e8 0c          	shr    $0xc,%rax
  800420539c:	89 45 84             	mov    %eax,-0x7c(%rbp)
  800420539f:	8b 55 84             	mov    -0x7c(%rbp),%edx
  80042053a2:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042053a9:	00 00 00 
  80042053ac:	48 8b 00             	mov    (%rax),%rax
  80042053af:	48 39 c2             	cmp    %rax,%rdx
  80042053b2:	72 32                	jb     80042053e6 <check_boot_pml4e+0x5ae>
  80042053b4:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042053b8:	48 89 c1             	mov    %rax,%rcx
  80042053bb:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  80042053c2:	00 00 00 
  80042053c5:	be b4 04 00 00       	mov    $0x4b4,%esi
  80042053ca:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042053d1:	00 00 00 
  80042053d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042053d9:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042053e0:	00 00 00 
  80042053e3:	41 ff d0             	callq  *%r8
  80042053e6:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042053ed:	00 00 00 
  80042053f0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042053f4:	48 01 d0             	add    %rdx,%rax
  80042053f7:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  80042053fe:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004205405:	00 
  8004205406:	e9 50 01 00 00       	jmpq   800420555b <check_boot_pml4e+0x723>
		switch (i) {
  800420540b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420540f:	48 83 f8 04          	cmp    $0x4,%rax
  8004205413:	72 67                	jb     800420547c <check_boot_pml4e+0x644>
  8004205415:	48 83 f8 05          	cmp    $0x5,%rax
  8004205419:	76 06                	jbe    8004205421 <check_boot_pml4e+0x5e9>
  800420541b:	48 83 f8 1f          	cmp    $0x1f,%rax
  800420541f:	75 5b                	jne    800420547c <check_boot_pml4e+0x644>
			//case PDX(UVPT):
		case PDX(KSTACKTOP - 1):
		case PDX(UPAGES):
		case PDX(UENVS):
			assert(pgdir[i] & PTE_P);
  8004205421:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205425:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420542c:	00 
  800420542d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205434:	48 01 d0             	add    %rdx,%rax
  8004205437:	48 8b 00             	mov    (%rax),%rax
  800420543a:	83 e0 01             	and    $0x1,%eax
  800420543d:	48 85 c0             	test   %rax,%rax
  8004205440:	75 35                	jne    8004205477 <check_boot_pml4e+0x63f>
  8004205442:	48 b9 e3 87 21 04 80 	movabs $0x80042187e3,%rcx
  8004205449:	00 00 00 
  800420544c:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205453:	00 00 00 
  8004205456:	be bc 04 00 00       	mov    $0x4bc,%esi
  800420545b:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205462:	00 00 00 
  8004205465:	b8 00 00 00 00       	mov    $0x0,%eax
  800420546a:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205471:	00 00 00 
  8004205474:	41 ff d0             	callq  *%r8
			break;
  8004205477:	e9 da 00 00 00       	jmpq   8004205556 <check_boot_pml4e+0x71e>
		default:
			if (i >= PDX(KERNBASE)) {
  800420547c:	48 83 7d f8 1f       	cmpq   $0x1f,-0x8(%rbp)
  8004205481:	0f 86 ce 00 00 00    	jbe    8004205555 <check_boot_pml4e+0x71d>
				if (pgdir[i] & PTE_P)
  8004205487:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420548b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205492:	00 
  8004205493:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420549a:	48 01 d0             	add    %rdx,%rax
  800420549d:	48 8b 00             	mov    (%rax),%rax
  80042054a0:	83 e0 01             	and    $0x1,%eax
  80042054a3:	48 85 c0             	test   %rax,%rax
  80042054a6:	74 5a                	je     8004205502 <check_boot_pml4e+0x6ca>
					assert(pgdir[i] & PTE_W);
  80042054a8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042054ac:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042054b3:	00 
  80042054b4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042054bb:	48 01 d0             	add    %rdx,%rax
  80042054be:	48 8b 00             	mov    (%rax),%rax
  80042054c1:	83 e0 02             	and    $0x2,%eax
  80042054c4:	48 85 c0             	test   %rax,%rax
  80042054c7:	0f 85 88 00 00 00    	jne    8004205555 <check_boot_pml4e+0x71d>
  80042054cd:	48 b9 f4 87 21 04 80 	movabs $0x80042187f4,%rcx
  80042054d4:	00 00 00 
  80042054d7:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042054de:	00 00 00 
  80042054e1:	be c1 04 00 00       	mov    $0x4c1,%esi
  80042054e6:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042054ed:	00 00 00 
  80042054f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042054f5:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042054fc:	00 00 00 
  80042054ff:	41 ff d0             	callq  *%r8
				else
					assert(pgdir[i] == 0);
  8004205502:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205506:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420550d:	00 
  800420550e:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004205515:	48 01 d0             	add    %rdx,%rax
  8004205518:	48 8b 00             	mov    (%rax),%rax
  800420551b:	48 85 c0             	test   %rax,%rax
  800420551e:	74 35                	je     8004205555 <check_boot_pml4e+0x71d>
  8004205520:	48 b9 05 88 21 04 80 	movabs $0x8004218805,%rcx
  8004205527:	00 00 00 
  800420552a:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205531:	00 00 00 
  8004205534:	be c3 04 00 00       	mov    $0x4c3,%esi
  8004205539:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205540:	00 00 00 
  8004205543:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205548:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420554f:	00 00 00 
  8004205552:	41 ff d0             	callq  *%r8
			} 
			break;
  8004205555:	90                   	nop
	}

	pdpe_t *pdpe = KADDR(PTE_ADDR(boot_pml4e[1]));
	pde_t  *pgdir = KADDR(PTE_ADDR(pdpe[0]));
	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
  8004205556:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420555b:	48 81 7d f8 ff 01 00 	cmpq   $0x1ff,-0x8(%rbp)
  8004205562:	00 
  8004205563:	0f 86 a2 fe ff ff    	jbe    800420540b <check_boot_pml4e+0x5d3>
					assert(pgdir[i] == 0);
			} 
			break;
		}
	}
	cprintf("check_boot_pml4e() succeeded!\n");
  8004205569:	48 bf 18 88 21 04 80 	movabs $0x8004218818,%rdi
  8004205570:	00 00 00 
  8004205573:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205578:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420557f:	00 00 00 
  8004205582:	ff d2                	callq  *%rdx
}
  8004205584:	c9                   	leaveq 
  8004205585:	c3                   	retq   

0000008004205586 <check_va2pa>:
// this functionality for us!  We define our own version to help check
// the check_boot_pml4e() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pml4e_t *pml4e, uintptr_t va)
{
  8004205586:	55                   	push   %rbp
  8004205587:	48 89 e5             	mov    %rsp,%rbp
  800420558a:	48 83 ec 60          	sub    $0x60,%rsp
  800420558e:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004205592:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	pte_t *pte;
	pdpe_t *pdpe;
	pde_t *pde;
	pml4e = &pml4e[PML4(va)];
  8004205596:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800420559a:	48 c1 e8 27          	shr    $0x27,%rax
  800420559e:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042055a3:	48 c1 e0 03          	shl    $0x3,%rax
  80042055a7:	48 01 45 a8          	add    %rax,-0x58(%rbp)
	//cprintf("pml4e %x %x \n" , PML4(va), *pml4e);
	if(!(*pml4e & PTE_P))
  80042055ab:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042055af:	48 8b 00             	mov    (%rax),%rax
  80042055b2:	83 e0 01             	and    $0x1,%eax
  80042055b5:	48 85 c0             	test   %rax,%rax
  80042055b8:	75 0c                	jne    80042055c6 <check_va2pa+0x40>
		return ~0;
  80042055ba:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042055c1:	e9 38 02 00 00       	jmpq   80042057fe <check_va2pa+0x278>
	pdpe = (pdpe_t *) KADDR(PTE_ADDR(*pml4e));
  80042055c6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042055ca:	48 8b 00             	mov    (%rax),%rax
  80042055cd:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042055d3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042055d7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042055db:	48 c1 e8 0c          	shr    $0xc,%rax
  80042055df:	89 45 f4             	mov    %eax,-0xc(%rbp)
  80042055e2:	8b 55 f4             	mov    -0xc(%rbp),%edx
  80042055e5:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042055ec:	00 00 00 
  80042055ef:	48 8b 00             	mov    (%rax),%rax
  80042055f2:	48 39 c2             	cmp    %rax,%rdx
  80042055f5:	72 32                	jb     8004205629 <check_va2pa+0xa3>
  80042055f7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042055fb:	48 89 c1             	mov    %rax,%rcx
  80042055fe:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004205605:	00 00 00 
  8004205608:	be da 04 00 00       	mov    $0x4da,%esi
  800420560d:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205614:	00 00 00 
  8004205617:	b8 00 00 00 00       	mov    $0x0,%eax
  800420561c:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205623:	00 00 00 
  8004205626:	41 ff d0             	callq  *%r8
  8004205629:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004205630:	00 00 00 
  8004205633:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004205637:	48 01 d0             	add    %rdx,%rax
  800420563a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	//cprintf("pdpe %x %x \n" , pdpe, *pdpe);
	if (!(pdpe[PDPE(va)] & PTE_P))
  800420563e:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205642:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205646:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420564b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205652:	00 
  8004205653:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004205657:	48 01 d0             	add    %rdx,%rax
  800420565a:	48 8b 00             	mov    (%rax),%rax
  800420565d:	83 e0 01             	and    $0x1,%eax
  8004205660:	48 85 c0             	test   %rax,%rax
  8004205663:	75 0c                	jne    8004205671 <check_va2pa+0xeb>
		return ~0;
  8004205665:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420566c:	e9 8d 01 00 00       	jmpq   80042057fe <check_va2pa+0x278>
	pde = (pde_t *) KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004205671:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205675:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004205679:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420567e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004205685:	00 
  8004205686:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420568a:	48 01 d0             	add    %rdx,%rax
  800420568d:	48 8b 00             	mov    (%rax),%rax
  8004205690:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205696:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  800420569a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420569e:	48 c1 e8 0c          	shr    $0xc,%rax
  80042056a2:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042056a5:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042056a8:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042056af:	00 00 00 
  80042056b2:	48 8b 00             	mov    (%rax),%rax
  80042056b5:	48 39 c2             	cmp    %rax,%rdx
  80042056b8:	72 32                	jb     80042056ec <check_va2pa+0x166>
  80042056ba:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042056be:	48 89 c1             	mov    %rax,%rcx
  80042056c1:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  80042056c8:	00 00 00 
  80042056cb:	be de 04 00 00       	mov    $0x4de,%esi
  80042056d0:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042056d7:	00 00 00 
  80042056da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042056df:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042056e6:	00 00 00 
  80042056e9:	41 ff d0             	callq  *%r8
  80042056ec:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042056f3:	00 00 00 
  80042056f6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042056fa:	48 01 d0             	add    %rdx,%rax
  80042056fd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//cprintf("pde %x %x \n" , pde, *pde);
	pde = &pde[PDX(va)];
  8004205701:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004205705:	48 c1 e8 15          	shr    $0x15,%rax
  8004205709:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420570e:	48 c1 e0 03          	shl    $0x3,%rax
  8004205712:	48 01 45 d0          	add    %rax,-0x30(%rbp)
	if (!(*pde & PTE_P))
  8004205716:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420571a:	48 8b 00             	mov    (%rax),%rax
  800420571d:	83 e0 01             	and    $0x1,%eax
  8004205720:	48 85 c0             	test   %rax,%rax
  8004205723:	75 0c                	jne    8004205731 <check_va2pa+0x1ab>
		return ~0;
  8004205725:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  800420572c:	e9 cd 00 00 00       	jmpq   80042057fe <check_va2pa+0x278>
	pte = (pte_t*) KADDR(PTE_ADDR(*pde));
  8004205731:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205735:	48 8b 00             	mov    (%rax),%rax
  8004205738:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420573e:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  8004205742:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205746:	48 c1 e8 0c          	shr    $0xc,%rax
  800420574a:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  800420574d:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004205750:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004205757:	00 00 00 
  800420575a:	48 8b 00             	mov    (%rax),%rax
  800420575d:	48 39 c2             	cmp    %rax,%rdx
  8004205760:	72 32                	jb     8004205794 <check_va2pa+0x20e>
  8004205762:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205766:	48 89 c1             	mov    %rax,%rcx
  8004205769:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004205770:	00 00 00 
  8004205773:	be e3 04 00 00       	mov    $0x4e3,%esi
  8004205778:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420577f:	00 00 00 
  8004205782:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205787:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420578e:	00 00 00 
  8004205791:	41 ff d0             	callq  *%r8
  8004205794:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420579b:	00 00 00 
  800420579e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042057a2:	48 01 d0             	add    %rdx,%rax
  80042057a5:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	//cprintf("pte %x %x %x \n" , pte, *pte, pte[PTX(va)]);
	if (!(pte[PTX(va)] & PTE_P))
  80042057a9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042057ad:	48 c1 e8 0c          	shr    $0xc,%rax
  80042057b1:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042057b6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042057bd:	00 
  80042057be:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042057c2:	48 01 d0             	add    %rdx,%rax
  80042057c5:	48 8b 00             	mov    (%rax),%rax
  80042057c8:	83 e0 01             	and    $0x1,%eax
  80042057cb:	48 85 c0             	test   %rax,%rax
  80042057ce:	75 09                	jne    80042057d9 <check_va2pa+0x253>
		return ~0;
  80042057d0:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
  80042057d7:	eb 25                	jmp    80042057fe <check_va2pa+0x278>
	//cprintf("page Tale Index %x %x \n" , PTX(va),  PTE_ADDR(pte[PTX(va)]));
	return PTE_ADDR(pte[PTX(va)]);
  80042057d9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042057dd:	48 c1 e8 0c          	shr    $0xc,%rax
  80042057e1:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042057e6:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042057ed:	00 
  80042057ee:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042057f2:	48 01 d0             	add    %rdx,%rax
  80042057f5:	48 8b 00             	mov    (%rax),%rax
  80042057f8:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
}
  80042057fe:	c9                   	leaveq 
  80042057ff:	c3                   	retq   

0000008004205800 <page_check>:


// check page_insert, page_remove, &c
static void
page_check(void)
{
  8004205800:	55                   	push   %rbp
  8004205801:	48 89 e5             	mov    %rsp,%rbp
  8004205804:	53                   	push   %rbx
  8004205805:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
	pdpe_t *pdpe;
	pde_t *pde;
	void *va;
	int i;
	uintptr_t mm1, mm2;
	pp0 = pp1 = pp2 = pp3 = pp4 = pp5 =0;
  800420580c:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  8004205813:	00 
  8004205814:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205818:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420581c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205820:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205824:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205828:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420582c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205830:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004205834:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205838:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	assert(pp0 = page_alloc(0));
  800420583c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205841:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004205848:	00 00 00 
  800420584b:	ff d0                	callq  *%rax
  800420584d:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  8004205851:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205856:	75 35                	jne    800420588d <page_check+0x8d>
  8004205858:	48 b9 37 88 21 04 80 	movabs $0x8004218837,%rcx
  800420585f:	00 00 00 
  8004205862:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205869:	00 00 00 
  800420586c:	be f9 04 00 00       	mov    $0x4f9,%esi
  8004205871:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205878:	00 00 00 
  800420587b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205880:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205887:	00 00 00 
  800420588a:	41 ff d0             	callq  *%r8
	assert(pp1 = page_alloc(0));
  800420588d:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205892:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004205899:	00 00 00 
  800420589c:	ff d0                	callq  *%rax
  800420589e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  80042058a2:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  80042058a7:	75 35                	jne    80042058de <page_check+0xde>
  80042058a9:	48 b9 4b 88 21 04 80 	movabs $0x800421884b,%rcx
  80042058b0:	00 00 00 
  80042058b3:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042058ba:	00 00 00 
  80042058bd:	be fa 04 00 00       	mov    $0x4fa,%esi
  80042058c2:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042058c9:	00 00 00 
  80042058cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042058d1:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042058d8:	00 00 00 
  80042058db:	41 ff d0             	callq  *%r8
	assert(pp2 = page_alloc(0));
  80042058de:	bf 00 00 00 00       	mov    $0x0,%edi
  80042058e3:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  80042058ea:	00 00 00 
  80042058ed:	ff d0                	callq  *%rax
  80042058ef:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  80042058f3:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  80042058f8:	75 35                	jne    800420592f <page_check+0x12f>
  80042058fa:	48 b9 5f 88 21 04 80 	movabs $0x800421885f,%rcx
  8004205901:	00 00 00 
  8004205904:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420590b:	00 00 00 
  800420590e:	be fb 04 00 00       	mov    $0x4fb,%esi
  8004205913:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420591a:	00 00 00 
  800420591d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205922:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205929:	00 00 00 
  800420592c:	41 ff d0             	callq  *%r8
	assert(pp3 = page_alloc(0));
  800420592f:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205934:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  800420593b:	00 00 00 
  800420593e:	ff d0                	callq  *%rax
  8004205940:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  8004205944:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205949:	75 35                	jne    8004205980 <page_check+0x180>
  800420594b:	48 b9 73 88 21 04 80 	movabs $0x8004218873,%rcx
  8004205952:	00 00 00 
  8004205955:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420595c:	00 00 00 
  800420595f:	be fc 04 00 00       	mov    $0x4fc,%esi
  8004205964:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420596b:	00 00 00 
  800420596e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205973:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420597a:	00 00 00 
  800420597d:	41 ff d0             	callq  *%r8
	assert(pp4 = page_alloc(0));
  8004205980:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205985:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  800420598c:	00 00 00 
  800420598f:	ff d0                	callq  *%rax
  8004205991:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  8004205995:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420599a:	75 35                	jne    80042059d1 <page_check+0x1d1>
  800420599c:	48 b9 87 88 21 04 80 	movabs $0x8004218887,%rcx
  80042059a3:	00 00 00 
  80042059a6:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042059ad:	00 00 00 
  80042059b0:	be fd 04 00 00       	mov    $0x4fd,%esi
  80042059b5:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042059bc:	00 00 00 
  80042059bf:	b8 00 00 00 00       	mov    $0x0,%eax
  80042059c4:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042059cb:	00 00 00 
  80042059ce:	41 ff d0             	callq  *%r8
	assert(pp5 = page_alloc(0));
  80042059d1:	bf 00 00 00 00       	mov    $0x0,%edi
  80042059d6:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  80042059dd:	00 00 00 
  80042059e0:	ff d0                	callq  *%rax
  80042059e2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042059e6:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  80042059eb:	75 35                	jne    8004205a22 <page_check+0x222>
  80042059ed:	48 b9 9b 88 21 04 80 	movabs $0x800421889b,%rcx
  80042059f4:	00 00 00 
  80042059f7:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042059fe:	00 00 00 
  8004205a01:	be fe 04 00 00       	mov    $0x4fe,%esi
  8004205a06:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205a0d:	00 00 00 
  8004205a10:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a15:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205a1c:	00 00 00 
  8004205a1f:	41 ff d0             	callq  *%r8

	assert(pp0);
  8004205a22:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  8004205a27:	75 35                	jne    8004205a5e <page_check+0x25e>
  8004205a29:	48 b9 e9 85 21 04 80 	movabs $0x80042185e9,%rcx
  8004205a30:	00 00 00 
  8004205a33:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205a3a:	00 00 00 
  8004205a3d:	be 00 05 00 00       	mov    $0x500,%esi
  8004205a42:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205a49:	00 00 00 
  8004205a4c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a51:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205a58:	00 00 00 
  8004205a5b:	41 ff d0             	callq  *%r8
	assert(pp1 && pp1 != pp0);
  8004205a5e:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004205a63:	74 0a                	je     8004205a6f <page_check+0x26f>
  8004205a65:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205a69:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205a6d:	75 35                	jne    8004205aa4 <page_check+0x2a4>
  8004205a6f:	48 b9 ed 85 21 04 80 	movabs $0x80042185ed,%rcx
  8004205a76:	00 00 00 
  8004205a79:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205a80:	00 00 00 
  8004205a83:	be 01 05 00 00       	mov    $0x501,%esi
  8004205a88:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205a8f:	00 00 00 
  8004205a92:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205a97:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205a9e:	00 00 00 
  8004205aa1:	41 ff d0             	callq  *%r8
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
  8004205aa4:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004205aa9:	74 14                	je     8004205abf <page_check+0x2bf>
  8004205aab:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205aaf:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205ab3:	74 0a                	je     8004205abf <page_check+0x2bf>
  8004205ab5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ab9:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205abd:	75 35                	jne    8004205af4 <page_check+0x2f4>
  8004205abf:	48 b9 00 86 21 04 80 	movabs $0x8004218600,%rcx
  8004205ac6:	00 00 00 
  8004205ac9:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205ad0:	00 00 00 
  8004205ad3:	be 02 05 00 00       	mov    $0x502,%esi
  8004205ad8:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205adf:	00 00 00 
  8004205ae2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ae7:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205aee:	00 00 00 
  8004205af1:	41 ff d0             	callq  *%r8
	assert(pp3 && pp3 != pp2 && pp3 != pp1 && pp3 != pp0);
  8004205af4:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004205af9:	74 1e                	je     8004205b19 <page_check+0x319>
  8004205afb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205aff:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205b03:	74 14                	je     8004205b19 <page_check+0x319>
  8004205b05:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b09:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205b0d:	74 0a                	je     8004205b19 <page_check+0x319>
  8004205b0f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205b13:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205b17:	75 35                	jne    8004205b4e <page_check+0x34e>
  8004205b19:	48 b9 b0 88 21 04 80 	movabs $0x80042188b0,%rcx
  8004205b20:	00 00 00 
  8004205b23:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205b2a:	00 00 00 
  8004205b2d:	be 03 05 00 00       	mov    $0x503,%esi
  8004205b32:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205b39:	00 00 00 
  8004205b3c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205b41:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205b48:	00 00 00 
  8004205b4b:	41 ff d0             	callq  *%r8
	assert(pp4 && pp4 != pp3 && pp4 != pp2 && pp4 != pp1 && pp4 != pp0);
  8004205b4e:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004205b53:	74 28                	je     8004205b7d <page_check+0x37d>
  8004205b55:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205b59:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205b5d:	74 1e                	je     8004205b7d <page_check+0x37d>
  8004205b5f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205b63:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205b67:	74 14                	je     8004205b7d <page_check+0x37d>
  8004205b69:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205b6d:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205b71:	74 0a                	je     8004205b7d <page_check+0x37d>
  8004205b73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004205b77:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205b7b:	75 35                	jne    8004205bb2 <page_check+0x3b2>
  8004205b7d:	48 b9 e0 88 21 04 80 	movabs $0x80042188e0,%rcx
  8004205b84:	00 00 00 
  8004205b87:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205b8e:	00 00 00 
  8004205b91:	be 04 05 00 00       	mov    $0x504,%esi
  8004205b96:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205b9d:	00 00 00 
  8004205ba0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ba5:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205bac:	00 00 00 
  8004205baf:	41 ff d0             	callq  *%r8
	assert(pp5 && pp5 != pp4 && pp5 != pp3 && pp5 != pp2 && pp5 != pp1 && pp5 != pp0);
  8004205bb2:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004205bb7:	74 32                	je     8004205beb <page_check+0x3eb>
  8004205bb9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205bbd:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  8004205bc1:	74 28                	je     8004205beb <page_check+0x3eb>
  8004205bc3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205bc7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004205bcb:	74 1e                	je     8004205beb <page_check+0x3eb>
  8004205bcd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205bd1:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004205bd5:	74 14                	je     8004205beb <page_check+0x3eb>
  8004205bd7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205bdb:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
  8004205bdf:	74 0a                	je     8004205beb <page_check+0x3eb>
  8004205be1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004205be5:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  8004205be9:	75 35                	jne    8004205c20 <page_check+0x420>
  8004205beb:	48 b9 20 89 21 04 80 	movabs $0x8004218920,%rcx
  8004205bf2:	00 00 00 
  8004205bf5:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205bfc:	00 00 00 
  8004205bff:	be 05 05 00 00       	mov    $0x505,%esi
  8004205c04:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205c0b:	00 00 00 
  8004205c0e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c13:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205c1a:	00 00 00 
  8004205c1d:	41 ff d0             	callq  *%r8

	// temporarily steal the rest of the free pages
	fl = page_free_list;
  8004205c20:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004205c27:	00 00 00 
  8004205c2a:	48 8b 00             	mov    (%rax),%rax
  8004205c2d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	page_free_list = NULL;
  8004205c31:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004205c38:	00 00 00 
  8004205c3b:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// should be no free memory
	assert(!page_alloc(0));
  8004205c42:	bf 00 00 00 00       	mov    $0x0,%edi
  8004205c47:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004205c4e:	00 00 00 
  8004205c51:	ff d0                	callq  *%rax
  8004205c53:	48 85 c0             	test   %rax,%rax
  8004205c56:	74 35                	je     8004205c8d <page_check+0x48d>
  8004205c58:	48 b9 77 86 21 04 80 	movabs $0x8004218677,%rcx
  8004205c5f:	00 00 00 
  8004205c62:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205c69:	00 00 00 
  8004205c6c:	be 0c 05 00 00       	mov    $0x50c,%esi
  8004205c71:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205c78:	00 00 00 
  8004205c7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205c80:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205c87:	00 00 00 
  8004205c8a:	41 ff d0             	callq  *%r8

	// there is no page allocated at address 0
	assert(page_lookup(boot_pml4e, (void *) 0x0, &ptep) == NULL);
  8004205c8d:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004205c94:	00 00 00 
  8004205c97:	48 8b 00             	mov    (%rax),%rax
  8004205c9a:	48 8d 95 e8 fe ff ff 	lea    -0x118(%rbp),%rdx
  8004205ca1:	be 00 00 00 00       	mov    $0x0,%esi
  8004205ca6:	48 89 c7             	mov    %rax,%rdi
  8004205ca9:	48 b8 7e 3a 20 04 80 	movabs $0x8004203a7e,%rax
  8004205cb0:	00 00 00 
  8004205cb3:	ff d0                	callq  *%rax
  8004205cb5:	48 85 c0             	test   %rax,%rax
  8004205cb8:	74 35                	je     8004205cef <page_check+0x4ef>
  8004205cba:	48 b9 70 89 21 04 80 	movabs $0x8004218970,%rcx
  8004205cc1:	00 00 00 
  8004205cc4:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205ccb:	00 00 00 
  8004205cce:	be 0f 05 00 00       	mov    $0x50f,%esi
  8004205cd3:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205cda:	00 00 00 
  8004205cdd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205ce2:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205ce9:	00 00 00 
  8004205cec:	41 ff d0             	callq  *%r8

	// there is no free memory, so we can't allocate a page table 
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205cef:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004205cf6:	00 00 00 
  8004205cf9:	48 8b 00             	mov    (%rax),%rax
  8004205cfc:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205d00:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205d05:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205d0a:	48 89 c7             	mov    %rax,%rdi
  8004205d0d:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  8004205d14:	00 00 00 
  8004205d17:	ff d0                	callq  *%rax
  8004205d19:	85 c0                	test   %eax,%eax
  8004205d1b:	78 35                	js     8004205d52 <page_check+0x552>
  8004205d1d:	48 b9 a8 89 21 04 80 	movabs $0x80042189a8,%rcx
  8004205d24:	00 00 00 
  8004205d27:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205d2e:	00 00 00 
  8004205d31:	be 12 05 00 00       	mov    $0x512,%esi
  8004205d36:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205d3d:	00 00 00 
  8004205d40:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205d45:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205d4c:	00 00 00 
  8004205d4f:	41 ff d0             	callq  *%r8

	// free pp0 and try again: pp0 should be used for page table
	page_free(pp0);
  8004205d52:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205d56:	48 89 c7             	mov    %rax,%rdi
  8004205d59:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004205d60:	00 00 00 
  8004205d63:	ff d0                	callq  *%rax
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) < 0);
  8004205d65:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004205d6c:	00 00 00 
  8004205d6f:	48 8b 00             	mov    (%rax),%rax
  8004205d72:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205d76:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205d7b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205d80:	48 89 c7             	mov    %rax,%rdi
  8004205d83:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  8004205d8a:	00 00 00 
  8004205d8d:	ff d0                	callq  *%rax
  8004205d8f:	85 c0                	test   %eax,%eax
  8004205d91:	78 35                	js     8004205dc8 <page_check+0x5c8>
  8004205d93:	48 b9 a8 89 21 04 80 	movabs $0x80042189a8,%rcx
  8004205d9a:	00 00 00 
  8004205d9d:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205da4:	00 00 00 
  8004205da7:	be 16 05 00 00       	mov    $0x516,%esi
  8004205dac:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205db3:	00 00 00 
  8004205db6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205dbb:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205dc2:	00 00 00 
  8004205dc5:	41 ff d0             	callq  *%r8
	page_free(pp2);
  8004205dc8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205dcc:	48 89 c7             	mov    %rax,%rdi
  8004205dcf:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004205dd6:	00 00 00 
  8004205dd9:	ff d0                	callq  *%rax
	page_free(pp3);
  8004205ddb:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205ddf:	48 89 c7             	mov    %rax,%rdi
  8004205de2:	48 b8 b1 31 20 04 80 	movabs $0x80042031b1,%rax
  8004205de9:	00 00 00 
  8004205dec:	ff d0                	callq  *%rax
	//cprintf("pp1 ref count = %d\n",pp1->pp_ref);
	//cprintf("pp0 ref count = %d\n",pp0->pp_ref);
	//cprintf("pp2 ref count = %d\n",pp2->pp_ref);
	assert(page_insert(boot_pml4e, pp1, 0x0, 0) == 0);
  8004205dee:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004205df5:	00 00 00 
  8004205df8:	48 8b 00             	mov    (%rax),%rax
  8004205dfb:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004205dff:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004205e04:	ba 00 00 00 00       	mov    $0x0,%edx
  8004205e09:	48 89 c7             	mov    %rax,%rdi
  8004205e0c:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  8004205e13:	00 00 00 
  8004205e16:	ff d0                	callq  *%rax
  8004205e18:	85 c0                	test   %eax,%eax
  8004205e1a:	74 35                	je     8004205e51 <page_check+0x651>
  8004205e1c:	48 b9 d8 89 21 04 80 	movabs $0x80042189d8,%rcx
  8004205e23:	00 00 00 
  8004205e26:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205e2d:	00 00 00 
  8004205e30:	be 1c 05 00 00       	mov    $0x51c,%esi
  8004205e35:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205e3c:	00 00 00 
  8004205e3f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205e44:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205e4b:	00 00 00 
  8004205e4e:	41 ff d0             	callq  *%r8
	assert((PTE_ADDR(boot_pml4e[0]) == page2pa(pp0) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp2) || PTE_ADDR(boot_pml4e[0]) == page2pa(pp3) ));
  8004205e51:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004205e58:	00 00 00 
  8004205e5b:	48 8b 00             	mov    (%rax),%rax
  8004205e5e:	48 8b 00             	mov    (%rax),%rax
  8004205e61:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205e67:	48 89 c3             	mov    %rax,%rbx
  8004205e6a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205e6e:	48 89 c7             	mov    %rax,%rdi
  8004205e71:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004205e78:	00 00 00 
  8004205e7b:	ff d0                	callq  *%rax
  8004205e7d:	48 39 c3             	cmp    %rax,%rbx
  8004205e80:	0f 84 97 00 00 00    	je     8004205f1d <page_check+0x71d>
  8004205e86:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004205e8d:	00 00 00 
  8004205e90:	48 8b 00             	mov    (%rax),%rax
  8004205e93:	48 8b 00             	mov    (%rax),%rax
  8004205e96:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205e9c:	48 89 c3             	mov    %rax,%rbx
  8004205e9f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004205ea3:	48 89 c7             	mov    %rax,%rdi
  8004205ea6:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004205ead:	00 00 00 
  8004205eb0:	ff d0                	callq  *%rax
  8004205eb2:	48 39 c3             	cmp    %rax,%rbx
  8004205eb5:	74 66                	je     8004205f1d <page_check+0x71d>
  8004205eb7:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004205ebe:	00 00 00 
  8004205ec1:	48 8b 00             	mov    (%rax),%rax
  8004205ec4:	48 8b 00             	mov    (%rax),%rax
  8004205ec7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004205ecd:	48 89 c3             	mov    %rax,%rbx
  8004205ed0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004205ed4:	48 89 c7             	mov    %rax,%rdi
  8004205ed7:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004205ede:	00 00 00 
  8004205ee1:	ff d0                	callq  *%rax
  8004205ee3:	48 39 c3             	cmp    %rax,%rbx
  8004205ee6:	74 35                	je     8004205f1d <page_check+0x71d>
  8004205ee8:	48 b9 08 8a 21 04 80 	movabs $0x8004218a08,%rcx
  8004205eef:	00 00 00 
  8004205ef2:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205ef9:	00 00 00 
  8004205efc:	be 1d 05 00 00       	mov    $0x51d,%esi
  8004205f01:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205f08:	00 00 00 
  8004205f0b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f10:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205f17:	00 00 00 
  8004205f1a:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, 0x0) == page2pa(pp1));
  8004205f1d:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004205f24:	00 00 00 
  8004205f27:	48 8b 00             	mov    (%rax),%rax
  8004205f2a:	be 00 00 00 00       	mov    $0x0,%esi
  8004205f2f:	48 89 c7             	mov    %rax,%rdi
  8004205f32:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  8004205f39:	00 00 00 
  8004205f3c:	ff d0                	callq  *%rax
  8004205f3e:	48 89 c3             	mov    %rax,%rbx
  8004205f41:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205f45:	48 89 c7             	mov    %rax,%rdi
  8004205f48:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004205f4f:	00 00 00 
  8004205f52:	ff d0                	callq  *%rax
  8004205f54:	48 39 c3             	cmp    %rax,%rbx
  8004205f57:	74 35                	je     8004205f8e <page_check+0x78e>
  8004205f59:	48 b9 90 8a 21 04 80 	movabs $0x8004218a90,%rcx
  8004205f60:	00 00 00 
  8004205f63:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205f6a:	00 00 00 
  8004205f6d:	be 1e 05 00 00       	mov    $0x51e,%esi
  8004205f72:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205f79:	00 00 00 
  8004205f7c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205f81:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205f88:	00 00 00 
  8004205f8b:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004205f8e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004205f92:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205f96:	66 83 f8 01          	cmp    $0x1,%ax
  8004205f9a:	74 35                	je     8004205fd1 <page_check+0x7d1>
  8004205f9c:	48 b9 bd 8a 21 04 80 	movabs $0x8004218abd,%rcx
  8004205fa3:	00 00 00 
  8004205fa6:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205fad:	00 00 00 
  8004205fb0:	be 1f 05 00 00       	mov    $0x51f,%esi
  8004205fb5:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205fbc:	00 00 00 
  8004205fbf:	b8 00 00 00 00       	mov    $0x0,%eax
  8004205fc4:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004205fcb:	00 00 00 
  8004205fce:	41 ff d0             	callq  *%r8
	assert(pp0->pp_ref == 1);
  8004205fd1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004205fd5:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004205fd9:	66 83 f8 01          	cmp    $0x1,%ax
  8004205fdd:	74 35                	je     8004206014 <page_check+0x814>
  8004205fdf:	48 b9 ce 8a 21 04 80 	movabs $0x8004218ace,%rcx
  8004205fe6:	00 00 00 
  8004205fe9:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004205ff0:	00 00 00 
  8004205ff3:	be 20 05 00 00       	mov    $0x520,%esi
  8004205ff8:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004205fff:	00 00 00 
  8004206002:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206007:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420600e:	00 00 00 
  8004206011:	41 ff d0             	callq  *%r8
	assert(pp2->pp_ref == 1);
  8004206014:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206018:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420601c:	66 83 f8 01          	cmp    $0x1,%ax
  8004206020:	74 35                	je     8004206057 <page_check+0x857>
  8004206022:	48 b9 df 8a 21 04 80 	movabs $0x8004218adf,%rcx
  8004206029:	00 00 00 
  800420602c:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206033:	00 00 00 
  8004206036:	be 21 05 00 00       	mov    $0x521,%esi
  800420603b:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206042:	00 00 00 
  8004206045:	b8 00 00 00 00       	mov    $0x0,%eax
  800420604a:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206051:	00 00 00 
  8004206054:	41 ff d0             	callq  *%r8
	//should be able to map pp3 at PGSIZE because pp0 is already allocated for page table
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  8004206057:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  800420605e:	00 00 00 
  8004206061:	48 8b 00             	mov    (%rax),%rax
  8004206064:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004206068:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420606d:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206072:	48 89 c7             	mov    %rax,%rdi
  8004206075:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  800420607c:	00 00 00 
  800420607f:	ff d0                	callq  *%rax
  8004206081:	85 c0                	test   %eax,%eax
  8004206083:	74 35                	je     80042060ba <page_check+0x8ba>
  8004206085:	48 b9 f0 8a 21 04 80 	movabs $0x8004218af0,%rcx
  800420608c:	00 00 00 
  800420608f:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206096:	00 00 00 
  8004206099:	be 23 05 00 00       	mov    $0x523,%esi
  800420609e:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042060a5:	00 00 00 
  80042060a8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042060ad:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042060b4:	00 00 00 
  80042060b7:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  80042060ba:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042060c1:	00 00 00 
  80042060c4:	48 8b 00             	mov    (%rax),%rax
  80042060c7:	be 00 10 00 00       	mov    $0x1000,%esi
  80042060cc:	48 89 c7             	mov    %rax,%rdi
  80042060cf:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  80042060d6:	00 00 00 
  80042060d9:	ff d0                	callq  *%rax
  80042060db:	48 89 c3             	mov    %rax,%rbx
  80042060de:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042060e2:	48 89 c7             	mov    %rax,%rdi
  80042060e5:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  80042060ec:	00 00 00 
  80042060ef:	ff d0                	callq  *%rax
  80042060f1:	48 39 c3             	cmp    %rax,%rbx
  80042060f4:	74 35                	je     800420612b <page_check+0x92b>
  80042060f6:	48 b9 28 8b 21 04 80 	movabs $0x8004218b28,%rcx
  80042060fd:	00 00 00 
  8004206100:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206107:	00 00 00 
  800420610a:	be 24 05 00 00       	mov    $0x524,%esi
  800420610f:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206116:	00 00 00 
  8004206119:	b8 00 00 00 00       	mov    $0x0,%eax
  800420611e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206125:	00 00 00 
  8004206128:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420612b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420612f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206133:	66 83 f8 02          	cmp    $0x2,%ax
  8004206137:	74 35                	je     800420616e <page_check+0x96e>
  8004206139:	48 b9 58 8b 21 04 80 	movabs $0x8004218b58,%rcx
  8004206140:	00 00 00 
  8004206143:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420614a:	00 00 00 
  800420614d:	be 25 05 00 00       	mov    $0x525,%esi
  8004206152:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206159:	00 00 00 
  800420615c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206161:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206168:	00 00 00 
  800420616b:	41 ff d0             	callq  *%r8

	// should be no free memory
	assert(!page_alloc(0));
  800420616e:	bf 00 00 00 00       	mov    $0x0,%edi
  8004206173:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  800420617a:	00 00 00 
  800420617d:	ff d0                	callq  *%rax
  800420617f:	48 85 c0             	test   %rax,%rax
  8004206182:	74 35                	je     80042061b9 <page_check+0x9b9>
  8004206184:	48 b9 77 86 21 04 80 	movabs $0x8004218677,%rcx
  800420618b:	00 00 00 
  800420618e:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206195:	00 00 00 
  8004206198:	be 28 05 00 00       	mov    $0x528,%esi
  800420619d:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042061a4:	00 00 00 
  80042061a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80042061ac:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042061b3:	00 00 00 
  80042061b6:	41 ff d0             	callq  *%r8

	// should be able to map pp3 at PGSIZE because it's already there
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, 0) == 0);
  80042061b9:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042061c0:	00 00 00 
  80042061c3:	48 8b 00             	mov    (%rax),%rax
  80042061c6:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042061ca:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042061cf:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042061d4:	48 89 c7             	mov    %rax,%rdi
  80042061d7:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  80042061de:	00 00 00 
  80042061e1:	ff d0                	callq  *%rax
  80042061e3:	85 c0                	test   %eax,%eax
  80042061e5:	74 35                	je     800420621c <page_check+0xa1c>
  80042061e7:	48 b9 f0 8a 21 04 80 	movabs $0x8004218af0,%rcx
  80042061ee:	00 00 00 
  80042061f1:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042061f8:	00 00 00 
  80042061fb:	be 2b 05 00 00       	mov    $0x52b,%esi
  8004206200:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206207:	00 00 00 
  800420620a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420620f:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206216:	00 00 00 
  8004206219:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420621c:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206223:	00 00 00 
  8004206226:	48 8b 00             	mov    (%rax),%rax
  8004206229:	be 00 10 00 00       	mov    $0x1000,%esi
  800420622e:	48 89 c7             	mov    %rax,%rdi
  8004206231:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  8004206238:	00 00 00 
  800420623b:	ff d0                	callq  *%rax
  800420623d:	48 89 c3             	mov    %rax,%rbx
  8004206240:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206244:	48 89 c7             	mov    %rax,%rdi
  8004206247:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  800420624e:	00 00 00 
  8004206251:	ff d0                	callq  *%rax
  8004206253:	48 39 c3             	cmp    %rax,%rbx
  8004206256:	74 35                	je     800420628d <page_check+0xa8d>
  8004206258:	48 b9 28 8b 21 04 80 	movabs $0x8004218b28,%rcx
  800420625f:	00 00 00 
  8004206262:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206269:	00 00 00 
  800420626c:	be 2c 05 00 00       	mov    $0x52c,%esi
  8004206271:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206278:	00 00 00 
  800420627b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206280:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206287:	00 00 00 
  800420628a:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  800420628d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206291:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206295:	66 83 f8 02          	cmp    $0x2,%ax
  8004206299:	74 35                	je     80042062d0 <page_check+0xad0>
  800420629b:	48 b9 58 8b 21 04 80 	movabs $0x8004218b58,%rcx
  80042062a2:	00 00 00 
  80042062a5:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042062ac:	00 00 00 
  80042062af:	be 2d 05 00 00       	mov    $0x52d,%esi
  80042062b4:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042062bb:	00 00 00 
  80042062be:	b8 00 00 00 00       	mov    $0x0,%eax
  80042062c3:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042062ca:	00 00 00 
  80042062cd:	41 ff d0             	callq  *%r8

	// pp3 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));
  80042062d0:	bf 00 00 00 00       	mov    $0x0,%edi
  80042062d5:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  80042062dc:	00 00 00 
  80042062df:	ff d0                	callq  *%rax
  80042062e1:	48 85 c0             	test   %rax,%rax
  80042062e4:	74 35                	je     800420631b <page_check+0xb1b>
  80042062e6:	48 b9 77 86 21 04 80 	movabs $0x8004218677,%rcx
  80042062ed:	00 00 00 
  80042062f0:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042062f7:	00 00 00 
  80042062fa:	be 31 05 00 00       	mov    $0x531,%esi
  80042062ff:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206306:	00 00 00 
  8004206309:	b8 00 00 00 00       	mov    $0x0,%eax
  800420630e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206315:	00 00 00 
  8004206318:	41 ff d0             	callq  *%r8
	// check that pgdir_walk returns a pointer to the pte
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(PGSIZE)]));
  800420631b:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206322:	00 00 00 
  8004206325:	48 8b 00             	mov    (%rax),%rax
  8004206328:	48 8b 00             	mov    (%rax),%rax
  800420632b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206331:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  8004206335:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206339:	48 c1 e8 0c          	shr    $0xc,%rax
  800420633d:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  8004206340:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004206343:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  800420634a:	00 00 00 
  800420634d:	48 8b 00             	mov    (%rax),%rax
  8004206350:	48 39 c2             	cmp    %rax,%rdx
  8004206353:	72 32                	jb     8004206387 <page_check+0xb87>
  8004206355:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206359:	48 89 c1             	mov    %rax,%rcx
  800420635c:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004206363:	00 00 00 
  8004206366:	be 33 05 00 00       	mov    $0x533,%esi
  800420636b:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206372:	00 00 00 
  8004206375:	b8 00 00 00 00       	mov    $0x0,%eax
  800420637a:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206381:	00 00 00 
  8004206384:	41 ff d0             	callq  *%r8
  8004206387:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420638e:	00 00 00 
  8004206391:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004206395:	48 01 d0             	add    %rdx,%rax
  8004206398:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde = KADDR(PTE_ADDR(pdpe[PDPE(PGSIZE)]));
  800420639c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042063a0:	48 8b 00             	mov    (%rax),%rax
  80042063a3:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042063a9:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  80042063ad:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042063b1:	48 c1 e8 0c          	shr    $0xc,%rax
  80042063b5:	89 45 8c             	mov    %eax,-0x74(%rbp)
  80042063b8:	8b 55 8c             	mov    -0x74(%rbp),%edx
  80042063bb:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042063c2:	00 00 00 
  80042063c5:	48 8b 00             	mov    (%rax),%rax
  80042063c8:	48 39 c2             	cmp    %rax,%rdx
  80042063cb:	72 32                	jb     80042063ff <page_check+0xbff>
  80042063cd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042063d1:	48 89 c1             	mov    %rax,%rcx
  80042063d4:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  80042063db:	00 00 00 
  80042063de:	be 34 05 00 00       	mov    $0x534,%esi
  80042063e3:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042063ea:	00 00 00 
  80042063ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042063f2:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042063f9:	00 00 00 
  80042063fc:	41 ff d0             	callq  *%r8
  80042063ff:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206406:	00 00 00 
  8004206409:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800420640d:	48 01 d0             	add    %rdx,%rax
  8004206410:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep = KADDR(PTE_ADDR(pde[PDX(PGSIZE)]));
  8004206414:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206418:	48 8b 00             	mov    (%rax),%rax
  800420641b:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206421:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004206428:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420642f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206433:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
  8004206439:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
  800420643f:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004206446:	00 00 00 
  8004206449:	48 8b 00             	mov    (%rax),%rax
  800420644c:	48 39 c2             	cmp    %rax,%rdx
  800420644f:	72 35                	jb     8004206486 <page_check+0xc86>
  8004206451:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206458:	48 89 c1             	mov    %rax,%rcx
  800420645b:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004206462:	00 00 00 
  8004206465:	be 35 05 00 00       	mov    $0x535,%esi
  800420646a:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206471:	00 00 00 
  8004206474:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206479:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206480:	00 00 00 
  8004206483:	41 ff d0             	callq  *%r8
  8004206486:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420648d:	00 00 00 
  8004206490:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004206497:	48 01 d0             	add    %rdx,%rax
  800420649a:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	assert(pml4e_walk(boot_pml4e, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));
  80042064a1:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042064a8:	00 00 00 
  80042064ab:	48 8b 00             	mov    (%rax),%rax
  80042064ae:	ba 00 00 00 00       	mov    $0x0,%edx
  80042064b3:	be 00 10 00 00       	mov    $0x1000,%esi
  80042064b8:	48 89 c7             	mov    %rax,%rdi
  80042064bb:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  80042064c2:	00 00 00 
  80042064c5:	ff d0                	callq  *%rax
  80042064c7:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
  80042064ce:	48 83 c2 08          	add    $0x8,%rdx
  80042064d2:	48 39 d0             	cmp    %rdx,%rax
  80042064d5:	74 35                	je     800420650c <page_check+0xd0c>
  80042064d7:	48 b9 70 8b 21 04 80 	movabs $0x8004218b70,%rcx
  80042064de:	00 00 00 
  80042064e1:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042064e8:	00 00 00 
  80042064eb:	be 36 05 00 00       	mov    $0x536,%esi
  80042064f0:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042064f7:	00 00 00 
  80042064fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042064ff:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206506:	00 00 00 
  8004206509:	41 ff d0             	callq  *%r8

	// should be able to change permissions too.
	assert(page_insert(boot_pml4e, pp3, (void*) PGSIZE, PTE_U) == 0);
  800420650c:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206513:	00 00 00 
  8004206516:	48 8b 00             	mov    (%rax),%rax
  8004206519:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800420651d:	b9 04 00 00 00       	mov    $0x4,%ecx
  8004206522:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206527:	48 89 c7             	mov    %rax,%rdi
  800420652a:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  8004206531:	00 00 00 
  8004206534:	ff d0                	callq  *%rax
  8004206536:	85 c0                	test   %eax,%eax
  8004206538:	74 35                	je     800420656f <page_check+0xd6f>
  800420653a:	48 b9 b0 8b 21 04 80 	movabs $0x8004218bb0,%rcx
  8004206541:	00 00 00 
  8004206544:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420654b:	00 00 00 
  800420654e:	be 39 05 00 00       	mov    $0x539,%esi
  8004206553:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420655a:	00 00 00 
  800420655d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206562:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206569:	00 00 00 
  800420656c:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp3));
  800420656f:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206576:	00 00 00 
  8004206579:	48 8b 00             	mov    (%rax),%rax
  800420657c:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206581:	48 89 c7             	mov    %rax,%rdi
  8004206584:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  800420658b:	00 00 00 
  800420658e:	ff d0                	callq  *%rax
  8004206590:	48 89 c3             	mov    %rax,%rbx
  8004206593:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206597:	48 89 c7             	mov    %rax,%rdi
  800420659a:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  80042065a1:	00 00 00 
  80042065a4:	ff d0                	callq  *%rax
  80042065a6:	48 39 c3             	cmp    %rax,%rbx
  80042065a9:	74 35                	je     80042065e0 <page_check+0xde0>
  80042065ab:	48 b9 28 8b 21 04 80 	movabs $0x8004218b28,%rcx
  80042065b2:	00 00 00 
  80042065b5:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042065bc:	00 00 00 
  80042065bf:	be 3a 05 00 00       	mov    $0x53a,%esi
  80042065c4:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042065cb:	00 00 00 
  80042065ce:	b8 00 00 00 00       	mov    $0x0,%eax
  80042065d3:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042065da:	00 00 00 
  80042065dd:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 2);
  80042065e0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042065e4:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042065e8:	66 83 f8 02          	cmp    $0x2,%ax
  80042065ec:	74 35                	je     8004206623 <page_check+0xe23>
  80042065ee:	48 b9 58 8b 21 04 80 	movabs $0x8004218b58,%rcx
  80042065f5:	00 00 00 
  80042065f8:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042065ff:	00 00 00 
  8004206602:	be 3b 05 00 00       	mov    $0x53b,%esi
  8004206607:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420660e:	00 00 00 
  8004206611:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206616:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420661d:	00 00 00 
  8004206620:	41 ff d0             	callq  *%r8
	assert(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U);
  8004206623:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  800420662a:	00 00 00 
  800420662d:	48 8b 00             	mov    (%rax),%rax
  8004206630:	ba 00 00 00 00       	mov    $0x0,%edx
  8004206635:	be 00 10 00 00       	mov    $0x1000,%esi
  800420663a:	48 89 c7             	mov    %rax,%rdi
  800420663d:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  8004206644:	00 00 00 
  8004206647:	ff d0                	callq  *%rax
  8004206649:	48 8b 00             	mov    (%rax),%rax
  800420664c:	83 e0 04             	and    $0x4,%eax
  800420664f:	48 85 c0             	test   %rax,%rax
  8004206652:	75 35                	jne    8004206689 <page_check+0xe89>
  8004206654:	48 b9 f0 8b 21 04 80 	movabs $0x8004218bf0,%rcx
  800420665b:	00 00 00 
  800420665e:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206665:	00 00 00 
  8004206668:	be 3c 05 00 00       	mov    $0x53c,%esi
  800420666d:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206674:	00 00 00 
  8004206677:	b8 00 00 00 00       	mov    $0x0,%eax
  800420667c:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206683:	00 00 00 
  8004206686:	41 ff d0             	callq  *%r8
	assert(boot_pml4e[0] & PTE_U);
  8004206689:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206690:	00 00 00 
  8004206693:	48 8b 00             	mov    (%rax),%rax
  8004206696:	48 8b 00             	mov    (%rax),%rax
  8004206699:	83 e0 04             	and    $0x4,%eax
  800420669c:	48 85 c0             	test   %rax,%rax
  800420669f:	75 35                	jne    80042066d6 <page_check+0xed6>
  80042066a1:	48 b9 23 8c 21 04 80 	movabs $0x8004218c23,%rcx
  80042066a8:	00 00 00 
  80042066ab:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042066b2:	00 00 00 
  80042066b5:	be 3d 05 00 00       	mov    $0x53d,%esi
  80042066ba:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042066c1:	00 00 00 
  80042066c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042066c9:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042066d0:	00 00 00 
  80042066d3:	41 ff d0             	callq  *%r8


	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(boot_pml4e, pp0, (void*) PTSIZE, 0) < 0);
  80042066d6:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042066dd:	00 00 00 
  80042066e0:	48 8b 00             	mov    (%rax),%rax
  80042066e3:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042066e7:	b9 00 00 00 00       	mov    $0x0,%ecx
  80042066ec:	ba 00 00 20 00       	mov    $0x200000,%edx
  80042066f1:	48 89 c7             	mov    %rax,%rdi
  80042066f4:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  80042066fb:	00 00 00 
  80042066fe:	ff d0                	callq  *%rax
  8004206700:	85 c0                	test   %eax,%eax
  8004206702:	78 35                	js     8004206739 <page_check+0xf39>
  8004206704:	48 b9 40 8c 21 04 80 	movabs $0x8004218c40,%rcx
  800420670b:	00 00 00 
  800420670e:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206715:	00 00 00 
  8004206718:	be 41 05 00 00       	mov    $0x541,%esi
  800420671d:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206724:	00 00 00 
  8004206727:	b8 00 00 00 00       	mov    $0x0,%eax
  800420672c:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206733:	00 00 00 
  8004206736:	41 ff d0             	callq  *%r8

	// insert pp1 at PGSIZE (replacing pp3)
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206739:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206740:	00 00 00 
  8004206743:	48 8b 00             	mov    (%rax),%rax
  8004206746:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420674a:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420674f:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206754:	48 89 c7             	mov    %rax,%rdi
  8004206757:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  800420675e:	00 00 00 
  8004206761:	ff d0                	callq  *%rax
  8004206763:	85 c0                	test   %eax,%eax
  8004206765:	74 35                	je     800420679c <page_check+0xf9c>
  8004206767:	48 b9 78 8c 21 04 80 	movabs $0x8004218c78,%rcx
  800420676e:	00 00 00 
  8004206771:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206778:	00 00 00 
  800420677b:	be 44 05 00 00       	mov    $0x544,%esi
  8004206780:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206787:	00 00 00 
  800420678a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420678f:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206796:	00 00 00 
  8004206799:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) PGSIZE, 0) & PTE_U));
  800420679c:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042067a3:	00 00 00 
  80042067a6:	48 8b 00             	mov    (%rax),%rax
  80042067a9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042067ae:	be 00 10 00 00       	mov    $0x1000,%esi
  80042067b3:	48 89 c7             	mov    %rax,%rdi
  80042067b6:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  80042067bd:	00 00 00 
  80042067c0:	ff d0                	callq  *%rax
  80042067c2:	48 8b 00             	mov    (%rax),%rax
  80042067c5:	83 e0 04             	and    $0x4,%eax
  80042067c8:	48 85 c0             	test   %rax,%rax
  80042067cb:	74 35                	je     8004206802 <page_check+0x1002>
  80042067cd:	48 b9 b0 8c 21 04 80 	movabs $0x8004218cb0,%rcx
  80042067d4:	00 00 00 
  80042067d7:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042067de:	00 00 00 
  80042067e1:	be 45 05 00 00       	mov    $0x545,%esi
  80042067e6:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042067ed:	00 00 00 
  80042067f0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042067f5:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042067fc:	00 00 00 
  80042067ff:	41 ff d0             	callq  *%r8

	// should have pp1 at both 0 and PGSIZE
	assert(check_va2pa(boot_pml4e, 0) == page2pa(pp1));
  8004206802:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206809:	00 00 00 
  800420680c:	48 8b 00             	mov    (%rax),%rax
  800420680f:	be 00 00 00 00       	mov    $0x0,%esi
  8004206814:	48 89 c7             	mov    %rax,%rdi
  8004206817:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  800420681e:	00 00 00 
  8004206821:	ff d0                	callq  *%rax
  8004206823:	48 89 c3             	mov    %rax,%rbx
  8004206826:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420682a:	48 89 c7             	mov    %rax,%rdi
  800420682d:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004206834:	00 00 00 
  8004206837:	ff d0                	callq  *%rax
  8004206839:	48 39 c3             	cmp    %rax,%rbx
  800420683c:	74 35                	je     8004206873 <page_check+0x1073>
  800420683e:	48 b9 e8 8c 21 04 80 	movabs $0x8004218ce8,%rcx
  8004206845:	00 00 00 
  8004206848:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420684f:	00 00 00 
  8004206852:	be 48 05 00 00       	mov    $0x548,%esi
  8004206857:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420685e:	00 00 00 
  8004206861:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206866:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420686d:	00 00 00 
  8004206870:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  8004206873:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  800420687a:	00 00 00 
  800420687d:	48 8b 00             	mov    (%rax),%rax
  8004206880:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206885:	48 89 c7             	mov    %rax,%rdi
  8004206888:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  800420688f:	00 00 00 
  8004206892:	ff d0                	callq  *%rax
  8004206894:	48 89 c3             	mov    %rax,%rbx
  8004206897:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420689b:	48 89 c7             	mov    %rax,%rdi
  800420689e:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  80042068a5:	00 00 00 
  80042068a8:	ff d0                	callq  *%rax
  80042068aa:	48 39 c3             	cmp    %rax,%rbx
  80042068ad:	74 35                	je     80042068e4 <page_check+0x10e4>
  80042068af:	48 b9 18 8d 21 04 80 	movabs $0x8004218d18,%rcx
  80042068b6:	00 00 00 
  80042068b9:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042068c0:	00 00 00 
  80042068c3:	be 49 05 00 00       	mov    $0x549,%esi
  80042068c8:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042068cf:	00 00 00 
  80042068d2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042068d7:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042068de:	00 00 00 
  80042068e1:	41 ff d0             	callq  *%r8
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
  80042068e4:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042068e8:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042068ec:	66 83 f8 02          	cmp    $0x2,%ax
  80042068f0:	74 35                	je     8004206927 <page_check+0x1127>
  80042068f2:	48 b9 48 8d 21 04 80 	movabs $0x8004218d48,%rcx
  80042068f9:	00 00 00 
  80042068fc:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206903:	00 00 00 
  8004206906:	be 4b 05 00 00       	mov    $0x54b,%esi
  800420690b:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206912:	00 00 00 
  8004206915:	b8 00 00 00 00       	mov    $0x0,%eax
  800420691a:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206921:	00 00 00 
  8004206924:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206927:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420692b:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  800420692f:	66 83 f8 01          	cmp    $0x1,%ax
  8004206933:	74 35                	je     800420696a <page_check+0x116a>
  8004206935:	48 b9 59 8d 21 04 80 	movabs $0x8004218d59,%rcx
  800420693c:	00 00 00 
  800420693f:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206946:	00 00 00 
  8004206949:	be 4c 05 00 00       	mov    $0x54c,%esi
  800420694e:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206955:	00 00 00 
  8004206958:	b8 00 00 00 00       	mov    $0x0,%eax
  800420695d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206964:	00 00 00 
  8004206967:	41 ff d0             	callq  *%r8


	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(boot_pml4e, 0x0);
  800420696a:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206971:	00 00 00 
  8004206974:	48 8b 00             	mov    (%rax),%rax
  8004206977:	be 00 00 00 00       	mov    $0x0,%esi
  800420697c:	48 89 c7             	mov    %rax,%rdi
  800420697f:	48 b8 18 3b 20 04 80 	movabs $0x8004203b18,%rax
  8004206986:	00 00 00 
  8004206989:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  800420698b:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206992:	00 00 00 
  8004206995:	48 8b 00             	mov    (%rax),%rax
  8004206998:	be 00 00 00 00       	mov    $0x0,%esi
  800420699d:	48 89 c7             	mov    %rax,%rdi
  80042069a0:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  80042069a7:	00 00 00 
  80042069aa:	ff d0                	callq  *%rax
  80042069ac:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  80042069b0:	74 35                	je     80042069e7 <page_check+0x11e7>
  80042069b2:	48 b9 70 8d 21 04 80 	movabs $0x8004218d70,%rcx
  80042069b9:	00 00 00 
  80042069bc:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042069c3:	00 00 00 
  80042069c6:	be 51 05 00 00       	mov    $0x551,%esi
  80042069cb:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042069d2:	00 00 00 
  80042069d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042069da:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042069e1:	00 00 00 
  80042069e4:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == page2pa(pp1));
  80042069e7:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042069ee:	00 00 00 
  80042069f1:	48 8b 00             	mov    (%rax),%rax
  80042069f4:	be 00 10 00 00       	mov    $0x1000,%esi
  80042069f9:	48 89 c7             	mov    %rax,%rdi
  80042069fc:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  8004206a03:	00 00 00 
  8004206a06:	ff d0                	callq  *%rax
  8004206a08:	48 89 c3             	mov    %rax,%rbx
  8004206a0b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a0f:	48 89 c7             	mov    %rax,%rdi
  8004206a12:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004206a19:	00 00 00 
  8004206a1c:	ff d0                	callq  *%rax
  8004206a1e:	48 39 c3             	cmp    %rax,%rbx
  8004206a21:	74 35                	je     8004206a58 <page_check+0x1258>
  8004206a23:	48 b9 18 8d 21 04 80 	movabs $0x8004218d18,%rcx
  8004206a2a:	00 00 00 
  8004206a2d:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206a34:	00 00 00 
  8004206a37:	be 52 05 00 00       	mov    $0x552,%esi
  8004206a3c:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206a43:	00 00 00 
  8004206a46:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a4b:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206a52:	00 00 00 
  8004206a55:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 1);
  8004206a58:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206a5c:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206a60:	66 83 f8 01          	cmp    $0x1,%ax
  8004206a64:	74 35                	je     8004206a9b <page_check+0x129b>
  8004206a66:	48 b9 bd 8a 21 04 80 	movabs $0x8004218abd,%rcx
  8004206a6d:	00 00 00 
  8004206a70:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206a77:	00 00 00 
  8004206a7a:	be 53 05 00 00       	mov    $0x553,%esi
  8004206a7f:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206a86:	00 00 00 
  8004206a89:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206a8e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206a95:	00 00 00 
  8004206a98:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206a9b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206a9f:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206aa3:	66 83 f8 01          	cmp    $0x1,%ax
  8004206aa7:	74 35                	je     8004206ade <page_check+0x12de>
  8004206aa9:	48 b9 59 8d 21 04 80 	movabs $0x8004218d59,%rcx
  8004206ab0:	00 00 00 
  8004206ab3:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206aba:	00 00 00 
  8004206abd:	be 54 05 00 00       	mov    $0x554,%esi
  8004206ac2:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206ac9:	00 00 00 
  8004206acc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206ad1:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206ad8:	00 00 00 
  8004206adb:	41 ff d0             	callq  *%r8

	// Test re-inserting pp1 at PGSIZE.
	// Thanks to Varun Agrawal for suggesting this test case.
	assert(page_insert(boot_pml4e, pp1, (void*) PGSIZE, 0) == 0);
  8004206ade:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206ae5:	00 00 00 
  8004206ae8:	48 8b 00             	mov    (%rax),%rax
  8004206aeb:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004206aef:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004206af4:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004206af9:	48 89 c7             	mov    %rax,%rdi
  8004206afc:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  8004206b03:	00 00 00 
  8004206b06:	ff d0                	callq  *%rax
  8004206b08:	85 c0                	test   %eax,%eax
  8004206b0a:	74 35                	je     8004206b41 <page_check+0x1341>
  8004206b0c:	48 b9 78 8c 21 04 80 	movabs $0x8004218c78,%rcx
  8004206b13:	00 00 00 
  8004206b16:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206b1d:	00 00 00 
  8004206b20:	be 58 05 00 00       	mov    $0x558,%esi
  8004206b25:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206b2c:	00 00 00 
  8004206b2f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b34:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206b3b:	00 00 00 
  8004206b3e:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref);
  8004206b41:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b45:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206b49:	66 85 c0             	test   %ax,%ax
  8004206b4c:	75 35                	jne    8004206b83 <page_check+0x1383>
  8004206b4e:	48 b9 93 8d 21 04 80 	movabs $0x8004218d93,%rcx
  8004206b55:	00 00 00 
  8004206b58:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206b5f:	00 00 00 
  8004206b62:	be 59 05 00 00       	mov    $0x559,%esi
  8004206b67:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206b6e:	00 00 00 
  8004206b71:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206b76:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206b7d:	00 00 00 
  8004206b80:	41 ff d0             	callq  *%r8
	assert(pp1->pp_link == NULL);
  8004206b83:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206b87:	48 8b 00             	mov    (%rax),%rax
  8004206b8a:	48 85 c0             	test   %rax,%rax
  8004206b8d:	74 35                	je     8004206bc4 <page_check+0x13c4>
  8004206b8f:	48 b9 9f 8d 21 04 80 	movabs $0x8004218d9f,%rcx
  8004206b96:	00 00 00 
  8004206b99:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206ba0:	00 00 00 
  8004206ba3:	be 5a 05 00 00       	mov    $0x55a,%esi
  8004206ba8:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206baf:	00 00 00 
  8004206bb2:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206bb7:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206bbe:	00 00 00 
  8004206bc1:	41 ff d0             	callq  *%r8

	// unmapping pp1 at PGSIZE should free it
	page_remove(boot_pml4e, (void*) PGSIZE);
  8004206bc4:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206bcb:	00 00 00 
  8004206bce:	48 8b 00             	mov    (%rax),%rax
  8004206bd1:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206bd6:	48 89 c7             	mov    %rax,%rdi
  8004206bd9:	48 b8 18 3b 20 04 80 	movabs $0x8004203b18,%rax
  8004206be0:	00 00 00 
  8004206be3:	ff d0                	callq  *%rax
	assert(check_va2pa(boot_pml4e, 0x0) == ~0);
  8004206be5:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206bec:	00 00 00 
  8004206bef:	48 8b 00             	mov    (%rax),%rax
  8004206bf2:	be 00 00 00 00       	mov    $0x0,%esi
  8004206bf7:	48 89 c7             	mov    %rax,%rdi
  8004206bfa:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  8004206c01:	00 00 00 
  8004206c04:	ff d0                	callq  *%rax
  8004206c06:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206c0a:	74 35                	je     8004206c41 <page_check+0x1441>
  8004206c0c:	48 b9 70 8d 21 04 80 	movabs $0x8004218d70,%rcx
  8004206c13:	00 00 00 
  8004206c16:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206c1d:	00 00 00 
  8004206c20:	be 5e 05 00 00       	mov    $0x55e,%esi
  8004206c25:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206c2c:	00 00 00 
  8004206c2f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c34:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206c3b:	00 00 00 
  8004206c3e:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, PGSIZE) == ~0);
  8004206c41:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206c48:	00 00 00 
  8004206c4b:	48 8b 00             	mov    (%rax),%rax
  8004206c4e:	be 00 10 00 00       	mov    $0x1000,%esi
  8004206c53:	48 89 c7             	mov    %rax,%rdi
  8004206c56:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  8004206c5d:	00 00 00 
  8004206c60:	ff d0                	callq  *%rax
  8004206c62:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004206c66:	74 35                	je     8004206c9d <page_check+0x149d>
  8004206c68:	48 b9 b8 8d 21 04 80 	movabs $0x8004218db8,%rcx
  8004206c6f:	00 00 00 
  8004206c72:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206c79:	00 00 00 
  8004206c7c:	be 5f 05 00 00       	mov    $0x55f,%esi
  8004206c81:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206c88:	00 00 00 
  8004206c8b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206c90:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206c97:	00 00 00 
  8004206c9a:	41 ff d0             	callq  *%r8
	assert(pp1->pp_ref == 0);
  8004206c9d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004206ca1:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206ca5:	66 85 c0             	test   %ax,%ax
  8004206ca8:	74 35                	je     8004206cdf <page_check+0x14df>
  8004206caa:	48 b9 de 8d 21 04 80 	movabs $0x8004218dde,%rcx
  8004206cb1:	00 00 00 
  8004206cb4:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206cbb:	00 00 00 
  8004206cbe:	be 60 05 00 00       	mov    $0x560,%esi
  8004206cc3:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206cca:	00 00 00 
  8004206ccd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206cd2:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206cd9:	00 00 00 
  8004206cdc:	41 ff d0             	callq  *%r8
	assert(pp3->pp_ref == 1);
  8004206cdf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206ce3:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206ce7:	66 83 f8 01          	cmp    $0x1,%ax
  8004206ceb:	74 35                	je     8004206d22 <page_check+0x1522>
  8004206ced:	48 b9 59 8d 21 04 80 	movabs $0x8004218d59,%rcx
  8004206cf4:	00 00 00 
  8004206cf7:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206cfe:	00 00 00 
  8004206d01:	be 61 05 00 00       	mov    $0x561,%esi
  8004206d06:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206d0d:	00 00 00 
  8004206d10:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d15:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206d1c:	00 00 00 
  8004206d1f:	41 ff d0             	callq  *%r8
	page_remove(boot_pgdir, 0x0);
	assert(pp2->pp_ref == 0);
#endif

	// forcibly take pp3 back
	assert(PTE_ADDR(boot_pml4e[0]) == page2pa(pp3));
  8004206d22:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206d29:	00 00 00 
  8004206d2c:	48 8b 00             	mov    (%rax),%rax
  8004206d2f:	48 8b 00             	mov    (%rax),%rax
  8004206d32:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206d38:	48 89 c3             	mov    %rax,%rbx
  8004206d3b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206d3f:	48 89 c7             	mov    %rax,%rdi
  8004206d42:	48 b8 5a 1d 20 04 80 	movabs $0x8004201d5a,%rax
  8004206d49:	00 00 00 
  8004206d4c:	ff d0                	callq  *%rax
  8004206d4e:	48 39 c3             	cmp    %rax,%rbx
  8004206d51:	74 35                	je     8004206d88 <page_check+0x1588>
  8004206d53:	48 b9 f0 8d 21 04 80 	movabs $0x8004218df0,%rcx
  8004206d5a:	00 00 00 
  8004206d5d:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206d64:	00 00 00 
  8004206d67:	be 75 05 00 00       	mov    $0x575,%esi
  8004206d6c:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206d73:	00 00 00 
  8004206d76:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206d7b:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206d82:	00 00 00 
  8004206d85:	41 ff d0             	callq  *%r8
	boot_pml4e[0] = 0;
  8004206d88:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206d8f:	00 00 00 
  8004206d92:	48 8b 00             	mov    (%rax),%rax
  8004206d95:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	assert(pp3->pp_ref == 1);
  8004206d9c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206da0:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004206da4:	66 83 f8 01          	cmp    $0x1,%ax
  8004206da8:	74 35                	je     8004206ddf <page_check+0x15df>
  8004206daa:	48 b9 59 8d 21 04 80 	movabs $0x8004218d59,%rcx
  8004206db1:	00 00 00 
  8004206db4:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004206dbb:	00 00 00 
  8004206dbe:	be 77 05 00 00       	mov    $0x577,%esi
  8004206dc3:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206dca:	00 00 00 
  8004206dcd:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206dd2:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206dd9:	00 00 00 
  8004206ddc:	41 ff d0             	callq  *%r8
	page_decref(pp3);
  8004206ddf:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004206de3:	48 89 c7             	mov    %rax,%rdi
  8004206de6:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  8004206ded:	00 00 00 
  8004206df0:	ff d0                	callq  *%rax
	// check pointer arithmetic in pml4e_walk
	page_decref(pp0);
  8004206df2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004206df6:	48 89 c7             	mov    %rax,%rdi
  8004206df9:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  8004206e00:	00 00 00 
  8004206e03:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004206e05:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004206e09:	48 89 c7             	mov    %rax,%rdi
  8004206e0c:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  8004206e13:	00 00 00 
  8004206e16:	ff d0                	callq  *%rax
	va = (void*)(PGSIZE * 100);
  8004206e18:	48 c7 85 68 ff ff ff 	movq   $0x64000,-0x98(%rbp)
  8004206e1f:	00 40 06 00 
	ptep = pml4e_walk(boot_pml4e, va, 1);
  8004206e23:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206e2a:	00 00 00 
  8004206e2d:	48 8b 00             	mov    (%rax),%rax
  8004206e30:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
  8004206e37:	ba 01 00 00 00       	mov    $0x1,%edx
  8004206e3c:	48 89 ce             	mov    %rcx,%rsi
  8004206e3f:	48 89 c7             	mov    %rax,%rdi
  8004206e42:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  8004206e49:	00 00 00 
  8004206e4c:	ff d0                	callq  *%rax
  8004206e4e:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	pdpe = KADDR(PTE_ADDR(boot_pml4e[PML4(va)]));
  8004206e55:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004206e5c:	00 00 00 
  8004206e5f:	48 8b 00             	mov    (%rax),%rax
  8004206e62:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
  8004206e69:	48 c1 ea 27          	shr    $0x27,%rdx
  8004206e6d:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
  8004206e73:	48 c1 e2 03          	shl    $0x3,%rdx
  8004206e77:	48 01 d0             	add    %rdx,%rax
  8004206e7a:	48 8b 00             	mov    (%rax),%rax
  8004206e7d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206e83:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  8004206e8a:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206e91:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206e95:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
  8004206e9b:	8b 95 5c ff ff ff    	mov    -0xa4(%rbp),%edx
  8004206ea1:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004206ea8:	00 00 00 
  8004206eab:	48 8b 00             	mov    (%rax),%rax
  8004206eae:	48 39 c2             	cmp    %rax,%rdx
  8004206eb1:	72 35                	jb     8004206ee8 <page_check+0x16e8>
  8004206eb3:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206eba:	48 89 c1             	mov    %rax,%rcx
  8004206ebd:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004206ec4:	00 00 00 
  8004206ec7:	be 7e 05 00 00       	mov    $0x57e,%esi
  8004206ecc:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206ed3:	00 00 00 
  8004206ed6:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206edb:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206ee2:	00 00 00 
  8004206ee5:	41 ff d0             	callq  *%r8
  8004206ee8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206eef:	00 00 00 
  8004206ef2:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004206ef9:	48 01 d0             	add    %rdx,%rax
  8004206efc:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[PDPE(va)]));
  8004206f00:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206f07:	48 c1 e8 1e          	shr    $0x1e,%rax
  8004206f0b:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206f10:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206f17:	00 
  8004206f18:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004206f1c:	48 01 d0             	add    %rdx,%rax
  8004206f1f:	48 8b 00             	mov    (%rax),%rax
  8004206f22:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206f28:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  8004206f2f:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206f36:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206f3a:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
  8004206f40:	8b 95 4c ff ff ff    	mov    -0xb4(%rbp),%edx
  8004206f46:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004206f4d:	00 00 00 
  8004206f50:	48 8b 00             	mov    (%rax),%rax
  8004206f53:	48 39 c2             	cmp    %rax,%rdx
  8004206f56:	72 35                	jb     8004206f8d <page_check+0x178d>
  8004206f58:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206f5f:	48 89 c1             	mov    %rax,%rcx
  8004206f62:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004206f69:	00 00 00 
  8004206f6c:	be 7f 05 00 00       	mov    $0x57f,%esi
  8004206f71:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004206f78:	00 00 00 
  8004206f7b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004206f80:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004206f87:	00 00 00 
  8004206f8a:	41 ff d0             	callq  *%r8
  8004206f8d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004206f94:	00 00 00 
  8004206f97:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004206f9e:	48 01 d0             	add    %rdx,%rax
  8004206fa1:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep1 = KADDR(PTE_ADDR(pde[PDX(va)]));
  8004206fa5:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004206fac:	48 c1 e8 15          	shr    $0x15,%rax
  8004206fb0:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004206fb5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004206fbc:	00 
  8004206fbd:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004206fc1:	48 01 d0             	add    %rdx,%rax
  8004206fc4:	48 8b 00             	mov    (%rax),%rax
  8004206fc7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004206fcd:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  8004206fd4:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004206fdb:	48 c1 e8 0c          	shr    $0xc,%rax
  8004206fdf:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
  8004206fe5:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
  8004206feb:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004206ff2:	00 00 00 
  8004206ff5:	48 8b 00             	mov    (%rax),%rax
  8004206ff8:	48 39 c2             	cmp    %rax,%rdx
  8004206ffb:	72 35                	jb     8004207032 <page_check+0x1832>
  8004206ffd:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004207004:	48 89 c1             	mov    %rax,%rcx
  8004207007:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  800420700e:	00 00 00 
  8004207011:	be 80 05 00 00       	mov    $0x580,%esi
  8004207016:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420701d:	00 00 00 
  8004207020:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207025:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420702c:	00 00 00 
  800420702f:	41 ff d0             	callq  *%r8
  8004207032:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207039:	00 00 00 
  800420703c:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004207043:	48 01 d0             	add    %rdx,%rax
  8004207046:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
	assert(ptep == ptep1 + PTX(va));
  800420704d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004207054:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207058:	25 ff 01 00 00       	and    $0x1ff,%eax
  800420705d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004207064:	00 
  8004207065:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  800420706c:	48 01 c2             	add    %rax,%rdx
  800420706f:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  8004207076:	48 39 c2             	cmp    %rax,%rdx
  8004207079:	74 35                	je     80042070b0 <page_check+0x18b0>
  800420707b:	48 b9 18 8e 21 04 80 	movabs $0x8004218e18,%rcx
  8004207082:	00 00 00 
  8004207085:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420708c:	00 00 00 
  800420708f:	be 81 05 00 00       	mov    $0x581,%esi
  8004207094:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420709b:	00 00 00 
  800420709e:	b8 00 00 00 00       	mov    $0x0,%eax
  80042070a3:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042070aa:	00 00 00 
  80042070ad:	41 ff d0             	callq  *%r8

	// check that new page tables get cleared
	page_decref(pp4);
  80042070b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042070b4:	48 89 c7             	mov    %rax,%rdi
  80042070b7:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  80042070be:	00 00 00 
  80042070c1:	ff d0                	callq  *%rax
	memset(page2kva(pp4), 0xFF, PGSIZE);
  80042070c3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042070c7:	48 89 c7             	mov    %rax,%rdi
  80042070ca:	48 b8 f0 1d 20 04 80 	movabs $0x8004201df0,%rax
  80042070d1:	00 00 00 
  80042070d4:	ff d0                	callq  *%rax
  80042070d6:	ba 00 10 00 00       	mov    $0x1000,%edx
  80042070db:	be ff 00 00 00       	mov    $0xff,%esi
  80042070e0:	48 89 c7             	mov    %rax,%rdi
  80042070e3:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  80042070ea:	00 00 00 
  80042070ed:	ff d0                	callq  *%rax
	pml4e_walk(boot_pml4e, 0x0, 1);
  80042070ef:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042070f6:	00 00 00 
  80042070f9:	48 8b 00             	mov    (%rax),%rax
  80042070fc:	ba 01 00 00 00       	mov    $0x1,%edx
  8004207101:	be 00 00 00 00       	mov    $0x0,%esi
  8004207106:	48 89 c7             	mov    %rax,%rdi
  8004207109:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  8004207110:	00 00 00 
  8004207113:	ff d0                	callq  *%rax
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
  8004207115:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  800420711c:	00 00 00 
  800420711f:	48 8b 00             	mov    (%rax),%rax
  8004207122:	48 8b 00             	mov    (%rax),%rax
  8004207125:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420712b:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004207132:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207139:	48 c1 e8 0c          	shr    $0xc,%rax
  800420713d:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
  8004207143:	8b 95 24 ff ff ff    	mov    -0xdc(%rbp),%edx
  8004207149:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004207150:	00 00 00 
  8004207153:	48 8b 00             	mov    (%rax),%rax
  8004207156:	48 39 c2             	cmp    %rax,%rdx
  8004207159:	72 35                	jb     8004207190 <page_check+0x1990>
  800420715b:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004207162:	48 89 c1             	mov    %rax,%rcx
  8004207165:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  800420716c:	00 00 00 
  800420716f:	be 87 05 00 00       	mov    $0x587,%esi
  8004207174:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420717b:	00 00 00 
  800420717e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207183:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420718a:	00 00 00 
  800420718d:	41 ff d0             	callq  *%r8
  8004207190:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207197:	00 00 00 
  800420719a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  80042071a1:	48 01 d0             	add    %rdx,%rax
  80042071a4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
	pde  = KADDR(PTE_ADDR(pdpe[0]));
  80042071a8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042071ac:	48 8b 00             	mov    (%rax),%rax
  80042071af:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042071b5:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  80042071bc:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042071c3:	48 c1 e8 0c          	shr    $0xc,%rax
  80042071c7:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
  80042071cd:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
  80042071d3:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042071da:	00 00 00 
  80042071dd:	48 8b 00             	mov    (%rax),%rax
  80042071e0:	48 39 c2             	cmp    %rax,%rdx
  80042071e3:	72 35                	jb     800420721a <page_check+0x1a1a>
  80042071e5:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042071ec:	48 89 c1             	mov    %rax,%rcx
  80042071ef:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  80042071f6:	00 00 00 
  80042071f9:	be 88 05 00 00       	mov    $0x588,%esi
  80042071fe:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004207205:	00 00 00 
  8004207208:	b8 00 00 00 00       	mov    $0x0,%eax
  800420720d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004207214:	00 00 00 
  8004207217:	41 ff d0             	callq  *%r8
  800420721a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207221:	00 00 00 
  8004207224:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  800420722b:	48 01 d0             	add    %rdx,%rax
  800420722e:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	ptep  = KADDR(PTE_ADDR(pde[0]));
  8004207232:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004207236:	48 8b 00             	mov    (%rax),%rax
  8004207239:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  800420723f:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004207246:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420724d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207251:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
  8004207257:	8b 95 04 ff ff ff    	mov    -0xfc(%rbp),%edx
  800420725d:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004207264:	00 00 00 
  8004207267:	48 8b 00             	mov    (%rax),%rax
  800420726a:	48 39 c2             	cmp    %rax,%rdx
  800420726d:	72 35                	jb     80042072a4 <page_check+0x1aa4>
  800420726f:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004207276:	48 89 c1             	mov    %rax,%rcx
  8004207279:	48 ba 58 81 21 04 80 	movabs $0x8004218158,%rdx
  8004207280:	00 00 00 
  8004207283:	be 89 05 00 00       	mov    $0x589,%esi
  8004207288:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  800420728f:	00 00 00 
  8004207292:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207297:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420729e:	00 00 00 
  80042072a1:	41 ff d0             	callq  *%r8
  80042072a4:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042072ab:	00 00 00 
  80042072ae:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042072b5:	48 01 d0             	add    %rdx,%rax
  80042072b8:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
	for(i=0; i<NPTENTRIES; i++)
  80042072bf:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042072c6:	eb 58                	jmp    8004207320 <page_check+0x1b20>
		assert((ptep[i] & PTE_P) == 0);
  80042072c8:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
  80042072cf:	8b 55 ec             	mov    -0x14(%rbp),%edx
  80042072d2:	48 63 d2             	movslq %edx,%rdx
  80042072d5:	48 c1 e2 03          	shl    $0x3,%rdx
  80042072d9:	48 01 d0             	add    %rdx,%rax
  80042072dc:	48 8b 00             	mov    (%rax),%rax
  80042072df:	83 e0 01             	and    $0x1,%eax
  80042072e2:	48 85 c0             	test   %rax,%rax
  80042072e5:	74 35                	je     800420731c <page_check+0x1b1c>
  80042072e7:	48 b9 30 8e 21 04 80 	movabs $0x8004218e30,%rcx
  80042072ee:	00 00 00 
  80042072f1:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042072f8:	00 00 00 
  80042072fb:	be 8b 05 00 00       	mov    $0x58b,%esi
  8004207300:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004207307:	00 00 00 
  800420730a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420730f:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004207316:	00 00 00 
  8004207319:	41 ff d0             	callq  *%r8
	memset(page2kva(pp4), 0xFF, PGSIZE);
	pml4e_walk(boot_pml4e, 0x0, 1);
	pdpe = KADDR(PTE_ADDR(boot_pml4e[0]));
	pde  = KADDR(PTE_ADDR(pdpe[0]));
	ptep  = KADDR(PTE_ADDR(pde[0]));
	for(i=0; i<NPTENTRIES; i++)
  800420731c:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004207320:	81 7d ec ff 01 00 00 	cmpl   $0x1ff,-0x14(%rbp)
  8004207327:	7e 9f                	jle    80042072c8 <page_check+0x1ac8>
		assert((ptep[i] & PTE_P) == 0);
	boot_pml4e[0] = 0;
  8004207329:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004207330:	00 00 00 
  8004207333:	48 8b 00             	mov    (%rax),%rax
  8004207336:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	// give free list back
	page_free_list = fl;
  800420733d:	48 b8 38 82 37 04 80 	movabs $0x8004378238,%rax
  8004207344:	00 00 00 
  8004207347:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420734b:	48 89 10             	mov    %rdx,(%rax)

	// free the pages we took
	page_decref(pp0);
  800420734e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004207352:	48 89 c7             	mov    %rax,%rdi
  8004207355:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  800420735c:	00 00 00 
  800420735f:	ff d0                	callq  *%rax
	page_decref(pp1);
  8004207361:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004207365:	48 89 c7             	mov    %rax,%rdi
  8004207368:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  800420736f:	00 00 00 
  8004207372:	ff d0                	callq  *%rax
	page_decref(pp2);
  8004207374:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207378:	48 89 c7             	mov    %rax,%rdi
  800420737b:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  8004207382:	00 00 00 
  8004207385:	ff d0                	callq  *%rax

	// test mmio_map_region
	mm1 = (uintptr_t) mmio_map_region(0, 4097);
  8004207387:	be 01 10 00 00       	mov    $0x1001,%esi
  800420738c:	bf 00 00 00 00       	mov    $0x0,%edi
  8004207391:	48 b8 75 3c 20 04 80 	movabs $0x8004203c75,%rax
  8004207398:	00 00 00 
  800420739b:	ff d0                	callq  *%rax
  800420739d:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
	mm2 = (uintptr_t) mmio_map_region(0, 4096);
  80042073a4:	be 00 10 00 00       	mov    $0x1000,%esi
  80042073a9:	bf 00 00 00 00       	mov    $0x0,%edi
  80042073ae:	48 b8 75 3c 20 04 80 	movabs $0x8004203c75,%rax
  80042073b5:	00 00 00 
  80042073b8:	ff d0                	callq  *%rax
  80042073ba:	48 89 85 f0 fe ff ff 	mov    %rax,-0x110(%rbp)
	// check that they're in the right region
	assert(mm1 >= MMIOBASE && mm1 + 8096 < MMIOLIM);
  80042073c1:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  80042073c8:	00 00 00 
  80042073cb:	48 39 85 f8 fe ff ff 	cmp    %rax,-0x108(%rbp)
  80042073d2:	76 1d                	jbe    80042073f1 <page_check+0x1bf1>
  80042073d4:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042073db:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  80042073e2:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  80042073e9:	00 00 00 
  80042073ec:	48 39 c2             	cmp    %rax,%rdx
  80042073ef:	76 35                	jbe    8004207426 <page_check+0x1c26>
  80042073f1:	48 b9 48 8e 21 04 80 	movabs $0x8004218e48,%rcx
  80042073f8:	00 00 00 
  80042073fb:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004207402:	00 00 00 
  8004207405:	be 9a 05 00 00       	mov    $0x59a,%esi
  800420740a:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004207411:	00 00 00 
  8004207414:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207419:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004207420:	00 00 00 
  8004207423:	41 ff d0             	callq  *%r8
	assert(mm2 >= MMIOBASE && mm2 + 8096 < MMIOLIM);
  8004207426:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420742d:	00 00 00 
  8004207430:	48 39 85 f0 fe ff ff 	cmp    %rax,-0x110(%rbp)
  8004207437:	76 1d                	jbe    8004207456 <page_check+0x1c56>
  8004207439:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  8004207440:	48 8d 90 a0 1f 00 00 	lea    0x1fa0(%rax),%rdx
  8004207447:	48 b8 ff ff df 03 80 	movabs $0x8003dfffff,%rax
  800420744e:	00 00 00 
  8004207451:	48 39 c2             	cmp    %rax,%rdx
  8004207454:	76 35                	jbe    800420748b <page_check+0x1c8b>
  8004207456:	48 b9 70 8e 21 04 80 	movabs $0x8004218e70,%rcx
  800420745d:	00 00 00 
  8004207460:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004207467:	00 00 00 
  800420746a:	be 9b 05 00 00       	mov    $0x59b,%esi
  800420746f:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004207476:	00 00 00 
  8004207479:	b8 00 00 00 00       	mov    $0x0,%eax
  800420747e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004207485:	00 00 00 
  8004207488:	41 ff d0             	callq  *%r8
	// check that they're page-aligned
	assert(mm1 % PGSIZE == 0 && mm2 % PGSIZE == 0);
  800420748b:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207492:	25 ff 0f 00 00       	and    $0xfff,%eax
  8004207497:	48 85 c0             	test   %rax,%rax
  800420749a:	75 11                	jne    80042074ad <page_check+0x1cad>
  800420749c:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  80042074a3:	25 ff 0f 00 00       	and    $0xfff,%eax
  80042074a8:	48 85 c0             	test   %rax,%rax
  80042074ab:	74 35                	je     80042074e2 <page_check+0x1ce2>
  80042074ad:	48 b9 98 8e 21 04 80 	movabs $0x8004218e98,%rcx
  80042074b4:	00 00 00 
  80042074b7:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042074be:	00 00 00 
  80042074c1:	be 9d 05 00 00       	mov    $0x59d,%esi
  80042074c6:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042074cd:	00 00 00 
  80042074d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042074d5:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042074dc:	00 00 00 
  80042074df:	41 ff d0             	callq  *%r8
	// check that they don't overlap
	assert(mm1 + 8096 <= mm2);
  80042074e2:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042074e9:	48 05 a0 1f 00 00    	add    $0x1fa0,%rax
  80042074ef:	48 3b 85 f0 fe ff ff 	cmp    -0x110(%rbp),%rax
  80042074f6:	76 35                	jbe    800420752d <page_check+0x1d2d>
  80042074f8:	48 b9 bf 8e 21 04 80 	movabs $0x8004218ebf,%rcx
  80042074ff:	00 00 00 
  8004207502:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004207509:	00 00 00 
  800420750c:	be 9f 05 00 00       	mov    $0x59f,%esi
  8004207511:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004207518:	00 00 00 
  800420751b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207520:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004207527:	00 00 00 
  800420752a:	41 ff d0             	callq  *%r8
	// check page mappings

	assert(check_va2pa(boot_pml4e, mm1) == 0);
  800420752d:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004207534:	00 00 00 
  8004207537:	48 8b 00             	mov    (%rax),%rax
  800420753a:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004207541:	48 89 d6             	mov    %rdx,%rsi
  8004207544:	48 89 c7             	mov    %rax,%rdi
  8004207547:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  800420754e:	00 00 00 
  8004207551:	ff d0                	callq  *%rax
  8004207553:	48 85 c0             	test   %rax,%rax
  8004207556:	74 35                	je     800420758d <page_check+0x1d8d>
  8004207558:	48 b9 d8 8e 21 04 80 	movabs $0x8004218ed8,%rcx
  800420755f:	00 00 00 
  8004207562:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004207569:	00 00 00 
  800420756c:	be a2 05 00 00       	mov    $0x5a2,%esi
  8004207571:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004207578:	00 00 00 
  800420757b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207580:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004207587:	00 00 00 
  800420758a:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm1+PGSIZE) == PGSIZE);
  800420758d:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004207594:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  800420759b:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042075a2:	00 00 00 
  80042075a5:	48 8b 00             	mov    (%rax),%rax
  80042075a8:	48 89 d6             	mov    %rdx,%rsi
  80042075ab:	48 89 c7             	mov    %rax,%rdi
  80042075ae:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  80042075b5:	00 00 00 
  80042075b8:	ff d0                	callq  *%rax
  80042075ba:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  80042075c0:	74 35                	je     80042075f7 <page_check+0x1df7>
  80042075c2:	48 b9 00 8f 21 04 80 	movabs $0x8004218f00,%rcx
  80042075c9:	00 00 00 
  80042075cc:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  80042075d3:	00 00 00 
  80042075d6:	be a3 05 00 00       	mov    $0x5a3,%esi
  80042075db:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042075e2:	00 00 00 
  80042075e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80042075ea:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042075f1:	00 00 00 
  80042075f4:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2) == 0);
  80042075f7:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042075fe:	00 00 00 
  8004207601:	48 8b 00             	mov    (%rax),%rax
  8004207604:	48 8b 95 f0 fe ff ff 	mov    -0x110(%rbp),%rdx
  800420760b:	48 89 d6             	mov    %rdx,%rsi
  800420760e:	48 89 c7             	mov    %rax,%rdi
  8004207611:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  8004207618:	00 00 00 
  800420761b:	ff d0                	callq  *%rax
  800420761d:	48 85 c0             	test   %rax,%rax
  8004207620:	74 35                	je     8004207657 <page_check+0x1e57>
  8004207622:	48 b9 30 8f 21 04 80 	movabs $0x8004218f30,%rcx
  8004207629:	00 00 00 
  800420762c:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004207633:	00 00 00 
  8004207636:	be a4 05 00 00       	mov    $0x5a4,%esi
  800420763b:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004207642:	00 00 00 
  8004207645:	b8 00 00 00 00       	mov    $0x0,%eax
  800420764a:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004207651:	00 00 00 
  8004207654:	41 ff d0             	callq  *%r8
	assert(check_va2pa(boot_pml4e, mm2+PGSIZE) == ~0);
  8004207657:	48 8b 85 f0 fe ff ff 	mov    -0x110(%rbp),%rax
  800420765e:	48 8d 90 00 10 00 00 	lea    0x1000(%rax),%rdx
  8004207665:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  800420766c:	00 00 00 
  800420766f:	48 8b 00             	mov    (%rax),%rax
  8004207672:	48 89 d6             	mov    %rdx,%rsi
  8004207675:	48 89 c7             	mov    %rax,%rdi
  8004207678:	48 b8 86 55 20 04 80 	movabs $0x8004205586,%rax
  800420767f:	00 00 00 
  8004207682:	ff d0                	callq  *%rax
  8004207684:	48 83 f8 ff          	cmp    $0xffffffffffffffff,%rax
  8004207688:	74 35                	je     80042076bf <page_check+0x1ebf>
  800420768a:	48 b9 58 8f 21 04 80 	movabs $0x8004218f58,%rcx
  8004207691:	00 00 00 
  8004207694:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  800420769b:	00 00 00 
  800420769e:	be a5 05 00 00       	mov    $0x5a5,%esi
  80042076a3:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  80042076aa:	00 00 00 
  80042076ad:	b8 00 00 00 00       	mov    $0x0,%eax
  80042076b2:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042076b9:	00 00 00 
  80042076bc:	41 ff d0             	callq  *%r8
	// check permissions
	assert(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & (PTE_W|PTE_PWT|PTE_PCD));
  80042076bf:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  80042076c6:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042076cd:	00 00 00 
  80042076d0:	48 8b 00             	mov    (%rax),%rax
  80042076d3:	ba 00 00 00 00       	mov    $0x0,%edx
  80042076d8:	48 89 ce             	mov    %rcx,%rsi
  80042076db:	48 89 c7             	mov    %rax,%rdi
  80042076de:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  80042076e5:	00 00 00 
  80042076e8:	ff d0                	callq  *%rax
  80042076ea:	48 8b 00             	mov    (%rax),%rax
  80042076ed:	83 e0 1a             	and    $0x1a,%eax
  80042076f0:	48 85 c0             	test   %rax,%rax
  80042076f3:	75 35                	jne    800420772a <page_check+0x1f2a>
  80042076f5:	48 b9 88 8f 21 04 80 	movabs $0x8004218f88,%rcx
  80042076fc:	00 00 00 
  80042076ff:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004207706:	00 00 00 
  8004207709:	be a7 05 00 00       	mov    $0x5a7,%esi
  800420770e:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004207715:	00 00 00 
  8004207718:	b8 00 00 00 00       	mov    $0x0,%eax
  800420771d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004207724:	00 00 00 
  8004207727:	41 ff d0             	callq  *%r8
	assert(!(*pml4e_walk(boot_pml4e, (void*) mm1, 0) & PTE_U));
  800420772a:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  8004207731:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004207738:	00 00 00 
  800420773b:	48 8b 00             	mov    (%rax),%rax
  800420773e:	ba 00 00 00 00       	mov    $0x0,%edx
  8004207743:	48 89 ce             	mov    %rcx,%rsi
  8004207746:	48 89 c7             	mov    %rax,%rdi
  8004207749:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  8004207750:	00 00 00 
  8004207753:	ff d0                	callq  *%rax
  8004207755:	48 8b 00             	mov    (%rax),%rax
  8004207758:	83 e0 04             	and    $0x4,%eax
  800420775b:	48 85 c0             	test   %rax,%rax
  800420775e:	74 35                	je     8004207795 <page_check+0x1f95>
  8004207760:	48 b9 d0 8f 21 04 80 	movabs $0x8004218fd0,%rcx
  8004207767:	00 00 00 
  800420776a:	48 ba d1 81 21 04 80 	movabs $0x80042181d1,%rdx
  8004207771:	00 00 00 
  8004207774:	be a8 05 00 00       	mov    $0x5a8,%esi
  8004207779:	48 bf e6 81 21 04 80 	movabs $0x80042181e6,%rdi
  8004207780:	00 00 00 
  8004207783:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207788:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420778f:	00 00 00 
  8004207792:	41 ff d0             	callq  *%r8
	// clear the mappings
	*pml4e_walk(boot_pml4e, (void*) mm1, 0) = 0;
  8004207795:	48 8b 8d f8 fe ff ff 	mov    -0x108(%rbp),%rcx
  800420779c:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042077a3:	00 00 00 
  80042077a6:	48 8b 00             	mov    (%rax),%rax
  80042077a9:	ba 00 00 00 00       	mov    $0x0,%edx
  80042077ae:	48 89 ce             	mov    %rcx,%rsi
  80042077b1:	48 89 c7             	mov    %rax,%rdi
  80042077b4:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  80042077bb:	00 00 00 
  80042077be:	ff d0                	callq  *%rax
  80042077c0:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm1 + PGSIZE, 0) = 0;
  80042077c7:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  80042077ce:	48 05 00 10 00 00    	add    $0x1000,%rax
  80042077d4:	48 89 c1             	mov    %rax,%rcx
  80042077d7:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  80042077de:	00 00 00 
  80042077e1:	48 8b 00             	mov    (%rax),%rax
  80042077e4:	ba 00 00 00 00       	mov    $0x0,%edx
  80042077e9:	48 89 ce             	mov    %rcx,%rsi
  80042077ec:	48 89 c7             	mov    %rax,%rdi
  80042077ef:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  80042077f6:	00 00 00 
  80042077f9:	ff d0                	callq  *%rax
  80042077fb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	*pml4e_walk(boot_pml4e, (void*) mm2, 0) = 0;
  8004207802:	48 8b 8d f0 fe ff ff 	mov    -0x110(%rbp),%rcx
  8004207809:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004207810:	00 00 00 
  8004207813:	48 8b 00             	mov    (%rax),%rax
  8004207816:	ba 00 00 00 00       	mov    $0x0,%edx
  800420781b:	48 89 ce             	mov    %rcx,%rsi
  800420781e:	48 89 c7             	mov    %rax,%rdi
  8004207821:	48 b8 8a 32 20 04 80 	movabs $0x800420328a,%rax
  8004207828:	00 00 00 
  800420782b:	ff d0                	callq  *%rax
  800420782d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)

	cprintf("check_page() succeeded!\n");
  8004207834:	48 bf 03 90 21 04 80 	movabs $0x8004219003,%rdi
  800420783b:	00 00 00 
  800420783e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207843:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420784a:	00 00 00 
  800420784d:	ff d2                	callq  *%rdx
}
  800420784f:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
  8004207856:	5b                   	pop    %rbx
  8004207857:	5d                   	pop    %rbp
  8004207858:	c3                   	retq   

0000008004207859 <page2ppn>:
int	user_mem_check(struct Env *env, const void *va, size_t len, int perm);
void	user_mem_assert(struct Env *env, const void *va, size_t len, int perm);

static inline ppn_t
page2ppn(struct PageInfo *pp)
{
  8004207859:	55                   	push   %rbp
  800420785a:	48 89 e5             	mov    %rsp,%rbp
  800420785d:	48 83 ec 08          	sub    $0x8,%rsp
  8004207861:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return pp - pages;
  8004207865:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207869:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004207870:	00 00 00 
  8004207873:	48 8b 00             	mov    (%rax),%rax
  8004207876:	48 29 c2             	sub    %rax,%rdx
  8004207879:	48 89 d0             	mov    %rdx,%rax
  800420787c:	48 c1 f8 04          	sar    $0x4,%rax
}
  8004207880:	c9                   	leaveq 
  8004207881:	c3                   	retq   

0000008004207882 <page2pa>:

static inline physaddr_t
page2pa(struct PageInfo *pp)
{
  8004207882:	55                   	push   %rbp
  8004207883:	48 89 e5             	mov    %rsp,%rbp
  8004207886:	48 83 ec 08          	sub    $0x8,%rsp
  800420788a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return page2ppn(pp) << PGSHIFT;
  800420788e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207892:	48 89 c7             	mov    %rax,%rdi
  8004207895:	48 b8 59 78 20 04 80 	movabs $0x8004207859,%rax
  800420789c:	00 00 00 
  800420789f:	ff d0                	callq  *%rax
  80042078a1:	48 c1 e0 0c          	shl    $0xc,%rax
}
  80042078a5:	c9                   	leaveq 
  80042078a6:	c3                   	retq   

00000080042078a7 <pa2page>:

static inline struct PageInfo*
pa2page(physaddr_t pa)
{
  80042078a7:	55                   	push   %rbp
  80042078a8:	48 89 e5             	mov    %rsp,%rbp
  80042078ab:	48 83 ec 10          	sub    $0x10,%rsp
  80042078af:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	if (PPN(pa) >= npages)
  80042078b3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042078b7:	48 c1 e8 0c          	shr    $0xc,%rax
  80042078bb:	48 89 c2             	mov    %rax,%rdx
  80042078be:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042078c5:	00 00 00 
  80042078c8:	48 8b 00             	mov    (%rax),%rax
  80042078cb:	48 39 c2             	cmp    %rax,%rdx
  80042078ce:	72 2a                	jb     80042078fa <pa2page+0x53>
		panic("pa2page called with invalid pa");
  80042078d0:	48 ba 20 90 21 04 80 	movabs $0x8004219020,%rdx
  80042078d7:	00 00 00 
  80042078da:	be 54 00 00 00       	mov    $0x54,%esi
  80042078df:	48 bf 3f 90 21 04 80 	movabs $0x800421903f,%rdi
  80042078e6:	00 00 00 
  80042078e9:	b8 00 00 00 00       	mov    $0x0,%eax
  80042078ee:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  80042078f5:	00 00 00 
  80042078f8:	ff d1                	callq  *%rcx
	return &pages[PPN(pa)];
  80042078fa:	48 b8 98 97 37 04 80 	movabs $0x8004379798,%rax
  8004207901:	00 00 00 
  8004207904:	48 8b 00             	mov    (%rax),%rax
  8004207907:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420790b:	48 c1 ea 0c          	shr    $0xc,%rdx
  800420790f:	48 c1 e2 04          	shl    $0x4,%rdx
  8004207913:	48 01 d0             	add    %rdx,%rax
}
  8004207916:	c9                   	leaveq 
  8004207917:	c3                   	retq   

0000008004207918 <page2kva>:

static inline void*
page2kva(struct PageInfo *pp)
{
  8004207918:	55                   	push   %rbp
  8004207919:	48 89 e5             	mov    %rsp,%rbp
  800420791c:	48 83 ec 20          	sub    $0x20,%rsp
  8004207920:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return KADDR(page2pa(pp));
  8004207924:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207928:	48 89 c7             	mov    %rax,%rdi
  800420792b:	48 b8 82 78 20 04 80 	movabs $0x8004207882,%rax
  8004207932:	00 00 00 
  8004207935:	ff d0                	callq  *%rax
  8004207937:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420793b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420793f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207943:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004207946:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004207949:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004207950:	00 00 00 
  8004207953:	48 8b 00             	mov    (%rax),%rax
  8004207956:	48 39 c2             	cmp    %rax,%rdx
  8004207959:	72 32                	jb     800420798d <page2kva+0x75>
  800420795b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420795f:	48 89 c1             	mov    %rax,%rcx
  8004207962:	48 ba 50 90 21 04 80 	movabs $0x8004219050,%rdx
  8004207969:	00 00 00 
  800420796c:	be 5b 00 00 00       	mov    $0x5b,%esi
  8004207971:	48 bf 3f 90 21 04 80 	movabs $0x800421903f,%rdi
  8004207978:	00 00 00 
  800420797b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207980:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004207987:	00 00 00 
  800420798a:	41 ff d0             	callq  *%r8
  800420798d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004207994:	00 00 00 
  8004207997:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420799b:	48 01 d0             	add    %rdx,%rax
}
  800420799e:	c9                   	leaveq 
  800420799f:	c3                   	retq   

00000080042079a0 <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  80042079a0:	55                   	push   %rbp
  80042079a1:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  80042079a4:	48 bf 40 b7 22 04 80 	movabs $0x800422b740,%rdi
  80042079ab:	00 00 00 
  80042079ae:	48 b8 ec 6e 21 04 80 	movabs $0x8004216eec,%rax
  80042079b5:	00 00 00 
  80042079b8:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  80042079ba:	f3 90                	pause  
}
  80042079bc:	5d                   	pop    %rbp
  80042079bd:	c3                   	retq   

00000080042079be <envid2env>:
//   On success, sets *env_store to the environment.
//   On error, sets *env_store to NULL.
//
int
envid2env(envid_t envid, struct Env **env_store, bool checkperm)
{
  80042079be:	55                   	push   %rbp
  80042079bf:	48 89 e5             	mov    %rsp,%rbp
  80042079c2:	53                   	push   %rbx
  80042079c3:	48 83 ec 28          	sub    $0x28,%rsp
  80042079c7:	89 7d dc             	mov    %edi,-0x24(%rbp)
  80042079ca:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042079ce:	89 d0                	mov    %edx,%eax
  80042079d0:	88 45 d8             	mov    %al,-0x28(%rbp)
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
  80042079d3:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  80042079d7:	75 41                	jne    8004207a1a <envid2env+0x5c>
		*env_store = curenv;
  80042079d9:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  80042079e0:	00 00 00 
  80042079e3:	ff d0                	callq  *%rax
  80042079e5:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  80042079ec:	00 00 00 
  80042079ef:	48 98                	cltq   
  80042079f1:	48 c1 e0 03          	shl    $0x3,%rax
  80042079f5:	48 89 c1             	mov    %rax,%rcx
  80042079f8:	48 c1 e1 04          	shl    $0x4,%rcx
  80042079fc:	48 01 c8             	add    %rcx,%rax
  80042079ff:	48 01 d0             	add    %rdx,%rax
  8004207a02:	48 83 c0 08          	add    $0x8,%rax
  8004207a06:	48 8b 10             	mov    (%rax),%rdx
  8004207a09:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207a0d:	48 89 10             	mov    %rdx,(%rax)
		return 0;
  8004207a10:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207a15:	e9 fd 00 00 00       	jmpq   8004207b17 <envid2env+0x159>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
  8004207a1a:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  8004207a21:	00 00 00 
  8004207a24:	48 8b 10             	mov    (%rax),%rdx
  8004207a27:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004207a2a:	48 98                	cltq   
  8004207a2c:	25 ff 03 00 00       	and    $0x3ff,%eax
  8004207a31:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207a38:	48 01 d0             	add    %rdx,%rax
  8004207a3b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
  8004207a3f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207a43:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004207a49:	85 c0                	test   %eax,%eax
  8004207a4b:	74 0f                	je     8004207a5c <envid2env+0x9e>
  8004207a4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207a51:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207a57:	3b 45 dc             	cmp    -0x24(%rbp),%eax
  8004207a5a:	74 15                	je     8004207a71 <envid2env+0xb3>
		*env_store = 0;
  8004207a5c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207a60:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207a67:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207a6c:	e9 a6 00 00 00       	jmpq   8004207b17 <envid2env+0x159>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	if (checkperm && e != curenv && e->env_parent_id != curenv->env_id) {
  8004207a71:	80 7d d8 00          	cmpb   $0x0,-0x28(%rbp)
  8004207a75:	0f 84 8c 00 00 00    	je     8004207b07 <envid2env+0x149>
  8004207a7b:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004207a82:	00 00 00 
  8004207a85:	ff d0                	callq  *%rax
  8004207a87:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004207a8e:	00 00 00 
  8004207a91:	48 98                	cltq   
  8004207a93:	48 c1 e0 03          	shl    $0x3,%rax
  8004207a97:	48 89 c1             	mov    %rax,%rcx
  8004207a9a:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207a9e:	48 01 c8             	add    %rcx,%rax
  8004207aa1:	48 01 d0             	add    %rdx,%rax
  8004207aa4:	48 83 c0 08          	add    $0x8,%rax
  8004207aa8:	48 8b 00             	mov    (%rax),%rax
  8004207aab:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004207aaf:	74 56                	je     8004207b07 <envid2env+0x149>
  8004207ab1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207ab5:	8b 98 cc 00 00 00    	mov    0xcc(%rax),%ebx
  8004207abb:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004207ac2:	00 00 00 
  8004207ac5:	ff d0                	callq  *%rax
  8004207ac7:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004207ace:	00 00 00 
  8004207ad1:	48 98                	cltq   
  8004207ad3:	48 c1 e0 03          	shl    $0x3,%rax
  8004207ad7:	48 89 c1             	mov    %rax,%rcx
  8004207ada:	48 c1 e1 04          	shl    $0x4,%rcx
  8004207ade:	48 01 c8             	add    %rcx,%rax
  8004207ae1:	48 01 d0             	add    %rdx,%rax
  8004207ae4:	48 83 c0 08          	add    $0x8,%rax
  8004207ae8:	48 8b 00             	mov    (%rax),%rax
  8004207aeb:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207af1:	39 c3                	cmp    %eax,%ebx
  8004207af3:	74 12                	je     8004207b07 <envid2env+0x149>
		*env_store = 0;
  8004207af5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207af9:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return -E_BAD_ENV;
  8004207b00:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8004207b05:	eb 10                	jmp    8004207b17 <envid2env+0x159>
	}

	*env_store = e;
  8004207b07:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207b0b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207b0f:	48 89 10             	mov    %rdx,(%rax)
	return 0;
  8004207b12:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207b17:	48 83 c4 28          	add    $0x28,%rsp
  8004207b1b:	5b                   	pop    %rbx
  8004207b1c:	5d                   	pop    %rbp
  8004207b1d:	c3                   	retq   

0000008004207b1e <env_init>:
// they are in the envs array (i.e., so that the first call to
// env_alloc() returns envs[0]).
//
void
env_init(void)
{
  8004207b1e:	55                   	push   %rbp
  8004207b1f:	48 89 e5             	mov    %rsp,%rbp
  8004207b22:	48 83 ec 10          	sub    $0x10,%rsp
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
  8004207b26:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  8004207b2d:	00 
	memset(envs, 0, NENV * sizeof(struct Env));
  8004207b2e:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  8004207b35:	00 00 00 
  8004207b38:	48 8b 00             	mov    (%rax),%rax
  8004207b3b:	ba 00 a0 05 00       	mov    $0x5a000,%edx
  8004207b40:	be 00 00 00 00       	mov    $0x0,%esi
  8004207b45:	48 89 c7             	mov    %rax,%rdi
  8004207b48:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004207b4f:	00 00 00 
  8004207b52:	ff d0                	callq  *%rax
	for (i = 0; i < NENV; i++) {
  8004207b54:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207b5b:	00 
  8004207b5c:	eb 7b                	jmp    8004207bd9 <env_init+0xbb>
		if(last)
  8004207b5e:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207b63:	74 28                	je     8004207b8d <env_init+0x6f>
			last->env_link = &envs[i];
  8004207b65:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  8004207b6c:	00 00 00 
  8004207b6f:	48 8b 10             	mov    (%rax),%rdx
  8004207b72:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b76:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207b7d:	48 01 c2             	add    %rax,%rdx
  8004207b80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207b84:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
  8004207b8b:	eb 28                	jmp    8004207bb5 <env_init+0x97>
		else
			env_free_list = &envs[i];
  8004207b8d:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  8004207b94:	00 00 00 
  8004207b97:	48 8b 10             	mov    (%rax),%rdx
  8004207b9a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207b9e:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207ba5:	48 01 c2             	add    %rax,%rdx
  8004207ba8:	48 b8 60 82 37 04 80 	movabs $0x8004378260,%rax
  8004207baf:	00 00 00 
  8004207bb2:	48 89 10             	mov    %rdx,(%rax)
		last = &envs[i];
  8004207bb5:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  8004207bbc:	00 00 00 
  8004207bbf:	48 8b 10             	mov    (%rax),%rdx
  8004207bc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207bc6:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004207bcd:	48 01 d0             	add    %rdx,%rax
  8004207bd0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// Set up envs array
	// LAB 3: Your code here.
	size_t i;
	struct Env* last = NULL;
	memset(envs, 0, NENV * sizeof(struct Env));
	for (i = 0; i < NENV; i++) {
  8004207bd4:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004207bd9:	48 81 7d f8 ff 03 00 	cmpq   $0x3ff,-0x8(%rbp)
  8004207be0:	00 
  8004207be1:	0f 86 77 ff ff ff    	jbe    8004207b5e <env_init+0x40>
		else
			env_free_list = &envs[i];
		last = &envs[i];
	}
	// Per-CPU part of the initialization
	env_init_percpu();
  8004207be7:	48 b8 f5 7b 20 04 80 	movabs $0x8004207bf5,%rax
  8004207bee:	00 00 00 
  8004207bf1:	ff d0                	callq  *%rax
}
  8004207bf3:	c9                   	leaveq 
  8004207bf4:	c3                   	retq   

0000008004207bf5 <env_init_percpu>:

// Load GDT and segment descriptors.
void
env_init_percpu(void)
{
  8004207bf5:	55                   	push   %rbp
  8004207bf6:	48 89 e5             	mov    %rsp,%rbp
  8004207bf9:	53                   	push   %rbx
  8004207bfa:	48 83 ec 10          	sub    $0x10,%rsp
  8004207bfe:	48 b8 48 b6 22 04 80 	movabs $0x800422b648,%rax
  8004207c05:	00 00 00 
  8004207c08:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}

    static __inline void
lgdt(void *p)
{
    __asm __volatile("lgdt (%0)" : : "r" (p));
  8004207c0c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207c10:	0f 01 10             	lgdt   (%rax)
	lgdt(&gdt_pd);

	// The kernel never uses GS or FS, so we leave those set to
	// the user data segment.
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
  8004207c13:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207c18:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
  8004207c1a:	b8 23 00 00 00       	mov    $0x23,%eax
  8004207c1f:	8e e0                	mov    %eax,%fs
	// The kernel does use ES, DS, and SS.  We'll change between
	// the kernel and user data segments as needed.
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
  8004207c21:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207c26:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
  8004207c28:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207c2d:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
  8004207c2f:	b8 10 00 00 00       	mov    $0x10,%eax
  8004207c34:	8e d0                	mov    %eax,%ss
	// Load the kernel text segment into CS.
	asm volatile("pushq %%rbx \n \t movabs $1f,%%rax \n \t pushq %%rax \n\t lretq \n 1:\n" :: "b" (GD_KT):"cc","memory");
  8004207c36:	b8 08 00 00 00       	mov    $0x8,%eax
  8004207c3b:	89 c3                	mov    %eax,%ebx
  8004207c3d:	53                   	push   %rbx
  8004207c3e:	48 b8 4b 7c 20 04 80 	movabs $0x8004207c4b,%rax
  8004207c45:	00 00 00 
  8004207c48:	50                   	push   %rax
  8004207c49:	48 cb                	lretq  
  8004207c4b:	66 c7 45 ee 00 00    	movw   $0x0,-0x12(%rbp)
}

    static __inline void
lldt(uint16_t sel)
{
    __asm __volatile("lldt %0" : : "r" (sel));
  8004207c51:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  8004207c55:	0f 00 d0             	lldt   %ax
	// For good measure, clear the local descriptor table (LDT),
	// since we don't use it.
	lldt(0);
}
  8004207c58:	48 83 c4 10          	add    $0x10,%rsp
  8004207c5c:	5b                   	pop    %rbx
  8004207c5d:	5d                   	pop    %rbp
  8004207c5e:	c3                   	retq   

0000008004207c5f <env_setup_vm>:
// Returns 0 on success, < 0 on error.  Errors include:
//	-E_NO_MEM if page directory or table could not be allocated.
//
static int
env_setup_vm(struct Env *e)
{
  8004207c5f:	55                   	push   %rbp
  8004207c60:	48 89 e5             	mov    %rsp,%rbp
  8004207c63:	48 83 ec 20          	sub    $0x20,%rsp
  8004207c67:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int r;
	int i;
	struct PageInfo *p = NULL;
  8004207c6b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004207c72:	00 

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
  8004207c73:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207c78:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004207c7f:	00 00 00 
  8004207c82:	ff d0                	callq  *%rax
  8004207c84:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004207c88:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004207c8d:	75 0a                	jne    8004207c99 <env_setup_vm+0x3a>
		return -E_NO_MEM;
  8004207c8f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  8004207c94:	e9 98 00 00 00       	jmpq   8004207d31 <env_setup_vm+0xd2>
	//    - The functions in kern/pmap.h are handy.

	// LAB 3: Your code here.

	//Increment page reference here
	p->pp_ref++;
  8004207c99:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207c9d:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004207ca1:	8d 50 01             	lea    0x1(%rax),%edx
  8004207ca4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207ca8:	66 89 50 08          	mov    %dx,0x8(%rax)

	//fill structure values
	e->env_pml4e = (pml4e_t *)page2kva(p);
  8004207cac:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207cb0:	48 89 c7             	mov    %rax,%rdi
  8004207cb3:	48 b8 18 79 20 04 80 	movabs $0x8004207918,%rax
  8004207cba:	00 00 00 
  8004207cbd:	ff d0                	callq  *%rax
  8004207cbf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207cc3:	48 89 82 e0 00 00 00 	mov    %rax,0xe0(%rdx)
	e->env_cr3= page2pa(p);
  8004207cca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207cce:	48 89 c7             	mov    %rax,%rdi
  8004207cd1:	48 b8 82 78 20 04 80 	movabs $0x8004207882,%rax
  8004207cd8:	00 00 00 
  8004207cdb:	ff d0                	callq  *%rax
  8004207cdd:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004207ce1:	48 89 82 e8 00 00 00 	mov    %rax,0xe8(%rdx)

	//copy kernel pml4e entries 
    //for (i = PML4(UTOP); i != NPDENTRIES; i++)
    //    e->env_pml4e[i] = boot_pml4e[i]|PTE_USER;
	
	e->env_pml4e[1] = boot_pml4e[1];
  8004207ce8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207cec:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207cf3:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004207cf7:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  8004207cfe:	00 00 00 
  8004207d01:	48 8b 00             	mov    (%rax),%rax
  8004207d04:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004207d08:	48 89 02             	mov    %rax,(%rdx)
	//cprintf("envpml4e[0] [%x],envpml4e[1] [%x], env cr3[%x] ,  UTOP [%x] PML4e1 [%x]",e->env_pml4e[0],e->env_pml4e[0], e->env_cr3, UTOP, PML4(UTOP));

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pml4e[PML4(UVPT)] = e->env_cr3 |PTE_P|PTE_W|PTE_U;
  8004207d0b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207d0f:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207d16:	48 8d 50 10          	lea    0x10(%rax),%rdx
  8004207d1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207d1e:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004207d25:	48 83 c8 07          	or     $0x7,%rax
  8004207d29:	48 89 02             	mov    %rax,(%rdx)

	return 0;
  8004207d2c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207d31:	c9                   	leaveq 
  8004207d32:	c3                   	retq   

0000008004207d33 <env_alloc>:
//	-E_NO_FREE_ENV if all NENVS environments are allocated
//	-E_NO_MEM on memory exhaustion
//
int
env_alloc(struct Env **newenv_store, envid_t parent_id)
{
  8004207d33:	55                   	push   %rbp
  8004207d34:	48 89 e5             	mov    %rsp,%rbp
  8004207d37:	48 83 ec 30          	sub    $0x30,%rsp
  8004207d3b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207d3f:	89 75 d4             	mov    %esi,-0x2c(%rbp)
	int32_t generation;
	int r;
	struct Env *e;

	if (!(e = env_free_list))
  8004207d42:	48 b8 60 82 37 04 80 	movabs $0x8004378260,%rax
  8004207d49:	00 00 00 
  8004207d4c:	48 8b 00             	mov    (%rax),%rax
  8004207d4f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004207d53:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  8004207d58:	75 0a                	jne    8004207d64 <env_alloc+0x31>
		return -E_NO_FREE_ENV;
  8004207d5a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8004207d5f:	e9 76 01 00 00       	jmpq   8004207eda <env_alloc+0x1a7>

	// Allocate and set up the page directory for this environment.
	if ((r = env_setup_vm(e)) < 0)
  8004207d64:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d68:	48 89 c7             	mov    %rax,%rdi
  8004207d6b:	48 b8 5f 7c 20 04 80 	movabs $0x8004207c5f,%rax
  8004207d72:	00 00 00 
  8004207d75:	ff d0                	callq  *%rax
  8004207d77:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004207d7a:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  8004207d7e:	79 08                	jns    8004207d88 <env_alloc+0x55>
		return r;
  8004207d80:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004207d83:	e9 52 01 00 00       	jmpq   8004207eda <env_alloc+0x1a7>

	// Generate an env_id for this environment.
	generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NENV - 1);
  8004207d88:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207d8c:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004207d92:	05 00 10 00 00       	add    $0x1000,%eax
  8004207d97:	25 00 fc ff ff       	and    $0xfffffc00,%eax
  8004207d9c:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (generation <= 0)	// Don't create a negative env_id.
  8004207d9f:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004207da3:	7f 07                	jg     8004207dac <env_alloc+0x79>
		generation = 1 << ENVGENSHIFT;
  8004207da5:	c7 45 fc 00 10 00 00 	movl   $0x1000,-0x4(%rbp)
	e->env_id = generation | (e - envs);
  8004207dac:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207db0:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  8004207db7:	00 00 00 
  8004207dba:	48 8b 00             	mov    (%rax),%rax
  8004207dbd:	48 29 c2             	sub    %rax,%rdx
  8004207dc0:	48 89 d0             	mov    %rdx,%rax
  8004207dc3:	48 c1 f8 03          	sar    $0x3,%rax
  8004207dc7:	48 89 c2             	mov    %rax,%rdx
  8004207dca:	48 b8 a5 4f fa a4 4f 	movabs $0x4fa4fa4fa4fa4fa5,%rax
  8004207dd1:	fa a4 4f 
  8004207dd4:	48 0f af c2          	imul   %rdx,%rax
  8004207dd8:	0b 45 fc             	or     -0x4(%rbp),%eax
  8004207ddb:	89 c2                	mov    %eax,%edx
  8004207ddd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207de1:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)

	// Set the basic status variables.
	e->env_parent_id = parent_id;
  8004207de7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207deb:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004207dee:	89 90 cc 00 00 00    	mov    %edx,0xcc(%rax)
	e->env_type = ENV_TYPE_USER;
  8004207df4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207df8:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%rax)
  8004207dff:	00 00 00 
	e->env_status = ENV_RUNNABLE;
  8004207e02:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e06:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004207e0d:	00 00 00 
	e->env_runs = 0;
  8004207e10:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e14:	c7 80 d8 00 00 00 00 	movl   $0x0,0xd8(%rax)
  8004207e1b:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(&e->env_tf, 0, sizeof(e->env_tf));
  8004207e1e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e22:	ba c0 00 00 00       	mov    $0xc0,%edx
  8004207e27:	be 00 00 00 00       	mov    $0x0,%esi
  8004207e2c:	48 89 c7             	mov    %rax,%rdi
  8004207e2f:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004207e36:	00 00 00 
  8004207e39:	ff d0                	callq  *%rax
	// The low 2 bits of each segment register contains the
	// Requestor Privilege Level (RPL); 3 means user mode.  When
	// we switch privilege levels, the hardware does various
	// checks involving the RPL and the Descriptor Privilege Level
	// (DPL) stored in the descriptors themselves.
	e->env_tf.tf_ds = GD_UD | 3;
  8004207e3b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e3f:	66 c7 80 80 00 00 00 	movw   $0x23,0x80(%rax)
  8004207e46:	23 00 
	e->env_tf.tf_es = GD_UD | 3;
  8004207e48:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e4c:	66 c7 40 78 23 00    	movw   $0x23,0x78(%rax)
	e->env_tf.tf_ss = GD_UD | 3;
  8004207e52:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e56:	66 c7 80 b8 00 00 00 	movw   $0x23,0xb8(%rax)
  8004207e5d:	23 00 
	e->env_tf.tf_rsp = USTACKTOP;
  8004207e5f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e63:	b9 00 e0 7f ef       	mov    $0xef7fe000,%ecx
  8004207e68:	48 89 88 b0 00 00 00 	mov    %rcx,0xb0(%rax)
	e->env_tf.tf_cs = GD_UT | 3;
  8004207e6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e73:	66 c7 80 a0 00 00 00 	movw   $0x1b,0xa0(%rax)
  8004207e7a:	1b 00 
	// You will set e->env_tf.tf_rip later.

	// Enable interrupts while in user mode.
	// LAB 4: Your code here.
	e->env_tf.tf_eflags = e->env_tf.tf_eflags |FL_IF;
  8004207e7c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e80:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  8004207e87:	80 cc 02             	or     $0x2,%ah
  8004207e8a:	48 89 c2             	mov    %rax,%rdx
  8004207e8d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e91:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	
	// Clear the page fault handler until user installs one.
	e->env_pgfault_upcall = 0;
  8004207e98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207e9c:	48 c7 80 f0 00 00 00 	movq   $0x0,0xf0(%rax)
  8004207ea3:	00 00 00 00 

	// Also clear the IPC receiving flag.
	e->env_ipc_recving = 0;
  8004207ea7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207eab:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)

	// commit the allocation
	env_free_list = e->env_link;
  8004207eb2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004207eb6:	48 8b 90 c0 00 00 00 	mov    0xc0(%rax),%rdx
  8004207ebd:	48 b8 60 82 37 04 80 	movabs $0x8004378260,%rax
  8004207ec4:	00 00 00 
  8004207ec7:	48 89 10             	mov    %rdx,(%rax)
	*newenv_store = e;
  8004207eca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207ece:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004207ed2:	48 89 10             	mov    %rdx,(%rax)
	//cprintf("env.tf->rsp [%x], e->env_id [%d]\n", e->env_tf.tf_rsp, e->env_id);

	// cprintf("[%08x] new env %08x\n", curenv ? curenv->env_id : 0, e->env_id);
	return 0;
  8004207ed5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004207eda:	c9                   	leaveq 
  8004207edb:	c3                   	retq   

0000008004207edc <region_alloc>:
// Pages should be writable by user and kernel.
// Panic if any allocation attempt fails.
//
static void
region_alloc(struct Env *e, void *va, size_t len)
{
  8004207edc:	55                   	push   %rbp
  8004207edd:	48 89 e5             	mov    %rsp,%rbp
  8004207ee0:	48 83 ec 40          	sub    $0x40,%rsp
  8004207ee4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004207ee8:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004207eec:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	//
	// Hint: It is easier to use region_alloc if the caller can pass
	//   'va' and 'len' values that are not page-aligned.
	//   You should round va down, and round (va + len) up.
	//   (Watch out for corner-cases!)
	uint64_t temp = (uint64_t)va;
  8004207ef0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207ef4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	size_t lenDown = (uint64_t)va - temp;
  8004207ef8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004207efc:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004207f00:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	int i = 0;
  8004207f04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	struct PageInfo *p;
	// Address round down
	temp =  (temp / PGSIZE) * PGSIZE;
  8004207f0b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004207f0f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207f13:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207f17:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	// size round up
	len += lenDown;
  8004207f1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004207f1f:	48 01 45 c8          	add    %rax,-0x38(%rbp)
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
  8004207f23:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004207f27:	48 05 00 10 00 00    	add    $0x1000,%rax
  8004207f2d:	48 c1 e8 0c          	shr    $0xc,%rax
  8004207f31:	48 c1 e0 0c          	shl    $0xc,%rax
  8004207f35:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  8004207f39:	eb 79                	jmp    8004207fb4 <region_alloc+0xd8>
	{	
		p = page_alloc(ALLOC_ZERO);
  8004207f3b:	bf 01 00 00 00       	mov    $0x1,%edi
  8004207f40:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  8004207f47:	00 00 00 
  8004207f4a:	ff d0                	callq  *%rax
  8004207f4c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		if(p == NULL)
  8004207f50:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004207f55:	75 2a                	jne    8004207f81 <region_alloc+0xa5>
		    panic("Page alloc fail\n");
  8004207f57:	48 ba 73 90 21 04 80 	movabs $0x8004219073,%rdx
  8004207f5e:	00 00 00 
  8004207f61:	be c5 01 00 00       	mov    $0x1c5,%esi
  8004207f66:	48 bf 84 90 21 04 80 	movabs $0x8004219084,%rdi
  8004207f6d:	00 00 00 
  8004207f70:	b8 00 00 00 00       	mov    $0x0,%eax
  8004207f75:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  8004207f7c:	00 00 00 
  8004207f7f:	ff d1                	callq  *%rcx
		page_insert(e->env_pml4e, p, (void*)temp, PTE_U|PTE_P|PTE_W);
  8004207f81:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004207f85:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004207f89:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004207f90:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  8004207f94:	b9 07 00 00 00       	mov    $0x7,%ecx
  8004207f99:	48 89 c7             	mov    %rax,%rdi
  8004207f9c:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  8004207fa3:	00 00 00 
  8004207fa6:	ff d0                	callq  *%rax
		temp+=PGSIZE;
  8004207fa8:	48 81 45 f8 00 10 00 	addq   $0x1000,-0x8(%rbp)
  8004207faf:	00 
	len += lenDown;
	len = ((len + PGSIZE) / PGSIZE) * PGSIZE;
	//cprintf("region_alloc entry PML4 is [%x] va [%x], memsize [%ld]\n", e->env_pml4e[0], va, len);

	//Alloc pages and insert physical pages in page table
	for(; i < len/PGSIZE; i++)
  8004207fb0:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004207fb4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004207fb7:	48 98                	cltq   
  8004207fb9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004207fbd:	48 c1 ea 0c          	shr    $0xc,%rdx
  8004207fc1:	48 39 d0             	cmp    %rdx,%rax
  8004207fc4:	0f 82 71 ff ff ff    	jb     8004207f3b <region_alloc+0x5f>
		temp+=PGSIZE;
		//cprintf("region_alloc temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);
	}
	//cprintf("region_alloc end temp = [%x] , index = [%x], e->env_pml4e is [%x], PML40 is [%x]\n", temp, PML4(temp), e->env_pml4e, e->env_pml4e[0]);

}
  8004207fca:	c9                   	leaveq 
  8004207fcb:	c3                   	retq   

0000008004207fcc <load_icode>:
// load_icode panics if it encounters problems.
//  - How might load_icode fail?  What might be wrong with the given input?
//
void
load_icode(struct Env *e, uint8_t *binary)
{
  8004207fcc:	55                   	push   %rbp
  8004207fcd:	48 89 e5             	mov    %rsp,%rbp
  8004207fd0:	48 83 ec 40          	sub    $0x40,%rsp
  8004207fd4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004207fd8:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)

	struct PageInfo *p;
	struct Elf * elfHeader;
	struct Proghdr *ph, *eph;

	if(e == NULL || binary == NULL)
  8004207fdc:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004207fe1:	74 07                	je     8004207fea <load_icode+0x1e>
  8004207fe3:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004207fe8:	75 2a                	jne    8004208014 <load_icode+0x48>
		panic("load icode Failed due to NULL input");
  8004207fea:	48 ba 90 90 21 04 80 	movabs $0x8004219090,%rdx
  8004207ff1:	00 00 00 
  8004207ff4:	be 0f 02 00 00       	mov    $0x20f,%esi
  8004207ff9:	48 bf 84 90 21 04 80 	movabs $0x8004219084,%rdi
  8004208000:	00 00 00 
  8004208003:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208008:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  800420800f:	00 00 00 
  8004208012:	ff d1                	callq  *%rcx


	elfHeader = (struct Elf *) binary;	
  8004208014:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004208018:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	// is this a valid ELF?
	if (elfHeader->e_magic != ELF_MAGIC)
  800420801c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208020:	8b 00                	mov    (%rax),%eax
  8004208022:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
  8004208027:	74 2a                	je     8004208053 <load_icode+0x87>
		panic("load icode Failed due to Corrupt ELF");
  8004208029:	48 ba b8 90 21 04 80 	movabs $0x80042190b8,%rdx
  8004208030:	00 00 00 
  8004208033:	be 15 02 00 00       	mov    $0x215,%esi
  8004208038:	48 bf 84 90 21 04 80 	movabs $0x8004219084,%rdi
  800420803f:	00 00 00 
  8004208042:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208047:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  800420804e:	00 00 00 
  8004208051:	ff d1                	callq  *%rcx

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
  8004208053:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208057:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800420805b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420805f:	48 01 d0             	add    %rdx,%rax
  8004208062:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	eph = ph + elfHeader->e_phnum;
  8004208066:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420806a:	0f b7 40 38          	movzwl 0x38(%rax),%eax
  800420806e:	0f b7 c0             	movzwl %ax,%eax
  8004208071:	48 c1 e0 03          	shl    $0x3,%rax
  8004208075:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420807c:	00 
  800420807d:	48 29 c2             	sub    %rax,%rdx
  8004208080:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208084:	48 01 d0             	add    %rdx,%rax
  8004208087:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	lcr3(e->env_cr3);
  800420808b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420808f:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208096:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420809a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420809e:	0f 22 d8             	mov    %rax,%cr3
	for (;ph < eph; ph++){
  80042080a1:	e9 d3 00 00 00       	jmpq   8004208179 <load_icode+0x1ad>
		if(ELF_PROG_LOAD == ph->p_type){
  80042080a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080aa:	8b 00                	mov    (%rax),%eax
  80042080ac:	83 f8 01             	cmp    $0x1,%eax
  80042080af:	0f 85 bf 00 00 00    	jne    8004208174 <load_icode+0x1a8>
			if(ph->p_filesz <= ph->p_memsz){
  80042080b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080b9:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042080bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080c1:	48 8b 40 28          	mov    0x28(%rax),%rax
  80042080c5:	48 39 c2             	cmp    %rax,%rdx
  80042080c8:	0f 87 a6 00 00 00    	ja     8004208174 <load_icode+0x1a8>
				region_alloc(e, (void *)ph->p_va, ph->p_memsz);
  80042080ce:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080d2:	48 8b 50 28          	mov    0x28(%rax),%rdx
  80042080d6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042080da:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042080de:	48 89 c1             	mov    %rax,%rcx
  80042080e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042080e5:	48 89 ce             	mov    %rcx,%rsi
  80042080e8:	48 89 c7             	mov    %rax,%rdi
  80042080eb:	48 b8 dc 7e 20 04 80 	movabs $0x8004207edc,%rax
  80042080f2:	00 00 00 
  80042080f5:	ff d0                	callq  *%rax
				size_t a = e->env_pml4e[0];
  80042080f7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042080fb:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208102:	48 8b 00             	mov    (%rax),%rax
  8004208105:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				//cprintf("load icode Inter  e->env_pml4e is [%x], PML40 is [%x], PML41 is [%x], ph->p_filesz [%ld]\n",  e->env_pml4e, e->env_pml4e[0],e->env_pml4e[1], ph->p_filesz);

				memcpy((void*)ph->p_va, binary + ph->p_offset, ph->p_filesz);
  8004208109:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420810d:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004208111:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208115:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004208119:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420811d:	48 01 c1             	add    %rax,%rcx
  8004208120:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208124:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004208128:	48 89 ce             	mov    %rcx,%rsi
  800420812b:	48 89 c7             	mov    %rax,%rdi
  800420812e:	48 b8 1f fc 20 04 80 	movabs $0x800420fc1f,%rax
  8004208135:	00 00 00 
  8004208138:	ff d0                	callq  *%rax
				memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);
  800420813a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420813e:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004208142:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208146:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420814a:	48 29 c2             	sub    %rax,%rdx
  800420814d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208151:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004208155:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208159:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420815d:	48 01 c8             	add    %rcx,%rax
  8004208160:	be 00 00 00 00       	mov    $0x0,%esi
  8004208165:	48 89 c7             	mov    %rax,%rdi
  8004208168:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  800420816f:	00 00 00 
  8004208172:	ff d0                	callq  *%rax
		panic("load icode Failed due to Corrupt ELF");

  	ph = (struct Proghdr *) (binary + elfHeader->e_phoff);
	eph = ph + elfHeader->e_phnum;
	lcr3(e->env_cr3);
	for (;ph < eph; ph++){
  8004208174:	48 83 45 f8 38       	addq   $0x38,-0x8(%rbp)
  8004208179:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420817d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004208181:	0f 82 1f ff ff ff    	jb     80042080a6 <load_icode+0xda>
		}
	}
	// call the entry point from the ELF header
	// note: does not return!
	
	region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);
  8004208187:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420818b:	ba 00 10 00 00       	mov    $0x1000,%edx
  8004208190:	be 00 d0 7f ef       	mov    $0xef7fd000,%esi
  8004208195:	48 89 c7             	mov    %rax,%rdi
  8004208198:	48 b8 dc 7e 20 04 80 	movabs $0x8004207edc,%rax
  800420819f:	00 00 00 
  80042081a2:	ff d0                	callq  *%rax
	e->env_tf.tf_rip = (uintptr_t)(elfHeader->e_entry);
  80042081a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042081a8:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042081ac:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042081b0:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	e->elf = binary;
  80042081b7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042081bb:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042081bf:	48 89 90 18 01 00 00 	mov    %rdx,0x118(%rax)
}
  80042081c6:	c9                   	leaveq 
  80042081c7:	c3                   	retq   

00000080042081c8 <env_create>:
// before running the first user-mode environment.
// The new env's parent ID is set to 0.
//
void
env_create(uint8_t *binary, enum EnvType type)
{
  80042081c8:	55                   	push   %rbp
  80042081c9:	48 89 e5             	mov    %rsp,%rbp
  80042081cc:	48 83 ec 20          	sub    $0x20,%rsp
  80042081d0:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042081d4:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.
	// LAB 5: Your code here.

	struct Env *e;
	envid_t parent_id;
	if(env_alloc(&e, 0) != 0)
  80042081d7:	48 8d 45 f8          	lea    -0x8(%rbp),%rax
  80042081db:	be 00 00 00 00       	mov    $0x0,%esi
  80042081e0:	48 89 c7             	mov    %rax,%rdi
  80042081e3:	48 b8 33 7d 20 04 80 	movabs $0x8004207d33,%rax
  80042081ea:	00 00 00 
  80042081ed:	ff d0                	callq  *%rax
  80042081ef:	85 c0                	test   %eax,%eax
  80042081f1:	74 2a                	je     800420821d <env_create+0x55>
	{
		panic("Failed in env_alloc");
  80042081f3:	48 ba dd 90 21 04 80 	movabs $0x80042190dd,%rdx
  80042081fa:	00 00 00 
  80042081fd:	be 42 02 00 00       	mov    $0x242,%esi
  8004208202:	48 bf 84 90 21 04 80 	movabs $0x8004219084,%rdi
  8004208209:	00 00 00 
  800420820c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208211:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  8004208218:	00 00 00 
  800420821b:	ff d1                	callq  *%rcx
	}
	e->env_type = type;
  800420821d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208221:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208224:	89 90 d0 00 00 00    	mov    %edx,0xd0(%rax)
	if(type == ENV_TYPE_FS)
  800420822a:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420822e:	75 19                	jne    8004208249 <env_create+0x81>
	{
		e->env_tf.tf_eflags |= FL_IOPL_MASK;
  8004208230:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208234:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004208238:	48 8b 92 a8 00 00 00 	mov    0xa8(%rdx),%rdx
  800420823f:	80 ce 30             	or     $0x30,%dh
  8004208242:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
	}
	load_icode(e, binary);
  8004208249:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420824d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004208251:	48 89 d6             	mov    %rdx,%rsi
  8004208254:	48 89 c7             	mov    %rax,%rdi
  8004208257:	48 b8 cc 7f 20 04 80 	movabs $0x8004207fcc,%rax
  800420825e:	00 00 00 
  8004208261:	ff d0                	callq  *%rax
}
  8004208263:	c9                   	leaveq 
  8004208264:	c3                   	retq   

0000008004208265 <env_free>:
//
// Frees env e and all memory it uses.
//
void
env_free(struct Env *e)
{
  8004208265:	55                   	push   %rbp
  8004208266:	48 89 e5             	mov    %rsp,%rbp
  8004208269:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
  8004208270:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
#endif

	// If freeing the current environment, switch to kern_pgdir
	// before freeing the page directory, just in case the page
	// gets reused.
	if (e == curenv)
  8004208277:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420827e:	00 00 00 
  8004208281:	ff d0                	callq  *%rax
  8004208283:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420828a:	00 00 00 
  800420828d:	48 98                	cltq   
  800420828f:	48 c1 e0 03          	shl    $0x3,%rax
  8004208293:	48 89 c1             	mov    %rax,%rcx
  8004208296:	48 c1 e1 04          	shl    $0x4,%rcx
  800420829a:	48 01 c8             	add    %rcx,%rax
  800420829d:	48 01 d0             	add    %rdx,%rax
  80042082a0:	48 83 c0 08          	add    $0x8,%rax
  80042082a4:	48 8b 00             	mov    (%rax),%rax
  80042082a7:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
  80042082ae:	75 18                	jne    80042082c8 <env_free+0x63>
		lcr3(boot_cr3);
  80042082b0:	48 b8 80 97 37 04 80 	movabs $0x8004379780,%rax
  80042082b7:	00 00 00 
  80042082ba:	48 8b 00             	mov    (%rax),%rax
  80042082bd:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  80042082c1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042082c5:	0f 22 d8             	mov    %rax,%cr3

	// Note the environment's demise.
	// cprintf("[%08x] free env %08x\n", curenv ? curenv->env_id : 0, e->env_id);

	// Flush all mapped pages in the user portion of the address space
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
  80042082c8:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042082cf:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  80042082d6:	48 8b 00             	mov    (%rax),%rax
  80042082d9:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042082df:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042082e3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042082e7:	48 c1 e8 0c          	shr    $0xc,%rax
  80042082eb:	89 45 dc             	mov    %eax,-0x24(%rbp)
  80042082ee:	8b 55 dc             	mov    -0x24(%rbp),%edx
  80042082f1:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042082f8:	00 00 00 
  80042082fb:	48 8b 00             	mov    (%rax),%rax
  80042082fe:	48 39 c2             	cmp    %rax,%rdx
  8004208301:	72 32                	jb     8004208335 <env_free+0xd0>
  8004208303:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208307:	48 89 c1             	mov    %rax,%rcx
  800420830a:	48 ba 50 90 21 04 80 	movabs $0x8004219050,%rdx
  8004208311:	00 00 00 
  8004208314:	be 67 02 00 00       	mov    $0x267,%esi
  8004208319:	48 bf 84 90 21 04 80 	movabs $0x8004219084,%rdi
  8004208320:	00 00 00 
  8004208323:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208328:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420832f:	00 00 00 
  8004208332:	41 ff d0             	callq  *%r8
  8004208335:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800420833c:	00 00 00 
  800420833f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004208343:	48 01 d0             	add    %rdx,%rax
  8004208346:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  800420834a:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004208351:	00 
  8004208352:	e9 ab 02 00 00       	jmpq   8004208602 <env_free+0x39d>
		if(!(env_pdpe[pdpe_index] & PTE_P))
  8004208357:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420835b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208362:	00 
  8004208363:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004208367:	48 01 d0             	add    %rdx,%rax
  800420836a:	48 8b 00             	mov    (%rax),%rax
  800420836d:	83 e0 01             	and    $0x1,%eax
  8004208370:	48 85 c0             	test   %rax,%rax
  8004208373:	75 05                	jne    800420837a <env_free+0x115>
			continue;
  8004208375:	e9 83 02 00 00       	jmpq   80042085fd <env_free+0x398>
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
  800420837a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420837e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208385:	00 
  8004208386:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420838a:	48 01 d0             	add    %rdx,%rax
  800420838d:	48 8b 00             	mov    (%rax),%rax
  8004208390:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208396:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  800420839a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420839e:	48 c1 e8 0c          	shr    $0xc,%rax
  80042083a2:	89 45 c4             	mov    %eax,-0x3c(%rbp)
  80042083a5:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  80042083a8:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  80042083af:	00 00 00 
  80042083b2:	48 8b 00             	mov    (%rax),%rax
  80042083b5:	48 39 c2             	cmp    %rax,%rdx
  80042083b8:	72 32                	jb     80042083ec <env_free+0x187>
  80042083ba:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042083be:	48 89 c1             	mov    %rax,%rcx
  80042083c1:	48 ba 50 90 21 04 80 	movabs $0x8004219050,%rdx
  80042083c8:	00 00 00 
  80042083cb:	be 6f 02 00 00       	mov    $0x26f,%esi
  80042083d0:	48 bf 84 90 21 04 80 	movabs $0x8004219084,%rdi
  80042083d7:	00 00 00 
  80042083da:	b8 00 00 00 00       	mov    $0x0,%eax
  80042083df:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042083e6:	00 00 00 
  80042083e9:	41 ff d0             	callq  *%r8
  80042083ec:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042083f3:	00 00 00 
  80042083f6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042083fa:	48 01 d0             	add    %rdx,%rax
  80042083fd:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
  8004208401:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208406:	75 07                	jne    800420840f <env_free+0x1aa>
  8004208408:	b8 04 00 00 00       	mov    $0x4,%eax
  800420840d:	eb 05                	jmp    8004208414 <env_free+0x1af>
  800420840f:	b8 ff 01 00 00       	mov    $0x1ff,%eax
  8004208414:	89 45 b4             	mov    %eax,-0x4c(%rbp)
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  8004208417:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420841e:	00 
  800420841f:	e9 6e 01 00 00       	jmpq   8004208592 <env_free+0x32d>

			// only look at mapped page tables
			if (!(env_pgdir[pdeno] & PTE_P))
  8004208424:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208428:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420842f:	00 
  8004208430:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208434:	48 01 d0             	add    %rdx,%rax
  8004208437:	48 8b 00             	mov    (%rax),%rax
  800420843a:	83 e0 01             	and    $0x1,%eax
  800420843d:	48 85 c0             	test   %rax,%rax
  8004208440:	75 05                	jne    8004208447 <env_free+0x1e2>
				continue;
  8004208442:	e9 46 01 00 00       	jmpq   800420858d <env_free+0x328>
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
  8004208447:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420844b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004208452:	00 
  8004208453:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208457:	48 01 d0             	add    %rdx,%rax
  800420845a:	48 8b 00             	mov    (%rax),%rax
  800420845d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208463:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			pt = (pte_t*) KADDR(pa);
  8004208467:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420846b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  800420846f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208473:	48 c1 e8 0c          	shr    $0xc,%rax
  8004208477:	89 45 9c             	mov    %eax,-0x64(%rbp)
  800420847a:	8b 55 9c             	mov    -0x64(%rbp),%edx
  800420847d:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004208484:	00 00 00 
  8004208487:	48 8b 00             	mov    (%rax),%rax
  800420848a:	48 39 c2             	cmp    %rax,%rdx
  800420848d:	72 32                	jb     80042084c1 <env_free+0x25c>
  800420848f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004208493:	48 89 c1             	mov    %rax,%rcx
  8004208496:	48 ba 50 90 21 04 80 	movabs $0x8004219050,%rdx
  800420849d:	00 00 00 
  80042084a0:	be 79 02 00 00       	mov    $0x279,%esi
  80042084a5:	48 bf 84 90 21 04 80 	movabs $0x8004219084,%rdi
  80042084ac:	00 00 00 
  80042084af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042084b4:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042084bb:	00 00 00 
  80042084be:	41 ff d0             	callq  *%r8
  80042084c1:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042084c8:	00 00 00 
  80042084cb:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042084cf:	48 01 d0             	add    %rdx,%rax
  80042084d2:	48 89 45 90          	mov    %rax,-0x70(%rbp)

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  80042084d6:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  80042084dd:	00 
  80042084de:	eb 67                	jmp    8004208547 <env_free+0x2e2>
				if (pt[pteno] & PTE_P){
  80042084e0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042084e4:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042084eb:	00 
  80042084ec:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042084f0:	48 01 d0             	add    %rdx,%rax
  80042084f3:	48 8b 00             	mov    (%rax),%rax
  80042084f6:	83 e0 01             	and    $0x1,%eax
  80042084f9:	48 85 c0             	test   %rax,%rax
  80042084fc:	74 44                	je     8004208542 <env_free+0x2dd>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
  80042084fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208502:	48 c1 e0 1e          	shl    $0x1e,%rax
  8004208506:	48 89 c2             	mov    %rax,%rdx
  8004208509:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420850d:	48 c1 e0 15          	shl    $0x15,%rax
  8004208511:	48 09 c2             	or     %rax,%rdx
  8004208514:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208518:	48 c1 e0 0c          	shl    $0xc,%rax
  800420851c:	48 09 d0             	or     %rdx,%rax
  800420851f:	48 89 c2             	mov    %rax,%rdx
  8004208522:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208529:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208530:	48 89 d6             	mov    %rdx,%rsi
  8004208533:	48 89 c7             	mov    %rax,%rdi
  8004208536:	48 b8 18 3b 20 04 80 	movabs $0x8004203b18,%rax
  800420853d:	00 00 00 
  8004208540:	ff d0                	callq  *%rax
			// find the pa and va of the page table
			pa = PTE_ADDR(env_pgdir[pdeno]);
			pt = (pte_t*) KADDR(pa);

			// unmap all PTEs in this page table
			for (pteno = 0; pteno < PTX(~0); pteno++) {
  8004208542:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
  8004208547:	48 81 7d f0 fe 01 00 	cmpq   $0x1fe,-0x10(%rbp)
  800420854e:	00 
  800420854f:	76 8f                	jbe    80042084e0 <env_free+0x27b>
					page_remove(e->env_pml4e, PGADDR((uint64_t)0,pdpe_index,pdeno, pteno, 0));
				}
			}

			// free the page table itself
			env_pgdir[pdeno] = 0;
  8004208551:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208555:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420855c:	00 
  800420855d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004208561:	48 01 d0             	add    %rdx,%rax
  8004208564:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			page_decref(pa2page(pa));
  800420856b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420856f:	48 89 c7             	mov    %rax,%rdi
  8004208572:	48 b8 a7 78 20 04 80 	movabs $0x80042078a7,%rax
  8004208579:	00 00 00 
  800420857c:	ff d0                	callq  *%rax
  800420857e:	48 89 c7             	mov    %rax,%rdi
  8004208581:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  8004208588:	00 00 00 
  800420858b:	ff d0                	callq  *%rax
		if(!(env_pdpe[pdpe_index] & PTE_P))
			continue;
		pde_t *env_pgdir = KADDR(PTE_ADDR(env_pdpe[pdpe_index]));
		pdeno_limit  = pdpe_index==3?PDX(UTOP):PDX(0xFFFFFFFF);
		static_assert(UTOP % PTSIZE == 0);
		for (pdeno = 0; pdeno < pdeno_limit; pdeno++) {
  800420858d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  8004208592:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  8004208595:	48 98                	cltq   
  8004208597:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420859b:	0f 87 83 fe ff ff    	ja     8004208424 <env_free+0x1bf>
			// free the page table itself
			env_pgdir[pdeno] = 0;
			page_decref(pa2page(pa));
		}
		// free the page directory
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
  80042085a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042085a5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042085ac:	00 
  80042085ad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042085b1:	48 01 d0             	add    %rdx,%rax
  80042085b4:	48 8b 00             	mov    (%rax),%rax
  80042085b7:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  80042085bd:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
		env_pdpe[pdpe_index] = 0;
  80042085c1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042085c5:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  80042085cc:	00 
  80042085cd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042085d1:	48 01 d0             	add    %rdx,%rax
  80042085d4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		page_decref(pa2page(pa));
  80042085db:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042085df:	48 89 c7             	mov    %rax,%rdi
  80042085e2:	48 b8 a7 78 20 04 80 	movabs $0x80042078a7,%rax
  80042085e9:	00 00 00 
  80042085ec:	ff d0                	callq  *%rax
  80042085ee:	48 89 c7             	mov    %rax,%rdi
  80042085f1:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  80042085f8:	00 00 00 
  80042085fb:	ff d0                	callq  *%rax
	pdpe_t *env_pdpe = KADDR(PTE_ADDR(e->env_pml4e[0]));
	int pdeno_limit;
	uint64_t pdpe_index;
	// using 3 instead of NPDPENTRIES as we have only first three indices
	// set for 4GB of address space.
	for(pdpe_index=0;pdpe_index<=3;pdpe_index++){
  80042085fd:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  8004208602:	48 83 7d e8 03       	cmpq   $0x3,-0x18(%rbp)
  8004208607:	0f 86 4a fd ff ff    	jbe    8004208357 <env_free+0xf2>
		pa = PTE_ADDR(env_pdpe[pdpe_index]);
		env_pdpe[pdpe_index] = 0;
		page_decref(pa2page(pa));
	}
	// free the page directory pointer
	page_decref(pa2page(PTE_ADDR(e->env_pml4e[0])));
  800420860d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208614:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420861b:	48 8b 00             	mov    (%rax),%rax
  800420861e:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
  8004208624:	48 89 c7             	mov    %rax,%rdi
  8004208627:	48 b8 a7 78 20 04 80 	movabs $0x80042078a7,%rax
  800420862e:	00 00 00 
  8004208631:	ff d0                	callq  *%rax
  8004208633:	48 89 c7             	mov    %rax,%rdi
  8004208636:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  800420863d:	00 00 00 
  8004208640:	ff d0                	callq  *%rax
	// free the page map level 4 (PML4)
	e->env_pml4e[0] = 0;
  8004208642:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208649:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  8004208650:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	pa = e->env_cr3;
  8004208657:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800420865e:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208665:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	e->env_pml4e = 0;
  8004208669:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208670:	48 c7 80 e0 00 00 00 	movq   $0x0,0xe0(%rax)
  8004208677:	00 00 00 00 
	e->env_cr3 = 0;
  800420867b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004208682:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
  8004208689:	00 00 00 00 
	page_decref(pa2page(pa));
  800420868d:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004208691:	48 89 c7             	mov    %rax,%rdi
  8004208694:	48 b8 a7 78 20 04 80 	movabs $0x80042078a7,%rax
  800420869b:	00 00 00 
  800420869e:	ff d0                	callq  *%rax
  80042086a0:	48 89 c7             	mov    %rax,%rdi
  80042086a3:	48 b8 49 32 20 04 80 	movabs $0x8004203249,%rax
  80042086aa:	00 00 00 
  80042086ad:	ff d0                	callq  *%rax

	// return the environment to the free list
	e->env_status = ENV_FREE;
  80042086af:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042086b6:	c7 80 d4 00 00 00 00 	movl   $0x0,0xd4(%rax)
  80042086bd:	00 00 00 
	e->env_link = env_free_list;
  80042086c0:	48 b8 60 82 37 04 80 	movabs $0x8004378260,%rax
  80042086c7:	00 00 00 
  80042086ca:	48 8b 10             	mov    (%rax),%rdx
  80042086cd:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042086d4:	48 89 90 c0 00 00 00 	mov    %rdx,0xc0(%rax)
	env_free_list = e;
  80042086db:	48 b8 60 82 37 04 80 	movabs $0x8004378260,%rax
  80042086e2:	00 00 00 
  80042086e5:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  80042086ec:	48 89 10             	mov    %rdx,(%rax)
}
  80042086ef:	c9                   	leaveq 
  80042086f0:	c3                   	retq   

00000080042086f1 <env_destroy>:
// If e was the current env, then runs a new environment (and does not return
// to the caller).
//
void
env_destroy(struct Env *e)
{
  80042086f1:	55                   	push   %rbp
  80042086f2:	48 89 e5             	mov    %rsp,%rbp
  80042086f5:	48 83 ec 10          	sub    $0x10,%rsp
  80042086f9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// If e is currently running on other CPUs, we change its state to
	// ENV_DYING. A zombie environment will be freed the next time
	// it traps to the kernel.
	if (e->env_status == ENV_RUNNING && curenv != e) {
  80042086fd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208701:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  8004208707:	83 f8 03             	cmp    $0x3,%eax
  800420870a:	75 49                	jne    8004208755 <env_destroy+0x64>
  800420870c:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208713:	00 00 00 
  8004208716:	ff d0                	callq  *%rax
  8004208718:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420871f:	00 00 00 
  8004208722:	48 98                	cltq   
  8004208724:	48 c1 e0 03          	shl    $0x3,%rax
  8004208728:	48 89 c1             	mov    %rax,%rcx
  800420872b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420872f:	48 01 c8             	add    %rcx,%rax
  8004208732:	48 01 d0             	add    %rdx,%rax
  8004208735:	48 83 c0 08          	add    $0x8,%rax
  8004208739:	48 8b 00             	mov    (%rax),%rax
  800420873c:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004208740:	74 13                	je     8004208755 <env_destroy+0x64>
		e->env_status = ENV_DYING;
  8004208742:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208746:	c7 80 d4 00 00 00 01 	movl   $0x1,0xd4(%rax)
  800420874d:	00 00 00 
		return;
  8004208750:	e9 89 00 00 00       	jmpq   80042087de <env_destroy+0xed>
	}

	env_free(e);
  8004208755:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208759:	48 89 c7             	mov    %rax,%rdi
  800420875c:	48 b8 65 82 20 04 80 	movabs $0x8004208265,%rax
  8004208763:	00 00 00 
  8004208766:	ff d0                	callq  *%rax
	if (curenv == e) {
  8004208768:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420876f:	00 00 00 
  8004208772:	ff d0                	callq  *%rax
  8004208774:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420877b:	00 00 00 
  800420877e:	48 98                	cltq   
  8004208780:	48 c1 e0 03          	shl    $0x3,%rax
  8004208784:	48 89 c1             	mov    %rax,%rcx
  8004208787:	48 c1 e1 04          	shl    $0x4,%rcx
  800420878b:	48 01 c8             	add    %rcx,%rax
  800420878e:	48 01 d0             	add    %rdx,%rax
  8004208791:	48 83 c0 08          	add    $0x8,%rax
  8004208795:	48 8b 00             	mov    (%rax),%rax
  8004208798:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420879c:	75 40                	jne    80042087de <env_destroy+0xed>
		curenv = NULL;
  800420879e:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  80042087a5:	00 00 00 
  80042087a8:	ff d0                	callq  *%rax
  80042087aa:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  80042087b1:	00 00 00 
  80042087b4:	48 98                	cltq   
  80042087b6:	48 c1 e0 03          	shl    $0x3,%rax
  80042087ba:	48 89 c1             	mov    %rax,%rcx
  80042087bd:	48 c1 e1 04          	shl    $0x4,%rcx
  80042087c1:	48 01 c8             	add    %rcx,%rax
  80042087c4:	48 01 d0             	add    %rdx,%rax
  80042087c7:	48 83 c0 08          	add    $0x8,%rax
  80042087cb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		sched_yield();
  80042087d2:	48 b8 3d d0 20 04 80 	movabs $0x800420d03d,%rax
  80042087d9:	00 00 00 
  80042087dc:	ff d0                	callq  *%rax
	}
}
  80042087de:	c9                   	leaveq 
  80042087df:	c3                   	retq   

00000080042087e0 <env_pop_tf>:
//
// This function does not return.
//
void
env_pop_tf(struct Trapframe *tf)
{
  80042087e0:	55                   	push   %rbp
  80042087e1:	48 89 e5             	mov    %rsp,%rbp
  80042087e4:	53                   	push   %rbx
  80042087e5:	48 83 ec 18          	sub    $0x18,%rsp
  80042087e9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// Record the CPU we are running on for user-space debugging
	curenv->env_cpunum = cpunum();
  80042087ed:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  80042087f4:	00 00 00 
  80042087f7:	ff d0                	callq  *%rax
  80042087f9:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004208800:	00 00 00 
  8004208803:	48 98                	cltq   
  8004208805:	48 c1 e0 03          	shl    $0x3,%rax
  8004208809:	48 89 c1             	mov    %rax,%rcx
  800420880c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208810:	48 01 c8             	add    %rcx,%rax
  8004208813:	48 01 d0             	add    %rdx,%rax
  8004208816:	48 83 c0 08          	add    $0x8,%rax
  800420881a:	48 8b 18             	mov    (%rax),%rbx
  800420881d:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208824:	00 00 00 
  8004208827:	ff d0                	callq  *%rax
  8004208829:	89 83 dc 00 00 00    	mov    %eax,0xdc(%rbx)

	//cprintf("tf->rsp [%x]\n", tf->tf_rsp);
	__asm __volatile("movq %0,%%rsp\n"
  800420882f:	48 8b 65 e8          	mov    -0x18(%rbp),%rsp
  8004208833:	4c 8b 3c 24          	mov    (%rsp),%r15
  8004208837:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420883c:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  8004208841:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  8004208846:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420884b:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  8004208850:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  8004208855:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420885a:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420885f:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  8004208864:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  8004208869:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420886e:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  8004208873:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  8004208878:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420887d:	48 83 c4 78          	add    $0x78,%rsp
  8004208881:	8e 04 24             	mov    (%rsp),%es
  8004208884:	8e 5c 24 08          	mov    0x8(%rsp),%ds
  8004208888:	48 83 c4 10          	add    $0x10,%rsp
  800420888c:	48 83 c4 10          	add    $0x10,%rsp
  8004208890:	48 cf                	iretq  
			 "movw 8(%%rsp),%%ds\n"
			 "addq $16,%%rsp\n"
			 "\taddq $16,%%rsp\n" /* skip tf_trapno and tf_errcode */
			 "\tiretq"
			 : : "g" (tf) : "memory");
	panic("iret failed");  /* mostly to placate the compiler */
  8004208892:	48 ba f1 90 21 04 80 	movabs $0x80042190f1,%rdx
  8004208899:	00 00 00 
  800420889c:	be c7 02 00 00       	mov    $0x2c7,%esi
  80042088a1:	48 bf 84 90 21 04 80 	movabs $0x8004219084,%rdi
  80042088a8:	00 00 00 
  80042088ab:	b8 00 00 00 00       	mov    $0x0,%eax
  80042088b0:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  80042088b7:	00 00 00 
  80042088ba:	ff d1                	callq  *%rcx

00000080042088bc <env_run>:
//
// This function does not return.
//
void
env_run(struct Env *e)
{
  80042088bc:	55                   	push   %rbp
  80042088bd:	48 89 e5             	mov    %rsp,%rbp
  80042088c0:	48 83 ec 20          	sub    $0x20,%rsp
  80042088c4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//	and make sure you have set the relevant parts of
	//	e->env_tf to sensible values.

	// LAB 3: Your code here.
	//cprintf("ENV_RUN being called from here: e->env_id [%d]",e->env_id); 
	if(curenv == e){
  80042088c8:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  80042088cf:	00 00 00 
  80042088d2:	ff d0                	callq  *%rax
  80042088d4:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  80042088db:	00 00 00 
  80042088de:	48 98                	cltq   
  80042088e0:	48 c1 e0 03          	shl    $0x3,%rax
  80042088e4:	48 89 c1             	mov    %rax,%rcx
  80042088e7:	48 c1 e1 04          	shl    $0x4,%rcx
  80042088eb:	48 01 c8             	add    %rcx,%rax
  80042088ee:	48 01 d0             	add    %rdx,%rax
  80042088f1:	48 83 c0 08          	add    $0x8,%rax
  80042088f5:	48 8b 00             	mov    (%rax),%rax
  80042088f8:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042088fc:	0f 85 8a 00 00 00    	jne    800420898c <env_run+0xd0>
		curenv->env_runs += 1;
  8004208902:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208909:	00 00 00 
  800420890c:	ff d0                	callq  *%rax
  800420890e:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004208915:	00 00 00 
  8004208918:	48 98                	cltq   
  800420891a:	48 c1 e0 03          	shl    $0x3,%rax
  800420891e:	48 89 c1             	mov    %rax,%rcx
  8004208921:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208925:	48 01 c8             	add    %rcx,%rax
  8004208928:	48 01 d0             	add    %rdx,%rax
  800420892b:	48 83 c0 08          	add    $0x8,%rax
  800420892f:	48 8b 00             	mov    (%rax),%rax
  8004208932:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004208938:	83 c2 01             	add    $0x1,%edx
  800420893b:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
		unlock_kernel();
  8004208941:	48 b8 a0 79 20 04 80 	movabs $0x80042079a0,%rax
  8004208948:	00 00 00 
  800420894b:	ff d0                	callq  *%rax
		env_pop_tf(&curenv->env_tf);
  800420894d:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208954:	00 00 00 
  8004208957:	ff d0                	callq  *%rax
  8004208959:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004208960:	00 00 00 
  8004208963:	48 98                	cltq   
  8004208965:	48 c1 e0 03          	shl    $0x3,%rax
  8004208969:	48 89 c1             	mov    %rax,%rcx
  800420896c:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208970:	48 01 c8             	add    %rcx,%rax
  8004208973:	48 01 d0             	add    %rdx,%rax
  8004208976:	48 83 c0 08          	add    $0x8,%rax
  800420897a:	48 8b 00             	mov    (%rax),%rax
  800420897d:	48 89 c7             	mov    %rax,%rdi
  8004208980:	48 b8 e0 87 20 04 80 	movabs $0x80042087e0,%rax
  8004208987:	00 00 00 
  800420898a:	ff d0                	callq  *%rax
	}
	if(curenv) //If this is a context switch
  800420898c:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208993:	00 00 00 
  8004208996:	ff d0                	callq  *%rax
  8004208998:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420899f:	00 00 00 
  80042089a2:	48 98                	cltq   
  80042089a4:	48 c1 e0 03          	shl    $0x3,%rax
  80042089a8:	48 89 c1             	mov    %rax,%rcx
  80042089ab:	48 c1 e1 04          	shl    $0x4,%rcx
  80042089af:	48 01 c8             	add    %rcx,%rax
  80042089b2:	48 01 d0             	add    %rdx,%rax
  80042089b5:	48 83 c0 08          	add    $0x8,%rax
  80042089b9:	48 8b 00             	mov    (%rax),%rax
  80042089bc:	48 85 c0             	test   %rax,%rax
  80042089bf:	74 75                	je     8004208a36 <env_run+0x17a>
	{
		if(curenv->env_status == ENV_RUNNING)
  80042089c1:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  80042089c8:	00 00 00 
  80042089cb:	ff d0                	callq  *%rax
  80042089cd:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  80042089d4:	00 00 00 
  80042089d7:	48 98                	cltq   
  80042089d9:	48 c1 e0 03          	shl    $0x3,%rax
  80042089dd:	48 89 c1             	mov    %rax,%rcx
  80042089e0:	48 c1 e1 04          	shl    $0x4,%rcx
  80042089e4:	48 01 c8             	add    %rcx,%rax
  80042089e7:	48 01 d0             	add    %rdx,%rax
  80042089ea:	48 83 c0 08          	add    $0x8,%rax
  80042089ee:	48 8b 00             	mov    (%rax),%rax
  80042089f1:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  80042089f7:	83 f8 03             	cmp    $0x3,%eax
  80042089fa:	75 3a                	jne    8004208a36 <env_run+0x17a>
		{
			curenv->env_status = ENV_RUNNABLE;	
  80042089fc:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208a03:	00 00 00 
  8004208a06:	ff d0                	callq  *%rax
  8004208a08:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004208a0f:	00 00 00 
  8004208a12:	48 98                	cltq   
  8004208a14:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a18:	48 89 c1             	mov    %rax,%rcx
  8004208a1b:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208a1f:	48 01 c8             	add    %rcx,%rax
  8004208a22:	48 01 d0             	add    %rdx,%rax
  8004208a25:	48 83 c0 08          	add    $0x8,%rax
  8004208a29:	48 8b 00             	mov    (%rax),%rax
  8004208a2c:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  8004208a33:	00 00 00 
		}
	}
	//make new enviornment as current enviornment
	
	curenv = e;
  8004208a36:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208a3d:	00 00 00 
  8004208a40:	ff d0                	callq  *%rax
  8004208a42:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004208a49:	00 00 00 
  8004208a4c:	48 98                	cltq   
  8004208a4e:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a52:	48 89 c1             	mov    %rax,%rcx
  8004208a55:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208a59:	48 01 c8             	add    %rcx,%rax
  8004208a5c:	48 01 d0             	add    %rdx,%rax
  8004208a5f:	48 8d 50 08          	lea    0x8(%rax),%rdx
  8004208a63:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004208a67:	48 89 02             	mov    %rax,(%rdx)
	curenv->env_status = ENV_RUNNING;
  8004208a6a:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208a71:	00 00 00 
  8004208a74:	ff d0                	callq  *%rax
  8004208a76:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004208a7d:	00 00 00 
  8004208a80:	48 98                	cltq   
  8004208a82:	48 c1 e0 03          	shl    $0x3,%rax
  8004208a86:	48 89 c1             	mov    %rax,%rcx
  8004208a89:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208a8d:	48 01 c8             	add    %rcx,%rax
  8004208a90:	48 01 d0             	add    %rdx,%rax
  8004208a93:	48 83 c0 08          	add    $0x8,%rax
  8004208a97:	48 8b 00             	mov    (%rax),%rax
  8004208a9a:	c7 80 d4 00 00 00 03 	movl   $0x3,0xd4(%rax)
  8004208aa1:	00 00 00 
	curenv->env_runs += 1;
  8004208aa4:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208aab:	00 00 00 
  8004208aae:	ff d0                	callq  *%rax
  8004208ab0:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004208ab7:	00 00 00 
  8004208aba:	48 98                	cltq   
  8004208abc:	48 c1 e0 03          	shl    $0x3,%rax
  8004208ac0:	48 89 c1             	mov    %rax,%rcx
  8004208ac3:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208ac7:	48 01 c8             	add    %rcx,%rax
  8004208aca:	48 01 d0             	add    %rdx,%rax
  8004208acd:	48 83 c0 08          	add    $0x8,%rax
  8004208ad1:	48 8b 00             	mov    (%rax),%rax
  8004208ad4:	8b 90 d8 00 00 00    	mov    0xd8(%rax),%edx
  8004208ada:	83 c2 01             	add    $0x1,%edx
  8004208add:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
	unlock_kernel();
  8004208ae3:	48 b8 a0 79 20 04 80 	movabs $0x80042079a0,%rax
  8004208aea:	00 00 00 
  8004208aed:	ff d0                	callq  *%rax
	lcr3(curenv->env_cr3);
  8004208aef:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208af6:	00 00 00 
  8004208af9:	ff d0                	callq  *%rax
  8004208afb:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004208b02:	00 00 00 
  8004208b05:	48 98                	cltq   
  8004208b07:	48 c1 e0 03          	shl    $0x3,%rax
  8004208b0b:	48 89 c1             	mov    %rax,%rcx
  8004208b0e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208b12:	48 01 c8             	add    %rcx,%rax
  8004208b15:	48 01 d0             	add    %rdx,%rax
  8004208b18:	48 83 c0 08          	add    $0x8,%rax
  8004208b1c:	48 8b 00             	mov    (%rax),%rax
  8004208b1f:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
  8004208b26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004208b2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004208b2e:	0f 22 d8             	mov    %rax,%cr3
	//restore the environment's registers
	//if(curenv->env_runs > 0)
	{
		env_pop_tf(&curenv->env_tf);
  8004208b31:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004208b38:	00 00 00 
  8004208b3b:	ff d0                	callq  *%rax
  8004208b3d:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004208b44:	00 00 00 
  8004208b47:	48 98                	cltq   
  8004208b49:	48 c1 e0 03          	shl    $0x3,%rax
  8004208b4d:	48 89 c1             	mov    %rax,%rcx
  8004208b50:	48 c1 e1 04          	shl    $0x4,%rcx
  8004208b54:	48 01 c8             	add    %rcx,%rax
  8004208b57:	48 01 d0             	add    %rdx,%rax
  8004208b5a:	48 83 c0 08          	add    $0x8,%rax
  8004208b5e:	48 8b 00             	mov    (%rax),%rax
  8004208b61:	48 89 c7             	mov    %rax,%rdi
  8004208b64:	48 b8 e0 87 20 04 80 	movabs $0x80042087e0,%rax
  8004208b6b:	00 00 00 
  8004208b6e:	ff d0                	callq  *%rax

0000008004208b70 <ipc_find_env>:

	//panic("env_run not yet implemented");
}
envid_t
ipc_find_env(enum EnvType type)
{
  8004208b70:	55                   	push   %rbp
  8004208b71:	48 89 e5             	mov    %rsp,%rbp
  8004208b74:	48 83 ec 14          	sub    $0x14,%rsp
  8004208b78:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int i;
	for (i = 0; i < NENV; i++) {
  8004208b7b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004208b82:	eb 4f                	jmp    8004208bd3 <ipc_find_env+0x63>
		if (envs[i].env_type == type)
  8004208b84:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  8004208b8b:	00 00 00 
  8004208b8e:	48 8b 10             	mov    (%rax),%rdx
  8004208b91:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208b94:	48 98                	cltq   
  8004208b96:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004208b9d:	48 01 d0             	add    %rdx,%rax
  8004208ba0:	8b 80 d0 00 00 00    	mov    0xd0(%rax),%eax
  8004208ba6:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004208ba9:	75 24                	jne    8004208bcf <ipc_find_env+0x5f>
			return envs[i].env_id;
  8004208bab:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  8004208bb2:	00 00 00 
  8004208bb5:	48 8b 10             	mov    (%rax),%rdx
  8004208bb8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208bbb:	48 98                	cltq   
  8004208bbd:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  8004208bc4:	48 01 d0             	add    %rdx,%rax
  8004208bc7:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  8004208bcd:	eb 12                	jmp    8004208be1 <ipc_find_env+0x71>
}
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++) {
  8004208bcf:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004208bd3:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  8004208bda:	7e a8                	jle    8004208b84 <ipc_find_env+0x14>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	}
	return 0;
  8004208bdc:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004208be1:	c9                   	leaveq 
  8004208be2:	c3                   	retq   

0000008004208be3 <mc146818_read>:
#include <kern/kclock.h>


unsigned
mc146818_read(unsigned reg)
{
  8004208be3:	55                   	push   %rbp
  8004208be4:	48 89 e5             	mov    %rsp,%rbp
  8004208be7:	48 83 ec 14          	sub    $0x14,%rsp
  8004208beb:	89 7d ec             	mov    %edi,-0x14(%rbp)
	outb(IO_RTC, reg);
  8004208bee:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208bf1:	0f b6 c0             	movzbl %al,%eax
  8004208bf4:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208bfb:	88 45 fb             	mov    %al,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208bfe:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208c02:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208c05:	ee                   	out    %al,(%dx)
  8004208c06:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004208c0d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004208c10:	89 c2                	mov    %eax,%edx
  8004208c12:	ec                   	in     (%dx),%al
  8004208c13:	88 45 f3             	mov    %al,-0xd(%rbp)
    return data;
  8004208c16:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
	return inb(IO_RTC+1);
  8004208c1a:	0f b6 c0             	movzbl %al,%eax
}
  8004208c1d:	c9                   	leaveq 
  8004208c1e:	c3                   	retq   

0000008004208c1f <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
  8004208c1f:	55                   	push   %rbp
  8004208c20:	48 89 e5             	mov    %rsp,%rbp
  8004208c23:	48 83 ec 18          	sub    $0x18,%rsp
  8004208c27:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004208c2a:	89 75 e8             	mov    %esi,-0x18(%rbp)
	outb(IO_RTC, reg);
  8004208c2d:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004208c30:	0f b6 c0             	movzbl %al,%eax
  8004208c33:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%rbp)
  8004208c3a:	88 45 fb             	mov    %al,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004208c3d:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208c41:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208c44:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
  8004208c45:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004208c48:	0f b6 c0             	movzbl %al,%eax
  8004208c4b:	c7 45 f4 71 00 00 00 	movl   $0x71,-0xc(%rbp)
  8004208c52:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004208c55:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208c59:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208c5c:	ee                   	out    %al,(%dx)
}
  8004208c5d:	c9                   	leaveq 
  8004208c5e:	c3                   	retq   

0000008004208c5f <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
  8004208c5f:	55                   	push   %rbp
  8004208c60:	48 89 e5             	mov    %rsp,%rbp
  8004208c63:	48 83 ec 70          	sub    $0x70,%rsp
	didinit = 1;
  8004208c67:	48 b8 68 82 37 04 80 	movabs $0x8004378268,%rax
  8004208c6e:	00 00 00 
  8004208c71:	c6 00 01             	movb   $0x1,(%rax)
  8004208c74:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%rbp)
  8004208c7b:	c6 45 fb ff          	movb   $0xff,-0x5(%rbp)
  8004208c7f:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208c83:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208c86:	ee                   	out    %al,(%dx)
  8004208c87:	c7 45 f4 a1 00 00 00 	movl   $0xa1,-0xc(%rbp)
  8004208c8e:	c6 45 f3 ff          	movb   $0xff,-0xd(%rbp)
  8004208c92:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208c96:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208c99:	ee                   	out    %al,(%dx)
  8004208c9a:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%rbp)
  8004208ca1:	c6 45 eb 11          	movb   $0x11,-0x15(%rbp)
  8004208ca5:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004208ca9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004208cac:	ee                   	out    %al,(%dx)
  8004208cad:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%rbp)
  8004208cb4:	c6 45 e3 20          	movb   $0x20,-0x1d(%rbp)
  8004208cb8:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004208cbc:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004208cbf:	ee                   	out    %al,(%dx)
  8004208cc0:	c7 45 dc 21 00 00 00 	movl   $0x21,-0x24(%rbp)
  8004208cc7:	c6 45 db 04          	movb   $0x4,-0x25(%rbp)
  8004208ccb:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004208ccf:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004208cd2:	ee                   	out    %al,(%dx)
  8004208cd3:	c7 45 d4 21 00 00 00 	movl   $0x21,-0x2c(%rbp)
  8004208cda:	c6 45 d3 03          	movb   $0x3,-0x2d(%rbp)
  8004208cde:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004208ce2:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004208ce5:	ee                   	out    %al,(%dx)
  8004208ce6:	c7 45 cc a0 00 00 00 	movl   $0xa0,-0x34(%rbp)
  8004208ced:	c6 45 cb 11          	movb   $0x11,-0x35(%rbp)
  8004208cf1:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  8004208cf5:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004208cf8:	ee                   	out    %al,(%dx)
  8004208cf9:	c7 45 c4 a1 00 00 00 	movl   $0xa1,-0x3c(%rbp)
  8004208d00:	c6 45 c3 28          	movb   $0x28,-0x3d(%rbp)
  8004208d04:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
  8004208d08:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004208d0b:	ee                   	out    %al,(%dx)
  8004208d0c:	c7 45 bc a1 00 00 00 	movl   $0xa1,-0x44(%rbp)
  8004208d13:	c6 45 bb 02          	movb   $0x2,-0x45(%rbp)
  8004208d17:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004208d1b:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004208d1e:	ee                   	out    %al,(%dx)
  8004208d1f:	c7 45 b4 a1 00 00 00 	movl   $0xa1,-0x4c(%rbp)
  8004208d26:	c6 45 b3 01          	movb   $0x1,-0x4d(%rbp)
  8004208d2a:	0f b6 45 b3          	movzbl -0x4d(%rbp),%eax
  8004208d2e:	8b 55 b4             	mov    -0x4c(%rbp),%edx
  8004208d31:	ee                   	out    %al,(%dx)
  8004208d32:	c7 45 ac 20 00 00 00 	movl   $0x20,-0x54(%rbp)
  8004208d39:	c6 45 ab 68          	movb   $0x68,-0x55(%rbp)
  8004208d3d:	0f b6 45 ab          	movzbl -0x55(%rbp),%eax
  8004208d41:	8b 55 ac             	mov    -0x54(%rbp),%edx
  8004208d44:	ee                   	out    %al,(%dx)
  8004208d45:	c7 45 a4 20 00 00 00 	movl   $0x20,-0x5c(%rbp)
  8004208d4c:	c6 45 a3 0a          	movb   $0xa,-0x5d(%rbp)
  8004208d50:	0f b6 45 a3          	movzbl -0x5d(%rbp),%eax
  8004208d54:	8b 55 a4             	mov    -0x5c(%rbp),%edx
  8004208d57:	ee                   	out    %al,(%dx)
  8004208d58:	c7 45 9c a0 00 00 00 	movl   $0xa0,-0x64(%rbp)
  8004208d5f:	c6 45 9b 68          	movb   $0x68,-0x65(%rbp)
  8004208d63:	0f b6 45 9b          	movzbl -0x65(%rbp),%eax
  8004208d67:	8b 55 9c             	mov    -0x64(%rbp),%edx
  8004208d6a:	ee                   	out    %al,(%dx)
  8004208d6b:	c7 45 94 a0 00 00 00 	movl   $0xa0,-0x6c(%rbp)
  8004208d72:	c6 45 93 0a          	movb   $0xa,-0x6d(%rbp)
  8004208d76:	0f b6 45 93          	movzbl -0x6d(%rbp),%eax
  8004208d7a:	8b 55 94             	mov    -0x6c(%rbp),%edx
  8004208d7d:	ee                   	out    %al,(%dx)
	outb(IO_PIC1, 0x0a);             /* read IRR by default */

	outb(IO_PIC2, 0x68);               /* OCW3 */
	outb(IO_PIC2, 0x0a);               /* OCW3 */

	if (irq_mask_8259A != 0xFFFF)
  8004208d7e:	48 b8 52 b6 22 04 80 	movabs $0x800422b652,%rax
  8004208d85:	00 00 00 
  8004208d88:	0f b7 00             	movzwl (%rax),%eax
  8004208d8b:	66 83 f8 ff          	cmp    $0xffff,%ax
  8004208d8f:	74 1e                	je     8004208daf <pic_init+0x150>
		irq_setmask_8259A(irq_mask_8259A);
  8004208d91:	48 b8 52 b6 22 04 80 	movabs $0x800422b652,%rax
  8004208d98:	00 00 00 
  8004208d9b:	0f b7 00             	movzwl (%rax),%eax
  8004208d9e:	0f b7 c0             	movzwl %ax,%eax
  8004208da1:	89 c7                	mov    %eax,%edi
  8004208da3:	48 b8 b1 8d 20 04 80 	movabs $0x8004208db1,%rax
  8004208daa:	00 00 00 
  8004208dad:	ff d0                	callq  *%rax
}
  8004208daf:	c9                   	leaveq 
  8004208db0:	c3                   	retq   

0000008004208db1 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16_t mask)
{
  8004208db1:	55                   	push   %rbp
  8004208db2:	48 89 e5             	mov    %rsp,%rbp
  8004208db5:	48 83 ec 30          	sub    $0x30,%rsp
  8004208db9:	89 f8                	mov    %edi,%eax
  8004208dbb:	66 89 45 dc          	mov    %ax,-0x24(%rbp)
	int i;
	irq_mask_8259A = mask;
  8004208dbf:	48 b8 52 b6 22 04 80 	movabs $0x800422b652,%rax
  8004208dc6:	00 00 00 
  8004208dc9:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
  8004208dcd:	66 89 10             	mov    %dx,(%rax)
	if (!didinit)
  8004208dd0:	48 b8 68 82 37 04 80 	movabs $0x8004378268,%rax
  8004208dd7:	00 00 00 
  8004208dda:	0f b6 00             	movzbl (%rax),%eax
  8004208ddd:	83 f0 01             	xor    $0x1,%eax
  8004208de0:	84 c0                	test   %al,%al
  8004208de2:	74 05                	je     8004208de9 <irq_setmask_8259A+0x38>
		return;
  8004208de4:	e9 b7 00 00 00       	jmpq   8004208ea0 <irq_setmask_8259A+0xef>
	outb(IO_PIC1+1, (char)mask);
  8004208de9:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208ded:	0f b6 c0             	movzbl %al,%eax
  8004208df0:	c7 45 f8 21 00 00 00 	movl   $0x21,-0x8(%rbp)
  8004208df7:	88 45 f7             	mov    %al,-0x9(%rbp)
  8004208dfa:	0f b6 45 f7          	movzbl -0x9(%rbp),%eax
  8004208dfe:	8b 55 f8             	mov    -0x8(%rbp),%edx
  8004208e01:	ee                   	out    %al,(%dx)
	outb(IO_PIC2+1, (char)(mask >> 8));
  8004208e02:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208e06:	66 c1 e8 08          	shr    $0x8,%ax
  8004208e0a:	0f b6 c0             	movzbl %al,%eax
  8004208e0d:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%rbp)
  8004208e14:	88 45 ef             	mov    %al,-0x11(%rbp)
  8004208e17:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  8004208e1b:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004208e1e:	ee                   	out    %al,(%dx)
	cprintf("enabled interrupts:");
  8004208e1f:	48 bf fd 90 21 04 80 	movabs $0x80042190fd,%rdi
  8004208e26:	00 00 00 
  8004208e29:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208e2e:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004208e35:	00 00 00 
  8004208e38:	ff d2                	callq  *%rdx
	for (i = 0; i < 16; i++)
  8004208e3a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004208e41:	eb 3c                	jmp    8004208e7f <irq_setmask_8259A+0xce>
		if (~mask & (1<<i))
  8004208e43:	0f b7 45 dc          	movzwl -0x24(%rbp),%eax
  8004208e47:	f7 d0                	not    %eax
  8004208e49:	89 c2                	mov    %eax,%edx
  8004208e4b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208e4e:	89 c1                	mov    %eax,%ecx
  8004208e50:	d3 fa                	sar    %cl,%edx
  8004208e52:	89 d0                	mov    %edx,%eax
  8004208e54:	83 e0 01             	and    $0x1,%eax
  8004208e57:	85 c0                	test   %eax,%eax
  8004208e59:	74 20                	je     8004208e7b <irq_setmask_8259A+0xca>
			cprintf(" %d", i);
  8004208e5b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208e5e:	89 c6                	mov    %eax,%esi
  8004208e60:	48 bf 11 91 21 04 80 	movabs $0x8004219111,%rdi
  8004208e67:	00 00 00 
  8004208e6a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208e6f:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004208e76:	00 00 00 
  8004208e79:	ff d2                	callq  *%rdx
	if (!didinit)
		return;
	outb(IO_PIC1+1, (char)mask);
	outb(IO_PIC2+1, (char)(mask >> 8));
	cprintf("enabled interrupts:");
	for (i = 0; i < 16; i++)
  8004208e7b:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004208e7f:	83 7d fc 0f          	cmpl   $0xf,-0x4(%rbp)
  8004208e83:	7e be                	jle    8004208e43 <irq_setmask_8259A+0x92>
		if (~mask & (1<<i))
			cprintf(" %d", i);
	cprintf("\n");
  8004208e85:	48 bf 15 91 21 04 80 	movabs $0x8004219115,%rdi
  8004208e8c:	00 00 00 
  8004208e8f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004208e94:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004208e9b:	00 00 00 
  8004208e9e:	ff d2                	callq  *%rdx
}
  8004208ea0:	c9                   	leaveq 
  8004208ea1:	c3                   	retq   

0000008004208ea2 <irq_eoi>:

void
irq_eoi(void)
{
  8004208ea2:	55                   	push   %rbp
  8004208ea3:	48 89 e5             	mov    %rsp,%rbp
  8004208ea6:	48 83 ec 10          	sub    $0x10,%rsp
  8004208eaa:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%rbp)
  8004208eb1:	c6 45 fb 20          	movb   $0x20,-0x5(%rbp)
  8004208eb5:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004208eb9:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004208ebc:	ee                   	out    %al,(%dx)
  8004208ebd:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%rbp)
  8004208ec4:	c6 45 f3 20          	movb   $0x20,-0xd(%rbp)
  8004208ec8:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004208ecc:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004208ecf:	ee                   	out    %al,(%dx)
	//   s: specific
	//   e: end-of-interrupt
	// xxx: specific interrupt line
	outb(IO_PIC1, 0x20);
	outb(IO_PIC2, 0x20);
}
  8004208ed0:	c9                   	leaveq 
  8004208ed1:	c3                   	retq   

0000008004208ed2 <putch>:
#include <inc/stdarg.h>


static void
putch(int ch, int *cnt)
{
  8004208ed2:	55                   	push   %rbp
  8004208ed3:	48 89 e5             	mov    %rsp,%rbp
  8004208ed6:	48 83 ec 10          	sub    $0x10,%rsp
  8004208eda:	89 7d fc             	mov    %edi,-0x4(%rbp)
  8004208edd:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	cputchar(ch);
  8004208ee1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004208ee4:	89 c7                	mov    %eax,%edi
  8004208ee6:	48 b8 af 13 20 04 80 	movabs $0x80042013af,%rax
  8004208eed:	00 00 00 
  8004208ef0:	ff d0                	callq  *%rax
	*cnt++;
  8004208ef2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004208ef6:	48 83 c0 04          	add    $0x4,%rax
  8004208efa:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
}
  8004208efe:	c9                   	leaveq 
  8004208eff:	c3                   	retq   

0000008004208f00 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  8004208f00:	55                   	push   %rbp
  8004208f01:	48 89 e5             	mov    %rsp,%rbp
  8004208f04:	48 83 ec 30          	sub    $0x30,%rsp
  8004208f08:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004208f0c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int cnt = 0;
  8004208f10:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208f17:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004208f1b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004208f1f:	48 8b 0a             	mov    (%rdx),%rcx
  8004208f22:	48 89 08             	mov    %rcx,(%rax)
  8004208f25:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208f29:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004208f2d:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004208f31:	48 89 50 10          	mov    %rdx,0x10(%rax)
	vprintfmt((void*)putch, &cnt, fmt, aq);
  8004208f35:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  8004208f39:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004208f3d:	48 8d 45 fc          	lea    -0x4(%rbp),%rax
  8004208f41:	48 89 c6             	mov    %rax,%rsi
  8004208f44:	48 bf d2 8e 20 04 80 	movabs $0x8004208ed2,%rdi
  8004208f4b:	00 00 00 
  8004208f4e:	48 b8 8d ee 20 04 80 	movabs $0x800420ee8d,%rax
  8004208f55:	00 00 00 
  8004208f58:	ff d0                	callq  *%rax
	va_end(aq);
	return cnt;
  8004208f5a:	8b 45 fc             	mov    -0x4(%rbp),%eax

}
  8004208f5d:	c9                   	leaveq 
  8004208f5e:	c3                   	retq   

0000008004208f5f <cprintf>:

int
cprintf(const char *fmt, ...)
{
  8004208f5f:	55                   	push   %rbp
  8004208f60:	48 89 e5             	mov    %rsp,%rbp
  8004208f63:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
  8004208f6a:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
  8004208f71:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
  8004208f78:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  8004208f7f:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  8004208f86:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  8004208f8d:	84 c0                	test   %al,%al
  8004208f8f:	74 20                	je     8004208fb1 <cprintf+0x52>
  8004208f91:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  8004208f95:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  8004208f99:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  8004208f9d:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  8004208fa1:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  8004208fa5:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  8004208fa9:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  8004208fad:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  8004208fb1:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
	va_list ap;
	int cnt;
	va_start(ap, fmt);
  8004208fb8:	c7 85 30 ff ff ff 08 	movl   $0x8,-0xd0(%rbp)
  8004208fbf:	00 00 00 
  8004208fc2:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  8004208fc9:	00 00 00 
  8004208fcc:	48 8d 45 10          	lea    0x10(%rbp),%rax
  8004208fd0:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004208fd7:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  8004208fde:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_list aq;
	va_copy(aq,ap);
  8004208fe5:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  8004208fec:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  8004208ff3:	48 8b 0a             	mov    (%rdx),%rcx
  8004208ff6:	48 89 08             	mov    %rcx,(%rax)
  8004208ff9:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004208ffd:	48 89 48 08          	mov    %rcx,0x8(%rax)
  8004209001:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  8004209005:	48 89 50 10          	mov    %rdx,0x10(%rax)
	cnt = vcprintf(fmt, aq);
  8004209009:	48 8d 95 18 ff ff ff 	lea    -0xe8(%rbp),%rdx
  8004209010:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004209017:	48 89 d6             	mov    %rdx,%rsi
  800420901a:	48 89 c7             	mov    %rax,%rdi
  800420901d:	48 b8 00 8f 20 04 80 	movabs $0x8004208f00,%rax
  8004209024:	00 00 00 
  8004209027:	ff d0                	callq  *%rax
  8004209029:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return cnt;
  800420902f:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  8004209035:	c9                   	leaveq 
  8004209036:	c3                   	retq   

0000008004209037 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004209037:	55                   	push   %rbp
  8004209038:	48 89 e5             	mov    %rsp,%rbp
  800420903b:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420903f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004209043:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004209046:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420904a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420904d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004209051:	f0 87 02             	lock xchg %eax,(%rdx)
  8004209054:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004209057:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420905a:	c9                   	leaveq 
  800420905b:	c3                   	retq   

000000800420905c <lock_kernel>:

extern struct spinlock kernel_lock;

static inline void
lock_kernel(void)
{
  800420905c:	55                   	push   %rbp
  800420905d:	48 89 e5             	mov    %rsp,%rbp
	spin_lock(&kernel_lock);
  8004209060:	48 bf 40 b7 22 04 80 	movabs $0x800422b740,%rdi
  8004209067:	00 00 00 
  800420906a:	48 b8 15 6e 21 04 80 	movabs $0x8004216e15,%rax
  8004209071:	00 00 00 
  8004209074:	ff d0                	callq  *%rax
}
  8004209076:	5d                   	pop    %rbp
  8004209077:	c3                   	retq   

0000008004209078 <trapname>:
struct Gatedesc idt[256] = { { 0 } };
struct Pseudodesc idt_pd = {0,0};


static const char *trapname(int trapno)
{
  8004209078:	55                   	push   %rbp
  8004209079:	48 89 e5             	mov    %rsp,%rbp
  800420907c:	48 83 ec 04          	sub    $0x4,%rsp
  8004209080:	89 7d fc             	mov    %edi,-0x4(%rbp)
		"Alignment Check",
		"Machine-Check",
		"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
  8004209083:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004209086:	83 f8 13             	cmp    $0x13,%eax
  8004209089:	77 16                	ja     80042090a1 <trapname+0x29>
		return excnames[trapno];
  800420908b:	48 b8 60 95 21 04 80 	movabs $0x8004219560,%rax
  8004209092:	00 00 00 
  8004209095:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004209098:	48 63 d2             	movslq %edx,%rdx
  800420909b:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  800420909f:	eb 34                	jmp    80042090d5 <trapname+0x5d>
	if (trapno == T_SYSCALL)
  80042090a1:	83 7d fc 30          	cmpl   $0x30,-0x4(%rbp)
  80042090a5:	75 0c                	jne    80042090b3 <trapname+0x3b>
		return "System call";
  80042090a7:	48 b8 20 91 21 04 80 	movabs $0x8004219120,%rax
  80042090ae:	00 00 00 
  80042090b1:	eb 22                	jmp    80042090d5 <trapname+0x5d>
	if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16)
  80042090b3:	83 7d fc 1f          	cmpl   $0x1f,-0x4(%rbp)
  80042090b7:	7e 12                	jle    80042090cb <trapname+0x53>
  80042090b9:	83 7d fc 2f          	cmpl   $0x2f,-0x4(%rbp)
  80042090bd:	7f 0c                	jg     80042090cb <trapname+0x53>
		return "Hardware Interrupt";
  80042090bf:	48 b8 2c 91 21 04 80 	movabs $0x800421912c,%rax
  80042090c6:	00 00 00 
  80042090c9:	eb 0a                	jmp    80042090d5 <trapname+0x5d>
	return "(unknown trap)";
  80042090cb:	48 b8 3f 91 21 04 80 	movabs $0x800421913f,%rax
  80042090d2:	00 00 00 
}
  80042090d5:	c9                   	leaveq 
  80042090d6:	c3                   	retq   

00000080042090d7 <trap_init>:


void
trap_init(void)
{
  80042090d7:	55                   	push   %rbp
  80042090d8:	48 89 e5             	mov    %rsp,%rbp
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
    SETGATE(idt[T_DIVIDE], 0, GD_KT, XTRPX_divzero, 0);  
  80042090db:	48 b8 20 ce 20 04 80 	movabs $0x800420ce20,%rax
  80042090e2:	00 00 00 
  80042090e5:	89 c2                	mov    %eax,%edx
  80042090e7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042090ee:	00 00 00 
  80042090f1:	66 89 10             	mov    %dx,(%rax)
  80042090f4:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042090fb:	00 00 00 
  80042090fe:	66 c7 40 02 08 00    	movw   $0x8,0x2(%rax)
  8004209104:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420910b:	00 00 00 
  800420910e:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209112:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209115:	88 50 04             	mov    %dl,0x4(%rax)
  8004209118:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420911f:	00 00 00 
  8004209122:	0f b6 50 04          	movzbl 0x4(%rax),%edx
  8004209126:	83 e2 07             	and    $0x7,%edx
  8004209129:	88 50 04             	mov    %dl,0x4(%rax)
  800420912c:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209133:	00 00 00 
  8004209136:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420913a:	83 e2 f0             	and    $0xfffffff0,%edx
  800420913d:	83 ca 0e             	or     $0xe,%edx
  8004209140:	88 50 05             	mov    %dl,0x5(%rax)
  8004209143:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420914a:	00 00 00 
  800420914d:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209151:	83 e2 ef             	and    $0xffffffef,%edx
  8004209154:	88 50 05             	mov    %dl,0x5(%rax)
  8004209157:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420915e:	00 00 00 
  8004209161:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209165:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209168:	88 50 05             	mov    %dl,0x5(%rax)
  800420916b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209172:	00 00 00 
  8004209175:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  8004209179:	83 ca 80             	or     $0xffffff80,%edx
  800420917c:	88 50 05             	mov    %dl,0x5(%rax)
  800420917f:	48 b8 20 ce 20 04 80 	movabs $0x800420ce20,%rax
  8004209186:	00 00 00 
  8004209189:	48 c1 e8 10          	shr    $0x10,%rax
  800420918d:	89 c2                	mov    %eax,%edx
  800420918f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209196:	00 00 00 
  8004209199:	66 89 50 06          	mov    %dx,0x6(%rax)
  800420919d:	48 b8 20 ce 20 04 80 	movabs $0x800420ce20,%rax
  80042091a4:	00 00 00 
  80042091a7:	48 c1 e8 20          	shr    $0x20,%rax
  80042091ab:	89 c2                	mov    %eax,%edx
  80042091ad:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042091b4:	00 00 00 
  80042091b7:	89 50 08             	mov    %edx,0x8(%rax)
  80042091ba:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042091c1:	00 00 00 
  80042091c4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
    SETGATE(idt[T_DEBUG], 0, GD_KT, XTRPX_Debug, 0);  
  80042091cb:	48 b8 2a ce 20 04 80 	movabs $0x800420ce2a,%rax
  80042091d2:	00 00 00 
  80042091d5:	89 c2                	mov    %eax,%edx
  80042091d7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042091de:	00 00 00 
  80042091e1:	66 89 50 10          	mov    %dx,0x10(%rax)
  80042091e5:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042091ec:	00 00 00 
  80042091ef:	66 c7 40 12 08 00    	movw   $0x8,0x12(%rax)
  80042091f5:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042091fc:	00 00 00 
  80042091ff:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004209203:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209206:	88 50 14             	mov    %dl,0x14(%rax)
  8004209209:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209210:	00 00 00 
  8004209213:	0f b6 50 14          	movzbl 0x14(%rax),%edx
  8004209217:	83 e2 07             	and    $0x7,%edx
  800420921a:	88 50 14             	mov    %dl,0x14(%rax)
  800420921d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209224:	00 00 00 
  8004209227:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420922b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420922e:	83 ca 0e             	or     $0xe,%edx
  8004209231:	88 50 15             	mov    %dl,0x15(%rax)
  8004209234:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420923b:	00 00 00 
  800420923e:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209242:	83 e2 ef             	and    $0xffffffef,%edx
  8004209245:	88 50 15             	mov    %dl,0x15(%rax)
  8004209248:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420924f:	00 00 00 
  8004209252:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  8004209256:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209259:	88 50 15             	mov    %dl,0x15(%rax)
  800420925c:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209263:	00 00 00 
  8004209266:	0f b6 50 15          	movzbl 0x15(%rax),%edx
  800420926a:	83 ca 80             	or     $0xffffff80,%edx
  800420926d:	88 50 15             	mov    %dl,0x15(%rax)
  8004209270:	48 b8 2a ce 20 04 80 	movabs $0x800420ce2a,%rax
  8004209277:	00 00 00 
  800420927a:	48 c1 e8 10          	shr    $0x10,%rax
  800420927e:	89 c2                	mov    %eax,%edx
  8004209280:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209287:	00 00 00 
  800420928a:	66 89 50 16          	mov    %dx,0x16(%rax)
  800420928e:	48 b8 2a ce 20 04 80 	movabs $0x800420ce2a,%rax
  8004209295:	00 00 00 
  8004209298:	48 c1 e8 20          	shr    $0x20,%rax
  800420929c:	89 c2                	mov    %eax,%edx
  800420929e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042092a5:	00 00 00 
  80042092a8:	89 50 18             	mov    %edx,0x18(%rax)
  80042092ab:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042092b2:	00 00 00 
  80042092b5:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%rax)
    SETGATE(idt[T_NMI], 0, GD_KT, XTRPX_NonMaskI, 0);  
  80042092bc:	48 b8 34 ce 20 04 80 	movabs $0x800420ce34,%rax
  80042092c3:	00 00 00 
  80042092c6:	89 c2                	mov    %eax,%edx
  80042092c8:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042092cf:	00 00 00 
  80042092d2:	66 89 50 20          	mov    %dx,0x20(%rax)
  80042092d6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042092dd:	00 00 00 
  80042092e0:	66 c7 40 22 08 00    	movw   $0x8,0x22(%rax)
  80042092e6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042092ed:	00 00 00 
  80042092f0:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  80042092f4:	83 e2 f8             	and    $0xfffffff8,%edx
  80042092f7:	88 50 24             	mov    %dl,0x24(%rax)
  80042092fa:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209301:	00 00 00 
  8004209304:	0f b6 50 24          	movzbl 0x24(%rax),%edx
  8004209308:	83 e2 07             	and    $0x7,%edx
  800420930b:	88 50 24             	mov    %dl,0x24(%rax)
  800420930e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209315:	00 00 00 
  8004209318:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420931c:	83 e2 f0             	and    $0xfffffff0,%edx
  800420931f:	83 ca 0e             	or     $0xe,%edx
  8004209322:	88 50 25             	mov    %dl,0x25(%rax)
  8004209325:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420932c:	00 00 00 
  800420932f:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209333:	83 e2 ef             	and    $0xffffffef,%edx
  8004209336:	88 50 25             	mov    %dl,0x25(%rax)
  8004209339:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209340:	00 00 00 
  8004209343:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  8004209347:	83 e2 9f             	and    $0xffffff9f,%edx
  800420934a:	88 50 25             	mov    %dl,0x25(%rax)
  800420934d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209354:	00 00 00 
  8004209357:	0f b6 50 25          	movzbl 0x25(%rax),%edx
  800420935b:	83 ca 80             	or     $0xffffff80,%edx
  800420935e:	88 50 25             	mov    %dl,0x25(%rax)
  8004209361:	48 b8 34 ce 20 04 80 	movabs $0x800420ce34,%rax
  8004209368:	00 00 00 
  800420936b:	48 c1 e8 10          	shr    $0x10,%rax
  800420936f:	89 c2                	mov    %eax,%edx
  8004209371:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209378:	00 00 00 
  800420937b:	66 89 50 26          	mov    %dx,0x26(%rax)
  800420937f:	48 b8 34 ce 20 04 80 	movabs $0x800420ce34,%rax
  8004209386:	00 00 00 
  8004209389:	48 c1 e8 20          	shr    $0x20,%rax
  800420938d:	89 c2                	mov    %eax,%edx
  800420938f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209396:	00 00 00 
  8004209399:	89 50 28             	mov    %edx,0x28(%rax)
  800420939c:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042093a3:	00 00 00 
  80042093a6:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%rax)
    SETGATE(idt[T_BRKPT], 0, GD_KT, XTRPX_Brkpt, 3);  
  80042093ad:	48 b8 3e ce 20 04 80 	movabs $0x800420ce3e,%rax
  80042093b4:	00 00 00 
  80042093b7:	89 c2                	mov    %eax,%edx
  80042093b9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042093c0:	00 00 00 
  80042093c3:	66 89 50 30          	mov    %dx,0x30(%rax)
  80042093c7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042093ce:	00 00 00 
  80042093d1:	66 c7 40 32 08 00    	movw   $0x8,0x32(%rax)
  80042093d7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042093de:	00 00 00 
  80042093e1:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  80042093e5:	83 e2 f8             	and    $0xfffffff8,%edx
  80042093e8:	88 50 34             	mov    %dl,0x34(%rax)
  80042093eb:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042093f2:	00 00 00 
  80042093f5:	0f b6 50 34          	movzbl 0x34(%rax),%edx
  80042093f9:	83 e2 07             	and    $0x7,%edx
  80042093fc:	88 50 34             	mov    %dl,0x34(%rax)
  80042093ff:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209406:	00 00 00 
  8004209409:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420940d:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209410:	83 ca 0e             	or     $0xe,%edx
  8004209413:	88 50 35             	mov    %dl,0x35(%rax)
  8004209416:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420941d:	00 00 00 
  8004209420:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209424:	83 e2 ef             	and    $0xffffffef,%edx
  8004209427:	88 50 35             	mov    %dl,0x35(%rax)
  800420942a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209431:	00 00 00 
  8004209434:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  8004209438:	83 ca 60             	or     $0x60,%edx
  800420943b:	88 50 35             	mov    %dl,0x35(%rax)
  800420943e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209445:	00 00 00 
  8004209448:	0f b6 50 35          	movzbl 0x35(%rax),%edx
  800420944c:	83 ca 80             	or     $0xffffff80,%edx
  800420944f:	88 50 35             	mov    %dl,0x35(%rax)
  8004209452:	48 b8 3e ce 20 04 80 	movabs $0x800420ce3e,%rax
  8004209459:	00 00 00 
  800420945c:	48 c1 e8 10          	shr    $0x10,%rax
  8004209460:	89 c2                	mov    %eax,%edx
  8004209462:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209469:	00 00 00 
  800420946c:	66 89 50 36          	mov    %dx,0x36(%rax)
  8004209470:	48 b8 3e ce 20 04 80 	movabs $0x800420ce3e,%rax
  8004209477:	00 00 00 
  800420947a:	48 c1 e8 20          	shr    $0x20,%rax
  800420947e:	89 c2                	mov    %eax,%edx
  8004209480:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209487:	00 00 00 
  800420948a:	89 50 38             	mov    %edx,0x38(%rax)
  800420948d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209494:	00 00 00 
  8004209497:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%rax)
    SETGATE(idt[T_OFLOW], 0, GD_KT, XTRPX_OFlow, 0);  
  800420949e:	48 b8 48 ce 20 04 80 	movabs $0x800420ce48,%rax
  80042094a5:	00 00 00 
  80042094a8:	89 c2                	mov    %eax,%edx
  80042094aa:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042094b1:	00 00 00 
  80042094b4:	66 89 50 40          	mov    %dx,0x40(%rax)
  80042094b8:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042094bf:	00 00 00 
  80042094c2:	66 c7 40 42 08 00    	movw   $0x8,0x42(%rax)
  80042094c8:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042094cf:	00 00 00 
  80042094d2:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  80042094d6:	83 e2 f8             	and    $0xfffffff8,%edx
  80042094d9:	88 50 44             	mov    %dl,0x44(%rax)
  80042094dc:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042094e3:	00 00 00 
  80042094e6:	0f b6 50 44          	movzbl 0x44(%rax),%edx
  80042094ea:	83 e2 07             	and    $0x7,%edx
  80042094ed:	88 50 44             	mov    %dl,0x44(%rax)
  80042094f0:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042094f7:	00 00 00 
  80042094fa:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  80042094fe:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209501:	83 ca 0e             	or     $0xe,%edx
  8004209504:	88 50 45             	mov    %dl,0x45(%rax)
  8004209507:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420950e:	00 00 00 
  8004209511:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209515:	83 e2 ef             	and    $0xffffffef,%edx
  8004209518:	88 50 45             	mov    %dl,0x45(%rax)
  800420951b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209522:	00 00 00 
  8004209525:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  8004209529:	83 e2 9f             	and    $0xffffff9f,%edx
  800420952c:	88 50 45             	mov    %dl,0x45(%rax)
  800420952f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209536:	00 00 00 
  8004209539:	0f b6 50 45          	movzbl 0x45(%rax),%edx
  800420953d:	83 ca 80             	or     $0xffffff80,%edx
  8004209540:	88 50 45             	mov    %dl,0x45(%rax)
  8004209543:	48 b8 48 ce 20 04 80 	movabs $0x800420ce48,%rax
  800420954a:	00 00 00 
  800420954d:	48 c1 e8 10          	shr    $0x10,%rax
  8004209551:	89 c2                	mov    %eax,%edx
  8004209553:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420955a:	00 00 00 
  800420955d:	66 89 50 46          	mov    %dx,0x46(%rax)
  8004209561:	48 b8 48 ce 20 04 80 	movabs $0x800420ce48,%rax
  8004209568:	00 00 00 
  800420956b:	48 c1 e8 20          	shr    $0x20,%rax
  800420956f:	89 c2                	mov    %eax,%edx
  8004209571:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209578:	00 00 00 
  800420957b:	89 50 48             	mov    %edx,0x48(%rax)
  800420957e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209585:	00 00 00 
  8004209588:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%rax)
    SETGATE(idt[T_BOUND], 0, GD_KT, XTRPX_Bound, 0);  
  800420958f:	48 b8 52 ce 20 04 80 	movabs $0x800420ce52,%rax
  8004209596:	00 00 00 
  8004209599:	89 c2                	mov    %eax,%edx
  800420959b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042095a2:	00 00 00 
  80042095a5:	66 89 50 50          	mov    %dx,0x50(%rax)
  80042095a9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042095b0:	00 00 00 
  80042095b3:	66 c7 40 52 08 00    	movw   $0x8,0x52(%rax)
  80042095b9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042095c0:	00 00 00 
  80042095c3:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  80042095c7:	83 e2 f8             	and    $0xfffffff8,%edx
  80042095ca:	88 50 54             	mov    %dl,0x54(%rax)
  80042095cd:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042095d4:	00 00 00 
  80042095d7:	0f b6 50 54          	movzbl 0x54(%rax),%edx
  80042095db:	83 e2 07             	and    $0x7,%edx
  80042095de:	88 50 54             	mov    %dl,0x54(%rax)
  80042095e1:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042095e8:	00 00 00 
  80042095eb:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  80042095ef:	83 e2 f0             	and    $0xfffffff0,%edx
  80042095f2:	83 ca 0e             	or     $0xe,%edx
  80042095f5:	88 50 55             	mov    %dl,0x55(%rax)
  80042095f8:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042095ff:	00 00 00 
  8004209602:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  8004209606:	83 e2 ef             	and    $0xffffffef,%edx
  8004209609:	88 50 55             	mov    %dl,0x55(%rax)
  800420960c:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209613:	00 00 00 
  8004209616:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420961a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420961d:	88 50 55             	mov    %dl,0x55(%rax)
  8004209620:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209627:	00 00 00 
  800420962a:	0f b6 50 55          	movzbl 0x55(%rax),%edx
  800420962e:	83 ca 80             	or     $0xffffff80,%edx
  8004209631:	88 50 55             	mov    %dl,0x55(%rax)
  8004209634:	48 b8 52 ce 20 04 80 	movabs $0x800420ce52,%rax
  800420963b:	00 00 00 
  800420963e:	48 c1 e8 10          	shr    $0x10,%rax
  8004209642:	89 c2                	mov    %eax,%edx
  8004209644:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420964b:	00 00 00 
  800420964e:	66 89 50 56          	mov    %dx,0x56(%rax)
  8004209652:	48 b8 52 ce 20 04 80 	movabs $0x800420ce52,%rax
  8004209659:	00 00 00 
  800420965c:	48 c1 e8 20          	shr    $0x20,%rax
  8004209660:	89 c2                	mov    %eax,%edx
  8004209662:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209669:	00 00 00 
  800420966c:	89 50 58             	mov    %edx,0x58(%rax)
  800420966f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209676:	00 00 00 
  8004209679:	c7 40 5c 00 00 00 00 	movl   $0x0,0x5c(%rax)
    SETGATE(idt[T_ILLOP], 0, GD_KT, XTRPX_Illop, 0);  
  8004209680:	48 b8 5c ce 20 04 80 	movabs $0x800420ce5c,%rax
  8004209687:	00 00 00 
  800420968a:	89 c2                	mov    %eax,%edx
  800420968c:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209693:	00 00 00 
  8004209696:	66 89 50 60          	mov    %dx,0x60(%rax)
  800420969a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042096a1:	00 00 00 
  80042096a4:	66 c7 40 62 08 00    	movw   $0x8,0x62(%rax)
  80042096aa:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042096b1:	00 00 00 
  80042096b4:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  80042096b8:	83 e2 f8             	and    $0xfffffff8,%edx
  80042096bb:	88 50 64             	mov    %dl,0x64(%rax)
  80042096be:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042096c5:	00 00 00 
  80042096c8:	0f b6 50 64          	movzbl 0x64(%rax),%edx
  80042096cc:	83 e2 07             	and    $0x7,%edx
  80042096cf:	88 50 64             	mov    %dl,0x64(%rax)
  80042096d2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042096d9:	00 00 00 
  80042096dc:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  80042096e0:	83 e2 f0             	and    $0xfffffff0,%edx
  80042096e3:	83 ca 0e             	or     $0xe,%edx
  80042096e6:	88 50 65             	mov    %dl,0x65(%rax)
  80042096e9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042096f0:	00 00 00 
  80042096f3:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  80042096f7:	83 e2 ef             	and    $0xffffffef,%edx
  80042096fa:	88 50 65             	mov    %dl,0x65(%rax)
  80042096fd:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209704:	00 00 00 
  8004209707:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420970b:	83 e2 9f             	and    $0xffffff9f,%edx
  800420970e:	88 50 65             	mov    %dl,0x65(%rax)
  8004209711:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209718:	00 00 00 
  800420971b:	0f b6 50 65          	movzbl 0x65(%rax),%edx
  800420971f:	83 ca 80             	or     $0xffffff80,%edx
  8004209722:	88 50 65             	mov    %dl,0x65(%rax)
  8004209725:	48 b8 5c ce 20 04 80 	movabs $0x800420ce5c,%rax
  800420972c:	00 00 00 
  800420972f:	48 c1 e8 10          	shr    $0x10,%rax
  8004209733:	89 c2                	mov    %eax,%edx
  8004209735:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420973c:	00 00 00 
  800420973f:	66 89 50 66          	mov    %dx,0x66(%rax)
  8004209743:	48 b8 5c ce 20 04 80 	movabs $0x800420ce5c,%rax
  800420974a:	00 00 00 
  800420974d:	48 c1 e8 20          	shr    $0x20,%rax
  8004209751:	89 c2                	mov    %eax,%edx
  8004209753:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420975a:	00 00 00 
  800420975d:	89 50 68             	mov    %edx,0x68(%rax)
  8004209760:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209767:	00 00 00 
  800420976a:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%rax)
    SETGATE(idt[T_DEVICE], 0, GD_KT, XTRPX_Device, 0);  
  8004209771:	48 b8 66 ce 20 04 80 	movabs $0x800420ce66,%rax
  8004209778:	00 00 00 
  800420977b:	89 c2                	mov    %eax,%edx
  800420977d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209784:	00 00 00 
  8004209787:	66 89 50 70          	mov    %dx,0x70(%rax)
  800420978b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209792:	00 00 00 
  8004209795:	66 c7 40 72 08 00    	movw   $0x8,0x72(%rax)
  800420979b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042097a2:	00 00 00 
  80042097a5:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  80042097a9:	83 e2 f8             	and    $0xfffffff8,%edx
  80042097ac:	88 50 74             	mov    %dl,0x74(%rax)
  80042097af:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042097b6:	00 00 00 
  80042097b9:	0f b6 50 74          	movzbl 0x74(%rax),%edx
  80042097bd:	83 e2 07             	and    $0x7,%edx
  80042097c0:	88 50 74             	mov    %dl,0x74(%rax)
  80042097c3:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042097ca:	00 00 00 
  80042097cd:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  80042097d1:	83 e2 f0             	and    $0xfffffff0,%edx
  80042097d4:	83 ca 0e             	or     $0xe,%edx
  80042097d7:	88 50 75             	mov    %dl,0x75(%rax)
  80042097da:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042097e1:	00 00 00 
  80042097e4:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  80042097e8:	83 e2 ef             	and    $0xffffffef,%edx
  80042097eb:	88 50 75             	mov    %dl,0x75(%rax)
  80042097ee:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042097f5:	00 00 00 
  80042097f8:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  80042097fc:	83 e2 9f             	and    $0xffffff9f,%edx
  80042097ff:	88 50 75             	mov    %dl,0x75(%rax)
  8004209802:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209809:	00 00 00 
  800420980c:	0f b6 50 75          	movzbl 0x75(%rax),%edx
  8004209810:	83 ca 80             	or     $0xffffff80,%edx
  8004209813:	88 50 75             	mov    %dl,0x75(%rax)
  8004209816:	48 b8 66 ce 20 04 80 	movabs $0x800420ce66,%rax
  800420981d:	00 00 00 
  8004209820:	48 c1 e8 10          	shr    $0x10,%rax
  8004209824:	89 c2                	mov    %eax,%edx
  8004209826:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420982d:	00 00 00 
  8004209830:	66 89 50 76          	mov    %dx,0x76(%rax)
  8004209834:	48 b8 66 ce 20 04 80 	movabs $0x800420ce66,%rax
  800420983b:	00 00 00 
  800420983e:	48 c1 e8 20          	shr    $0x20,%rax
  8004209842:	89 c2                	mov    %eax,%edx
  8004209844:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420984b:	00 00 00 
  800420984e:	89 50 78             	mov    %edx,0x78(%rax)
  8004209851:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209858:	00 00 00 
  800420985b:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%rax)
    SETGATE(idt[T_DBLFLT], 0, GD_KT, XTRPX_DblFlt, 0);  
  8004209862:	48 b8 70 ce 20 04 80 	movabs $0x800420ce70,%rax
  8004209869:	00 00 00 
  800420986c:	89 c2                	mov    %eax,%edx
  800420986e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209875:	00 00 00 
  8004209878:	66 89 90 80 00 00 00 	mov    %dx,0x80(%rax)
  800420987f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209886:	00 00 00 
  8004209889:	66 c7 80 82 00 00 00 	movw   $0x8,0x82(%rax)
  8004209890:	08 00 
  8004209892:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209899:	00 00 00 
  800420989c:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  80042098a3:	83 e2 f8             	and    $0xfffffff8,%edx
  80042098a6:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  80042098ac:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042098b3:	00 00 00 
  80042098b6:	0f b6 90 84 00 00 00 	movzbl 0x84(%rax),%edx
  80042098bd:	83 e2 07             	and    $0x7,%edx
  80042098c0:	88 90 84 00 00 00    	mov    %dl,0x84(%rax)
  80042098c6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042098cd:	00 00 00 
  80042098d0:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042098d7:	83 e2 f0             	and    $0xfffffff0,%edx
  80042098da:	83 ca 0e             	or     $0xe,%edx
  80042098dd:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042098e3:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042098ea:	00 00 00 
  80042098ed:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  80042098f4:	83 e2 ef             	and    $0xffffffef,%edx
  80042098f7:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  80042098fd:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209904:	00 00 00 
  8004209907:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  800420990e:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209911:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209917:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420991e:	00 00 00 
  8004209921:	0f b6 90 85 00 00 00 	movzbl 0x85(%rax),%edx
  8004209928:	83 ca 80             	or     $0xffffff80,%edx
  800420992b:	88 90 85 00 00 00    	mov    %dl,0x85(%rax)
  8004209931:	48 b8 70 ce 20 04 80 	movabs $0x800420ce70,%rax
  8004209938:	00 00 00 
  800420993b:	48 c1 e8 10          	shr    $0x10,%rax
  800420993f:	89 c2                	mov    %eax,%edx
  8004209941:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209948:	00 00 00 
  800420994b:	66 89 90 86 00 00 00 	mov    %dx,0x86(%rax)
  8004209952:	48 b8 70 ce 20 04 80 	movabs $0x800420ce70,%rax
  8004209959:	00 00 00 
  800420995c:	48 c1 e8 20          	shr    $0x20,%rax
  8004209960:	89 c2                	mov    %eax,%edx
  8004209962:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209969:	00 00 00 
  800420996c:	89 90 88 00 00 00    	mov    %edx,0x88(%rax)
  8004209972:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209979:	00 00 00 
  800420997c:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%rax)
  8004209983:	00 00 00 
    SETGATE(idt[T_TSS], 0, GD_KT, XTRPX_Tss, 0);  
  8004209986:	48 b8 78 ce 20 04 80 	movabs $0x800420ce78,%rax
  800420998d:	00 00 00 
  8004209990:	89 c2                	mov    %eax,%edx
  8004209992:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209999:	00 00 00 
  800420999c:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
  80042099a3:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042099aa:	00 00 00 
  80042099ad:	66 c7 80 a2 00 00 00 	movw   $0x8,0xa2(%rax)
  80042099b4:	08 00 
  80042099b6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042099bd:	00 00 00 
  80042099c0:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  80042099c7:	83 e2 f8             	and    $0xfffffff8,%edx
  80042099ca:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  80042099d0:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042099d7:	00 00 00 
  80042099da:	0f b6 90 a4 00 00 00 	movzbl 0xa4(%rax),%edx
  80042099e1:	83 e2 07             	and    $0x7,%edx
  80042099e4:	88 90 a4 00 00 00    	mov    %dl,0xa4(%rax)
  80042099ea:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  80042099f1:	00 00 00 
  80042099f4:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  80042099fb:	83 e2 f0             	and    $0xfffffff0,%edx
  80042099fe:	83 ca 0e             	or     $0xe,%edx
  8004209a01:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209a07:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209a0e:	00 00 00 
  8004209a11:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209a18:	83 e2 ef             	and    $0xffffffef,%edx
  8004209a1b:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209a21:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209a28:	00 00 00 
  8004209a2b:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209a32:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209a35:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209a3b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209a42:	00 00 00 
  8004209a45:	0f b6 90 a5 00 00 00 	movzbl 0xa5(%rax),%edx
  8004209a4c:	83 ca 80             	or     $0xffffff80,%edx
  8004209a4f:	88 90 a5 00 00 00    	mov    %dl,0xa5(%rax)
  8004209a55:	48 b8 78 ce 20 04 80 	movabs $0x800420ce78,%rax
  8004209a5c:	00 00 00 
  8004209a5f:	48 c1 e8 10          	shr    $0x10,%rax
  8004209a63:	89 c2                	mov    %eax,%edx
  8004209a65:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209a6c:	00 00 00 
  8004209a6f:	66 89 90 a6 00 00 00 	mov    %dx,0xa6(%rax)
  8004209a76:	48 b8 78 ce 20 04 80 	movabs $0x800420ce78,%rax
  8004209a7d:	00 00 00 
  8004209a80:	48 c1 e8 20          	shr    $0x20,%rax
  8004209a84:	89 c2                	mov    %eax,%edx
  8004209a86:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209a8d:	00 00 00 
  8004209a90:	89 90 a8 00 00 00    	mov    %edx,0xa8(%rax)
  8004209a96:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209a9d:	00 00 00 
  8004209aa0:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%rax)
  8004209aa7:	00 00 00 
    SETGATE(idt[T_SEGNP], 0, GD_KT, XTRPX_Segnp, 0);  
  8004209aaa:	48 b8 80 ce 20 04 80 	movabs $0x800420ce80,%rax
  8004209ab1:	00 00 00 
  8004209ab4:	89 c2                	mov    %eax,%edx
  8004209ab6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209abd:	00 00 00 
  8004209ac0:	66 89 90 b0 00 00 00 	mov    %dx,0xb0(%rax)
  8004209ac7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209ace:	00 00 00 
  8004209ad1:	66 c7 80 b2 00 00 00 	movw   $0x8,0xb2(%rax)
  8004209ad8:	08 00 
  8004209ada:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209ae1:	00 00 00 
  8004209ae4:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209aeb:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209aee:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209af4:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209afb:	00 00 00 
  8004209afe:	0f b6 90 b4 00 00 00 	movzbl 0xb4(%rax),%edx
  8004209b05:	83 e2 07             	and    $0x7,%edx
  8004209b08:	88 90 b4 00 00 00    	mov    %dl,0xb4(%rax)
  8004209b0e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209b15:	00 00 00 
  8004209b18:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209b1f:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209b22:	83 ca 0e             	or     $0xe,%edx
  8004209b25:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209b2b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209b32:	00 00 00 
  8004209b35:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209b3c:	83 e2 ef             	and    $0xffffffef,%edx
  8004209b3f:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209b45:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209b4c:	00 00 00 
  8004209b4f:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209b56:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209b59:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209b5f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209b66:	00 00 00 
  8004209b69:	0f b6 90 b5 00 00 00 	movzbl 0xb5(%rax),%edx
  8004209b70:	83 ca 80             	or     $0xffffff80,%edx
  8004209b73:	88 90 b5 00 00 00    	mov    %dl,0xb5(%rax)
  8004209b79:	48 b8 80 ce 20 04 80 	movabs $0x800420ce80,%rax
  8004209b80:	00 00 00 
  8004209b83:	48 c1 e8 10          	shr    $0x10,%rax
  8004209b87:	89 c2                	mov    %eax,%edx
  8004209b89:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209b90:	00 00 00 
  8004209b93:	66 89 90 b6 00 00 00 	mov    %dx,0xb6(%rax)
  8004209b9a:	48 b8 80 ce 20 04 80 	movabs $0x800420ce80,%rax
  8004209ba1:	00 00 00 
  8004209ba4:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ba8:	89 c2                	mov    %eax,%edx
  8004209baa:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209bb1:	00 00 00 
  8004209bb4:	89 90 b8 00 00 00    	mov    %edx,0xb8(%rax)
  8004209bba:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209bc1:	00 00 00 
  8004209bc4:	c7 80 bc 00 00 00 00 	movl   $0x0,0xbc(%rax)
  8004209bcb:	00 00 00 
    SETGATE(idt[T_STACK], 0, GD_KT, XTRPX_Stack, 0);  
  8004209bce:	48 b8 88 ce 20 04 80 	movabs $0x800420ce88,%rax
  8004209bd5:	00 00 00 
  8004209bd8:	89 c2                	mov    %eax,%edx
  8004209bda:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209be1:	00 00 00 
  8004209be4:	66 89 90 c0 00 00 00 	mov    %dx,0xc0(%rax)
  8004209beb:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209bf2:	00 00 00 
  8004209bf5:	66 c7 80 c2 00 00 00 	movw   $0x8,0xc2(%rax)
  8004209bfc:	08 00 
  8004209bfe:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209c05:	00 00 00 
  8004209c08:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209c0f:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209c12:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209c18:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209c1f:	00 00 00 
  8004209c22:	0f b6 90 c4 00 00 00 	movzbl 0xc4(%rax),%edx
  8004209c29:	83 e2 07             	and    $0x7,%edx
  8004209c2c:	88 90 c4 00 00 00    	mov    %dl,0xc4(%rax)
  8004209c32:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209c39:	00 00 00 
  8004209c3c:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209c43:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209c46:	83 ca 0e             	or     $0xe,%edx
  8004209c49:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209c4f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209c56:	00 00 00 
  8004209c59:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209c60:	83 e2 ef             	and    $0xffffffef,%edx
  8004209c63:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209c69:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209c70:	00 00 00 
  8004209c73:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209c7a:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209c7d:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209c83:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209c8a:	00 00 00 
  8004209c8d:	0f b6 90 c5 00 00 00 	movzbl 0xc5(%rax),%edx
  8004209c94:	83 ca 80             	or     $0xffffff80,%edx
  8004209c97:	88 90 c5 00 00 00    	mov    %dl,0xc5(%rax)
  8004209c9d:	48 b8 88 ce 20 04 80 	movabs $0x800420ce88,%rax
  8004209ca4:	00 00 00 
  8004209ca7:	48 c1 e8 10          	shr    $0x10,%rax
  8004209cab:	89 c2                	mov    %eax,%edx
  8004209cad:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209cb4:	00 00 00 
  8004209cb7:	66 89 90 c6 00 00 00 	mov    %dx,0xc6(%rax)
  8004209cbe:	48 b8 88 ce 20 04 80 	movabs $0x800420ce88,%rax
  8004209cc5:	00 00 00 
  8004209cc8:	48 c1 e8 20          	shr    $0x20,%rax
  8004209ccc:	89 c2                	mov    %eax,%edx
  8004209cce:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209cd5:	00 00 00 
  8004209cd8:	89 90 c8 00 00 00    	mov    %edx,0xc8(%rax)
  8004209cde:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209ce5:	00 00 00 
  8004209ce8:	c7 80 cc 00 00 00 00 	movl   $0x0,0xcc(%rax)
  8004209cef:	00 00 00 
    SETGATE(idt[T_GPFLT], 0, GD_KT, XTRPX_Gpflt, 0);  
  8004209cf2:	48 b8 90 ce 20 04 80 	movabs $0x800420ce90,%rax
  8004209cf9:	00 00 00 
  8004209cfc:	89 c2                	mov    %eax,%edx
  8004209cfe:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209d05:	00 00 00 
  8004209d08:	66 89 90 d0 00 00 00 	mov    %dx,0xd0(%rax)
  8004209d0f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209d16:	00 00 00 
  8004209d19:	66 c7 80 d2 00 00 00 	movw   $0x8,0xd2(%rax)
  8004209d20:	08 00 
  8004209d22:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209d29:	00 00 00 
  8004209d2c:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209d33:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209d36:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209d3c:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209d43:	00 00 00 
  8004209d46:	0f b6 90 d4 00 00 00 	movzbl 0xd4(%rax),%edx
  8004209d4d:	83 e2 07             	and    $0x7,%edx
  8004209d50:	88 90 d4 00 00 00    	mov    %dl,0xd4(%rax)
  8004209d56:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209d5d:	00 00 00 
  8004209d60:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209d67:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209d6a:	83 ca 0e             	or     $0xe,%edx
  8004209d6d:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209d73:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209d7a:	00 00 00 
  8004209d7d:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209d84:	83 e2 ef             	and    $0xffffffef,%edx
  8004209d87:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209d8d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209d94:	00 00 00 
  8004209d97:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209d9e:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209da1:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209da7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209dae:	00 00 00 
  8004209db1:	0f b6 90 d5 00 00 00 	movzbl 0xd5(%rax),%edx
  8004209db8:	83 ca 80             	or     $0xffffff80,%edx
  8004209dbb:	88 90 d5 00 00 00    	mov    %dl,0xd5(%rax)
  8004209dc1:	48 b8 90 ce 20 04 80 	movabs $0x800420ce90,%rax
  8004209dc8:	00 00 00 
  8004209dcb:	48 c1 e8 10          	shr    $0x10,%rax
  8004209dcf:	89 c2                	mov    %eax,%edx
  8004209dd1:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209dd8:	00 00 00 
  8004209ddb:	66 89 90 d6 00 00 00 	mov    %dx,0xd6(%rax)
  8004209de2:	48 b8 90 ce 20 04 80 	movabs $0x800420ce90,%rax
  8004209de9:	00 00 00 
  8004209dec:	48 c1 e8 20          	shr    $0x20,%rax
  8004209df0:	89 c2                	mov    %eax,%edx
  8004209df2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209df9:	00 00 00 
  8004209dfc:	89 90 d8 00 00 00    	mov    %edx,0xd8(%rax)
  8004209e02:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209e09:	00 00 00 
  8004209e0c:	c7 80 dc 00 00 00 00 	movl   $0x0,0xdc(%rax)
  8004209e13:	00 00 00 
    SETGATE(idt[T_PGFLT], 0, GD_KT, XTRPX_Pgflt, 0);  
  8004209e16:	48 b8 98 ce 20 04 80 	movabs $0x800420ce98,%rax
  8004209e1d:	00 00 00 
  8004209e20:	89 c2                	mov    %eax,%edx
  8004209e22:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209e29:	00 00 00 
  8004209e2c:	66 89 90 e0 00 00 00 	mov    %dx,0xe0(%rax)
  8004209e33:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209e3a:	00 00 00 
  8004209e3d:	66 c7 80 e2 00 00 00 	movw   $0x8,0xe2(%rax)
  8004209e44:	08 00 
  8004209e46:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209e4d:	00 00 00 
  8004209e50:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209e57:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209e5a:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209e60:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209e67:	00 00 00 
  8004209e6a:	0f b6 90 e4 00 00 00 	movzbl 0xe4(%rax),%edx
  8004209e71:	83 e2 07             	and    $0x7,%edx
  8004209e74:	88 90 e4 00 00 00    	mov    %dl,0xe4(%rax)
  8004209e7a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209e81:	00 00 00 
  8004209e84:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209e8b:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209e8e:	83 ca 0e             	or     $0xe,%edx
  8004209e91:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209e97:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209e9e:	00 00 00 
  8004209ea1:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209ea8:	83 e2 ef             	and    $0xffffffef,%edx
  8004209eab:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209eb1:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209eb8:	00 00 00 
  8004209ebb:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209ec2:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209ec5:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209ecb:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209ed2:	00 00 00 
  8004209ed5:	0f b6 90 e5 00 00 00 	movzbl 0xe5(%rax),%edx
  8004209edc:	83 ca 80             	or     $0xffffff80,%edx
  8004209edf:	88 90 e5 00 00 00    	mov    %dl,0xe5(%rax)
  8004209ee5:	48 b8 98 ce 20 04 80 	movabs $0x800420ce98,%rax
  8004209eec:	00 00 00 
  8004209eef:	48 c1 e8 10          	shr    $0x10,%rax
  8004209ef3:	89 c2                	mov    %eax,%edx
  8004209ef5:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209efc:	00 00 00 
  8004209eff:	66 89 90 e6 00 00 00 	mov    %dx,0xe6(%rax)
  8004209f06:	48 b8 98 ce 20 04 80 	movabs $0x800420ce98,%rax
  8004209f0d:	00 00 00 
  8004209f10:	48 c1 e8 20          	shr    $0x20,%rax
  8004209f14:	89 c2                	mov    %eax,%edx
  8004209f16:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209f1d:	00 00 00 
  8004209f20:	89 90 e8 00 00 00    	mov    %edx,0xe8(%rax)
  8004209f26:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209f2d:	00 00 00 
  8004209f30:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%rax)
  8004209f37:	00 00 00 
    SETGATE(idt[T_FPERR], 0, GD_KT, XTRPX_FpErr, 0);  
  8004209f3a:	48 b8 a0 ce 20 04 80 	movabs $0x800420cea0,%rax
  8004209f41:	00 00 00 
  8004209f44:	89 c2                	mov    %eax,%edx
  8004209f46:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209f4d:	00 00 00 
  8004209f50:	66 89 90 00 01 00 00 	mov    %dx,0x100(%rax)
  8004209f57:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209f5e:	00 00 00 
  8004209f61:	66 c7 80 02 01 00 00 	movw   $0x8,0x102(%rax)
  8004209f68:	08 00 
  8004209f6a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209f71:	00 00 00 
  8004209f74:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209f7b:	83 e2 f8             	and    $0xfffffff8,%edx
  8004209f7e:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209f84:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209f8b:	00 00 00 
  8004209f8e:	0f b6 90 04 01 00 00 	movzbl 0x104(%rax),%edx
  8004209f95:	83 e2 07             	and    $0x7,%edx
  8004209f98:	88 90 04 01 00 00    	mov    %dl,0x104(%rax)
  8004209f9e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209fa5:	00 00 00 
  8004209fa8:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209faf:	83 e2 f0             	and    $0xfffffff0,%edx
  8004209fb2:	83 ca 0e             	or     $0xe,%edx
  8004209fb5:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209fbb:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209fc2:	00 00 00 
  8004209fc5:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209fcc:	83 e2 ef             	and    $0xffffffef,%edx
  8004209fcf:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209fd5:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209fdc:	00 00 00 
  8004209fdf:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  8004209fe6:	83 e2 9f             	and    $0xffffff9f,%edx
  8004209fe9:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  8004209fef:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  8004209ff6:	00 00 00 
  8004209ff9:	0f b6 90 05 01 00 00 	movzbl 0x105(%rax),%edx
  800420a000:	83 ca 80             	or     $0xffffff80,%edx
  800420a003:	88 90 05 01 00 00    	mov    %dl,0x105(%rax)
  800420a009:	48 b8 a0 ce 20 04 80 	movabs $0x800420cea0,%rax
  800420a010:	00 00 00 
  800420a013:	48 c1 e8 10          	shr    $0x10,%rax
  800420a017:	89 c2                	mov    %eax,%edx
  800420a019:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a020:	00 00 00 
  800420a023:	66 89 90 06 01 00 00 	mov    %dx,0x106(%rax)
  800420a02a:	48 b8 a0 ce 20 04 80 	movabs $0x800420cea0,%rax
  800420a031:	00 00 00 
  800420a034:	48 c1 e8 20          	shr    $0x20,%rax
  800420a038:	89 c2                	mov    %eax,%edx
  800420a03a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a041:	00 00 00 
  800420a044:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
  800420a04a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a051:	00 00 00 
  800420a054:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%rax)
  800420a05b:	00 00 00 
    SETGATE(idt[T_ALIGN], 0, GD_KT, XTRPX_Align, 0);  
  800420a05e:	48 b8 aa ce 20 04 80 	movabs $0x800420ceaa,%rax
  800420a065:	00 00 00 
  800420a068:	89 c2                	mov    %eax,%edx
  800420a06a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a071:	00 00 00 
  800420a074:	66 89 90 10 01 00 00 	mov    %dx,0x110(%rax)
  800420a07b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a082:	00 00 00 
  800420a085:	66 c7 80 12 01 00 00 	movw   $0x8,0x112(%rax)
  800420a08c:	08 00 
  800420a08e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a095:	00 00 00 
  800420a098:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a09f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a0a2:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a0a8:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a0af:	00 00 00 
  800420a0b2:	0f b6 90 14 01 00 00 	movzbl 0x114(%rax),%edx
  800420a0b9:	83 e2 07             	and    $0x7,%edx
  800420a0bc:	88 90 14 01 00 00    	mov    %dl,0x114(%rax)
  800420a0c2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a0c9:	00 00 00 
  800420a0cc:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a0d3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a0d6:	83 ca 0e             	or     $0xe,%edx
  800420a0d9:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a0df:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a0e6:	00 00 00 
  800420a0e9:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a0f0:	83 e2 ef             	and    $0xffffffef,%edx
  800420a0f3:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a0f9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a100:	00 00 00 
  800420a103:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a10a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a10d:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a113:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a11a:	00 00 00 
  800420a11d:	0f b6 90 15 01 00 00 	movzbl 0x115(%rax),%edx
  800420a124:	83 ca 80             	or     $0xffffff80,%edx
  800420a127:	88 90 15 01 00 00    	mov    %dl,0x115(%rax)
  800420a12d:	48 b8 aa ce 20 04 80 	movabs $0x800420ceaa,%rax
  800420a134:	00 00 00 
  800420a137:	48 c1 e8 10          	shr    $0x10,%rax
  800420a13b:	89 c2                	mov    %eax,%edx
  800420a13d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a144:	00 00 00 
  800420a147:	66 89 90 16 01 00 00 	mov    %dx,0x116(%rax)
  800420a14e:	48 b8 aa ce 20 04 80 	movabs $0x800420ceaa,%rax
  800420a155:	00 00 00 
  800420a158:	48 c1 e8 20          	shr    $0x20,%rax
  800420a15c:	89 c2                	mov    %eax,%edx
  800420a15e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a165:	00 00 00 
  800420a168:	89 90 18 01 00 00    	mov    %edx,0x118(%rax)
  800420a16e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a175:	00 00 00 
  800420a178:	c7 80 1c 01 00 00 00 	movl   $0x0,0x11c(%rax)
  800420a17f:	00 00 00 
    SETGATE(idt[T_MCHK], 0, GD_KT, XTRPX_Mchk, 0);  
  800420a182:	48 b8 ae ce 20 04 80 	movabs $0x800420ceae,%rax
  800420a189:	00 00 00 
  800420a18c:	89 c2                	mov    %eax,%edx
  800420a18e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a195:	00 00 00 
  800420a198:	66 89 90 20 01 00 00 	mov    %dx,0x120(%rax)
  800420a19f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a1a6:	00 00 00 
  800420a1a9:	66 c7 80 22 01 00 00 	movw   $0x8,0x122(%rax)
  800420a1b0:	08 00 
  800420a1b2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a1b9:	00 00 00 
  800420a1bc:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a1c3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a1c6:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a1cc:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a1d3:	00 00 00 
  800420a1d6:	0f b6 90 24 01 00 00 	movzbl 0x124(%rax),%edx
  800420a1dd:	83 e2 07             	and    $0x7,%edx
  800420a1e0:	88 90 24 01 00 00    	mov    %dl,0x124(%rax)
  800420a1e6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a1ed:	00 00 00 
  800420a1f0:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a1f7:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a1fa:	83 ca 0e             	or     $0xe,%edx
  800420a1fd:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a203:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a20a:	00 00 00 
  800420a20d:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a214:	83 e2 ef             	and    $0xffffffef,%edx
  800420a217:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a21d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a224:	00 00 00 
  800420a227:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a22e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a231:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a237:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a23e:	00 00 00 
  800420a241:	0f b6 90 25 01 00 00 	movzbl 0x125(%rax),%edx
  800420a248:	83 ca 80             	or     $0xffffff80,%edx
  800420a24b:	88 90 25 01 00 00    	mov    %dl,0x125(%rax)
  800420a251:	48 b8 ae ce 20 04 80 	movabs $0x800420ceae,%rax
  800420a258:	00 00 00 
  800420a25b:	48 c1 e8 10          	shr    $0x10,%rax
  800420a25f:	89 c2                	mov    %eax,%edx
  800420a261:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a268:	00 00 00 
  800420a26b:	66 89 90 26 01 00 00 	mov    %dx,0x126(%rax)
  800420a272:	48 b8 ae ce 20 04 80 	movabs $0x800420ceae,%rax
  800420a279:	00 00 00 
  800420a27c:	48 c1 e8 20          	shr    $0x20,%rax
  800420a280:	89 c2                	mov    %eax,%edx
  800420a282:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a289:	00 00 00 
  800420a28c:	89 90 28 01 00 00    	mov    %edx,0x128(%rax)
  800420a292:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a299:	00 00 00 
  800420a29c:	c7 80 2c 01 00 00 00 	movl   $0x0,0x12c(%rax)
  800420a2a3:	00 00 00 
    SETGATE(idt[T_SIMDERR], 0, GD_KT, XTRPX_SimdErr, 0);  
  800420a2a6:	48 b8 b4 ce 20 04 80 	movabs $0x800420ceb4,%rax
  800420a2ad:	00 00 00 
  800420a2b0:	89 c2                	mov    %eax,%edx
  800420a2b2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a2b9:	00 00 00 
  800420a2bc:	66 89 90 30 01 00 00 	mov    %dx,0x130(%rax)
  800420a2c3:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a2ca:	00 00 00 
  800420a2cd:	66 c7 80 32 01 00 00 	movw   $0x8,0x132(%rax)
  800420a2d4:	08 00 
  800420a2d6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a2dd:	00 00 00 
  800420a2e0:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a2e7:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a2ea:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a2f0:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a2f7:	00 00 00 
  800420a2fa:	0f b6 90 34 01 00 00 	movzbl 0x134(%rax),%edx
  800420a301:	83 e2 07             	and    $0x7,%edx
  800420a304:	88 90 34 01 00 00    	mov    %dl,0x134(%rax)
  800420a30a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a311:	00 00 00 
  800420a314:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a31b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a31e:	83 ca 0e             	or     $0xe,%edx
  800420a321:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a327:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a32e:	00 00 00 
  800420a331:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a338:	83 e2 ef             	and    $0xffffffef,%edx
  800420a33b:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a341:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a348:	00 00 00 
  800420a34b:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a352:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a355:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a35b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a362:	00 00 00 
  800420a365:	0f b6 90 35 01 00 00 	movzbl 0x135(%rax),%edx
  800420a36c:	83 ca 80             	or     $0xffffff80,%edx
  800420a36f:	88 90 35 01 00 00    	mov    %dl,0x135(%rax)
  800420a375:	48 b8 b4 ce 20 04 80 	movabs $0x800420ceb4,%rax
  800420a37c:	00 00 00 
  800420a37f:	48 c1 e8 10          	shr    $0x10,%rax
  800420a383:	89 c2                	mov    %eax,%edx
  800420a385:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a38c:	00 00 00 
  800420a38f:	66 89 90 36 01 00 00 	mov    %dx,0x136(%rax)
  800420a396:	48 b8 b4 ce 20 04 80 	movabs $0x800420ceb4,%rax
  800420a39d:	00 00 00 
  800420a3a0:	48 c1 e8 20          	shr    $0x20,%rax
  800420a3a4:	89 c2                	mov    %eax,%edx
  800420a3a6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a3ad:	00 00 00 
  800420a3b0:	89 90 38 01 00 00    	mov    %edx,0x138(%rax)
  800420a3b6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a3bd:	00 00 00 
  800420a3c0:	c7 80 3c 01 00 00 00 	movl   $0x0,0x13c(%rax)
  800420a3c7:	00 00 00 
    SETGATE(idt[T_SYSCALL], 0, GD_KT, XTRPX_Syscall, 3);
  800420a3ca:	48 b8 ba ce 20 04 80 	movabs $0x800420ceba,%rax
  800420a3d1:	00 00 00 
  800420a3d4:	89 c2                	mov    %eax,%edx
  800420a3d6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a3dd:	00 00 00 
  800420a3e0:	66 89 90 00 03 00 00 	mov    %dx,0x300(%rax)
  800420a3e7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a3ee:	00 00 00 
  800420a3f1:	66 c7 80 02 03 00 00 	movw   $0x8,0x302(%rax)
  800420a3f8:	08 00 
  800420a3fa:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a401:	00 00 00 
  800420a404:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a40b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a40e:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a414:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a41b:	00 00 00 
  800420a41e:	0f b6 90 04 03 00 00 	movzbl 0x304(%rax),%edx
  800420a425:	83 e2 07             	and    $0x7,%edx
  800420a428:	88 90 04 03 00 00    	mov    %dl,0x304(%rax)
  800420a42e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a435:	00 00 00 
  800420a438:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a43f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a442:	83 ca 0e             	or     $0xe,%edx
  800420a445:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a44b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a452:	00 00 00 
  800420a455:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a45c:	83 e2 ef             	and    $0xffffffef,%edx
  800420a45f:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a465:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a46c:	00 00 00 
  800420a46f:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a476:	83 ca 60             	or     $0x60,%edx
  800420a479:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a47f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a486:	00 00 00 
  800420a489:	0f b6 90 05 03 00 00 	movzbl 0x305(%rax),%edx
  800420a490:	83 ca 80             	or     $0xffffff80,%edx
  800420a493:	88 90 05 03 00 00    	mov    %dl,0x305(%rax)
  800420a499:	48 b8 ba ce 20 04 80 	movabs $0x800420ceba,%rax
  800420a4a0:	00 00 00 
  800420a4a3:	48 c1 e8 10          	shr    $0x10,%rax
  800420a4a7:	89 c2                	mov    %eax,%edx
  800420a4a9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a4b0:	00 00 00 
  800420a4b3:	66 89 90 06 03 00 00 	mov    %dx,0x306(%rax)
  800420a4ba:	48 b8 ba ce 20 04 80 	movabs $0x800420ceba,%rax
  800420a4c1:	00 00 00 
  800420a4c4:	48 c1 e8 20          	shr    $0x20,%rax
  800420a4c8:	89 c2                	mov    %eax,%edx
  800420a4ca:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a4d1:	00 00 00 
  800420a4d4:	89 90 08 03 00 00    	mov    %edx,0x308(%rax)
  800420a4da:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a4e1:	00 00 00 
  800420a4e4:	c7 80 0c 03 00 00 00 	movl   $0x0,0x30c(%rax)
  800420a4eb:	00 00 00 
    SETGATE(idt[T_DEFAULT], 0, GD_KT, XTRPX_Default, 0);
  800420a4ee:	48 b8 c0 ce 20 04 80 	movabs $0x800420cec0,%rax
  800420a4f5:	00 00 00 
  800420a4f8:	89 c2                	mov    %eax,%edx
  800420a4fa:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a501:	00 00 00 
  800420a504:	66 89 90 40 1f 00 00 	mov    %dx,0x1f40(%rax)
  800420a50b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a512:	00 00 00 
  800420a515:	66 c7 80 42 1f 00 00 	movw   $0x8,0x1f42(%rax)
  800420a51c:	08 00 
  800420a51e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a525:	00 00 00 
  800420a528:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a52f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a532:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a538:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a53f:	00 00 00 
  800420a542:	0f b6 90 44 1f 00 00 	movzbl 0x1f44(%rax),%edx
  800420a549:	83 e2 07             	and    $0x7,%edx
  800420a54c:	88 90 44 1f 00 00    	mov    %dl,0x1f44(%rax)
  800420a552:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a559:	00 00 00 
  800420a55c:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a563:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a566:	83 ca 0e             	or     $0xe,%edx
  800420a569:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a56f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a576:	00 00 00 
  800420a579:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a580:	83 e2 ef             	and    $0xffffffef,%edx
  800420a583:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a589:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a590:	00 00 00 
  800420a593:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a59a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a59d:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a5a3:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a5aa:	00 00 00 
  800420a5ad:	0f b6 90 45 1f 00 00 	movzbl 0x1f45(%rax),%edx
  800420a5b4:	83 ca 80             	or     $0xffffff80,%edx
  800420a5b7:	88 90 45 1f 00 00    	mov    %dl,0x1f45(%rax)
  800420a5bd:	48 b8 c0 ce 20 04 80 	movabs $0x800420cec0,%rax
  800420a5c4:	00 00 00 
  800420a5c7:	48 c1 e8 10          	shr    $0x10,%rax
  800420a5cb:	89 c2                	mov    %eax,%edx
  800420a5cd:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a5d4:	00 00 00 
  800420a5d7:	66 89 90 46 1f 00 00 	mov    %dx,0x1f46(%rax)
  800420a5de:	48 b8 c0 ce 20 04 80 	movabs $0x800420cec0,%rax
  800420a5e5:	00 00 00 
  800420a5e8:	48 c1 e8 20          	shr    $0x20,%rax
  800420a5ec:	89 c2                	mov    %eax,%edx
  800420a5ee:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a5f5:	00 00 00 
  800420a5f8:	89 90 48 1f 00 00    	mov    %edx,0x1f48(%rax)
  800420a5fe:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a605:	00 00 00 
  800420a608:	c7 80 4c 1f 00 00 00 	movl   $0x0,0x1f4c(%rax)
  800420a60f:	00 00 00 
	
    SETGATE(idt[IRQ_OFFSET+IRQ_TIMER], 0, GD_KT, XTRPX_IRQ0, 0);
  800420a612:	48 b8 ca ce 20 04 80 	movabs $0x800420ceca,%rax
  800420a619:	00 00 00 
  800420a61c:	89 c2                	mov    %eax,%edx
  800420a61e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a625:	00 00 00 
  800420a628:	66 89 90 00 02 00 00 	mov    %dx,0x200(%rax)
  800420a62f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a636:	00 00 00 
  800420a639:	66 c7 80 02 02 00 00 	movw   $0x8,0x202(%rax)
  800420a640:	08 00 
  800420a642:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a649:	00 00 00 
  800420a64c:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a653:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a656:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a65c:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a663:	00 00 00 
  800420a666:	0f b6 90 04 02 00 00 	movzbl 0x204(%rax),%edx
  800420a66d:	83 e2 07             	and    $0x7,%edx
  800420a670:	88 90 04 02 00 00    	mov    %dl,0x204(%rax)
  800420a676:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a67d:	00 00 00 
  800420a680:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a687:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a68a:	83 ca 0e             	or     $0xe,%edx
  800420a68d:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a693:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a69a:	00 00 00 
  800420a69d:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a6a4:	83 e2 ef             	and    $0xffffffef,%edx
  800420a6a7:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a6ad:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a6b4:	00 00 00 
  800420a6b7:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a6be:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a6c1:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a6c7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a6ce:	00 00 00 
  800420a6d1:	0f b6 90 05 02 00 00 	movzbl 0x205(%rax),%edx
  800420a6d8:	83 ca 80             	or     $0xffffff80,%edx
  800420a6db:	88 90 05 02 00 00    	mov    %dl,0x205(%rax)
  800420a6e1:	48 b8 ca ce 20 04 80 	movabs $0x800420ceca,%rax
  800420a6e8:	00 00 00 
  800420a6eb:	48 c1 e8 10          	shr    $0x10,%rax
  800420a6ef:	89 c2                	mov    %eax,%edx
  800420a6f1:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a6f8:	00 00 00 
  800420a6fb:	66 89 90 06 02 00 00 	mov    %dx,0x206(%rax)
  800420a702:	48 b8 ca ce 20 04 80 	movabs $0x800420ceca,%rax
  800420a709:	00 00 00 
  800420a70c:	48 c1 e8 20          	shr    $0x20,%rax
  800420a710:	89 c2                	mov    %eax,%edx
  800420a712:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a719:	00 00 00 
  800420a71c:	89 90 08 02 00 00    	mov    %edx,0x208(%rax)
  800420a722:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a729:	00 00 00 
  800420a72c:	c7 80 0c 02 00 00 00 	movl   $0x0,0x20c(%rax)
  800420a733:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_KBD], 0, GD_KT, XTRPX_IRQ1, 0);
  800420a736:	48 b8 d0 ce 20 04 80 	movabs $0x800420ced0,%rax
  800420a73d:	00 00 00 
  800420a740:	89 c2                	mov    %eax,%edx
  800420a742:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a749:	00 00 00 
  800420a74c:	66 89 90 10 02 00 00 	mov    %dx,0x210(%rax)
  800420a753:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a75a:	00 00 00 
  800420a75d:	66 c7 80 12 02 00 00 	movw   $0x8,0x212(%rax)
  800420a764:	08 00 
  800420a766:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a76d:	00 00 00 
  800420a770:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a777:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a77a:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a780:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a787:	00 00 00 
  800420a78a:	0f b6 90 14 02 00 00 	movzbl 0x214(%rax),%edx
  800420a791:	83 e2 07             	and    $0x7,%edx
  800420a794:	88 90 14 02 00 00    	mov    %dl,0x214(%rax)
  800420a79a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a7a1:	00 00 00 
  800420a7a4:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a7ab:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a7ae:	83 ca 0e             	or     $0xe,%edx
  800420a7b1:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a7b7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a7be:	00 00 00 
  800420a7c1:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a7c8:	83 e2 ef             	and    $0xffffffef,%edx
  800420a7cb:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a7d1:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a7d8:	00 00 00 
  800420a7db:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a7e2:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a7e5:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a7eb:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a7f2:	00 00 00 
  800420a7f5:	0f b6 90 15 02 00 00 	movzbl 0x215(%rax),%edx
  800420a7fc:	83 ca 80             	or     $0xffffff80,%edx
  800420a7ff:	88 90 15 02 00 00    	mov    %dl,0x215(%rax)
  800420a805:	48 b8 d0 ce 20 04 80 	movabs $0x800420ced0,%rax
  800420a80c:	00 00 00 
  800420a80f:	48 c1 e8 10          	shr    $0x10,%rax
  800420a813:	89 c2                	mov    %eax,%edx
  800420a815:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a81c:	00 00 00 
  800420a81f:	66 89 90 16 02 00 00 	mov    %dx,0x216(%rax)
  800420a826:	48 b8 d0 ce 20 04 80 	movabs $0x800420ced0,%rax
  800420a82d:	00 00 00 
  800420a830:	48 c1 e8 20          	shr    $0x20,%rax
  800420a834:	89 c2                	mov    %eax,%edx
  800420a836:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a83d:	00 00 00 
  800420a840:	89 90 18 02 00 00    	mov    %edx,0x218(%rax)
  800420a846:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a84d:	00 00 00 
  800420a850:	c7 80 1c 02 00 00 00 	movl   $0x0,0x21c(%rax)
  800420a857:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+2], 0, GD_KT, XTRPX_IRQ2, 0);
  800420a85a:	48 b8 d6 ce 20 04 80 	movabs $0x800420ced6,%rax
  800420a861:	00 00 00 
  800420a864:	89 c2                	mov    %eax,%edx
  800420a866:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a86d:	00 00 00 
  800420a870:	66 89 90 20 02 00 00 	mov    %dx,0x220(%rax)
  800420a877:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a87e:	00 00 00 
  800420a881:	66 c7 80 22 02 00 00 	movw   $0x8,0x222(%rax)
  800420a888:	08 00 
  800420a88a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a891:	00 00 00 
  800420a894:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a89b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a89e:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a8a4:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a8ab:	00 00 00 
  800420a8ae:	0f b6 90 24 02 00 00 	movzbl 0x224(%rax),%edx
  800420a8b5:	83 e2 07             	and    $0x7,%edx
  800420a8b8:	88 90 24 02 00 00    	mov    %dl,0x224(%rax)
  800420a8be:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a8c5:	00 00 00 
  800420a8c8:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a8cf:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a8d2:	83 ca 0e             	or     $0xe,%edx
  800420a8d5:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a8db:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a8e2:	00 00 00 
  800420a8e5:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a8ec:	83 e2 ef             	and    $0xffffffef,%edx
  800420a8ef:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a8f5:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a8fc:	00 00 00 
  800420a8ff:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a906:	83 e2 9f             	and    $0xffffff9f,%edx
  800420a909:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a90f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a916:	00 00 00 
  800420a919:	0f b6 90 25 02 00 00 	movzbl 0x225(%rax),%edx
  800420a920:	83 ca 80             	or     $0xffffff80,%edx
  800420a923:	88 90 25 02 00 00    	mov    %dl,0x225(%rax)
  800420a929:	48 b8 d6 ce 20 04 80 	movabs $0x800420ced6,%rax
  800420a930:	00 00 00 
  800420a933:	48 c1 e8 10          	shr    $0x10,%rax
  800420a937:	89 c2                	mov    %eax,%edx
  800420a939:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a940:	00 00 00 
  800420a943:	66 89 90 26 02 00 00 	mov    %dx,0x226(%rax)
  800420a94a:	48 b8 d6 ce 20 04 80 	movabs $0x800420ced6,%rax
  800420a951:	00 00 00 
  800420a954:	48 c1 e8 20          	shr    $0x20,%rax
  800420a958:	89 c2                	mov    %eax,%edx
  800420a95a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a961:	00 00 00 
  800420a964:	89 90 28 02 00 00    	mov    %edx,0x228(%rax)
  800420a96a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a971:	00 00 00 
  800420a974:	c7 80 2c 02 00 00 00 	movl   $0x0,0x22c(%rax)
  800420a97b:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+3], 0, GD_KT, XTRPX_IRQ3, 0);
  800420a97e:	48 b8 dc ce 20 04 80 	movabs $0x800420cedc,%rax
  800420a985:	00 00 00 
  800420a988:	89 c2                	mov    %eax,%edx
  800420a98a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a991:	00 00 00 
  800420a994:	66 89 90 30 02 00 00 	mov    %dx,0x230(%rax)
  800420a99b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a9a2:	00 00 00 
  800420a9a5:	66 c7 80 32 02 00 00 	movw   $0x8,0x232(%rax)
  800420a9ac:	08 00 
  800420a9ae:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a9b5:	00 00 00 
  800420a9b8:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a9bf:	83 e2 f8             	and    $0xfffffff8,%edx
  800420a9c2:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a9c8:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a9cf:	00 00 00 
  800420a9d2:	0f b6 90 34 02 00 00 	movzbl 0x234(%rax),%edx
  800420a9d9:	83 e2 07             	and    $0x7,%edx
  800420a9dc:	88 90 34 02 00 00    	mov    %dl,0x234(%rax)
  800420a9e2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420a9e9:	00 00 00 
  800420a9ec:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420a9f3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420a9f6:	83 ca 0e             	or     $0xe,%edx
  800420a9f9:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420a9ff:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aa06:	00 00 00 
  800420aa09:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420aa10:	83 e2 ef             	and    $0xffffffef,%edx
  800420aa13:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420aa19:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aa20:	00 00 00 
  800420aa23:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420aa2a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aa2d:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420aa33:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aa3a:	00 00 00 
  800420aa3d:	0f b6 90 35 02 00 00 	movzbl 0x235(%rax),%edx
  800420aa44:	83 ca 80             	or     $0xffffff80,%edx
  800420aa47:	88 90 35 02 00 00    	mov    %dl,0x235(%rax)
  800420aa4d:	48 b8 dc ce 20 04 80 	movabs $0x800420cedc,%rax
  800420aa54:	00 00 00 
  800420aa57:	48 c1 e8 10          	shr    $0x10,%rax
  800420aa5b:	89 c2                	mov    %eax,%edx
  800420aa5d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aa64:	00 00 00 
  800420aa67:	66 89 90 36 02 00 00 	mov    %dx,0x236(%rax)
  800420aa6e:	48 b8 dc ce 20 04 80 	movabs $0x800420cedc,%rax
  800420aa75:	00 00 00 
  800420aa78:	48 c1 e8 20          	shr    $0x20,%rax
  800420aa7c:	89 c2                	mov    %eax,%edx
  800420aa7e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aa85:	00 00 00 
  800420aa88:	89 90 38 02 00 00    	mov    %edx,0x238(%rax)
  800420aa8e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aa95:	00 00 00 
  800420aa98:	c7 80 3c 02 00 00 00 	movl   $0x0,0x23c(%rax)
  800420aa9f:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SERIAL], 0, GD_KT, XTRPX_IRQ4, 0);
  800420aaa2:	48 b8 e2 ce 20 04 80 	movabs $0x800420cee2,%rax
  800420aaa9:	00 00 00 
  800420aaac:	89 c2                	mov    %eax,%edx
  800420aaae:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aab5:	00 00 00 
  800420aab8:	66 89 90 40 02 00 00 	mov    %dx,0x240(%rax)
  800420aabf:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aac6:	00 00 00 
  800420aac9:	66 c7 80 42 02 00 00 	movw   $0x8,0x242(%rax)
  800420aad0:	08 00 
  800420aad2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aad9:	00 00 00 
  800420aadc:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420aae3:	83 e2 f8             	and    $0xfffffff8,%edx
  800420aae6:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420aaec:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aaf3:	00 00 00 
  800420aaf6:	0f b6 90 44 02 00 00 	movzbl 0x244(%rax),%edx
  800420aafd:	83 e2 07             	and    $0x7,%edx
  800420ab00:	88 90 44 02 00 00    	mov    %dl,0x244(%rax)
  800420ab06:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ab0d:	00 00 00 
  800420ab10:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420ab17:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ab1a:	83 ca 0e             	or     $0xe,%edx
  800420ab1d:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420ab23:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ab2a:	00 00 00 
  800420ab2d:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420ab34:	83 e2 ef             	and    $0xffffffef,%edx
  800420ab37:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420ab3d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ab44:	00 00 00 
  800420ab47:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420ab4e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ab51:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420ab57:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ab5e:	00 00 00 
  800420ab61:	0f b6 90 45 02 00 00 	movzbl 0x245(%rax),%edx
  800420ab68:	83 ca 80             	or     $0xffffff80,%edx
  800420ab6b:	88 90 45 02 00 00    	mov    %dl,0x245(%rax)
  800420ab71:	48 b8 e2 ce 20 04 80 	movabs $0x800420cee2,%rax
  800420ab78:	00 00 00 
  800420ab7b:	48 c1 e8 10          	shr    $0x10,%rax
  800420ab7f:	89 c2                	mov    %eax,%edx
  800420ab81:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ab88:	00 00 00 
  800420ab8b:	66 89 90 46 02 00 00 	mov    %dx,0x246(%rax)
  800420ab92:	48 b8 e2 ce 20 04 80 	movabs $0x800420cee2,%rax
  800420ab99:	00 00 00 
  800420ab9c:	48 c1 e8 20          	shr    $0x20,%rax
  800420aba0:	89 c2                	mov    %eax,%edx
  800420aba2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aba9:	00 00 00 
  800420abac:	89 90 48 02 00 00    	mov    %edx,0x248(%rax)
  800420abb2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420abb9:	00 00 00 
  800420abbc:	c7 80 4c 02 00 00 00 	movl   $0x0,0x24c(%rax)
  800420abc3:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+5], 0, GD_KT, XTRPX_IRQ5, 0);
  800420abc6:	48 b8 e8 ce 20 04 80 	movabs $0x800420cee8,%rax
  800420abcd:	00 00 00 
  800420abd0:	89 c2                	mov    %eax,%edx
  800420abd2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420abd9:	00 00 00 
  800420abdc:	66 89 90 50 02 00 00 	mov    %dx,0x250(%rax)
  800420abe3:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420abea:	00 00 00 
  800420abed:	66 c7 80 52 02 00 00 	movw   $0x8,0x252(%rax)
  800420abf4:	08 00 
  800420abf6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420abfd:	00 00 00 
  800420ac00:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420ac07:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ac0a:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420ac10:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ac17:	00 00 00 
  800420ac1a:	0f b6 90 54 02 00 00 	movzbl 0x254(%rax),%edx
  800420ac21:	83 e2 07             	and    $0x7,%edx
  800420ac24:	88 90 54 02 00 00    	mov    %dl,0x254(%rax)
  800420ac2a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ac31:	00 00 00 
  800420ac34:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420ac3b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ac3e:	83 ca 0e             	or     $0xe,%edx
  800420ac41:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420ac47:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ac4e:	00 00 00 
  800420ac51:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420ac58:	83 e2 ef             	and    $0xffffffef,%edx
  800420ac5b:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420ac61:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ac68:	00 00 00 
  800420ac6b:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420ac72:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ac75:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420ac7b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ac82:	00 00 00 
  800420ac85:	0f b6 90 55 02 00 00 	movzbl 0x255(%rax),%edx
  800420ac8c:	83 ca 80             	or     $0xffffff80,%edx
  800420ac8f:	88 90 55 02 00 00    	mov    %dl,0x255(%rax)
  800420ac95:	48 b8 e8 ce 20 04 80 	movabs $0x800420cee8,%rax
  800420ac9c:	00 00 00 
  800420ac9f:	48 c1 e8 10          	shr    $0x10,%rax
  800420aca3:	89 c2                	mov    %eax,%edx
  800420aca5:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420acac:	00 00 00 
  800420acaf:	66 89 90 56 02 00 00 	mov    %dx,0x256(%rax)
  800420acb6:	48 b8 e8 ce 20 04 80 	movabs $0x800420cee8,%rax
  800420acbd:	00 00 00 
  800420acc0:	48 c1 e8 20          	shr    $0x20,%rax
  800420acc4:	89 c2                	mov    %eax,%edx
  800420acc6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420accd:	00 00 00 
  800420acd0:	89 90 58 02 00 00    	mov    %edx,0x258(%rax)
  800420acd6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420acdd:	00 00 00 
  800420ace0:	c7 80 5c 02 00 00 00 	movl   $0x0,0x25c(%rax)
  800420ace7:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+6], 0, GD_KT, XTRPX_IRQ6, 0);
  800420acea:	48 b8 ee ce 20 04 80 	movabs $0x800420ceee,%rax
  800420acf1:	00 00 00 
  800420acf4:	89 c2                	mov    %eax,%edx
  800420acf6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420acfd:	00 00 00 
  800420ad00:	66 89 90 60 02 00 00 	mov    %dx,0x260(%rax)
  800420ad07:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ad0e:	00 00 00 
  800420ad11:	66 c7 80 62 02 00 00 	movw   $0x8,0x262(%rax)
  800420ad18:	08 00 
  800420ad1a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ad21:	00 00 00 
  800420ad24:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420ad2b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ad2e:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420ad34:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ad3b:	00 00 00 
  800420ad3e:	0f b6 90 64 02 00 00 	movzbl 0x264(%rax),%edx
  800420ad45:	83 e2 07             	and    $0x7,%edx
  800420ad48:	88 90 64 02 00 00    	mov    %dl,0x264(%rax)
  800420ad4e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ad55:	00 00 00 
  800420ad58:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420ad5f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ad62:	83 ca 0e             	or     $0xe,%edx
  800420ad65:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420ad6b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ad72:	00 00 00 
  800420ad75:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420ad7c:	83 e2 ef             	and    $0xffffffef,%edx
  800420ad7f:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420ad85:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ad8c:	00 00 00 
  800420ad8f:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420ad96:	83 e2 9f             	and    $0xffffff9f,%edx
  800420ad99:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420ad9f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ada6:	00 00 00 
  800420ada9:	0f b6 90 65 02 00 00 	movzbl 0x265(%rax),%edx
  800420adb0:	83 ca 80             	or     $0xffffff80,%edx
  800420adb3:	88 90 65 02 00 00    	mov    %dl,0x265(%rax)
  800420adb9:	48 b8 ee ce 20 04 80 	movabs $0x800420ceee,%rax
  800420adc0:	00 00 00 
  800420adc3:	48 c1 e8 10          	shr    $0x10,%rax
  800420adc7:	89 c2                	mov    %eax,%edx
  800420adc9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420add0:	00 00 00 
  800420add3:	66 89 90 66 02 00 00 	mov    %dx,0x266(%rax)
  800420adda:	48 b8 ee ce 20 04 80 	movabs $0x800420ceee,%rax
  800420ade1:	00 00 00 
  800420ade4:	48 c1 e8 20          	shr    $0x20,%rax
  800420ade8:	89 c2                	mov    %eax,%edx
  800420adea:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420adf1:	00 00 00 
  800420adf4:	89 90 68 02 00 00    	mov    %edx,0x268(%rax)
  800420adfa:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ae01:	00 00 00 
  800420ae04:	c7 80 6c 02 00 00 00 	movl   $0x0,0x26c(%rax)
  800420ae0b:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_SPURIOUS], 0, GD_KT, XTRPX_IRQ7, 0);
  800420ae0e:	48 b8 f4 ce 20 04 80 	movabs $0x800420cef4,%rax
  800420ae15:	00 00 00 
  800420ae18:	89 c2                	mov    %eax,%edx
  800420ae1a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ae21:	00 00 00 
  800420ae24:	66 89 90 70 02 00 00 	mov    %dx,0x270(%rax)
  800420ae2b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ae32:	00 00 00 
  800420ae35:	66 c7 80 72 02 00 00 	movw   $0x8,0x272(%rax)
  800420ae3c:	08 00 
  800420ae3e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ae45:	00 00 00 
  800420ae48:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420ae4f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420ae52:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420ae58:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ae5f:	00 00 00 
  800420ae62:	0f b6 90 74 02 00 00 	movzbl 0x274(%rax),%edx
  800420ae69:	83 e2 07             	and    $0x7,%edx
  800420ae6c:	88 90 74 02 00 00    	mov    %dl,0x274(%rax)
  800420ae72:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ae79:	00 00 00 
  800420ae7c:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420ae83:	83 e2 f0             	and    $0xfffffff0,%edx
  800420ae86:	83 ca 0e             	or     $0xe,%edx
  800420ae89:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420ae8f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420ae96:	00 00 00 
  800420ae99:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420aea0:	83 e2 ef             	and    $0xffffffef,%edx
  800420aea3:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420aea9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aeb0:	00 00 00 
  800420aeb3:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420aeba:	83 e2 9f             	and    $0xffffff9f,%edx
  800420aebd:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420aec3:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aeca:	00 00 00 
  800420aecd:	0f b6 90 75 02 00 00 	movzbl 0x275(%rax),%edx
  800420aed4:	83 ca 80             	or     $0xffffff80,%edx
  800420aed7:	88 90 75 02 00 00    	mov    %dl,0x275(%rax)
  800420aedd:	48 b8 f4 ce 20 04 80 	movabs $0x800420cef4,%rax
  800420aee4:	00 00 00 
  800420aee7:	48 c1 e8 10          	shr    $0x10,%rax
  800420aeeb:	89 c2                	mov    %eax,%edx
  800420aeed:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420aef4:	00 00 00 
  800420aef7:	66 89 90 76 02 00 00 	mov    %dx,0x276(%rax)
  800420aefe:	48 b8 f4 ce 20 04 80 	movabs $0x800420cef4,%rax
  800420af05:	00 00 00 
  800420af08:	48 c1 e8 20          	shr    $0x20,%rax
  800420af0c:	89 c2                	mov    %eax,%edx
  800420af0e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420af15:	00 00 00 
  800420af18:	89 90 78 02 00 00    	mov    %edx,0x278(%rax)
  800420af1e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420af25:	00 00 00 
  800420af28:	c7 80 7c 02 00 00 00 	movl   $0x0,0x27c(%rax)
  800420af2f:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+8], 0, GD_KT, XTRPX_IRQ8, 0);
  800420af32:	48 b8 fa ce 20 04 80 	movabs $0x800420cefa,%rax
  800420af39:	00 00 00 
  800420af3c:	89 c2                	mov    %eax,%edx
  800420af3e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420af45:	00 00 00 
  800420af48:	66 89 90 80 02 00 00 	mov    %dx,0x280(%rax)
  800420af4f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420af56:	00 00 00 
  800420af59:	66 c7 80 82 02 00 00 	movw   $0x8,0x282(%rax)
  800420af60:	08 00 
  800420af62:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420af69:	00 00 00 
  800420af6c:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420af73:	83 e2 f8             	and    $0xfffffff8,%edx
  800420af76:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420af7c:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420af83:	00 00 00 
  800420af86:	0f b6 90 84 02 00 00 	movzbl 0x284(%rax),%edx
  800420af8d:	83 e2 07             	and    $0x7,%edx
  800420af90:	88 90 84 02 00 00    	mov    %dl,0x284(%rax)
  800420af96:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420af9d:	00 00 00 
  800420afa0:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420afa7:	83 e2 f0             	and    $0xfffffff0,%edx
  800420afaa:	83 ca 0e             	or     $0xe,%edx
  800420afad:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420afb3:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420afba:	00 00 00 
  800420afbd:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420afc4:	83 e2 ef             	and    $0xffffffef,%edx
  800420afc7:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420afcd:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420afd4:	00 00 00 
  800420afd7:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420afde:	83 e2 9f             	and    $0xffffff9f,%edx
  800420afe1:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420afe7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420afee:	00 00 00 
  800420aff1:	0f b6 90 85 02 00 00 	movzbl 0x285(%rax),%edx
  800420aff8:	83 ca 80             	or     $0xffffff80,%edx
  800420affb:	88 90 85 02 00 00    	mov    %dl,0x285(%rax)
  800420b001:	48 b8 fa ce 20 04 80 	movabs $0x800420cefa,%rax
  800420b008:	00 00 00 
  800420b00b:	48 c1 e8 10          	shr    $0x10,%rax
  800420b00f:	89 c2                	mov    %eax,%edx
  800420b011:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b018:	00 00 00 
  800420b01b:	66 89 90 86 02 00 00 	mov    %dx,0x286(%rax)
  800420b022:	48 b8 fa ce 20 04 80 	movabs $0x800420cefa,%rax
  800420b029:	00 00 00 
  800420b02c:	48 c1 e8 20          	shr    $0x20,%rax
  800420b030:	89 c2                	mov    %eax,%edx
  800420b032:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b039:	00 00 00 
  800420b03c:	89 90 88 02 00 00    	mov    %edx,0x288(%rax)
  800420b042:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b049:	00 00 00 
  800420b04c:	c7 80 8c 02 00 00 00 	movl   $0x0,0x28c(%rax)
  800420b053:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+9], 0, GD_KT, XTRPX_IRQ9, 0);
  800420b056:	48 b8 00 cf 20 04 80 	movabs $0x800420cf00,%rax
  800420b05d:	00 00 00 
  800420b060:	89 c2                	mov    %eax,%edx
  800420b062:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b069:	00 00 00 
  800420b06c:	66 89 90 90 02 00 00 	mov    %dx,0x290(%rax)
  800420b073:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b07a:	00 00 00 
  800420b07d:	66 c7 80 92 02 00 00 	movw   $0x8,0x292(%rax)
  800420b084:	08 00 
  800420b086:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b08d:	00 00 00 
  800420b090:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b097:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b09a:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b0a0:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b0a7:	00 00 00 
  800420b0aa:	0f b6 90 94 02 00 00 	movzbl 0x294(%rax),%edx
  800420b0b1:	83 e2 07             	and    $0x7,%edx
  800420b0b4:	88 90 94 02 00 00    	mov    %dl,0x294(%rax)
  800420b0ba:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b0c1:	00 00 00 
  800420b0c4:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b0cb:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b0ce:	83 ca 0e             	or     $0xe,%edx
  800420b0d1:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b0d7:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b0de:	00 00 00 
  800420b0e1:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b0e8:	83 e2 ef             	and    $0xffffffef,%edx
  800420b0eb:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b0f1:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b0f8:	00 00 00 
  800420b0fb:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b102:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b105:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b10b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b112:	00 00 00 
  800420b115:	0f b6 90 95 02 00 00 	movzbl 0x295(%rax),%edx
  800420b11c:	83 ca 80             	or     $0xffffff80,%edx
  800420b11f:	88 90 95 02 00 00    	mov    %dl,0x295(%rax)
  800420b125:	48 b8 00 cf 20 04 80 	movabs $0x800420cf00,%rax
  800420b12c:	00 00 00 
  800420b12f:	48 c1 e8 10          	shr    $0x10,%rax
  800420b133:	89 c2                	mov    %eax,%edx
  800420b135:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b13c:	00 00 00 
  800420b13f:	66 89 90 96 02 00 00 	mov    %dx,0x296(%rax)
  800420b146:	48 b8 00 cf 20 04 80 	movabs $0x800420cf00,%rax
  800420b14d:	00 00 00 
  800420b150:	48 c1 e8 20          	shr    $0x20,%rax
  800420b154:	89 c2                	mov    %eax,%edx
  800420b156:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b15d:	00 00 00 
  800420b160:	89 90 98 02 00 00    	mov    %edx,0x298(%rax)
  800420b166:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b16d:	00 00 00 
  800420b170:	c7 80 9c 02 00 00 00 	movl   $0x0,0x29c(%rax)
  800420b177:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+10], 0, GD_KT, XTRPX_IRQa, 0);
  800420b17a:	48 b8 06 cf 20 04 80 	movabs $0x800420cf06,%rax
  800420b181:	00 00 00 
  800420b184:	89 c2                	mov    %eax,%edx
  800420b186:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b18d:	00 00 00 
  800420b190:	66 89 90 a0 02 00 00 	mov    %dx,0x2a0(%rax)
  800420b197:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b19e:	00 00 00 
  800420b1a1:	66 c7 80 a2 02 00 00 	movw   $0x8,0x2a2(%rax)
  800420b1a8:	08 00 
  800420b1aa:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b1b1:	00 00 00 
  800420b1b4:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b1bb:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b1be:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b1c4:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b1cb:	00 00 00 
  800420b1ce:	0f b6 90 a4 02 00 00 	movzbl 0x2a4(%rax),%edx
  800420b1d5:	83 e2 07             	and    $0x7,%edx
  800420b1d8:	88 90 a4 02 00 00    	mov    %dl,0x2a4(%rax)
  800420b1de:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b1e5:	00 00 00 
  800420b1e8:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b1ef:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b1f2:	83 ca 0e             	or     $0xe,%edx
  800420b1f5:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b1fb:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b202:	00 00 00 
  800420b205:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b20c:	83 e2 ef             	and    $0xffffffef,%edx
  800420b20f:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b215:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b21c:	00 00 00 
  800420b21f:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b226:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b229:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b22f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b236:	00 00 00 
  800420b239:	0f b6 90 a5 02 00 00 	movzbl 0x2a5(%rax),%edx
  800420b240:	83 ca 80             	or     $0xffffff80,%edx
  800420b243:	88 90 a5 02 00 00    	mov    %dl,0x2a5(%rax)
  800420b249:	48 b8 06 cf 20 04 80 	movabs $0x800420cf06,%rax
  800420b250:	00 00 00 
  800420b253:	48 c1 e8 10          	shr    $0x10,%rax
  800420b257:	89 c2                	mov    %eax,%edx
  800420b259:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b260:	00 00 00 
  800420b263:	66 89 90 a6 02 00 00 	mov    %dx,0x2a6(%rax)
  800420b26a:	48 b8 06 cf 20 04 80 	movabs $0x800420cf06,%rax
  800420b271:	00 00 00 
  800420b274:	48 c1 e8 20          	shr    $0x20,%rax
  800420b278:	89 c2                	mov    %eax,%edx
  800420b27a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b281:	00 00 00 
  800420b284:	89 90 a8 02 00 00    	mov    %edx,0x2a8(%rax)
  800420b28a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b291:	00 00 00 
  800420b294:	c7 80 ac 02 00 00 00 	movl   $0x0,0x2ac(%rax)
  800420b29b:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+11], 0, GD_KT, XTRPX_IRQb, 0);
  800420b29e:	48 b8 0c cf 20 04 80 	movabs $0x800420cf0c,%rax
  800420b2a5:	00 00 00 
  800420b2a8:	89 c2                	mov    %eax,%edx
  800420b2aa:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b2b1:	00 00 00 
  800420b2b4:	66 89 90 b0 02 00 00 	mov    %dx,0x2b0(%rax)
  800420b2bb:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b2c2:	00 00 00 
  800420b2c5:	66 c7 80 b2 02 00 00 	movw   $0x8,0x2b2(%rax)
  800420b2cc:	08 00 
  800420b2ce:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b2d5:	00 00 00 
  800420b2d8:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b2df:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b2e2:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b2e8:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b2ef:	00 00 00 
  800420b2f2:	0f b6 90 b4 02 00 00 	movzbl 0x2b4(%rax),%edx
  800420b2f9:	83 e2 07             	and    $0x7,%edx
  800420b2fc:	88 90 b4 02 00 00    	mov    %dl,0x2b4(%rax)
  800420b302:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b309:	00 00 00 
  800420b30c:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b313:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b316:	83 ca 0e             	or     $0xe,%edx
  800420b319:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b31f:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b326:	00 00 00 
  800420b329:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b330:	83 e2 ef             	and    $0xffffffef,%edx
  800420b333:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b339:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b340:	00 00 00 
  800420b343:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b34a:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b34d:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b353:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b35a:	00 00 00 
  800420b35d:	0f b6 90 b5 02 00 00 	movzbl 0x2b5(%rax),%edx
  800420b364:	83 ca 80             	or     $0xffffff80,%edx
  800420b367:	88 90 b5 02 00 00    	mov    %dl,0x2b5(%rax)
  800420b36d:	48 b8 0c cf 20 04 80 	movabs $0x800420cf0c,%rax
  800420b374:	00 00 00 
  800420b377:	48 c1 e8 10          	shr    $0x10,%rax
  800420b37b:	89 c2                	mov    %eax,%edx
  800420b37d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b384:	00 00 00 
  800420b387:	66 89 90 b6 02 00 00 	mov    %dx,0x2b6(%rax)
  800420b38e:	48 b8 0c cf 20 04 80 	movabs $0x800420cf0c,%rax
  800420b395:	00 00 00 
  800420b398:	48 c1 e8 20          	shr    $0x20,%rax
  800420b39c:	89 c2                	mov    %eax,%edx
  800420b39e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b3a5:	00 00 00 
  800420b3a8:	89 90 b8 02 00 00    	mov    %edx,0x2b8(%rax)
  800420b3ae:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b3b5:	00 00 00 
  800420b3b8:	c7 80 bc 02 00 00 00 	movl   $0x0,0x2bc(%rax)
  800420b3bf:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+12], 0, GD_KT, XTRPX_IRQc, 0);
  800420b3c2:	48 b8 12 cf 20 04 80 	movabs $0x800420cf12,%rax
  800420b3c9:	00 00 00 
  800420b3cc:	89 c2                	mov    %eax,%edx
  800420b3ce:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b3d5:	00 00 00 
  800420b3d8:	66 89 90 c0 02 00 00 	mov    %dx,0x2c0(%rax)
  800420b3df:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b3e6:	00 00 00 
  800420b3e9:	66 c7 80 c2 02 00 00 	movw   $0x8,0x2c2(%rax)
  800420b3f0:	08 00 
  800420b3f2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b3f9:	00 00 00 
  800420b3fc:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b403:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b406:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b40c:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b413:	00 00 00 
  800420b416:	0f b6 90 c4 02 00 00 	movzbl 0x2c4(%rax),%edx
  800420b41d:	83 e2 07             	and    $0x7,%edx
  800420b420:	88 90 c4 02 00 00    	mov    %dl,0x2c4(%rax)
  800420b426:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b42d:	00 00 00 
  800420b430:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b437:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b43a:	83 ca 0e             	or     $0xe,%edx
  800420b43d:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b443:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b44a:	00 00 00 
  800420b44d:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b454:	83 e2 ef             	and    $0xffffffef,%edx
  800420b457:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b45d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b464:	00 00 00 
  800420b467:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b46e:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b471:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b477:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b47e:	00 00 00 
  800420b481:	0f b6 90 c5 02 00 00 	movzbl 0x2c5(%rax),%edx
  800420b488:	83 ca 80             	or     $0xffffff80,%edx
  800420b48b:	88 90 c5 02 00 00    	mov    %dl,0x2c5(%rax)
  800420b491:	48 b8 12 cf 20 04 80 	movabs $0x800420cf12,%rax
  800420b498:	00 00 00 
  800420b49b:	48 c1 e8 10          	shr    $0x10,%rax
  800420b49f:	89 c2                	mov    %eax,%edx
  800420b4a1:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b4a8:	00 00 00 
  800420b4ab:	66 89 90 c6 02 00 00 	mov    %dx,0x2c6(%rax)
  800420b4b2:	48 b8 12 cf 20 04 80 	movabs $0x800420cf12,%rax
  800420b4b9:	00 00 00 
  800420b4bc:	48 c1 e8 20          	shr    $0x20,%rax
  800420b4c0:	89 c2                	mov    %eax,%edx
  800420b4c2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b4c9:	00 00 00 
  800420b4cc:	89 90 c8 02 00 00    	mov    %edx,0x2c8(%rax)
  800420b4d2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b4d9:	00 00 00 
  800420b4dc:	c7 80 cc 02 00 00 00 	movl   $0x0,0x2cc(%rax)
  800420b4e3:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+13], 0, GD_KT, XTRPX_IRQd, 0);
  800420b4e6:	48 b8 18 cf 20 04 80 	movabs $0x800420cf18,%rax
  800420b4ed:	00 00 00 
  800420b4f0:	89 c2                	mov    %eax,%edx
  800420b4f2:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b4f9:	00 00 00 
  800420b4fc:	66 89 90 d0 02 00 00 	mov    %dx,0x2d0(%rax)
  800420b503:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b50a:	00 00 00 
  800420b50d:	66 c7 80 d2 02 00 00 	movw   $0x8,0x2d2(%rax)
  800420b514:	08 00 
  800420b516:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b51d:	00 00 00 
  800420b520:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b527:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b52a:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b530:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b537:	00 00 00 
  800420b53a:	0f b6 90 d4 02 00 00 	movzbl 0x2d4(%rax),%edx
  800420b541:	83 e2 07             	and    $0x7,%edx
  800420b544:	88 90 d4 02 00 00    	mov    %dl,0x2d4(%rax)
  800420b54a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b551:	00 00 00 
  800420b554:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b55b:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b55e:	83 ca 0e             	or     $0xe,%edx
  800420b561:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b567:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b56e:	00 00 00 
  800420b571:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b578:	83 e2 ef             	and    $0xffffffef,%edx
  800420b57b:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b581:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b588:	00 00 00 
  800420b58b:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b592:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b595:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b59b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b5a2:	00 00 00 
  800420b5a5:	0f b6 90 d5 02 00 00 	movzbl 0x2d5(%rax),%edx
  800420b5ac:	83 ca 80             	or     $0xffffff80,%edx
  800420b5af:	88 90 d5 02 00 00    	mov    %dl,0x2d5(%rax)
  800420b5b5:	48 b8 18 cf 20 04 80 	movabs $0x800420cf18,%rax
  800420b5bc:	00 00 00 
  800420b5bf:	48 c1 e8 10          	shr    $0x10,%rax
  800420b5c3:	89 c2                	mov    %eax,%edx
  800420b5c5:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b5cc:	00 00 00 
  800420b5cf:	66 89 90 d6 02 00 00 	mov    %dx,0x2d6(%rax)
  800420b5d6:	48 b8 18 cf 20 04 80 	movabs $0x800420cf18,%rax
  800420b5dd:	00 00 00 
  800420b5e0:	48 c1 e8 20          	shr    $0x20,%rax
  800420b5e4:	89 c2                	mov    %eax,%edx
  800420b5e6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b5ed:	00 00 00 
  800420b5f0:	89 90 d8 02 00 00    	mov    %edx,0x2d8(%rax)
  800420b5f6:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b5fd:	00 00 00 
  800420b600:	c7 80 dc 02 00 00 00 	movl   $0x0,0x2dc(%rax)
  800420b607:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+IRQ_IDE], 0, GD_KT, XTRPX_IRQe, 0);
  800420b60a:	48 b8 1e cf 20 04 80 	movabs $0x800420cf1e,%rax
  800420b611:	00 00 00 
  800420b614:	89 c2                	mov    %eax,%edx
  800420b616:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b61d:	00 00 00 
  800420b620:	66 89 90 e0 02 00 00 	mov    %dx,0x2e0(%rax)
  800420b627:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b62e:	00 00 00 
  800420b631:	66 c7 80 e2 02 00 00 	movw   $0x8,0x2e2(%rax)
  800420b638:	08 00 
  800420b63a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b641:	00 00 00 
  800420b644:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420b64b:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b64e:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420b654:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b65b:	00 00 00 
  800420b65e:	0f b6 90 e4 02 00 00 	movzbl 0x2e4(%rax),%edx
  800420b665:	83 e2 07             	and    $0x7,%edx
  800420b668:	88 90 e4 02 00 00    	mov    %dl,0x2e4(%rax)
  800420b66e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b675:	00 00 00 
  800420b678:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b67f:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b682:	83 ca 0e             	or     $0xe,%edx
  800420b685:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b68b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b692:	00 00 00 
  800420b695:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b69c:	83 e2 ef             	and    $0xffffffef,%edx
  800420b69f:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b6a5:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b6ac:	00 00 00 
  800420b6af:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b6b6:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b6b9:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b6bf:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b6c6:	00 00 00 
  800420b6c9:	0f b6 90 e5 02 00 00 	movzbl 0x2e5(%rax),%edx
  800420b6d0:	83 ca 80             	or     $0xffffff80,%edx
  800420b6d3:	88 90 e5 02 00 00    	mov    %dl,0x2e5(%rax)
  800420b6d9:	48 b8 1e cf 20 04 80 	movabs $0x800420cf1e,%rax
  800420b6e0:	00 00 00 
  800420b6e3:	48 c1 e8 10          	shr    $0x10,%rax
  800420b6e7:	89 c2                	mov    %eax,%edx
  800420b6e9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b6f0:	00 00 00 
  800420b6f3:	66 89 90 e6 02 00 00 	mov    %dx,0x2e6(%rax)
  800420b6fa:	48 b8 1e cf 20 04 80 	movabs $0x800420cf1e,%rax
  800420b701:	00 00 00 
  800420b704:	48 c1 e8 20          	shr    $0x20,%rax
  800420b708:	89 c2                	mov    %eax,%edx
  800420b70a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b711:	00 00 00 
  800420b714:	89 90 e8 02 00 00    	mov    %edx,0x2e8(%rax)
  800420b71a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b721:	00 00 00 
  800420b724:	c7 80 ec 02 00 00 00 	movl   $0x0,0x2ec(%rax)
  800420b72b:	00 00 00 
    SETGATE(idt[IRQ_OFFSET+15], 0, GD_KT, XTRPX_IRQf, 0);
  800420b72e:	48 b8 24 cf 20 04 80 	movabs $0x800420cf24,%rax
  800420b735:	00 00 00 
  800420b738:	89 c2                	mov    %eax,%edx
  800420b73a:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b741:	00 00 00 
  800420b744:	66 89 90 f0 02 00 00 	mov    %dx,0x2f0(%rax)
  800420b74b:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b752:	00 00 00 
  800420b755:	66 c7 80 f2 02 00 00 	movw   $0x8,0x2f2(%rax)
  800420b75c:	08 00 
  800420b75e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b765:	00 00 00 
  800420b768:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420b76f:	83 e2 f8             	and    $0xfffffff8,%edx
  800420b772:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420b778:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b77f:	00 00 00 
  800420b782:	0f b6 90 f4 02 00 00 	movzbl 0x2f4(%rax),%edx
  800420b789:	83 e2 07             	and    $0x7,%edx
  800420b78c:	88 90 f4 02 00 00    	mov    %dl,0x2f4(%rax)
  800420b792:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b799:	00 00 00 
  800420b79c:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b7a3:	83 e2 f0             	and    $0xfffffff0,%edx
  800420b7a6:	83 ca 0e             	or     $0xe,%edx
  800420b7a9:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b7af:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b7b6:	00 00 00 
  800420b7b9:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b7c0:	83 e2 ef             	and    $0xffffffef,%edx
  800420b7c3:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b7c9:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b7d0:	00 00 00 
  800420b7d3:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b7da:	83 e2 9f             	and    $0xffffff9f,%edx
  800420b7dd:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b7e3:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b7ea:	00 00 00 
  800420b7ed:	0f b6 90 f5 02 00 00 	movzbl 0x2f5(%rax),%edx
  800420b7f4:	83 ca 80             	or     $0xffffff80,%edx
  800420b7f7:	88 90 f5 02 00 00    	mov    %dl,0x2f5(%rax)
  800420b7fd:	48 b8 24 cf 20 04 80 	movabs $0x800420cf24,%rax
  800420b804:	00 00 00 
  800420b807:	48 c1 e8 10          	shr    $0x10,%rax
  800420b80b:	89 c2                	mov    %eax,%edx
  800420b80d:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b814:	00 00 00 
  800420b817:	66 89 90 f6 02 00 00 	mov    %dx,0x2f6(%rax)
  800420b81e:	48 b8 24 cf 20 04 80 	movabs $0x800420cf24,%rax
  800420b825:	00 00 00 
  800420b828:	48 c1 e8 20          	shr    $0x20,%rax
  800420b82c:	89 c2                	mov    %eax,%edx
  800420b82e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b835:	00 00 00 
  800420b838:	89 90 f8 02 00 00    	mov    %edx,0x2f8(%rax)
  800420b83e:	48 b8 80 82 37 04 80 	movabs $0x8004378280,%rax
  800420b845:	00 00 00 
  800420b848:	c7 80 fc 02 00 00 00 	movl   $0x0,0x2fc(%rax)
  800420b84f:	00 00 00 
	
    idt_pd.pd_lim = sizeof(idt)-1;
  800420b852:	48 b8 80 92 37 04 80 	movabs $0x8004379280,%rax
  800420b859:	00 00 00 
  800420b85c:	66 c7 00 ff 0f       	movw   $0xfff,(%rax)
    idt_pd.pd_base = (uint64_t)idt;
  800420b861:	48 ba 80 82 37 04 80 	movabs $0x8004378280,%rdx
  800420b868:	00 00 00 
  800420b86b:	48 b8 80 92 37 04 80 	movabs $0x8004379280,%rax
  800420b872:	00 00 00 
  800420b875:	48 89 50 02          	mov    %rdx,0x2(%rax)
	// Per-CPU setup
	trap_init_percpu();
  800420b879:	48 b8 87 b8 20 04 80 	movabs $0x800420b887,%rax
  800420b880:	00 00 00 
  800420b883:	ff d0                	callq  *%rax
}
  800420b885:	5d                   	pop    %rbp
  800420b886:	c3                   	retq   

000000800420b887 <trap_init_percpu>:

// Initialize and load the per-CPU TSS and IDT
void
trap_init_percpu(void)
{
  800420b887:	55                   	push   %rbp
  800420b888:	48 89 e5             	mov    %rsp,%rbp
  800420b88b:	53                   	push   %rbx
  800420b88c:	48 83 ec 18          	sub    $0x18,%rsp
	//
	// LAB 4: Your code here:

	// Setup a TSS so that we get the right stack
	// when we trap to the kernel.
	thiscpu->cpu_ts.ts_esp0 = KSTACKTOP + thiscpu->cpu_id * (KSTKSIZE+KSTKGAP);
  800420b890:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420b897:	00 00 00 
  800420b89a:	ff d0                	callq  *%rax
  800420b89c:	89 c3                	mov    %eax,%ebx
  800420b89e:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420b8a5:	00 00 00 
  800420b8a8:	ff d0                	callq  *%rax
  800420b8aa:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420b8b1:	00 00 00 
  800420b8b4:	48 98                	cltq   
  800420b8b6:	48 c1 e0 03          	shl    $0x3,%rax
  800420b8ba:	48 89 c1             	mov    %rax,%rcx
  800420b8bd:	48 c1 e1 04          	shl    $0x4,%rcx
  800420b8c1:	48 01 c8             	add    %rcx,%rax
  800420b8c4:	48 01 d0             	add    %rdx,%rax
  800420b8c7:	0f b6 00             	movzbl (%rax),%eax
  800420b8ca:	0f b6 d0             	movzbl %al,%edx
  800420b8cd:	89 d0                	mov    %edx,%eax
  800420b8cf:	01 c0                	add    %eax,%eax
  800420b8d1:	01 d0                	add    %edx,%eax
  800420b8d3:	c1 e0 0f             	shl    $0xf,%eax
  800420b8d6:	48 63 d0             	movslq %eax,%rdx
  800420b8d9:	48 b8 00 00 00 04 80 	movabs $0x8004000000,%rax
  800420b8e0:	00 00 00 
  800420b8e3:	48 01 d0             	add    %rdx,%rax
  800420b8e6:	48 89 c2             	mov    %rax,%rdx
  800420b8e9:	48 b9 20 b0 37 04 80 	movabs $0x800437b020,%rcx
  800420b8f0:	00 00 00 
  800420b8f3:	48 63 c3             	movslq %ebx,%rax
  800420b8f6:	48 c1 e0 03          	shl    $0x3,%rax
  800420b8fa:	48 89 c6             	mov    %rax,%rsi
  800420b8fd:	48 c1 e6 04          	shl    $0x4,%rsi
  800420b901:	48 01 f0             	add    %rsi,%rax
  800420b904:	48 01 c8             	add    %rcx,%rax
  800420b907:	48 83 c0 10          	add    $0x10,%rax
  800420b90b:	48 89 50 04          	mov    %rdx,0x4(%rax)
	//	thiscpu->cpu_ts.ts_ss0 = GD_KD;
	// Initialize the TSS slot of the gdt.
	SETTSS((struct SystemSegdesc64 *) (&gdt[(GD_TSS0>>3) + (thiscpu->cpu_id*2)]),STS_T64A,
  800420b90f:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420b916:	00 00 00 
  800420b919:	ff d0                	callq  *%rax
  800420b91b:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420b922:	00 00 00 
  800420b925:	48 98                	cltq   
  800420b927:	48 c1 e0 03          	shl    $0x3,%rax
  800420b92b:	48 89 c1             	mov    %rax,%rcx
  800420b92e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420b932:	48 01 c8             	add    %rcx,%rax
  800420b935:	48 01 d0             	add    %rdx,%rax
  800420b938:	0f b6 00             	movzbl (%rax),%eax
  800420b93b:	0f b6 c0             	movzbl %al,%eax
  800420b93e:	01 c0                	add    %eax,%eax
  800420b940:	83 c0 05             	add    $0x5,%eax
  800420b943:	48 98                	cltq   
  800420b945:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b94c:	00 
  800420b94d:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420b954:	00 00 00 
  800420b957:	48 01 d0             	add    %rdx,%rax
  800420b95a:	66 c7 00 68 00       	movw   $0x68,(%rax)
  800420b95f:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420b966:	00 00 00 
  800420b969:	ff d0                	callq  *%rax
  800420b96b:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420b972:	00 00 00 
  800420b975:	48 98                	cltq   
  800420b977:	48 c1 e0 03          	shl    $0x3,%rax
  800420b97b:	48 89 c1             	mov    %rax,%rcx
  800420b97e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420b982:	48 01 c8             	add    %rcx,%rax
  800420b985:	48 01 d0             	add    %rdx,%rax
  800420b988:	0f b6 00             	movzbl (%rax),%eax
  800420b98b:	0f b6 c0             	movzbl %al,%eax
  800420b98e:	01 c0                	add    %eax,%eax
  800420b990:	83 c0 05             	add    $0x5,%eax
  800420b993:	48 98                	cltq   
  800420b995:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420b99c:	00 
  800420b99d:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420b9a4:	00 00 00 
  800420b9a7:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420b9ab:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420b9b2:	00 00 00 
  800420b9b5:	ff d0                	callq  *%rax
  800420b9b7:	48 98                	cltq   
  800420b9b9:	48 c1 e0 03          	shl    $0x3,%rax
  800420b9bd:	48 89 c2             	mov    %rax,%rdx
  800420b9c0:	48 c1 e2 04          	shl    $0x4,%rdx
  800420b9c4:	48 01 d0             	add    %rdx,%rax
  800420b9c7:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420b9cb:	48 b8 20 b0 37 04 80 	movabs $0x800437b020,%rax
  800420b9d2:	00 00 00 
  800420b9d5:	48 01 d0             	add    %rdx,%rax
  800420b9d8:	66 89 43 02          	mov    %ax,0x2(%rbx)
  800420b9dc:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420b9e3:	00 00 00 
  800420b9e6:	ff d0                	callq  *%rax
  800420b9e8:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420b9ef:	00 00 00 
  800420b9f2:	48 98                	cltq   
  800420b9f4:	48 c1 e0 03          	shl    $0x3,%rax
  800420b9f8:	48 89 c1             	mov    %rax,%rcx
  800420b9fb:	48 c1 e1 04          	shl    $0x4,%rcx
  800420b9ff:	48 01 c8             	add    %rcx,%rax
  800420ba02:	48 01 d0             	add    %rdx,%rax
  800420ba05:	0f b6 00             	movzbl (%rax),%eax
  800420ba08:	0f b6 c0             	movzbl %al,%eax
  800420ba0b:	01 c0                	add    %eax,%eax
  800420ba0d:	83 c0 05             	add    $0x5,%eax
  800420ba10:	48 98                	cltq   
  800420ba12:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ba19:	00 
  800420ba1a:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420ba21:	00 00 00 
  800420ba24:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420ba28:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420ba2f:	00 00 00 
  800420ba32:	ff d0                	callq  *%rax
  800420ba34:	48 98                	cltq   
  800420ba36:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba3a:	48 89 c2             	mov    %rax,%rdx
  800420ba3d:	48 c1 e2 04          	shl    $0x4,%rdx
  800420ba41:	48 01 d0             	add    %rdx,%rax
  800420ba44:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420ba48:	48 b8 20 b0 37 04 80 	movabs $0x800437b020,%rax
  800420ba4f:	00 00 00 
  800420ba52:	48 01 d0             	add    %rdx,%rax
  800420ba55:	48 c1 e8 10          	shr    $0x10,%rax
  800420ba59:	88 43 04             	mov    %al,0x4(%rbx)
  800420ba5c:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420ba63:	00 00 00 
  800420ba66:	ff d0                	callq  *%rax
  800420ba68:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420ba6f:	00 00 00 
  800420ba72:	48 98                	cltq   
  800420ba74:	48 c1 e0 03          	shl    $0x3,%rax
  800420ba78:	48 89 c1             	mov    %rax,%rcx
  800420ba7b:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ba7f:	48 01 c8             	add    %rcx,%rax
  800420ba82:	48 01 d0             	add    %rdx,%rax
  800420ba85:	0f b6 00             	movzbl (%rax),%eax
  800420ba88:	0f b6 c0             	movzbl %al,%eax
  800420ba8b:	01 c0                	add    %eax,%eax
  800420ba8d:	83 c0 05             	add    $0x5,%eax
  800420ba90:	48 98                	cltq   
  800420ba92:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ba99:	00 
  800420ba9a:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420baa1:	00 00 00 
  800420baa4:	48 01 d0             	add    %rdx,%rax
  800420baa7:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420baab:	83 e2 f0             	and    $0xfffffff0,%edx
  800420baae:	83 ca 09             	or     $0x9,%edx
  800420bab1:	88 50 05             	mov    %dl,0x5(%rax)
  800420bab4:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420babb:	00 00 00 
  800420babe:	ff d0                	callq  *%rax
  800420bac0:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bac7:	00 00 00 
  800420baca:	48 98                	cltq   
  800420bacc:	48 c1 e0 03          	shl    $0x3,%rax
  800420bad0:	48 89 c1             	mov    %rax,%rcx
  800420bad3:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bad7:	48 01 c8             	add    %rcx,%rax
  800420bada:	48 01 d0             	add    %rdx,%rax
  800420badd:	0f b6 00             	movzbl (%rax),%eax
  800420bae0:	0f b6 c0             	movzbl %al,%eax
  800420bae3:	01 c0                	add    %eax,%eax
  800420bae5:	83 c0 05             	add    $0x5,%eax
  800420bae8:	48 98                	cltq   
  800420baea:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420baf1:	00 
  800420baf2:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420baf9:	00 00 00 
  800420bafc:	48 01 d0             	add    %rdx,%rax
  800420baff:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bb03:	83 e2 ef             	and    $0xffffffef,%edx
  800420bb06:	88 50 05             	mov    %dl,0x5(%rax)
  800420bb09:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bb10:	00 00 00 
  800420bb13:	ff d0                	callq  *%rax
  800420bb15:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bb1c:	00 00 00 
  800420bb1f:	48 98                	cltq   
  800420bb21:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb25:	48 89 c1             	mov    %rax,%rcx
  800420bb28:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bb2c:	48 01 c8             	add    %rcx,%rax
  800420bb2f:	48 01 d0             	add    %rdx,%rax
  800420bb32:	0f b6 00             	movzbl (%rax),%eax
  800420bb35:	0f b6 c0             	movzbl %al,%eax
  800420bb38:	01 c0                	add    %eax,%eax
  800420bb3a:	83 c0 05             	add    $0x5,%eax
  800420bb3d:	48 98                	cltq   
  800420bb3f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bb46:	00 
  800420bb47:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420bb4e:	00 00 00 
  800420bb51:	48 01 d0             	add    %rdx,%rax
  800420bb54:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bb58:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bb5b:	88 50 05             	mov    %dl,0x5(%rax)
  800420bb5e:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bb65:	00 00 00 
  800420bb68:	ff d0                	callq  *%rax
  800420bb6a:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bb71:	00 00 00 
  800420bb74:	48 98                	cltq   
  800420bb76:	48 c1 e0 03          	shl    $0x3,%rax
  800420bb7a:	48 89 c1             	mov    %rax,%rcx
  800420bb7d:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bb81:	48 01 c8             	add    %rcx,%rax
  800420bb84:	48 01 d0             	add    %rdx,%rax
  800420bb87:	0f b6 00             	movzbl (%rax),%eax
  800420bb8a:	0f b6 c0             	movzbl %al,%eax
  800420bb8d:	01 c0                	add    %eax,%eax
  800420bb8f:	83 c0 05             	add    $0x5,%eax
  800420bb92:	48 98                	cltq   
  800420bb94:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bb9b:	00 
  800420bb9c:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420bba3:	00 00 00 
  800420bba6:	48 01 d0             	add    %rdx,%rax
  800420bba9:	0f b6 50 05          	movzbl 0x5(%rax),%edx
  800420bbad:	83 ca 80             	or     $0xffffff80,%edx
  800420bbb0:	88 50 05             	mov    %dl,0x5(%rax)
  800420bbb3:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bbba:	00 00 00 
  800420bbbd:	ff d0                	callq  *%rax
  800420bbbf:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bbc6:	00 00 00 
  800420bbc9:	48 98                	cltq   
  800420bbcb:	48 c1 e0 03          	shl    $0x3,%rax
  800420bbcf:	48 89 c1             	mov    %rax,%rcx
  800420bbd2:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bbd6:	48 01 c8             	add    %rcx,%rax
  800420bbd9:	48 01 d0             	add    %rdx,%rax
  800420bbdc:	0f b6 00             	movzbl (%rax),%eax
  800420bbdf:	0f b6 c0             	movzbl %al,%eax
  800420bbe2:	01 c0                	add    %eax,%eax
  800420bbe4:	83 c0 05             	add    $0x5,%eax
  800420bbe7:	48 98                	cltq   
  800420bbe9:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bbf0:	00 
  800420bbf1:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420bbf8:	00 00 00 
  800420bbfb:	48 01 d0             	add    %rdx,%rax
  800420bbfe:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bc02:	83 e2 f0             	and    $0xfffffff0,%edx
  800420bc05:	88 50 06             	mov    %dl,0x6(%rax)
  800420bc08:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bc0f:	00 00 00 
  800420bc12:	ff d0                	callq  *%rax
  800420bc14:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bc1b:	00 00 00 
  800420bc1e:	48 98                	cltq   
  800420bc20:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc24:	48 89 c1             	mov    %rax,%rcx
  800420bc27:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bc2b:	48 01 c8             	add    %rcx,%rax
  800420bc2e:	48 01 d0             	add    %rdx,%rax
  800420bc31:	0f b6 00             	movzbl (%rax),%eax
  800420bc34:	0f b6 c0             	movzbl %al,%eax
  800420bc37:	01 c0                	add    %eax,%eax
  800420bc39:	83 c0 05             	add    $0x5,%eax
  800420bc3c:	48 98                	cltq   
  800420bc3e:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bc45:	00 
  800420bc46:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420bc4d:	00 00 00 
  800420bc50:	48 01 d0             	add    %rdx,%rax
  800420bc53:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bc57:	83 e2 ef             	and    $0xffffffef,%edx
  800420bc5a:	88 50 06             	mov    %dl,0x6(%rax)
  800420bc5d:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bc64:	00 00 00 
  800420bc67:	ff d0                	callq  *%rax
  800420bc69:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bc70:	00 00 00 
  800420bc73:	48 98                	cltq   
  800420bc75:	48 c1 e0 03          	shl    $0x3,%rax
  800420bc79:	48 89 c1             	mov    %rax,%rcx
  800420bc7c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bc80:	48 01 c8             	add    %rcx,%rax
  800420bc83:	48 01 d0             	add    %rdx,%rax
  800420bc86:	0f b6 00             	movzbl (%rax),%eax
  800420bc89:	0f b6 c0             	movzbl %al,%eax
  800420bc8c:	01 c0                	add    %eax,%eax
  800420bc8e:	83 c0 05             	add    $0x5,%eax
  800420bc91:	48 98                	cltq   
  800420bc93:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bc9a:	00 
  800420bc9b:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420bca2:	00 00 00 
  800420bca5:	48 01 d0             	add    %rdx,%rax
  800420bca8:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bcac:	83 e2 9f             	and    $0xffffff9f,%edx
  800420bcaf:	88 50 06             	mov    %dl,0x6(%rax)
  800420bcb2:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bcb9:	00 00 00 
  800420bcbc:	ff d0                	callq  *%rax
  800420bcbe:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bcc5:	00 00 00 
  800420bcc8:	48 98                	cltq   
  800420bcca:	48 c1 e0 03          	shl    $0x3,%rax
  800420bcce:	48 89 c1             	mov    %rax,%rcx
  800420bcd1:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bcd5:	48 01 c8             	add    %rcx,%rax
  800420bcd8:	48 01 d0             	add    %rdx,%rax
  800420bcdb:	0f b6 00             	movzbl (%rax),%eax
  800420bcde:	0f b6 c0             	movzbl %al,%eax
  800420bce1:	01 c0                	add    %eax,%eax
  800420bce3:	83 c0 05             	add    $0x5,%eax
  800420bce6:	48 98                	cltq   
  800420bce8:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bcef:	00 
  800420bcf0:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420bcf7:	00 00 00 
  800420bcfa:	48 01 d0             	add    %rdx,%rax
  800420bcfd:	0f b6 50 06          	movzbl 0x6(%rax),%edx
  800420bd01:	83 e2 7f             	and    $0x7f,%edx
  800420bd04:	88 50 06             	mov    %dl,0x6(%rax)
  800420bd07:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bd0e:	00 00 00 
  800420bd11:	ff d0                	callq  *%rax
  800420bd13:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bd1a:	00 00 00 
  800420bd1d:	48 98                	cltq   
  800420bd1f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd23:	48 89 c1             	mov    %rax,%rcx
  800420bd26:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bd2a:	48 01 c8             	add    %rcx,%rax
  800420bd2d:	48 01 d0             	add    %rdx,%rax
  800420bd30:	0f b6 00             	movzbl (%rax),%eax
  800420bd33:	0f b6 c0             	movzbl %al,%eax
  800420bd36:	01 c0                	add    %eax,%eax
  800420bd38:	83 c0 05             	add    $0x5,%eax
  800420bd3b:	48 98                	cltq   
  800420bd3d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bd44:	00 
  800420bd45:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420bd4c:	00 00 00 
  800420bd4f:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bd53:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bd5a:	00 00 00 
  800420bd5d:	ff d0                	callq  *%rax
  800420bd5f:	48 98                	cltq   
  800420bd61:	48 c1 e0 03          	shl    $0x3,%rax
  800420bd65:	48 89 c2             	mov    %rax,%rdx
  800420bd68:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bd6c:	48 01 d0             	add    %rdx,%rax
  800420bd6f:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420bd73:	48 b8 20 b0 37 04 80 	movabs $0x800437b020,%rax
  800420bd7a:	00 00 00 
  800420bd7d:	48 01 d0             	add    %rdx,%rax
  800420bd80:	48 c1 e8 18          	shr    $0x18,%rax
  800420bd84:	88 43 07             	mov    %al,0x7(%rbx)
  800420bd87:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bd8e:	00 00 00 
  800420bd91:	ff d0                	callq  *%rax
  800420bd93:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bd9a:	00 00 00 
  800420bd9d:	48 98                	cltq   
  800420bd9f:	48 c1 e0 03          	shl    $0x3,%rax
  800420bda3:	48 89 c1             	mov    %rax,%rcx
  800420bda6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bdaa:	48 01 c8             	add    %rcx,%rax
  800420bdad:	48 01 d0             	add    %rdx,%rax
  800420bdb0:	0f b6 00             	movzbl (%rax),%eax
  800420bdb3:	0f b6 c0             	movzbl %al,%eax
  800420bdb6:	01 c0                	add    %eax,%eax
  800420bdb8:	83 c0 05             	add    $0x5,%eax
  800420bdbb:	48 98                	cltq   
  800420bdbd:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bdc4:	00 
  800420bdc5:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420bdcc:	00 00 00 
  800420bdcf:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  800420bdd3:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bdda:	00 00 00 
  800420bddd:	ff d0                	callq  *%rax
  800420bddf:	48 98                	cltq   
  800420bde1:	48 c1 e0 03          	shl    $0x3,%rax
  800420bde5:	48 89 c2             	mov    %rax,%rdx
  800420bde8:	48 c1 e2 04          	shl    $0x4,%rdx
  800420bdec:	48 01 d0             	add    %rdx,%rax
  800420bdef:	48 8d 50 10          	lea    0x10(%rax),%rdx
  800420bdf3:	48 b8 20 b0 37 04 80 	movabs $0x800437b020,%rax
  800420bdfa:	00 00 00 
  800420bdfd:	48 01 d0             	add    %rdx,%rax
  800420be00:	48 c1 e8 20          	shr    $0x20,%rax
  800420be04:	89 43 08             	mov    %eax,0x8(%rbx)
  800420be07:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420be0e:	00 00 00 
  800420be11:	ff d0                	callq  *%rax
  800420be13:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420be1a:	00 00 00 
  800420be1d:	48 98                	cltq   
  800420be1f:	48 c1 e0 03          	shl    $0x3,%rax
  800420be23:	48 89 c1             	mov    %rax,%rcx
  800420be26:	48 c1 e1 04          	shl    $0x4,%rcx
  800420be2a:	48 01 c8             	add    %rcx,%rax
  800420be2d:	48 01 d0             	add    %rdx,%rax
  800420be30:	0f b6 00             	movzbl (%rax),%eax
  800420be33:	0f b6 c0             	movzbl %al,%eax
  800420be36:	01 c0                	add    %eax,%eax
  800420be38:	83 c0 05             	add    $0x5,%eax
  800420be3b:	48 98                	cltq   
  800420be3d:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420be44:	00 
  800420be45:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420be4c:	00 00 00 
  800420be4f:	48 01 d0             	add    %rdx,%rax
  800420be52:	c6 40 0c 00          	movb   $0x0,0xc(%rax)
  800420be56:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420be5d:	00 00 00 
  800420be60:	ff d0                	callq  *%rax
  800420be62:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420be69:	00 00 00 
  800420be6c:	48 98                	cltq   
  800420be6e:	48 c1 e0 03          	shl    $0x3,%rax
  800420be72:	48 89 c1             	mov    %rax,%rcx
  800420be75:	48 c1 e1 04          	shl    $0x4,%rcx
  800420be79:	48 01 c8             	add    %rcx,%rax
  800420be7c:	48 01 d0             	add    %rdx,%rax
  800420be7f:	0f b6 00             	movzbl (%rax),%eax
  800420be82:	0f b6 c0             	movzbl %al,%eax
  800420be85:	01 c0                	add    %eax,%eax
  800420be87:	83 c0 05             	add    $0x5,%eax
  800420be8a:	48 98                	cltq   
  800420be8c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420be93:	00 
  800420be94:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420be9b:	00 00 00 
  800420be9e:	48 01 d0             	add    %rdx,%rax
  800420bea1:	c6 40 0d 00          	movb   $0x0,0xd(%rax)
  800420bea5:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420beac:	00 00 00 
  800420beaf:	ff d0                	callq  *%rax
  800420beb1:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420beb8:	00 00 00 
  800420bebb:	48 98                	cltq   
  800420bebd:	48 c1 e0 03          	shl    $0x3,%rax
  800420bec1:	48 89 c1             	mov    %rax,%rcx
  800420bec4:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bec8:	48 01 c8             	add    %rcx,%rax
  800420becb:	48 01 d0             	add    %rdx,%rax
  800420bece:	0f b6 00             	movzbl (%rax),%eax
  800420bed1:	0f b6 c0             	movzbl %al,%eax
  800420bed4:	01 c0                	add    %eax,%eax
  800420bed6:	83 c0 05             	add    $0x5,%eax
  800420bed9:	48 98                	cltq   
  800420bedb:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420bee2:	00 
  800420bee3:	48 b8 e0 b5 22 04 80 	movabs $0x800422b5e0,%rax
  800420beea:	00 00 00 
  800420beed:	48 01 d0             	add    %rdx,%rax
  800420bef0:	66 c7 40 0e 00 00    	movw   $0x0,0xe(%rax)
				(uint64_t) (&thiscpu->cpu_ts),sizeof(struct Taskstate), 0);
	// Load the TSS selector (like other segment selectors, the
	// bottom three bits are special; we leave them 0)
	ltr(((GD_TSS0>>3) + (thiscpu->cpu_id*2))*8);
  800420bef6:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420befd:	00 00 00 
  800420bf00:	ff d0                	callq  *%rax
  800420bf02:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420bf09:	00 00 00 
  800420bf0c:	48 98                	cltq   
  800420bf0e:	48 c1 e0 03          	shl    $0x3,%rax
  800420bf12:	48 89 c1             	mov    %rax,%rcx
  800420bf15:	48 c1 e1 04          	shl    $0x4,%rcx
  800420bf19:	48 01 c8             	add    %rcx,%rax
  800420bf1c:	48 01 d0             	add    %rdx,%rax
  800420bf1f:	0f b6 00             	movzbl (%rax),%eax
  800420bf22:	0f b6 c0             	movzbl %al,%eax
  800420bf25:	c1 e0 04             	shl    $0x4,%eax
  800420bf28:	83 c0 28             	add    $0x28,%eax
  800420bf2b:	0f b7 c0             	movzwl %ax,%eax
  800420bf2e:	66 89 45 ee          	mov    %ax,-0x12(%rbp)
    __asm __volatile("lgdt (%0)" : : "r" (p));
}
    static __inline void
ltr(uint16_t sel)
{
    __asm __volatile("ltr %0" : : "r" (sel));
  800420bf32:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
  800420bf36:	0f 00 d8             	ltr    %ax
  800420bf39:	48 b8 80 92 37 04 80 	movabs $0x8004379280,%rax
  800420bf40:	00 00 00 
  800420bf43:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
}  

    static __inline void
lidt(void *p)
{
    __asm __volatile("lidt (%0)" : : "r" (p));
  800420bf47:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420bf4b:	0f 01 18             	lidt   (%rax)

	// Load the IDT
	lidt(&idt_pd);
}
  800420bf4e:	48 83 c4 18          	add    $0x18,%rsp
  800420bf52:	5b                   	pop    %rbx
  800420bf53:	5d                   	pop    %rbp
  800420bf54:	c3                   	retq   

000000800420bf55 <print_trapframe>:
void
print_trapframe(struct Trapframe *tf)
{
  800420bf55:	55                   	push   %rbp
  800420bf56:	48 89 e5             	mov    %rsp,%rbp
  800420bf59:	48 83 ec 20          	sub    $0x20,%rsp
  800420bf5d:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	cprintf("TRAP frame at %p from CPU %d\n", tf, cpunum());
  800420bf61:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420bf68:	00 00 00 
  800420bf6b:	ff d0                	callq  *%rax
  800420bf6d:	89 c2                	mov    %eax,%edx
  800420bf6f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf73:	48 89 c6             	mov    %rax,%rsi
  800420bf76:	48 bf 4e 91 21 04 80 	movabs $0x800421914e,%rdi
  800420bf7d:	00 00 00 
  800420bf80:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bf85:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  800420bf8c:	00 00 00 
  800420bf8f:	ff d1                	callq  *%rcx
	print_regs(&tf->tf_regs);
  800420bf91:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bf95:	48 89 c7             	mov    %rax,%rdi
  800420bf98:	48 b8 66 c2 20 04 80 	movabs $0x800420c266,%rax
  800420bf9f:	00 00 00 
  800420bfa2:	ff d0                	callq  *%rax
	cprintf("  es   0x----%04x\n", tf->tf_es);
  800420bfa4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bfa8:	0f b7 40 78          	movzwl 0x78(%rax),%eax
  800420bfac:	0f b7 c0             	movzwl %ax,%eax
  800420bfaf:	89 c6                	mov    %eax,%esi
  800420bfb1:	48 bf 6c 91 21 04 80 	movabs $0x800421916c,%rdi
  800420bfb8:	00 00 00 
  800420bfbb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bfc0:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420bfc7:	00 00 00 
  800420bfca:	ff d2                	callq  *%rdx
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
  800420bfcc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bfd0:	0f b7 80 80 00 00 00 	movzwl 0x80(%rax),%eax
  800420bfd7:	0f b7 c0             	movzwl %ax,%eax
  800420bfda:	89 c6                	mov    %eax,%esi
  800420bfdc:	48 bf 7f 91 21 04 80 	movabs $0x800421917f,%rdi
  800420bfe3:	00 00 00 
  800420bfe6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420bfeb:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420bff2:	00 00 00 
  800420bff5:	ff d2                	callq  *%rdx
	cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
  800420bff7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420bffb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c002:	89 c7                	mov    %eax,%edi
  800420c004:	48 b8 78 90 20 04 80 	movabs $0x8004209078,%rax
  800420c00b:	00 00 00 
  800420c00e:	ff d0                	callq  *%rax
  800420c010:	48 89 c2             	mov    %rax,%rdx
  800420c013:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c017:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c01e:	48 89 c6             	mov    %rax,%rsi
  800420c021:	48 bf 92 91 21 04 80 	movabs $0x8004219192,%rdi
  800420c028:	00 00 00 
  800420c02b:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c030:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  800420c037:	00 00 00 
  800420c03a:	ff d1                	callq  *%rcx
	// If this trap was a page fault that just happened
	// (so %cr2 is meaningful), print the faulting linear address.
	if (tf == last_tf && tf->tf_trapno == T_PGFLT)
  800420c03c:	48 b8 90 92 37 04 80 	movabs $0x8004379290,%rax
  800420c043:	00 00 00 
  800420c046:	48 8b 00             	mov    (%rax),%rax
  800420c049:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420c04d:	75 3a                	jne    800420c089 <print_trapframe+0x134>
  800420c04f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c053:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c05a:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c05e:	75 29                	jne    800420c089 <print_trapframe+0x134>

    static __inline uint64_t
rcr2(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420c060:	0f 20 d0             	mov    %cr2,%rax
  800420c063:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    return val;
  800420c067:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
		cprintf("  cr2  0x%08x\n", rcr2());
  800420c06b:	48 89 c6             	mov    %rax,%rsi
  800420c06e:	48 bf a4 91 21 04 80 	movabs $0x80042191a4,%rdi
  800420c075:	00 00 00 
  800420c078:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c07d:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c084:	00 00 00 
  800420c087:	ff d2                	callq  *%rdx
	cprintf("  err  0x%08x", tf->tf_err);
  800420c089:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c08d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c094:	48 89 c6             	mov    %rax,%rsi
  800420c097:	48 bf b3 91 21 04 80 	movabs $0x80042191b3,%rdi
  800420c09e:	00 00 00 
  800420c0a1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c0a6:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c0ad:	00 00 00 
  800420c0b0:	ff d2                	callq  *%rdx
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
  800420c0b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c0b6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c0bd:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c0c1:	0f 85 9c 00 00 00    	jne    800420c163 <print_trapframe+0x20e>
		cprintf(" [%s, %s, %s]\n",
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
  800420c0c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c0cb:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c0d2:	83 e0 01             	and    $0x1,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c0d5:	48 85 c0             	test   %rax,%rax
  800420c0d8:	74 0c                	je     800420c0e6 <print_trapframe+0x191>
  800420c0da:	48 b9 c1 91 21 04 80 	movabs $0x80042191c1,%rcx
  800420c0e1:	00 00 00 
  800420c0e4:	eb 0a                	jmp    800420c0f0 <print_trapframe+0x19b>
  800420c0e6:	48 b9 cc 91 21 04 80 	movabs $0x80042191cc,%rcx
  800420c0ed:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
  800420c0f0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c0f4:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c0fb:	83 e0 02             	and    $0x2,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c0fe:	48 85 c0             	test   %rax,%rax
  800420c101:	74 0c                	je     800420c10f <print_trapframe+0x1ba>
  800420c103:	48 ba d8 91 21 04 80 	movabs $0x80042191d8,%rdx
  800420c10a:	00 00 00 
  800420c10d:	eb 0a                	jmp    800420c119 <print_trapframe+0x1c4>
  800420c10f:	48 ba de 91 21 04 80 	movabs $0x80042191de,%rdx
  800420c116:	00 00 00 
			tf->tf_err & 4 ? "user" : "kernel",
  800420c119:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c11d:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
  800420c124:	83 e0 04             	and    $0x4,%eax
	// For page faults, print decoded fault error code:
	// U/K=fault occurred in user/kernel mode
	// W/R=a write/read caused the fault
	// PR=a protection violation caused the fault (NP=page not present).
	if (tf->tf_trapno == T_PGFLT)
		cprintf(" [%s, %s, %s]\n",
  800420c127:	48 85 c0             	test   %rax,%rax
  800420c12a:	74 0c                	je     800420c138 <print_trapframe+0x1e3>
  800420c12c:	48 b8 e3 91 21 04 80 	movabs $0x80042191e3,%rax
  800420c133:	00 00 00 
  800420c136:	eb 0a                	jmp    800420c142 <print_trapframe+0x1ed>
  800420c138:	48 b8 e8 91 21 04 80 	movabs $0x80042191e8,%rax
  800420c13f:	00 00 00 
  800420c142:	48 89 c6             	mov    %rax,%rsi
  800420c145:	48 bf ef 91 21 04 80 	movabs $0x80042191ef,%rdi
  800420c14c:	00 00 00 
  800420c14f:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c154:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  800420c15b:	00 00 00 
  800420c15e:	41 ff d0             	callq  *%r8
  800420c161:	eb 1b                	jmp    800420c17e <print_trapframe+0x229>
			tf->tf_err & 4 ? "user" : "kernel",
			tf->tf_err & 2 ? "write" : "read",
			tf->tf_err & 1 ? "protection" : "not-present");
	else
		cprintf("\n");
  800420c163:	48 bf fe 91 21 04 80 	movabs $0x80042191fe,%rdi
  800420c16a:	00 00 00 
  800420c16d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c172:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c179:	00 00 00 
  800420c17c:	ff d2                	callq  *%rdx
	cprintf("  rip  0x%08x\n", tf->tf_rip);
  800420c17e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c182:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
  800420c189:	48 89 c6             	mov    %rax,%rsi
  800420c18c:	48 bf 00 92 21 04 80 	movabs $0x8004219200,%rdi
  800420c193:	00 00 00 
  800420c196:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c19b:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c1a2:	00 00 00 
  800420c1a5:	ff d2                	callq  *%rdx
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
  800420c1a7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c1ab:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c1b2:	0f b7 c0             	movzwl %ax,%eax
  800420c1b5:	89 c6                	mov    %eax,%esi
  800420c1b7:	48 bf 0f 92 21 04 80 	movabs $0x800421920f,%rdi
  800420c1be:	00 00 00 
  800420c1c1:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1c6:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c1cd:	00 00 00 
  800420c1d0:	ff d2                	callq  *%rdx
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
  800420c1d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c1d6:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420c1dd:	48 89 c6             	mov    %rax,%rsi
  800420c1e0:	48 bf 22 92 21 04 80 	movabs $0x8004219222,%rdi
  800420c1e7:	00 00 00 
  800420c1ea:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c1ef:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c1f6:	00 00 00 
  800420c1f9:	ff d2                	callq  *%rdx
	if ((tf->tf_cs & 3) != 0) {
  800420c1fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c1ff:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c206:	0f b7 c0             	movzwl %ax,%eax
  800420c209:	83 e0 03             	and    $0x3,%eax
  800420c20c:	85 c0                	test   %eax,%eax
  800420c20e:	74 54                	je     800420c264 <print_trapframe+0x30f>
		cprintf("  rsp  0x%08x\n", tf->tf_rsp);
  800420c210:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c214:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420c21b:	48 89 c6             	mov    %rax,%rsi
  800420c21e:	48 bf 31 92 21 04 80 	movabs $0x8004219231,%rdi
  800420c225:	00 00 00 
  800420c228:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c22d:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c234:	00 00 00 
  800420c237:	ff d2                	callq  *%rdx
		cprintf("  ss   0x----%04x\n", tf->tf_ss);
  800420c239:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c23d:	0f b7 80 b8 00 00 00 	movzwl 0xb8(%rax),%eax
  800420c244:	0f b7 c0             	movzwl %ax,%eax
  800420c247:	89 c6                	mov    %eax,%esi
  800420c249:	48 bf 40 92 21 04 80 	movabs $0x8004219240,%rdi
  800420c250:	00 00 00 
  800420c253:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c258:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c25f:	00 00 00 
  800420c262:	ff d2                	callq  *%rdx
	}
}
  800420c264:	c9                   	leaveq 
  800420c265:	c3                   	retq   

000000800420c266 <print_regs>:

void
print_regs(struct PushRegs *regs)
{
  800420c266:	55                   	push   %rbp
  800420c267:	48 89 e5             	mov    %rsp,%rbp
  800420c26a:	48 83 ec 10          	sub    $0x10,%rsp
  800420c26e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	cprintf("  r15  0x%08x\n", regs->reg_r15);
  800420c272:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c276:	48 8b 00             	mov    (%rax),%rax
  800420c279:	48 89 c6             	mov    %rax,%rsi
  800420c27c:	48 bf 53 92 21 04 80 	movabs $0x8004219253,%rdi
  800420c283:	00 00 00 
  800420c286:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c28b:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c292:	00 00 00 
  800420c295:	ff d2                	callq  *%rdx
	cprintf("  r14  0x%08x\n", regs->reg_r14);
  800420c297:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c29b:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420c29f:	48 89 c6             	mov    %rax,%rsi
  800420c2a2:	48 bf 62 92 21 04 80 	movabs $0x8004219262,%rdi
  800420c2a9:	00 00 00 
  800420c2ac:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2b1:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c2b8:	00 00 00 
  800420c2bb:	ff d2                	callq  *%rdx
	cprintf("  r13  0x%08x\n", regs->reg_r13);
  800420c2bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c2c1:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420c2c5:	48 89 c6             	mov    %rax,%rsi
  800420c2c8:	48 bf 71 92 21 04 80 	movabs $0x8004219271,%rdi
  800420c2cf:	00 00 00 
  800420c2d2:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2d7:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c2de:	00 00 00 
  800420c2e1:	ff d2                	callq  *%rdx
	cprintf("  r12  0x%08x\n", regs->reg_r12);
  800420c2e3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c2e7:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420c2eb:	48 89 c6             	mov    %rax,%rsi
  800420c2ee:	48 bf 80 92 21 04 80 	movabs $0x8004219280,%rdi
  800420c2f5:	00 00 00 
  800420c2f8:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c2fd:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c304:	00 00 00 
  800420c307:	ff d2                	callq  *%rdx
	cprintf("  r11  0x%08x\n", regs->reg_r11);
  800420c309:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c30d:	48 8b 40 20          	mov    0x20(%rax),%rax
  800420c311:	48 89 c6             	mov    %rax,%rsi
  800420c314:	48 bf 8f 92 21 04 80 	movabs $0x800421928f,%rdi
  800420c31b:	00 00 00 
  800420c31e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c323:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c32a:	00 00 00 
  800420c32d:	ff d2                	callq  *%rdx
	cprintf("  r10  0x%08x\n", regs->reg_r10);
  800420c32f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c333:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420c337:	48 89 c6             	mov    %rax,%rsi
  800420c33a:	48 bf 9e 92 21 04 80 	movabs $0x800421929e,%rdi
  800420c341:	00 00 00 
  800420c344:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c349:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c350:	00 00 00 
  800420c353:	ff d2                	callq  *%rdx
	cprintf("  r9  0x%08x\n", regs->reg_r9);
  800420c355:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c359:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420c35d:	48 89 c6             	mov    %rax,%rsi
  800420c360:	48 bf ad 92 21 04 80 	movabs $0x80042192ad,%rdi
  800420c367:	00 00 00 
  800420c36a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c36f:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c376:	00 00 00 
  800420c379:	ff d2                	callq  *%rdx
	cprintf("  r8  0x%08x\n", regs->reg_r8);
  800420c37b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c37f:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420c383:	48 89 c6             	mov    %rax,%rsi
  800420c386:	48 bf bb 92 21 04 80 	movabs $0x80042192bb,%rdi
  800420c38d:	00 00 00 
  800420c390:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c395:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c39c:	00 00 00 
  800420c39f:	ff d2                	callq  *%rdx
	cprintf("  rdi  0x%08x\n", regs->reg_rdi);
  800420c3a1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3a5:	48 8b 40 48          	mov    0x48(%rax),%rax
  800420c3a9:	48 89 c6             	mov    %rax,%rsi
  800420c3ac:	48 bf c9 92 21 04 80 	movabs $0x80042192c9,%rdi
  800420c3b3:	00 00 00 
  800420c3b6:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c3bb:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c3c2:	00 00 00 
  800420c3c5:	ff d2                	callq  *%rdx
	cprintf("  rsi  0x%08x\n", regs->reg_rsi);
  800420c3c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3cb:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420c3cf:	48 89 c6             	mov    %rax,%rsi
  800420c3d2:	48 bf d8 92 21 04 80 	movabs $0x80042192d8,%rdi
  800420c3d9:	00 00 00 
  800420c3dc:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c3e1:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c3e8:	00 00 00 
  800420c3eb:	ff d2                	callq  *%rdx
	cprintf("  rbp  0x%08x\n", regs->reg_rbp);
  800420c3ed:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c3f1:	48 8b 40 50          	mov    0x50(%rax),%rax
  800420c3f5:	48 89 c6             	mov    %rax,%rsi
  800420c3f8:	48 bf e7 92 21 04 80 	movabs $0x80042192e7,%rdi
  800420c3ff:	00 00 00 
  800420c402:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c407:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c40e:	00 00 00 
  800420c411:	ff d2                	callq  *%rdx
	cprintf("  rbx  0x%08x\n", regs->reg_rbx);
  800420c413:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c417:	48 8b 40 68          	mov    0x68(%rax),%rax
  800420c41b:	48 89 c6             	mov    %rax,%rsi
  800420c41e:	48 bf f6 92 21 04 80 	movabs $0x80042192f6,%rdi
  800420c425:	00 00 00 
  800420c428:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c42d:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c434:	00 00 00 
  800420c437:	ff d2                	callq  *%rdx
	cprintf("  rdx  0x%08x\n", regs->reg_rdx);
  800420c439:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c43d:	48 8b 40 58          	mov    0x58(%rax),%rax
  800420c441:	48 89 c6             	mov    %rax,%rsi
  800420c444:	48 bf 05 93 21 04 80 	movabs $0x8004219305,%rdi
  800420c44b:	00 00 00 
  800420c44e:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c453:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c45a:	00 00 00 
  800420c45d:	ff d2                	callq  *%rdx
	cprintf("  rcx  0x%08x\n", regs->reg_rcx);
  800420c45f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c463:	48 8b 40 60          	mov    0x60(%rax),%rax
  800420c467:	48 89 c6             	mov    %rax,%rsi
  800420c46a:	48 bf 14 93 21 04 80 	movabs $0x8004219314,%rdi
  800420c471:	00 00 00 
  800420c474:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c479:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c480:	00 00 00 
  800420c483:	ff d2                	callq  *%rdx
	cprintf("  rax  0x%08x\n", regs->reg_rax);
  800420c485:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c489:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c48d:	48 89 c6             	mov    %rax,%rsi
  800420c490:	48 bf 23 93 21 04 80 	movabs $0x8004219323,%rdi
  800420c497:	00 00 00 
  800420c49a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c49f:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c4a6:	00 00 00 
  800420c4a9:	ff d2                	callq  *%rdx
}
  800420c4ab:	c9                   	leaveq 
  800420c4ac:	c3                   	retq   

000000800420c4ad <trap_dispatch>:

static void
trap_dispatch(struct Trapframe *tf)
{
  800420c4ad:	55                   	push   %rbp
  800420c4ae:	48 89 e5             	mov    %rsp,%rbp
  800420c4b1:	48 83 ec 10          	sub    $0x10,%rsp
  800420c4b5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	// Handle processor exceptions.
	// LAB 3: Your code here.
	//print_trapframe(tf);
	if(tf->tf_trapno == T_PGFLT)
  800420c4b9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4bd:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c4c4:	48 83 f8 0e          	cmp    $0xe,%rax
  800420c4c8:	75 18                	jne    800420c4e2 <trap_dispatch+0x35>
    {
        page_fault_handler(tf);
  800420c4ca:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4ce:	48 89 c7             	mov    %rax,%rdi
  800420c4d1:	48 b8 26 ca 20 04 80 	movabs $0x800420ca26,%rax
  800420c4d8:	00 00 00 
  800420c4db:	ff d0                	callq  *%rax
  800420c4dd:	e9 8c 00 00 00       	jmpq   800420c56e <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_BRKPT)
  800420c4e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4e6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c4ed:	48 83 f8 03          	cmp    $0x3,%rax
  800420c4f1:	75 15                	jne    800420c508 <trap_dispatch+0x5b>
    {
        monitor(tf);
  800420c4f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c4f7:	48 89 c7             	mov    %rax,%rdi
  800420c4fa:	48 b8 90 1c 20 04 80 	movabs $0x8004201c90,%rax
  800420c501:	00 00 00 
  800420c504:	ff d0                	callq  *%rax
  800420c506:	eb 66                	jmp    800420c56e <trap_dispatch+0xc1>
    }
    else if(tf->tf_trapno == T_SYSCALL)
  800420c508:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c50c:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c513:	48 83 f8 30          	cmp    $0x30,%rax
  800420c517:	75 55                	jne    800420c56e <trap_dispatch+0xc1>
    {
        tf->tf_regs.reg_rax = syscall(tf->tf_regs.reg_rax, tf->tf_regs.reg_rdx,
  800420c519:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c51d:	4c 8b 40 40          	mov    0x40(%rax),%r8
  800420c521:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c525:	48 8b 78 48          	mov    0x48(%rax),%rdi
  800420c529:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c52d:	48 8b 48 68          	mov    0x68(%rax),%rcx
  800420c531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c535:	48 8b 50 60          	mov    0x60(%rax),%rdx
  800420c539:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c53d:	48 8b 70 58          	mov    0x58(%rax),%rsi
  800420c541:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c545:	48 8b 40 70          	mov    0x70(%rax),%rax
  800420c549:	4d 89 c1             	mov    %r8,%r9
  800420c54c:	49 89 f8             	mov    %rdi,%r8
  800420c54f:	48 89 c7             	mov    %rax,%rdi
  800420c552:	48 b8 64 dd 20 04 80 	movabs $0x800420dd64,%rax
  800420c559:	00 00 00 
  800420c55c:	ff d0                	callq  *%rax
  800420c55e:	48 89 c2             	mov    %rax,%rdx
  800420c561:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c565:	48 89 50 70          	mov    %rdx,0x70(%rax)
                        tf->tf_regs.reg_rcx, tf->tf_regs.reg_rbx,
                        tf->tf_regs.reg_rdi, tf->tf_regs.reg_rsi);
        return;
  800420c569:	e9 59 01 00 00       	jmpq   800420c6c7 <trap_dispatch+0x21a>
    }

	// Handle spurious interrupts
	// The hardware sometimes raises these because of noise on the
	// IRQ line or other reasons. We don't care.
	if (tf->tf_trapno == IRQ_OFFSET + IRQ_SPURIOUS) {
  800420c56e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c572:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c579:	48 83 f8 27          	cmp    $0x27,%rax
  800420c57d:	75 33                	jne    800420c5b2 <trap_dispatch+0x105>
		cprintf("Spurious interrupt on irq 7\n");
  800420c57f:	48 bf 32 93 21 04 80 	movabs $0x8004219332,%rdi
  800420c586:	00 00 00 
  800420c589:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c58e:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420c595:	00 00 00 
  800420c598:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420c59a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c59e:	48 89 c7             	mov    %rax,%rdi
  800420c5a1:	48 b8 55 bf 20 04 80 	movabs $0x800420bf55,%rax
  800420c5a8:	00 00 00 
  800420c5ab:	ff d0                	callq  *%rax
		return;
  800420c5ad:	e9 15 01 00 00       	jmpq   800420c6c7 <trap_dispatch+0x21a>
	// LAB 6: Your code here.


	// Handle keyboard and serial interrupts.
	// LAB 5: Your code here.
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_TIMER))
  800420c5b2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5b6:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c5bd:	48 83 f8 20          	cmp    $0x20,%rax
  800420c5c1:	75 24                	jne    800420c5e7 <trap_dispatch+0x13a>
	{
		lapic_eoi();
  800420c5c3:	48 b8 bf 6a 21 04 80 	movabs $0x8004216abf,%rax
  800420c5ca:	00 00 00 
  800420c5cd:	ff d0                	callq  *%rax
		time_tick();
  800420c5cf:	48 b8 46 7c 21 04 80 	movabs $0x8004217c46,%rax
  800420c5d6:	00 00 00 
  800420c5d9:	ff d0                	callq  *%rax
		sched_yield();
  800420c5db:	48 b8 3d d0 20 04 80 	movabs $0x800420d03d,%rax
  800420c5e2:	00 00 00 
  800420c5e5:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_KBD))
  800420c5e7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c5eb:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c5f2:	48 83 f8 21          	cmp    $0x21,%rax
  800420c5f6:	75 18                	jne    800420c610 <trap_dispatch+0x163>
	{
		kbd_intr();
  800420c5f8:	48 b8 88 11 20 04 80 	movabs $0x8004201188,%rax
  800420c5ff:	00 00 00 
  800420c602:	ff d0                	callq  *%rax
		sched_yield();
  800420c604:	48 b8 3d d0 20 04 80 	movabs $0x800420d03d,%rax
  800420c60b:	00 00 00 
  800420c60e:	ff d0                	callq  *%rax
	}
	else if(tf->tf_trapno == (IRQ_OFFSET + IRQ_SERIAL))
  800420c610:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c614:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  800420c61b:	48 83 f8 24          	cmp    $0x24,%rax
  800420c61f:	75 18                	jne    800420c639 <trap_dispatch+0x18c>
	{
		serial_intr();
  800420c621:	48 b8 0d 09 20 04 80 	movabs $0x800420090d,%rax
  800420c628:	00 00 00 
  800420c62b:	ff d0                	callq  *%rax
		sched_yield();
  800420c62d:	48 b8 3d d0 20 04 80 	movabs $0x800420d03d,%rax
  800420c634:	00 00 00 
  800420c637:	ff d0                	callq  *%rax
	}
	// Unexpected trap: The user process or the kernel has a bug.
	print_trapframe(tf);
  800420c639:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c63d:	48 89 c7             	mov    %rax,%rdi
  800420c640:	48 b8 55 bf 20 04 80 	movabs $0x800420bf55,%rax
  800420c647:	00 00 00 
  800420c64a:	ff d0                	callq  *%rax
	if (tf->tf_cs == GD_KT)
  800420c64c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420c650:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c657:	66 83 f8 08          	cmp    $0x8,%ax
  800420c65b:	75 2a                	jne    800420c687 <trap_dispatch+0x1da>
		panic("unhandled trap in kernel");
  800420c65d:	48 ba 4f 93 21 04 80 	movabs $0x800421934f,%rdx
  800420c664:	00 00 00 
  800420c667:	be 16 01 00 00       	mov    $0x116,%esi
  800420c66c:	48 bf 68 93 21 04 80 	movabs $0x8004219368,%rdi
  800420c673:	00 00 00 
  800420c676:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c67b:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  800420c682:	00 00 00 
  800420c685:	ff d1                	callq  *%rcx
	else {
		env_destroy(curenv);
  800420c687:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c68e:	00 00 00 
  800420c691:	ff d0                	callq  *%rax
  800420c693:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c69a:	00 00 00 
  800420c69d:	48 98                	cltq   
  800420c69f:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6a3:	48 89 c1             	mov    %rax,%rcx
  800420c6a6:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c6aa:	48 01 c8             	add    %rcx,%rax
  800420c6ad:	48 01 d0             	add    %rdx,%rax
  800420c6b0:	48 83 c0 08          	add    $0x8,%rax
  800420c6b4:	48 8b 00             	mov    (%rax),%rax
  800420c6b7:	48 89 c7             	mov    %rax,%rdi
  800420c6ba:	48 b8 f1 86 20 04 80 	movabs $0x80042086f1,%rax
  800420c6c1:	00 00 00 
  800420c6c4:	ff d0                	callq  *%rax
		return;
  800420c6c6:	90                   	nop
	}
}
  800420c6c7:	c9                   	leaveq 
  800420c6c8:	c3                   	retq   

000000800420c6c9 <trap>:

void
trap(struct Trapframe *tf)
{
  800420c6c9:	55                   	push   %rbp
  800420c6ca:	48 89 e5             	mov    %rsp,%rbp
  800420c6cd:	48 83 ec 20          	sub    $0x20,%rsp
  800420c6d1:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	//struct Trapframe *tf = &tf_;
	// The environment may have set DF and some versions
	// of GCC rely on DF being clear
	asm volatile("cld" ::: "cc");
  800420c6d5:	fc                   	cld    

	// Halt the CPU if some other CPU has called panic()
	extern char *panicstr;
	if (panicstr)
  800420c6d6:	48 b8 70 97 37 04 80 	movabs $0x8004379770,%rax
  800420c6dd:	00 00 00 
  800420c6e0:	48 8b 00             	mov    (%rax),%rax
  800420c6e3:	48 85 c0             	test   %rax,%rax
  800420c6e6:	74 01                	je     800420c6e9 <trap+0x20>
		asm volatile("hlt");
  800420c6e8:	f4                   	hlt    

	// Re-acqurie the big kernel lock if we were halted in
	// sched_yield()
	if (xchg(&thiscpu->cpu_status, CPU_STARTED) == CPU_HALTED)
  800420c6e9:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c6f0:	00 00 00 
  800420c6f3:	ff d0                	callq  *%rax
  800420c6f5:	48 98                	cltq   
  800420c6f7:	48 c1 e0 03          	shl    $0x3,%rax
  800420c6fb:	48 89 c2             	mov    %rax,%rdx
  800420c6fe:	48 c1 e2 04          	shl    $0x4,%rdx
  800420c702:	48 01 d0             	add    %rdx,%rax
  800420c705:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c70c:	00 00 00 
  800420c70f:	48 01 d0             	add    %rdx,%rax
  800420c712:	48 83 c0 04          	add    $0x4,%rax
  800420c716:	be 01 00 00 00       	mov    $0x1,%esi
  800420c71b:	48 89 c7             	mov    %rax,%rdi
  800420c71e:	48 b8 37 90 20 04 80 	movabs $0x8004209037,%rax
  800420c725:	00 00 00 
  800420c728:	ff d0                	callq  *%rax
  800420c72a:	83 f8 02             	cmp    $0x2,%eax
  800420c72d:	75 0c                	jne    800420c73b <trap+0x72>
		lock_kernel();
  800420c72f:	48 b8 5c 90 20 04 80 	movabs $0x800420905c,%rax
  800420c736:	00 00 00 
  800420c739:	ff d0                	callq  *%rax

    static __inline uint64_t
read_eflags(void)
{
    uint64_t rflags;
    __asm __volatile("pushfq; popq %0" : "=r" (rflags));
  800420c73b:	9c                   	pushfq 
  800420c73c:	58                   	pop    %rax
  800420c73d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    return rflags;
  800420c741:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
	// Check that interrupts are disabled.  If this assertion
	// fails, DO NOT be tempted to fix it by inserting a "cli" in
	// the interrupt path.
	assert(!(read_eflags() & FL_IF));
  800420c745:	25 00 02 00 00       	and    $0x200,%eax
  800420c74a:	48 85 c0             	test   %rax,%rax
  800420c74d:	74 35                	je     800420c784 <trap+0xbb>
  800420c74f:	48 b9 74 93 21 04 80 	movabs $0x8004219374,%rcx
  800420c756:	00 00 00 
  800420c759:	48 ba 8d 93 21 04 80 	movabs $0x800421938d,%rdx
  800420c760:	00 00 00 
  800420c763:	be 31 01 00 00       	mov    $0x131,%esi
  800420c768:	48 bf 68 93 21 04 80 	movabs $0x8004219368,%rdi
  800420c76f:	00 00 00 
  800420c772:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c777:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420c77e:	00 00 00 
  800420c781:	41 ff d0             	callq  *%r8

	if ((tf->tf_cs & 3) == 3) {
  800420c784:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c788:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420c78f:	0f b7 c0             	movzwl %ax,%eax
  800420c792:	83 e0 03             	and    $0x3,%eax
  800420c795:	83 f8 03             	cmp    $0x3,%eax
  800420c798:	0f 85 a9 01 00 00    	jne    800420c947 <trap+0x27e>
		// Trapped from user mode.
		// Acquire the big kernel lock before doing any
		// serious kernel work.
		// LAB 4: Your code here.
		lock_kernel();
  800420c79e:	48 b8 5c 90 20 04 80 	movabs $0x800420905c,%rax
  800420c7a5:	00 00 00 
  800420c7a8:	ff d0                	callq  *%rax
		assert(curenv);
  800420c7aa:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c7b1:	00 00 00 
  800420c7b4:	ff d0                	callq  *%rax
  800420c7b6:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c7bd:	00 00 00 
  800420c7c0:	48 98                	cltq   
  800420c7c2:	48 c1 e0 03          	shl    $0x3,%rax
  800420c7c6:	48 89 c1             	mov    %rax,%rcx
  800420c7c9:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c7cd:	48 01 c8             	add    %rcx,%rax
  800420c7d0:	48 01 d0             	add    %rdx,%rax
  800420c7d3:	48 83 c0 08          	add    $0x8,%rax
  800420c7d7:	48 8b 00             	mov    (%rax),%rax
  800420c7da:	48 85 c0             	test   %rax,%rax
  800420c7dd:	75 35                	jne    800420c814 <trap+0x14b>
  800420c7df:	48 b9 a2 93 21 04 80 	movabs $0x80042193a2,%rcx
  800420c7e6:	00 00 00 
  800420c7e9:	48 ba 8d 93 21 04 80 	movabs $0x800421938d,%rdx
  800420c7f0:	00 00 00 
  800420c7f3:	be 39 01 00 00       	mov    $0x139,%esi
  800420c7f8:	48 bf 68 93 21 04 80 	movabs $0x8004219368,%rdi
  800420c7ff:	00 00 00 
  800420c802:	b8 00 00 00 00       	mov    $0x0,%eax
  800420c807:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420c80e:	00 00 00 
  800420c811:	41 ff d0             	callq  *%r8

		// Garbage collect if current enviroment is a zombie
		if (curenv->env_status == ENV_DYING) {
  800420c814:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c81b:	00 00 00 
  800420c81e:	ff d0                	callq  *%rax
  800420c820:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c827:	00 00 00 
  800420c82a:	48 98                	cltq   
  800420c82c:	48 c1 e0 03          	shl    $0x3,%rax
  800420c830:	48 89 c1             	mov    %rax,%rcx
  800420c833:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c837:	48 01 c8             	add    %rcx,%rax
  800420c83a:	48 01 d0             	add    %rdx,%rax
  800420c83d:	48 83 c0 08          	add    $0x8,%rax
  800420c841:	48 8b 00             	mov    (%rax),%rax
  800420c844:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c84a:	83 f8 01             	cmp    $0x1,%eax
  800420c84d:	75 7f                	jne    800420c8ce <trap+0x205>
			env_free(curenv);
  800420c84f:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c856:	00 00 00 
  800420c859:	ff d0                	callq  *%rax
  800420c85b:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c862:	00 00 00 
  800420c865:	48 98                	cltq   
  800420c867:	48 c1 e0 03          	shl    $0x3,%rax
  800420c86b:	48 89 c1             	mov    %rax,%rcx
  800420c86e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c872:	48 01 c8             	add    %rcx,%rax
  800420c875:	48 01 d0             	add    %rdx,%rax
  800420c878:	48 83 c0 08          	add    $0x8,%rax
  800420c87c:	48 8b 00             	mov    (%rax),%rax
  800420c87f:	48 89 c7             	mov    %rax,%rdi
  800420c882:	48 b8 65 82 20 04 80 	movabs $0x8004208265,%rax
  800420c889:	00 00 00 
  800420c88c:	ff d0                	callq  *%rax
			curenv = NULL;
  800420c88e:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c895:	00 00 00 
  800420c898:	ff d0                	callq  *%rax
  800420c89a:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c8a1:	00 00 00 
  800420c8a4:	48 98                	cltq   
  800420c8a6:	48 c1 e0 03          	shl    $0x3,%rax
  800420c8aa:	48 89 c1             	mov    %rax,%rcx
  800420c8ad:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c8b1:	48 01 c8             	add    %rcx,%rax
  800420c8b4:	48 01 d0             	add    %rdx,%rax
  800420c8b7:	48 83 c0 08          	add    $0x8,%rax
  800420c8bb:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			sched_yield();
  800420c8c2:	48 b8 3d d0 20 04 80 	movabs $0x800420d03d,%rax
  800420c8c9:	00 00 00 
  800420c8cc:	ff d0                	callq  *%rax
		}

		// Copy trap frame (which is currently on the stack)
		// into 'curenv->env_tf', so that running the environment
		// will restart at the trap point.
		curenv->env_tf = *tf;
  800420c8ce:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c8d5:	00 00 00 
  800420c8d8:	ff d0                	callq  *%rax
  800420c8da:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c8e1:	00 00 00 
  800420c8e4:	48 98                	cltq   
  800420c8e6:	48 c1 e0 03          	shl    $0x3,%rax
  800420c8ea:	48 89 c1             	mov    %rax,%rcx
  800420c8ed:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c8f1:	48 01 c8             	add    %rcx,%rax
  800420c8f4:	48 01 d0             	add    %rdx,%rax
  800420c8f7:	48 83 c0 08          	add    $0x8,%rax
  800420c8fb:	48 8b 10             	mov    (%rax),%rdx
  800420c8fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c902:	48 89 c6             	mov    %rax,%rsi
  800420c905:	b8 18 00 00 00       	mov    $0x18,%eax
  800420c90a:	48 89 d7             	mov    %rdx,%rdi
  800420c90d:	48 89 c1             	mov    %rax,%rcx
  800420c910:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		// The trapframe on the stack should be ignored from here on.
		tf = &curenv->env_tf;
  800420c913:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c91a:	00 00 00 
  800420c91d:	ff d0                	callq  *%rax
  800420c91f:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c926:	00 00 00 
  800420c929:	48 98                	cltq   
  800420c92b:	48 c1 e0 03          	shl    $0x3,%rax
  800420c92f:	48 89 c1             	mov    %rax,%rcx
  800420c932:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c936:	48 01 c8             	add    %rcx,%rax
  800420c939:	48 01 d0             	add    %rdx,%rax
  800420c93c:	48 83 c0 08          	add    $0x8,%rax
  800420c940:	48 8b 00             	mov    (%rax),%rax
  800420c943:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}

	// Record that tf is the last real trapframe so
	// print_trapframe can print some additional information.
	last_tf = tf;
  800420c947:	48 b8 90 92 37 04 80 	movabs $0x8004379290,%rax
  800420c94e:	00 00 00 
  800420c951:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420c955:	48 89 10             	mov    %rdx,(%rax)

	// Dispatch based on what type of trap occurred
	trap_dispatch(tf);
  800420c958:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420c95c:	48 89 c7             	mov    %rax,%rdi
  800420c95f:	48 b8 ad c4 20 04 80 	movabs $0x800420c4ad,%rax
  800420c966:	00 00 00 
  800420c969:	ff d0                	callq  *%rax

	// If we made it to this point, then no other environment was
	// scheduled, so we should return to the current environment
	// if doing so makes sense.
	if (curenv && curenv->env_status == ENV_RUNNING)
  800420c96b:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c972:	00 00 00 
  800420c975:	ff d0                	callq  *%rax
  800420c977:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c97e:	00 00 00 
  800420c981:	48 98                	cltq   
  800420c983:	48 c1 e0 03          	shl    $0x3,%rax
  800420c987:	48 89 c1             	mov    %rax,%rcx
  800420c98a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c98e:	48 01 c8             	add    %rcx,%rax
  800420c991:	48 01 d0             	add    %rdx,%rax
  800420c994:	48 83 c0 08          	add    $0x8,%rax
  800420c998:	48 8b 00             	mov    (%rax),%rax
  800420c99b:	48 85 c0             	test   %rax,%rax
  800420c99e:	74 7a                	je     800420ca1a <trap+0x351>
  800420c9a0:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c9a7:	00 00 00 
  800420c9aa:	ff d0                	callq  *%rax
  800420c9ac:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c9b3:	00 00 00 
  800420c9b6:	48 98                	cltq   
  800420c9b8:	48 c1 e0 03          	shl    $0x3,%rax
  800420c9bc:	48 89 c1             	mov    %rax,%rcx
  800420c9bf:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c9c3:	48 01 c8             	add    %rcx,%rax
  800420c9c6:	48 01 d0             	add    %rdx,%rax
  800420c9c9:	48 83 c0 08          	add    $0x8,%rax
  800420c9cd:	48 8b 00             	mov    (%rax),%rax
  800420c9d0:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420c9d6:	83 f8 03             	cmp    $0x3,%eax
  800420c9d9:	75 3f                	jne    800420ca1a <trap+0x351>
		env_run(curenv);
  800420c9db:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420c9e2:	00 00 00 
  800420c9e5:	ff d0                	callq  *%rax
  800420c9e7:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420c9ee:	00 00 00 
  800420c9f1:	48 98                	cltq   
  800420c9f3:	48 c1 e0 03          	shl    $0x3,%rax
  800420c9f7:	48 89 c1             	mov    %rax,%rcx
  800420c9fa:	48 c1 e1 04          	shl    $0x4,%rcx
  800420c9fe:	48 01 c8             	add    %rcx,%rax
  800420ca01:	48 01 d0             	add    %rdx,%rax
  800420ca04:	48 83 c0 08          	add    $0x8,%rax
  800420ca08:	48 8b 00             	mov    (%rax),%rax
  800420ca0b:	48 89 c7             	mov    %rax,%rdi
  800420ca0e:	48 b8 bc 88 20 04 80 	movabs $0x80042088bc,%rax
  800420ca15:	00 00 00 
  800420ca18:	ff d0                	callq  *%rax
	else
		sched_yield();
  800420ca1a:	48 b8 3d d0 20 04 80 	movabs $0x800420d03d,%rax
  800420ca21:	00 00 00 
  800420ca24:	ff d0                	callq  *%rax

000000800420ca26 <page_fault_handler>:
}


void
page_fault_handler(struct Trapframe *tf)
{
  800420ca26:	55                   	push   %rbp
  800420ca27:	48 89 e5             	mov    %rsp,%rbp
  800420ca2a:	53                   	push   %rbx
  800420ca2b:	48 83 ec 38          	sub    $0x38,%rsp
  800420ca2f:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)

    static __inline uint64_t
rcr2(void)
{
    uint64_t val;
    __asm __volatile("movq %%cr2,%0" : "=r" (val));
  800420ca33:	0f 20 d0             	mov    %cr2,%rax
  800420ca36:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    return val;
  800420ca3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
	uint64_t fault_va;

	// Read processor's CR2 register to find the faulting address
	fault_va = rcr2();
  800420ca3e:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	struct PageInfo *pp;

	// Handle kernel-mode page faults.
	
	// LAB 3: Your code here.
	if((tf->tf_cs & 3) == 0)
  800420ca42:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca46:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420ca4d:	0f b7 c0             	movzwl %ax,%eax
  800420ca50:	83 e0 03             	and    $0x3,%eax
  800420ca53:	85 c0                	test   %eax,%eax
  800420ca55:	75 5f                	jne    800420cab6 <page_fault_handler+0x90>
	{
		cprintf("fault_va is [%x]",fault_va);
  800420ca57:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ca5b:	48 89 c6             	mov    %rax,%rsi
  800420ca5e:	48 bf a9 93 21 04 80 	movabs $0x80042193a9,%rdi
  800420ca65:	00 00 00 
  800420ca68:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ca6d:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420ca74:	00 00 00 
  800420ca77:	ff d2                	callq  *%rdx
		print_trapframe(tf);
  800420ca79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ca7d:	48 89 c7             	mov    %rax,%rdi
  800420ca80:	48 b8 55 bf 20 04 80 	movabs $0x800420bf55,%rax
  800420ca87:	00 00 00 
  800420ca8a:	ff d0                	callq  *%rax
		panic("Page fault hapened in kernel mode");
  800420ca8c:	48 ba c0 93 21 04 80 	movabs $0x80042193c0,%rdx
  800420ca93:	00 00 00 
  800420ca96:	be 6c 01 00 00       	mov    $0x16c,%esi
  800420ca9b:	48 bf 68 93 21 04 80 	movabs $0x8004219368,%rdi
  800420caa2:	00 00 00 
  800420caa5:	b8 00 00 00 00       	mov    $0x0,%eax
  800420caaa:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  800420cab1:	00 00 00 
  800420cab4:	ff d1                	callq  *%rcx
	// LAB 4: Your code here.
	
	/*check if user env has registered a pg fault upcall.*/
		//cprintf("hello1");
	//cprintf("hello2");
    if(curenv->env_pgfault_upcall){
  800420cab6:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420cabd:	00 00 00 
  800420cac0:	ff d0                	callq  *%rax
  800420cac2:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420cac9:	00 00 00 
  800420cacc:	48 98                	cltq   
  800420cace:	48 c1 e0 03          	shl    $0x3,%rax
  800420cad2:	48 89 c1             	mov    %rax,%rcx
  800420cad5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cad9:	48 01 c8             	add    %rcx,%rax
  800420cadc:	48 01 d0             	add    %rdx,%rax
  800420cadf:	48 83 c0 08          	add    $0x8,%rax
  800420cae3:	48 8b 00             	mov    (%rax),%rax
  800420cae6:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420caed:	48 85 c0             	test   %rax,%rax
  800420caf0:	0f 84 6a 02 00 00    	je     800420cd60 <page_fault_handler+0x33a>
		//user_mem_assert(curenv,(const void *)curenv->env_pgfault_upcall,8,PTE_P|PTE_U);
		user_mem_assert(curenv,(const void *)UXSTACKTOP-PGSIZE,PGSIZE, PTE_W | PTE_U | PTE_P);
  800420caf6:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420cafd:	00 00 00 
  800420cb00:	ff d0                	callq  *%rax
  800420cb02:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420cb09:	00 00 00 
  800420cb0c:	48 98                	cltq   
  800420cb0e:	48 c1 e0 03          	shl    $0x3,%rax
  800420cb12:	48 89 c1             	mov    %rax,%rcx
  800420cb15:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cb19:	48 01 c8             	add    %rcx,%rax
  800420cb1c:	48 01 d0             	add    %rdx,%rax
  800420cb1f:	48 83 c0 08          	add    $0x8,%rax
  800420cb23:	48 8b 00             	mov    (%rax),%rax
  800420cb26:	b9 07 00 00 00       	mov    $0x7,%ecx
  800420cb2b:	ba 00 10 00 00       	mov    $0x1000,%edx
  800420cb30:	be 00 f0 7f ef       	mov    $0xef7ff000,%esi
  800420cb35:	48 89 c7             	mov    %rax,%rdi
  800420cb38:	48 b8 98 3e 20 04 80 	movabs $0x8004203e98,%rax
  800420cb3f:	00 00 00 
  800420cb42:	ff d0                	callq  *%rax
		/*If user mem assert returns , then the address is valid for the env*/	
		if(!(tf->tf_rsp < UXSTACKTOP && tf->tf_rsp > UXSTACKTOP-PGSIZE)){
  800420cb44:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb48:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cb4f:	b8 ff ff 7f ef       	mov    $0xef7fffff,%eax
  800420cb54:	48 39 c2             	cmp    %rax,%rdx
  800420cb57:	77 15                	ja     800420cb6e <page_fault_handler+0x148>
  800420cb59:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb5d:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420cb64:	b8 00 f0 7f ef       	mov    $0xef7ff000,%eax
  800420cb69:	48 39 c2             	cmp    %rax,%rdx
  800420cb6c:	77 0b                	ja     800420cb79 <page_fault_handler+0x153>
			/*1st Page Fault*/
			utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe));
  800420cb6e:	b8 60 ff 7f ef       	mov    $0xef7fff60,%eax
  800420cb73:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420cb77:	eb 72                	jmp    800420cbeb <page_fault_handler+0x1c5>
		}else{
			if(tf->tf_rsp - sizeof(struct UTrapframe) - 8 < (UXSTACKTOP-PGSIZE)){
  800420cb79:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cb7d:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420cb84:	48 8d 90 58 ff ff ff 	lea    -0xa8(%rax),%rdx
  800420cb8b:	b8 ff ef 7f ef       	mov    $0xef7fefff,%eax
  800420cb90:	48 39 c2             	cmp    %rax,%rdx
  800420cb93:	77 41                	ja     800420cbd6 <page_fault_handler+0x1b0>
				env_destroy(curenv);
  800420cb95:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420cb9c:	00 00 00 
  800420cb9f:	ff d0                	callq  *%rax
  800420cba1:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420cba8:	00 00 00 
  800420cbab:	48 98                	cltq   
  800420cbad:	48 c1 e0 03          	shl    $0x3,%rax
  800420cbb1:	48 89 c1             	mov    %rax,%rcx
  800420cbb4:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cbb8:	48 01 c8             	add    %rcx,%rax
  800420cbbb:	48 01 d0             	add    %rdx,%rax
  800420cbbe:	48 83 c0 08          	add    $0x8,%rax
  800420cbc2:	48 8b 00             	mov    (%rax),%rax
  800420cbc5:	48 89 c7             	mov    %rax,%rdi
  800420cbc8:	48 b8 f1 86 20 04 80 	movabs $0x80042086f1,%rax
  800420cbcf:	00 00 00 
  800420cbd2:	ff d0                	callq  *%rax
  800420cbd4:	eb 15                	jmp    800420cbeb <page_fault_handler+0x1c5>
			}
			else
			{
				utf = (struct UTrapframe *)(tf->tf_rsp - sizeof(struct UTrapframe) - 8);
  800420cbd6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cbda:	48 8b 80 b0 00 00 00 	mov    0xb0(%rax),%rax
  800420cbe1:	48 2d a8 00 00 00    	sub    $0xa8,%rax
  800420cbe7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			/*Nested Page Fault*/
			
		}
		/*Populate the Utrapframe*/
		//user_mem_assert(curenv,(const void *)utf,sizeof(struct UTrapframe),PTE_W|PTE_U);
		utf->utf_eflags = tf->tf_eflags;
  800420cbeb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cbef:	48 8b 90 a8 00 00 00 	mov    0xa8(%rax),%rdx
  800420cbf6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cbfa:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
		utf->utf_err = tf->tf_err;
  800420cc01:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cc05:	48 8b 90 90 00 00 00 	mov    0x90(%rax),%rdx
  800420cc0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc10:	48 89 50 08          	mov    %rdx,0x8(%rax)
		utf->utf_fault_va = fault_va;
  800420cc14:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc18:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cc1c:	48 89 10             	mov    %rdx,(%rax)
		utf->utf_regs = tf->tf_regs;
  800420cc1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420cc23:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420cc27:	48 8b 0a             	mov    (%rdx),%rcx
  800420cc2a:	48 89 48 10          	mov    %rcx,0x10(%rax)
  800420cc2e:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420cc32:	48 89 48 18          	mov    %rcx,0x18(%rax)
  800420cc36:	48 8b 4a 10          	mov    0x10(%rdx),%rcx
  800420cc3a:	48 89 48 20          	mov    %rcx,0x20(%rax)
  800420cc3e:	48 8b 4a 18          	mov    0x18(%rdx),%rcx
  800420cc42:	48 89 48 28          	mov    %rcx,0x28(%rax)
  800420cc46:	48 8b 4a 20          	mov    0x20(%rdx),%rcx
  800420cc4a:	48 89 48 30          	mov    %rcx,0x30(%rax)
  800420cc4e:	48 8b 4a 28          	mov    0x28(%rdx),%rcx
  800420cc52:	48 89 48 38          	mov    %rcx,0x38(%rax)
  800420cc56:	48 8b 4a 30          	mov    0x30(%rdx),%rcx
  800420cc5a:	48 89 48 40          	mov    %rcx,0x40(%rax)
  800420cc5e:	48 8b 4a 38          	mov    0x38(%rdx),%rcx
  800420cc62:	48 89 48 48          	mov    %rcx,0x48(%rax)
  800420cc66:	48 8b 4a 40          	mov    0x40(%rdx),%rcx
  800420cc6a:	48 89 48 50          	mov    %rcx,0x50(%rax)
  800420cc6e:	48 8b 4a 48          	mov    0x48(%rdx),%rcx
  800420cc72:	48 89 48 58          	mov    %rcx,0x58(%rax)
  800420cc76:	48 8b 4a 50          	mov    0x50(%rdx),%rcx
  800420cc7a:	48 89 48 60          	mov    %rcx,0x60(%rax)
  800420cc7e:	48 8b 4a 58          	mov    0x58(%rdx),%rcx
  800420cc82:	48 89 48 68          	mov    %rcx,0x68(%rax)
  800420cc86:	48 8b 4a 60          	mov    0x60(%rdx),%rcx
  800420cc8a:	48 89 48 70          	mov    %rcx,0x70(%rax)
  800420cc8e:	48 8b 4a 68          	mov    0x68(%rdx),%rcx
  800420cc92:	48 89 48 78          	mov    %rcx,0x78(%rax)
  800420cc96:	48 8b 52 70          	mov    0x70(%rdx),%rdx
  800420cc9a:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
		utf->utf_rip = tf->tf_rip;
  800420cca1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cca5:	48 8b 90 98 00 00 00 	mov    0x98(%rax),%rdx
  800420ccac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccb0:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
		utf->utf_rsp = tf->tf_rsp;
  800420ccb7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420ccbb:	48 8b 90 b0 00 00 00 	mov    0xb0(%rax),%rdx
  800420ccc2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ccc6:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rip = (uint64_t)curenv->env_pgfault_upcall;
  800420cccd:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420ccd4:	00 00 00 
  800420ccd7:	ff d0                	callq  *%rax
  800420ccd9:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420cce0:	00 00 00 
  800420cce3:	48 98                	cltq   
  800420cce5:	48 c1 e0 03          	shl    $0x3,%rax
  800420cce9:	48 89 c1             	mov    %rax,%rcx
  800420ccec:	48 c1 e1 04          	shl    $0x4,%rcx
  800420ccf0:	48 01 c8             	add    %rcx,%rax
  800420ccf3:	48 01 d0             	add    %rdx,%rax
  800420ccf6:	48 83 c0 08          	add    $0x8,%rax
  800420ccfa:	48 8b 00             	mov    (%rax),%rax
  800420ccfd:	48 8b 80 f0 00 00 00 	mov    0xf0(%rax),%rax
  800420cd04:	48 89 c2             	mov    %rax,%rdx
  800420cd07:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd0b:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
		tf->tf_rsp = (uint64_t)utf;
  800420cd12:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420cd16:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd1a:	48 89 90 b0 00 00 00 	mov    %rdx,0xb0(%rax)
		

		
		env_run(curenv);
  800420cd21:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420cd28:	00 00 00 
  800420cd2b:	ff d0                	callq  *%rax
  800420cd2d:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420cd34:	00 00 00 
  800420cd37:	48 98                	cltq   
  800420cd39:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd3d:	48 89 c1             	mov    %rax,%rcx
  800420cd40:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cd44:	48 01 c8             	add    %rcx,%rax
  800420cd47:	48 01 d0             	add    %rdx,%rax
  800420cd4a:	48 83 c0 08          	add    $0x8,%rax
  800420cd4e:	48 8b 00             	mov    (%rax),%rax
  800420cd51:	48 89 c7             	mov    %rax,%rdi
  800420cd54:	48 b8 bc 88 20 04 80 	movabs $0x80042088bc,%rax
  800420cd5b:	00 00 00 
  800420cd5e:	ff d0                	callq  *%rax
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420cd60:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cd64:	48 8b 98 98 00 00 00 	mov    0x98(%rax),%rbx
			curenv->env_id, fault_va, tf->tf_rip);
  800420cd6b:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420cd72:	00 00 00 
  800420cd75:	ff d0                	callq  *%rax
  800420cd77:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420cd7e:	00 00 00 
  800420cd81:	48 98                	cltq   
  800420cd83:	48 c1 e0 03          	shl    $0x3,%rax
  800420cd87:	48 89 c1             	mov    %rax,%rcx
  800420cd8a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cd8e:	48 01 c8             	add    %rcx,%rax
  800420cd91:	48 01 d0             	add    %rdx,%rax
  800420cd94:	48 83 c0 08          	add    $0x8,%rax
  800420cd98:	48 8b 00             	mov    (%rax),%rax
		
		env_run(curenv);
	
    }else{
		// Destroy the environment that caused the fault.
		cprintf("[%08x] user fault va %08x ip %08x\n",
  800420cd9b:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420cda1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420cda5:	48 89 d9             	mov    %rbx,%rcx
  800420cda8:	89 c6                	mov    %eax,%esi
  800420cdaa:	48 bf e8 93 21 04 80 	movabs $0x80042193e8,%rdi
  800420cdb1:	00 00 00 
  800420cdb4:	b8 00 00 00 00       	mov    $0x0,%eax
  800420cdb9:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  800420cdc0:	00 00 00 
  800420cdc3:	41 ff d0             	callq  *%r8
			curenv->env_id, fault_va, tf->tf_rip);
		print_trapframe(tf);
  800420cdc6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420cdca:	48 89 c7             	mov    %rax,%rdi
  800420cdcd:	48 b8 55 bf 20 04 80 	movabs $0x800420bf55,%rax
  800420cdd4:	00 00 00 
  800420cdd7:	ff d0                	callq  *%rax
		env_destroy(curenv);
  800420cdd9:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420cde0:	00 00 00 
  800420cde3:	ff d0                	callq  *%rax
  800420cde5:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420cdec:	00 00 00 
  800420cdef:	48 98                	cltq   
  800420cdf1:	48 c1 e0 03          	shl    $0x3,%rax
  800420cdf5:	48 89 c1             	mov    %rax,%rcx
  800420cdf8:	48 c1 e1 04          	shl    $0x4,%rcx
  800420cdfc:	48 01 c8             	add    %rcx,%rax
  800420cdff:	48 01 d0             	add    %rdx,%rax
  800420ce02:	48 83 c0 08          	add    $0x8,%rax
  800420ce06:	48 8b 00             	mov    (%rax),%rax
  800420ce09:	48 89 c7             	mov    %rax,%rdi
  800420ce0c:	48 b8 f1 86 20 04 80 	movabs $0x80042086f1,%rax
  800420ce13:	00 00 00 
  800420ce16:	ff d0                	callq  *%rax
    }
}
  800420ce18:	48 83 c4 38          	add    $0x38,%rsp
  800420ce1c:	5b                   	pop    %rbx
  800420ce1d:	5d                   	pop    %rbp
  800420ce1e:	c3                   	retq   
  800420ce1f:	90                   	nop

000000800420ce20 <XTRPX_divzero>:
 * Lab 3: Your code here for generating entry points for the different traps.
   Find the PUSHA,POPA macros in kern/macro.h. Since amd64 doesn't support
   pusha,popa so you will find these macros handy.
 */

	TRAPHANDLER_NOEC(XTRPX_divzero, T_DIVIDE)
  800420ce20:	6a 00                	pushq  $0x0
  800420ce22:	6a 00                	pushq  $0x0
  800420ce24:	e9 01 01 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce29:	90                   	nop

000000800420ce2a <XTRPX_Debug>:
	TRAPHANDLER_NOEC(XTRPX_Debug, T_DEBUG)
  800420ce2a:	6a 00                	pushq  $0x0
  800420ce2c:	6a 01                	pushq  $0x1
  800420ce2e:	e9 f7 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce33:	90                   	nop

000000800420ce34 <XTRPX_NonMaskI>:
	TRAPHANDLER_NOEC(XTRPX_NonMaskI, T_NMI)
  800420ce34:	6a 00                	pushq  $0x0
  800420ce36:	6a 02                	pushq  $0x2
  800420ce38:	e9 ed 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce3d:	90                   	nop

000000800420ce3e <XTRPX_Brkpt>:
	TRAPHANDLER_NOEC(XTRPX_Brkpt, T_BRKPT)
  800420ce3e:	6a 00                	pushq  $0x0
  800420ce40:	6a 03                	pushq  $0x3
  800420ce42:	e9 e3 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce47:	90                   	nop

000000800420ce48 <XTRPX_OFlow>:
	TRAPHANDLER_NOEC(XTRPX_OFlow, T_OFLOW)
  800420ce48:	6a 00                	pushq  $0x0
  800420ce4a:	6a 04                	pushq  $0x4
  800420ce4c:	e9 d9 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce51:	90                   	nop

000000800420ce52 <XTRPX_Bound>:
	TRAPHANDLER_NOEC(XTRPX_Bound, T_BOUND)
  800420ce52:	6a 00                	pushq  $0x0
  800420ce54:	6a 05                	pushq  $0x5
  800420ce56:	e9 cf 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce5b:	90                   	nop

000000800420ce5c <XTRPX_Illop>:
	TRAPHANDLER_NOEC(XTRPX_Illop, T_ILLOP)
  800420ce5c:	6a 00                	pushq  $0x0
  800420ce5e:	6a 06                	pushq  $0x6
  800420ce60:	e9 c5 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce65:	90                   	nop

000000800420ce66 <XTRPX_Device>:
	TRAPHANDLER_NOEC(XTRPX_Device, T_DEVICE)
  800420ce66:	6a 00                	pushq  $0x0
  800420ce68:	6a 07                	pushq  $0x7
  800420ce6a:	e9 bb 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce6f:	90                   	nop

000000800420ce70 <XTRPX_DblFlt>:
	TRAPHANDLER(XTRPX_DblFlt, T_DBLFLT)
  800420ce70:	6a 08                	pushq  $0x8
  800420ce72:	e9 b3 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce77:	90                   	nop

000000800420ce78 <XTRPX_Tss>:
	TRAPHANDLER(XTRPX_Tss, T_TSS)
  800420ce78:	6a 0a                	pushq  $0xa
  800420ce7a:	e9 ab 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce7f:	90                   	nop

000000800420ce80 <XTRPX_Segnp>:
	TRAPHANDLER(XTRPX_Segnp, T_SEGNP)
  800420ce80:	6a 0b                	pushq  $0xb
  800420ce82:	e9 a3 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce87:	90                   	nop

000000800420ce88 <XTRPX_Stack>:
	TRAPHANDLER(XTRPX_Stack, T_STACK)
  800420ce88:	6a 0c                	pushq  $0xc
  800420ce8a:	e9 9b 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce8f:	90                   	nop

000000800420ce90 <XTRPX_Gpflt>:
	TRAPHANDLER(XTRPX_Gpflt, T_GPFLT)
  800420ce90:	6a 0d                	pushq  $0xd
  800420ce92:	e9 93 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce97:	90                   	nop

000000800420ce98 <XTRPX_Pgflt>:
	TRAPHANDLER(XTRPX_Pgflt, T_PGFLT)
  800420ce98:	6a 0e                	pushq  $0xe
  800420ce9a:	e9 8b 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420ce9f:	90                   	nop

000000800420cea0 <XTRPX_FpErr>:
	TRAPHANDLER_NOEC(XTRPX_FpErr, T_FPERR)
  800420cea0:	6a 00                	pushq  $0x0
  800420cea2:	6a 10                	pushq  $0x10
  800420cea4:	e9 81 00 00 00       	jmpq   800420cf2a <_alltraps>
  800420cea9:	90                   	nop

000000800420ceaa <XTRPX_Align>:
	TRAPHANDLER(XTRPX_Align, T_ALIGN)
  800420ceaa:	6a 11                	pushq  $0x11
  800420ceac:	eb 7c                	jmp    800420cf2a <_alltraps>

000000800420ceae <XTRPX_Mchk>:
	TRAPHANDLER_NOEC(XTRPX_Mchk, T_MCHK)
  800420ceae:	6a 00                	pushq  $0x0
  800420ceb0:	6a 12                	pushq  $0x12
  800420ceb2:	eb 76                	jmp    800420cf2a <_alltraps>

000000800420ceb4 <XTRPX_SimdErr>:
	TRAPHANDLER_NOEC(XTRPX_SimdErr, T_SIMDERR)
  800420ceb4:	6a 00                	pushq  $0x0
  800420ceb6:	6a 13                	pushq  $0x13
  800420ceb8:	eb 70                	jmp    800420cf2a <_alltraps>

000000800420ceba <XTRPX_Syscall>:
	TRAPHANDLER_NOEC(XTRPX_Syscall, T_SYSCALL)
  800420ceba:	6a 00                	pushq  $0x0
  800420cebc:	6a 30                	pushq  $0x30
  800420cebe:	eb 6a                	jmp    800420cf2a <_alltraps>

000000800420cec0 <XTRPX_Default>:
	TRAPHANDLER_NOEC(XTRPX_Default, T_DEFAULT)
  800420cec0:	6a 00                	pushq  $0x0
  800420cec2:	68 f4 01 00 00       	pushq  $0x1f4
  800420cec7:	eb 61                	jmp    800420cf2a <_alltraps>
  800420cec9:	90                   	nop

000000800420ceca <XTRPX_IRQ0>:
	TRAPHANDLER_NOEC(XTRPX_IRQ0, IRQ_OFFSET+IRQ_TIMER)
  800420ceca:	6a 00                	pushq  $0x0
  800420cecc:	6a 20                	pushq  $0x20
  800420cece:	eb 5a                	jmp    800420cf2a <_alltraps>

000000800420ced0 <XTRPX_IRQ1>:
	TRAPHANDLER_NOEC(XTRPX_IRQ1, IRQ_OFFSET+IRQ_KBD)
  800420ced0:	6a 00                	pushq  $0x0
  800420ced2:	6a 21                	pushq  $0x21
  800420ced4:	eb 54                	jmp    800420cf2a <_alltraps>

000000800420ced6 <XTRPX_IRQ2>:
	TRAPHANDLER_NOEC(XTRPX_IRQ2, IRQ_OFFSET+2)
  800420ced6:	6a 00                	pushq  $0x0
  800420ced8:	6a 22                	pushq  $0x22
  800420ceda:	eb 4e                	jmp    800420cf2a <_alltraps>

000000800420cedc <XTRPX_IRQ3>:
	TRAPHANDLER_NOEC(XTRPX_IRQ3, IRQ_OFFSET+3)
  800420cedc:	6a 00                	pushq  $0x0
  800420cede:	6a 23                	pushq  $0x23
  800420cee0:	eb 48                	jmp    800420cf2a <_alltraps>

000000800420cee2 <XTRPX_IRQ4>:
	TRAPHANDLER_NOEC(XTRPX_IRQ4, IRQ_OFFSET+IRQ_SERIAL)
  800420cee2:	6a 00                	pushq  $0x0
  800420cee4:	6a 24                	pushq  $0x24
  800420cee6:	eb 42                	jmp    800420cf2a <_alltraps>

000000800420cee8 <XTRPX_IRQ5>:
	TRAPHANDLER_NOEC(XTRPX_IRQ5, IRQ_OFFSET+5)
  800420cee8:	6a 00                	pushq  $0x0
  800420ceea:	6a 25                	pushq  $0x25
  800420ceec:	eb 3c                	jmp    800420cf2a <_alltraps>

000000800420ceee <XTRPX_IRQ6>:
	TRAPHANDLER_NOEC(XTRPX_IRQ6, IRQ_OFFSET+6)
  800420ceee:	6a 00                	pushq  $0x0
  800420cef0:	6a 26                	pushq  $0x26
  800420cef2:	eb 36                	jmp    800420cf2a <_alltraps>

000000800420cef4 <XTRPX_IRQ7>:
	TRAPHANDLER_NOEC(XTRPX_IRQ7, IRQ_OFFSET+IRQ_SPURIOUS)
  800420cef4:	6a 00                	pushq  $0x0
  800420cef6:	6a 27                	pushq  $0x27
  800420cef8:	eb 30                	jmp    800420cf2a <_alltraps>

000000800420cefa <XTRPX_IRQ8>:
	TRAPHANDLER_NOEC(XTRPX_IRQ8, IRQ_OFFSET+8)
  800420cefa:	6a 00                	pushq  $0x0
  800420cefc:	6a 28                	pushq  $0x28
  800420cefe:	eb 2a                	jmp    800420cf2a <_alltraps>

000000800420cf00 <XTRPX_IRQ9>:
	TRAPHANDLER_NOEC(XTRPX_IRQ9, IRQ_OFFSET+9)
  800420cf00:	6a 00                	pushq  $0x0
  800420cf02:	6a 29                	pushq  $0x29
  800420cf04:	eb 24                	jmp    800420cf2a <_alltraps>

000000800420cf06 <XTRPX_IRQa>:
	TRAPHANDLER_NOEC(XTRPX_IRQa, IRQ_OFFSET+10)
  800420cf06:	6a 00                	pushq  $0x0
  800420cf08:	6a 2a                	pushq  $0x2a
  800420cf0a:	eb 1e                	jmp    800420cf2a <_alltraps>

000000800420cf0c <XTRPX_IRQb>:
	TRAPHANDLER_NOEC(XTRPX_IRQb, IRQ_OFFSET+11)
  800420cf0c:	6a 00                	pushq  $0x0
  800420cf0e:	6a 2b                	pushq  $0x2b
  800420cf10:	eb 18                	jmp    800420cf2a <_alltraps>

000000800420cf12 <XTRPX_IRQc>:
	TRAPHANDLER_NOEC(XTRPX_IRQc, IRQ_OFFSET+12)
  800420cf12:	6a 00                	pushq  $0x0
  800420cf14:	6a 2c                	pushq  $0x2c
  800420cf16:	eb 12                	jmp    800420cf2a <_alltraps>

000000800420cf18 <XTRPX_IRQd>:
	TRAPHANDLER_NOEC(XTRPX_IRQd, IRQ_OFFSET+13)
  800420cf18:	6a 00                	pushq  $0x0
  800420cf1a:	6a 2d                	pushq  $0x2d
  800420cf1c:	eb 0c                	jmp    800420cf2a <_alltraps>

000000800420cf1e <XTRPX_IRQe>:
	TRAPHANDLER_NOEC(XTRPX_IRQe, IRQ_OFFSET+IRQ_IDE)
  800420cf1e:	6a 00                	pushq  $0x0
  800420cf20:	6a 2e                	pushq  $0x2e
  800420cf22:	eb 06                	jmp    800420cf2a <_alltraps>

000000800420cf24 <XTRPX_IRQf>:
	TRAPHANDLER_NOEC(XTRPX_IRQf, IRQ_OFFSET+15)
  800420cf24:	6a 00                	pushq  $0x0
  800420cf26:	6a 2f                	pushq  $0x2f
  800420cf28:	eb 00                	jmp    800420cf2a <_alltraps>

000000800420cf2a <_alltraps>:
 * Hint: Be sure to review the x64 calling convention from lab1
 *       for how to pass a pointer to the trapframe.
 */
    _alltraps:
    	/* Since ES and DS registers can't be pushed in x86-64. So moving them to r15 first */
		xor %r15, %r15
  800420cf2a:	4d 31 ff             	xor    %r15,%r15
		movw %ds,%r15 
  800420cf2d:	66 41 8c df          	mov    %ds,%r15w
		pushq %r15
  800420cf31:	41 57                	push   %r15
		movw %es, %r15
  800420cf33:	66 41 8c c7          	mov    %es,%r15w
		pushq %r15
  800420cf37:	41 57                	push   %r15
		/* Now push all registers onto the stack */
		PUSHA
  800420cf39:	48 83 ec 78          	sub    $0x78,%rsp
  800420cf3d:	48 89 44 24 70       	mov    %rax,0x70(%rsp)
  800420cf42:	48 89 5c 24 68       	mov    %rbx,0x68(%rsp)
  800420cf47:	48 89 4c 24 60       	mov    %rcx,0x60(%rsp)
  800420cf4c:	48 89 54 24 58       	mov    %rdx,0x58(%rsp)
  800420cf51:	48 89 6c 24 50       	mov    %rbp,0x50(%rsp)
  800420cf56:	48 89 7c 24 48       	mov    %rdi,0x48(%rsp)
  800420cf5b:	48 89 74 24 40       	mov    %rsi,0x40(%rsp)
  800420cf60:	4c 89 44 24 38       	mov    %r8,0x38(%rsp)
  800420cf65:	4c 89 4c 24 30       	mov    %r9,0x30(%rsp)
  800420cf6a:	4c 89 54 24 28       	mov    %r10,0x28(%rsp)
  800420cf6f:	4c 89 5c 24 20       	mov    %r11,0x20(%rsp)
  800420cf74:	4c 89 64 24 18       	mov    %r12,0x18(%rsp)
  800420cf79:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
  800420cf7e:	4c 89 74 24 08       	mov    %r14,0x8(%rsp)
  800420cf83:	4c 89 3c 24          	mov    %r15,(%rsp)
		/* Far pointer addressing*/
		mov %rsp, %rdi
  800420cf87:	48 89 e7             	mov    %rsp,%rdi
		/* filling es and ds now */
		xor %r15, %r15
  800420cf8a:	4d 31 ff             	xor    %r15,%r15
		movw $(GD_KD), %r15
  800420cf8d:	66 41 c7 c7 10 00    	mov    $0x10,%r15w
		movw %r15, %es
  800420cf93:	41 8e c7             	mov    %r15d,%es
		movw %r15, %ds
  800420cf96:	41 8e df             	mov    %r15d,%ds
		call trap
  800420cf99:	e8 2b f7 ff ff       	callq  800420c6c9 <trap>
		POPA_
  800420cf9e:	4c 8b 3c 24          	mov    (%rsp),%r15
  800420cfa2:	4c 8b 74 24 08       	mov    0x8(%rsp),%r14
  800420cfa7:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
  800420cfac:	4c 8b 64 24 18       	mov    0x18(%rsp),%r12
  800420cfb1:	4c 8b 5c 24 20       	mov    0x20(%rsp),%r11
  800420cfb6:	4c 8b 54 24 28       	mov    0x28(%rsp),%r10
  800420cfbb:	4c 8b 4c 24 30       	mov    0x30(%rsp),%r9
  800420cfc0:	4c 8b 44 24 38       	mov    0x38(%rsp),%r8
  800420cfc5:	48 8b 74 24 40       	mov    0x40(%rsp),%rsi
  800420cfca:	48 8b 7c 24 48       	mov    0x48(%rsp),%rdi
  800420cfcf:	48 8b 6c 24 50       	mov    0x50(%rsp),%rbp
  800420cfd4:	48 8b 54 24 58       	mov    0x58(%rsp),%rdx
  800420cfd9:	48 8b 4c 24 60       	mov    0x60(%rsp),%rcx
  800420cfde:	48 8b 5c 24 68       	mov    0x68(%rsp),%rbx
  800420cfe3:	48 8b 44 24 70       	mov    0x70(%rsp),%rax
  800420cfe8:	48 83 c4 78          	add    $0x78,%rsp
		/*Now make the stack same as we got from CPU*/
		xor %r15, %r15
  800420cfec:	4d 31 ff             	xor    %r15,%r15
		popq %r15
  800420cfef:	41 5f                	pop    %r15
		movw %r15, %es
  800420cff1:	41 8e c7             	mov    %r15d,%es
		popq %r15
  800420cff4:	41 5f                	pop    %r15
		movw %r15, %ds
  800420cff6:	41 8e df             	mov    %r15d,%ds
		iret 
  800420cff9:	cf                   	iret   

000000800420cffa <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  800420cffa:	55                   	push   %rbp
  800420cffb:	48 89 e5             	mov    %rsp,%rbp
  800420cffe:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420d002:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420d006:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  800420d009:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420d00d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420d010:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420d014:	f0 87 02             	lock xchg %eax,(%rdx)
  800420d017:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  800420d01a:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420d01d:	c9                   	leaveq 
  800420d01e:	c3                   	retq   

000000800420d01f <unlock_kernel>:

static inline void
unlock_kernel(void)
{
  800420d01f:	55                   	push   %rbp
  800420d020:	48 89 e5             	mov    %rsp,%rbp
	spin_unlock(&kernel_lock);
  800420d023:	48 bf 40 b7 22 04 80 	movabs $0x800422b740,%rdi
  800420d02a:	00 00 00 
  800420d02d:	48 b8 ec 6e 21 04 80 	movabs $0x8004216eec,%rax
  800420d034:	00 00 00 
  800420d037:	ff d0                	callq  *%rax

	// Normally we wouldn't need to do this, but QEMU only runs
	// one CPU at a time and has a long time-slice.  Without the
	// pause, this CPU is likely to reacquire the lock before
	// another CPU has even been given a chance to acquire it.
	asm volatile("pause");
  800420d039:	f3 90                	pause  
}
  800420d03b:	5d                   	pop    %rbp
  800420d03c:	c3                   	retq   

000000800420d03d <sched_yield>:
#endif

// Choose a user environment to run and run it.
void
sched_yield(void)
{	
  800420d03d:	55                   	push   %rbp
  800420d03e:	48 89 e5             	mov    %rsp,%rbp
  800420d041:	48 83 ec 10          	sub    $0x10,%rsp
		// no runnable environments, simply drop through to the code
		// below to halt the cpu.	
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
  800420d045:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420d04c:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)
  800420d053:	e9 96 00 00 00       	jmpq   800420d0ee <sched_yield+0xb1>
			if(envs[(env_counter+i)%NENV].env_status == ENV_RUNNABLE){
  800420d058:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  800420d05f:	00 00 00 
  800420d062:	48 8b 10             	mov    (%rax),%rdx
  800420d065:	48 b8 98 92 37 04 80 	movabs $0x8004379298,%rax
  800420d06c:	00 00 00 
  800420d06f:	8b 08                	mov    (%rax),%ecx
  800420d071:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d074:	01 c8                	add    %ecx,%eax
  800420d076:	89 c0                	mov    %eax,%eax
  800420d078:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420d07d:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d084:	48 01 d0             	add    %rdx,%rax
  800420d087:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d08d:	83 f8 02             	cmp    $0x2,%eax
  800420d090:	75 58                	jne    800420d0ea <sched_yield+0xad>
				env_counter = (env_counter+i)%NENV;
  800420d092:	48 b8 98 92 37 04 80 	movabs $0x8004379298,%rax
  800420d099:	00 00 00 
  800420d09c:	8b 10                	mov    (%rax),%edx
  800420d09e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d0a1:	01 d0                	add    %edx,%eax
  800420d0a3:	25 ff 03 00 00       	and    $0x3ff,%eax
  800420d0a8:	89 c2                	mov    %eax,%edx
  800420d0aa:	48 b8 98 92 37 04 80 	movabs $0x8004379298,%rax
  800420d0b1:	00 00 00 
  800420d0b4:	89 10                	mov    %edx,(%rax)
				    	vmx_vmrun(&envs[env_counter]);
				}
				else
			#endif					
				{
					env_run(&envs[env_counter]);
  800420d0b6:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  800420d0bd:	00 00 00 
  800420d0c0:	48 8b 10             	mov    (%rax),%rdx
  800420d0c3:	48 b8 98 92 37 04 80 	movabs $0x8004379298,%rax
  800420d0ca:	00 00 00 
  800420d0cd:	8b 00                	mov    (%rax),%eax
  800420d0cf:	89 c0                	mov    %eax,%eax
  800420d0d1:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d0d8:	48 01 d0             	add    %rdx,%rax
  800420d0db:	48 89 c7             	mov    %rax,%rdi
  800420d0de:	48 b8 bc 88 20 04 80 	movabs $0x80042088bc,%rax
  800420d0e5:	00 00 00 
  800420d0e8:	ff d0                	callq  *%rax
	
		// LAB 4: Your code here.
		static uint32_t env_counter = 0;
		uint32_t i = 0;
		//cprintf("envcounter1 = [%d]\n",env_counter);
		for(i=1;i<= NENV;i++){
  800420d0ea:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420d0ee:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420d0f5:	0f 86 5d ff ff ff    	jbe    800420d058 <sched_yield+0x1b>
				}
				break;
			}
		}
		//cprintf("envcounter2 = [%d]\n",env_counter);
		if(curenv && curenv->env_status == ENV_RUNNING){
  800420d0fb:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d102:	00 00 00 
  800420d105:	ff d0                	callq  *%rax
  800420d107:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d10e:	00 00 00 
  800420d111:	48 98                	cltq   
  800420d113:	48 c1 e0 03          	shl    $0x3,%rax
  800420d117:	48 89 c1             	mov    %rax,%rcx
  800420d11a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d11e:	48 01 c8             	add    %rcx,%rax
  800420d121:	48 01 d0             	add    %rdx,%rax
  800420d124:	48 83 c0 08          	add    $0x8,%rax
  800420d128:	48 8b 00             	mov    (%rax),%rax
  800420d12b:	48 85 c0             	test   %rax,%rax
  800420d12e:	74 7a                	je     800420d1aa <sched_yield+0x16d>
  800420d130:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d137:	00 00 00 
  800420d13a:	ff d0                	callq  *%rax
  800420d13c:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d143:	00 00 00 
  800420d146:	48 98                	cltq   
  800420d148:	48 c1 e0 03          	shl    $0x3,%rax
  800420d14c:	48 89 c1             	mov    %rax,%rcx
  800420d14f:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d153:	48 01 c8             	add    %rcx,%rax
  800420d156:	48 01 d0             	add    %rdx,%rax
  800420d159:	48 83 c0 08          	add    $0x8,%rax
  800420d15d:	48 8b 00             	mov    (%rax),%rax
  800420d160:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d166:	83 f8 03             	cmp    $0x3,%eax
  800420d169:	75 3f                	jne    800420d1aa <sched_yield+0x16d>
					vmx_vmrun(curenv);
			}
			else
		#endif		
			{
				env_run(curenv);
  800420d16b:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d172:	00 00 00 
  800420d175:	ff d0                	callq  *%rax
  800420d177:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d17e:	00 00 00 
  800420d181:	48 98                	cltq   
  800420d183:	48 c1 e0 03          	shl    $0x3,%rax
  800420d187:	48 89 c1             	mov    %rax,%rcx
  800420d18a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d18e:	48 01 c8             	add    %rcx,%rax
  800420d191:	48 01 d0             	add    %rdx,%rax
  800420d194:	48 83 c0 08          	add    $0x8,%rax
  800420d198:	48 8b 00             	mov    (%rax),%rax
  800420d19b:	48 89 c7             	mov    %rax,%rdi
  800420d19e:	48 b8 bc 88 20 04 80 	movabs $0x80042088bc,%rax
  800420d1a5:	00 00 00 
  800420d1a8:	ff d0                	callq  *%rax
			}
		}
		else{
			sched_halt();	
  800420d1aa:	48 b8 b8 d1 20 04 80 	movabs $0x800420d1b8,%rax
  800420d1b1:	00 00 00 
  800420d1b4:	ff d0                	callq  *%rax
		}
	}
  800420d1b6:	c9                   	leaveq 
  800420d1b7:	c3                   	retq   

000000800420d1b8 <sched_halt>:
// Halt this CPU when there is nothing to do. Wait until the
// timer interrupt wakes it up. This function never returns.
//
void
sched_halt(void)
	{
  800420d1b8:	55                   	push   %rbp
  800420d1b9:	48 89 e5             	mov    %rsp,%rbp
  800420d1bc:	48 83 ec 20          	sub    $0x20,%rsp
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420d1c0:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420d1c7:	eb 79                	jmp    800420d242 <sched_halt+0x8a>
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d1c9:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  800420d1d0:	00 00 00 
  800420d1d3:	48 8b 10             	mov    (%rax),%rdx
  800420d1d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d1d9:	48 98                	cltq   
  800420d1db:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d1e2:	48 01 d0             	add    %rdx,%rax
  800420d1e5:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
  800420d1eb:	83 f8 02             	cmp    $0x2,%eax
  800420d1ee:	74 5f                	je     800420d24f <sched_halt+0x97>
				 envs[i].env_status == ENV_RUNNING ||
  800420d1f0:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  800420d1f7:	00 00 00 
  800420d1fa:	48 8b 10             	mov    (%rax),%rdx
  800420d1fd:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d200:	48 98                	cltq   
  800420d202:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d209:	48 01 d0             	add    %rdx,%rax
  800420d20c:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
  800420d212:	83 f8 03             	cmp    $0x3,%eax
  800420d215:	74 38                	je     800420d24f <sched_halt+0x97>
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
  800420d217:	48 b8 58 82 37 04 80 	movabs $0x8004378258,%rax
  800420d21e:	00 00 00 
  800420d221:	48 8b 10             	mov    (%rax),%rdx
  800420d224:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d227:	48 98                	cltq   
  800420d229:	48 69 c0 68 01 00 00 	imul   $0x168,%rax,%rax
  800420d230:	48 01 d0             	add    %rdx,%rax
  800420d233:	8b 80 d4 00 00 00    	mov    0xd4(%rax),%eax
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
  800420d239:	83 f8 01             	cmp    $0x1,%eax
  800420d23c:	74 11                	je     800420d24f <sched_halt+0x97>
	{
		int i;
	
		// For debugging and testing purposes, if there are no runnable
		// environments in the system, then drop into the kernel monitor.
		for (i = 0; i < NENV; i++) {
  800420d23e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800420d242:	81 7d fc ff 03 00 00 	cmpl   $0x3ff,-0x4(%rbp)
  800420d249:	0f 8e 7a ff ff ff    	jle    800420d1c9 <sched_halt+0x11>
			if ((envs[i].env_status == ENV_RUNNABLE ||
				 envs[i].env_status == ENV_RUNNING ||
				 envs[i].env_status == ENV_DYING))
				break;
		}
		if (i == NENV) {
  800420d24f:	81 7d fc 00 04 00 00 	cmpl   $0x400,-0x4(%rbp)
  800420d256:	75 2e                	jne    800420d286 <sched_halt+0xce>
			cprintf("No runnable environments in the system!\n");
  800420d258:	48 bf 00 96 21 04 80 	movabs $0x8004219600,%rdi
  800420d25f:	00 00 00 
  800420d262:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d267:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420d26e:	00 00 00 
  800420d271:	ff d2                	callq  *%rdx
			while (1)
				monitor(NULL);
  800420d273:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d278:	48 b8 90 1c 20 04 80 	movabs $0x8004201c90,%rax
  800420d27f:	00 00 00 
  800420d282:	ff d0                	callq  *%rax
  800420d284:	eb ed                	jmp    800420d273 <sched_halt+0xbb>
		}
	
		// Mark that no environment is running on this CPU
		curenv = NULL;
  800420d286:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d28d:	00 00 00 
  800420d290:	ff d0                	callq  *%rax
  800420d292:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d299:	00 00 00 
  800420d29c:	48 98                	cltq   
  800420d29e:	48 c1 e0 03          	shl    $0x3,%rax
  800420d2a2:	48 89 c1             	mov    %rax,%rcx
  800420d2a5:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d2a9:	48 01 c8             	add    %rcx,%rax
  800420d2ac:	48 01 d0             	add    %rdx,%rax
  800420d2af:	48 83 c0 08          	add    $0x8,%rax
  800420d2b3:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		lcr3(PADDR(boot_pml4e));
  800420d2ba:	48 b8 88 97 37 04 80 	movabs $0x8004379788,%rax
  800420d2c1:	00 00 00 
  800420d2c4:	48 8b 00             	mov    (%rax),%rax
  800420d2c7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  800420d2cb:	48 b8 ff ff ff 03 80 	movabs $0x8003ffffff,%rax
  800420d2d2:	00 00 00 
  800420d2d5:	48 39 45 f0          	cmp    %rax,-0x10(%rbp)
  800420d2d9:	77 32                	ja     800420d30d <sched_halt+0x155>
  800420d2db:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d2df:	48 89 c1             	mov    %rax,%rcx
  800420d2e2:	48 ba 30 96 21 04 80 	movabs $0x8004219630,%rdx
  800420d2e9:	00 00 00 
  800420d2ec:	be 79 00 00 00       	mov    $0x79,%esi
  800420d2f1:	48 bf 54 96 21 04 80 	movabs $0x8004219654,%rdi
  800420d2f8:	00 00 00 
  800420d2fb:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d300:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420d307:	00 00 00 
  800420d30a:	41 ff d0             	callq  *%r8
  800420d30d:	48 ba 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rdx
  800420d314:	ff ff ff 
  800420d317:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d31b:	48 01 d0             	add    %rdx,%rax
  800420d31e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
}

    static __inline void
lcr3(uint64_t val)
{
    __asm __volatile("movq %0,%%cr3" : : "r" (val));
  800420d322:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d326:	0f 22 d8             	mov    %rax,%cr3
	
		// Mark that this CPU is in the HALT state, so that when
		// timer interupts come in, we know we should re-acquire the
		// big kernel lock
		xchg(&thiscpu->cpu_status, CPU_HALTED);
  800420d329:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d330:	00 00 00 
  800420d333:	ff d0                	callq  *%rax
  800420d335:	48 98                	cltq   
  800420d337:	48 c1 e0 03          	shl    $0x3,%rax
  800420d33b:	48 89 c2             	mov    %rax,%rdx
  800420d33e:	48 c1 e2 04          	shl    $0x4,%rdx
  800420d342:	48 01 d0             	add    %rdx,%rax
  800420d345:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d34c:	00 00 00 
  800420d34f:	48 01 d0             	add    %rdx,%rax
  800420d352:	48 83 c0 04          	add    $0x4,%rax
  800420d356:	be 02 00 00 00       	mov    $0x2,%esi
  800420d35b:	48 89 c7             	mov    %rax,%rdi
  800420d35e:	48 b8 fa cf 20 04 80 	movabs $0x800420cffa,%rax
  800420d365:	00 00 00 
  800420d368:	ff d0                	callq  *%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
  800420d36a:	48 b8 1f d0 20 04 80 	movabs $0x800420d01f,%rax
  800420d371:	00 00 00 
  800420d374:	ff d0                	callq  *%rax
			"movq %0, %%rsp\n"
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
  800420d376:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d37d:	00 00 00 
  800420d380:	ff d0                	callq  *%rax
  800420d382:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d389:	00 00 00 
  800420d38c:	48 98                	cltq   
  800420d38e:	48 c1 e0 03          	shl    $0x3,%rax
  800420d392:	48 89 c1             	mov    %rax,%rcx
  800420d395:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d399:	48 01 c8             	add    %rcx,%rax
  800420d39c:	48 01 d0             	add    %rdx,%rax
  800420d39f:	48 83 c0 10          	add    $0x10,%rax
  800420d3a3:	48 8b 40 04          	mov    0x4(%rax),%rax
	
		// Release the big kernel lock as if we were "leaving" the kernel
		unlock_kernel();
	
		// Reset stack pointer, enable interrupts and then halt.
		asm volatile (
  800420d3a7:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp
  800420d3ae:	48 89 c4             	mov    %rax,%rsp
  800420d3b1:	6a 00                	pushq  $0x0
  800420d3b3:	6a 00                	pushq  $0x0
  800420d3b5:	fb                   	sti    
  800420d3b6:	f4                   	hlt    
			"pushq $0\n"
			"pushq $0\n"
			"sti\n"
			"hlt\n"
			: : "a" (thiscpu->cpu_ts.ts_esp0));
	}
  800420d3b7:	c9                   	leaveq 
  800420d3b8:	c3                   	retq   

000000800420d3b9 <sys_cputs>:
// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void
sys_cputs(const char *s, size_t len)
{
  800420d3b9:	55                   	push   %rbp
  800420d3ba:	48 89 e5             	mov    %rsp,%rbp
  800420d3bd:	48 83 ec 10          	sub    $0x10,%rsp
  800420d3c1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420d3c5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	// Check that the user has permission to read memory [s, s+len).
	// Destroy the environment if not.

	// LAB 3: Your code here.
	user_mem_assert(curenv, (const void *)s, len, PTE_U );
  800420d3c9:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d3d0:	00 00 00 
  800420d3d3:	ff d0                	callq  *%rax
  800420d3d5:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d3dc:	00 00 00 
  800420d3df:	48 98                	cltq   
  800420d3e1:	48 c1 e0 03          	shl    $0x3,%rax
  800420d3e5:	48 89 c1             	mov    %rax,%rcx
  800420d3e8:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d3ec:	48 01 c8             	add    %rcx,%rax
  800420d3ef:	48 01 d0             	add    %rdx,%rax
  800420d3f2:	48 83 c0 08          	add    $0x8,%rax
  800420d3f6:	48 8b 00             	mov    (%rax),%rax
  800420d3f9:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d3fd:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420d401:	b9 04 00 00 00       	mov    $0x4,%ecx
  800420d406:	48 89 c7             	mov    %rax,%rdi
  800420d409:	48 b8 98 3e 20 04 80 	movabs $0x8004203e98,%rax
  800420d410:	00 00 00 
  800420d413:	ff d0                	callq  *%rax
	
	// Print the string supplied by the user.
	
	cprintf("%.*s", len, s);
  800420d415:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420d419:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d41d:	48 89 c6             	mov    %rax,%rsi
  800420d420:	48 bf 68 96 21 04 80 	movabs $0x8004219668,%rdi
  800420d427:	00 00 00 
  800420d42a:	b8 00 00 00 00       	mov    $0x0,%eax
  800420d42f:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  800420d436:	00 00 00 
  800420d439:	ff d1                	callq  *%rcx
}
  800420d43b:	c9                   	leaveq 
  800420d43c:	c3                   	retq   

000000800420d43d <sys_cgetc>:

// Read a character from the system console without blocking.
// Returns the character, or 0 if there is no input waiting.
static int
sys_cgetc(void)
{
  800420d43d:	55                   	push   %rbp
  800420d43e:	48 89 e5             	mov    %rsp,%rbp
	return cons_getc();
  800420d441:	48 b8 62 12 20 04 80 	movabs $0x8004201262,%rax
  800420d448:	00 00 00 
  800420d44b:	ff d0                	callq  *%rax
}
  800420d44d:	5d                   	pop    %rbp
  800420d44e:	c3                   	retq   

000000800420d44f <sys_getenvid>:

// Returns the current environment's envid.
static envid_t
sys_getenvid(void)
{
  800420d44f:	55                   	push   %rbp
  800420d450:	48 89 e5             	mov    %rsp,%rbp
	return curenv->env_id;
  800420d453:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d45a:	00 00 00 
  800420d45d:	ff d0                	callq  *%rax
  800420d45f:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d466:	00 00 00 
  800420d469:	48 98                	cltq   
  800420d46b:	48 c1 e0 03          	shl    $0x3,%rax
  800420d46f:	48 89 c1             	mov    %rax,%rcx
  800420d472:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d476:	48 01 c8             	add    %rcx,%rax
  800420d479:	48 01 d0             	add    %rdx,%rax
  800420d47c:	48 83 c0 08          	add    $0x8,%rax
  800420d480:	48 8b 00             	mov    (%rax),%rax
  800420d483:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
}
  800420d489:	5d                   	pop    %rbp
  800420d48a:	c3                   	retq   

000000800420d48b <sys_env_destroy>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_destroy(envid_t envid)
{
  800420d48b:	55                   	push   %rbp
  800420d48c:	48 89 e5             	mov    %rsp,%rbp
  800420d48f:	48 83 ec 20          	sub    $0x20,%rsp
  800420d493:	89 7d ec             	mov    %edi,-0x14(%rbp)
	int r;
	struct Env *e;

	if ((r = envid2env(envid, &e, 1)) < 0)
  800420d496:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d49a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d49d:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d4a2:	48 89 ce             	mov    %rcx,%rsi
  800420d4a5:	89 c7                	mov    %eax,%edi
  800420d4a7:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420d4ae:	00 00 00 
  800420d4b1:	ff d0                	callq  *%rax
  800420d4b3:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800420d4b6:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d4ba:	79 05                	jns    800420d4c1 <sys_env_destroy+0x36>
		return r;
  800420d4bc:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d4bf:	eb 18                	jmp    800420d4d9 <sys_env_destroy+0x4e>
	env_destroy(e);
  800420d4c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d4c5:	48 89 c7             	mov    %rax,%rdi
  800420d4c8:	48 b8 f1 86 20 04 80 	movabs $0x80042086f1,%rax
  800420d4cf:	00 00 00 
  800420d4d2:	ff d0                	callq  *%rax
	return 0;
  800420d4d4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420d4d9:	c9                   	leaveq 
  800420d4da:	c3                   	retq   

000000800420d4db <sys_yield>:

// Deschedule current environment and pick a different one to run.
static void
sys_yield(void)
{
  800420d4db:	55                   	push   %rbp
  800420d4dc:	48 89 e5             	mov    %rsp,%rbp
	sched_yield();
  800420d4df:	48 b8 3d d0 20 04 80 	movabs $0x800420d03d,%rax
  800420d4e6:	00 00 00 
  800420d4e9:	ff d0                	callq  *%rax

000000800420d4eb <sys_exofork>:
// Returns envid of new environment, or < 0 on error.  Errors are:
//	-E_NO_FREE_ENV if no free environment is available.
//	-E_NO_MEM on memory exhaustion.
static envid_t
sys_exofork(void)
{
  800420d4eb:	55                   	push   %rbp
  800420d4ec:	48 89 e5             	mov    %rsp,%rbp
  800420d4ef:	53                   	push   %rbx
  800420d4f0:	48 83 ec 18          	sub    $0x18,%rsp
	// from the current environment -- but tweaked so sys_exofork
	// will appear to return 0.

	// LAB 4: Your code here.
	struct Env *newenv_store;
	uint32_t  result = 0;
  800420d4f4:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
	result= env_alloc(&newenv_store, curenv->env_id);
  800420d4fb:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d502:	00 00 00 
  800420d505:	ff d0                	callq  *%rax
  800420d507:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d50e:	00 00 00 
  800420d511:	48 98                	cltq   
  800420d513:	48 c1 e0 03          	shl    $0x3,%rax
  800420d517:	48 89 c1             	mov    %rax,%rcx
  800420d51a:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d51e:	48 01 c8             	add    %rcx,%rax
  800420d521:	48 01 d0             	add    %rdx,%rax
  800420d524:	48 83 c0 08          	add    $0x8,%rax
  800420d528:	48 8b 00             	mov    (%rax),%rax
  800420d52b:	8b 90 c8 00 00 00    	mov    0xc8(%rax),%edx
  800420d531:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420d535:	89 d6                	mov    %edx,%esi
  800420d537:	48 89 c7             	mov    %rax,%rdi
  800420d53a:	48 b8 33 7d 20 04 80 	movabs $0x8004207d33,%rax
  800420d541:	00 00 00 
  800420d544:	ff d0                	callq  *%rax
  800420d546:	89 45 ec             	mov    %eax,-0x14(%rbp)

	if(result != 0)
  800420d549:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
  800420d54d:	74 05                	je     800420d554 <sys_exofork+0x69>
		return result;
  800420d54f:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d552:	eb 6c                	jmp    800420d5c0 <sys_exofork+0xd5>
	//cprintf("curenv->env_id [%d], newenv_store->env_parent_id [%d],  newenv_store->env_id [%d]\n",curenv->env_id, newenv_store->env_parent_id,newenv_store->env_id);

	newenv_store->env_status = ENV_NOT_RUNNABLE;
  800420d554:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d558:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420d55f:	00 00 00 
	newenv_store->env_tf = curenv->env_tf;
  800420d562:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  800420d566:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420d56d:	00 00 00 
  800420d570:	ff d0                	callq  *%rax
  800420d572:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420d579:	00 00 00 
  800420d57c:	48 98                	cltq   
  800420d57e:	48 c1 e0 03          	shl    $0x3,%rax
  800420d582:	48 89 c1             	mov    %rax,%rcx
  800420d585:	48 c1 e1 04          	shl    $0x4,%rcx
  800420d589:	48 01 c8             	add    %rcx,%rax
  800420d58c:	48 01 d0             	add    %rdx,%rax
  800420d58f:	48 83 c0 08          	add    $0x8,%rax
  800420d593:	48 8b 00             	mov    (%rax),%rax
  800420d596:	48 89 da             	mov    %rbx,%rdx
  800420d599:	48 89 c6             	mov    %rax,%rsi
  800420d59c:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d5a1:	48 89 d7             	mov    %rdx,%rdi
  800420d5a4:	48 89 c1             	mov    %rax,%rcx
  800420d5a7:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
	newenv_store->env_tf.tf_regs.reg_rax = 0x00;
  800420d5aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d5ae:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420d5b5:	00 
	return newenv_store->env_id;
  800420d5b6:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d5ba:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax

	//panic("sys_exofork not implemented");
}
  800420d5c0:	48 83 c4 18          	add    $0x18,%rsp
  800420d5c4:	5b                   	pop    %rbx
  800420d5c5:	5d                   	pop    %rbp
  800420d5c6:	c3                   	retq   

000000800420d5c7 <sys_env_set_status>:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if status is not a valid status for an environment.
static int
sys_env_set_status(envid_t envid, int status)
{
  800420d5c7:	55                   	push   %rbp
  800420d5c8:	48 89 e5             	mov    %rsp,%rbp
  800420d5cb:	48 83 ec 20          	sub    $0x20,%rsp
  800420d5cf:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d5d2:	89 75 e8             	mov    %esi,-0x18(%rbp)
	// You should set envid2env's third argument to 1, which will
	// check whether the current environment has permission to set
	// envid's status.

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420d5d5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420d5dc:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d5e0:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d5e3:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d5e8:	48 89 ce             	mov    %rcx,%rsi
  800420d5eb:	89 c7                	mov    %eax,%edi
  800420d5ed:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420d5f4:	00 00 00 
  800420d5f7:	ff d0                	callq  *%rax
  800420d5f9:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d5fc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d600:	74 05                	je     800420d607 <sys_env_set_status+0x40>
		return result;
  800420d602:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d605:	eb 23                	jmp    800420d62a <sys_env_set_status+0x63>
	if(status< 0 || status >4)
  800420d607:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800420d60b:	78 06                	js     800420d613 <sys_env_set_status+0x4c>
  800420d60d:	83 7d e8 04          	cmpl   $0x4,-0x18(%rbp)
  800420d611:	7e 07                	jle    800420d61a <sys_env_set_status+0x53>
		return -E_INVAL;
  800420d613:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d618:	eb 10                	jmp    800420d62a <sys_env_set_status+0x63>
	
	env_store->env_status = status;
  800420d61a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d61e:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800420d621:	89 90 d4 00 00 00    	mov    %edx,0xd4(%rax)
	return result;
  800420d627:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_env_set_status not implemented");
}
  800420d62a:	c9                   	leaveq 
  800420d62b:	c3                   	retq   

000000800420d62c <sys_env_set_trapframe>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
	{
  800420d62c:	55                   	push   %rbp
  800420d62d:	48 89 e5             	mov    %rsp,%rbp
  800420d630:	48 83 ec 20          	sub    $0x20,%rsp
  800420d634:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d637:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
		// LAB 5: Your code here.
		// Remember to check whether the user has supplied us with a good
		// address!
		//panic("sys_env_set_trapframe not implemented");
		uint32_t  result = 0;
  800420d63b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
		struct Env *env_store;
		if(!tf)
  800420d642:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420d647:	75 07                	jne    800420d650 <sys_env_set_trapframe+0x24>
			return -E_BAD_ENV;
  800420d649:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d64e:	eb 73                	jmp    800420d6c3 <sys_env_set_trapframe+0x97>
		result = envid2env(envid,&env_store,1);
  800420d650:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d654:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d657:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d65c:	48 89 ce             	mov    %rcx,%rsi
  800420d65f:	89 c7                	mov    %eax,%edi
  800420d661:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420d668:	00 00 00 
  800420d66b:	ff d0                	callq  *%rax
  800420d66d:	89 45 fc             	mov    %eax,-0x4(%rbp)
		if(result < 0)
			return result;
		//user_mem_assert(env_store, tf, sizeof(struct Trapframe), PTE_U|PTE_P);
		tf->tf_cs |= 0x3;
  800420d670:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d674:	0f b7 80 a0 00 00 00 	movzwl 0xa0(%rax),%eax
  800420d67b:	83 c8 03             	or     $0x3,%eax
  800420d67e:	89 c2                	mov    %eax,%edx
  800420d680:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d684:	66 89 90 a0 00 00 00 	mov    %dx,0xa0(%rax)
		tf->tf_eflags |= FL_IF;
  800420d68b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d68f:	48 8b 80 a8 00 00 00 	mov    0xa8(%rax),%rax
  800420d696:	80 cc 02             	or     $0x2,%ah
  800420d699:	48 89 c2             	mov    %rax,%rdx
  800420d69c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d6a0:	48 89 90 a8 00 00 00 	mov    %rdx,0xa8(%rax)
		env_store->env_tf = *tf;
  800420d6a7:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420d6ab:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d6af:	48 89 c6             	mov    %rax,%rsi
  800420d6b2:	b8 18 00 00 00       	mov    $0x18,%eax
  800420d6b7:	48 89 d7             	mov    %rdx,%rdi
  800420d6ba:	48 89 c1             	mov    %rax,%rcx
  800420d6bd:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		return result;
  800420d6c0:	8b 45 fc             	mov    -0x4(%rbp),%eax
	}
  800420d6c3:	c9                   	leaveq 
  800420d6c4:	c3                   	retq   

000000800420d6c5 <sys_env_set_pgfault_upcall>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int
sys_env_set_pgfault_upcall(envid_t envid, void *func)
{
  800420d6c5:	55                   	push   %rbp
  800420d6c6:	48 89 e5             	mov    %rsp,%rbp
  800420d6c9:	48 83 ec 20          	sub    $0x20,%rsp
  800420d6cd:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d6d0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// LAB 4: Your code here.
	
	uint32_t  result =0;
  800420d6d4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	result = envid2env(envid,&env_store,1);
  800420d6db:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  800420d6df:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d6e2:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d6e7:	48 89 ce             	mov    %rcx,%rsi
  800420d6ea:	89 c7                	mov    %eax,%edi
  800420d6ec:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420d6f3:	00 00 00 
  800420d6f6:	ff d0                	callq  *%rax
  800420d6f8:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d6fb:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d6ff:	74 05                	je     800420d706 <sys_env_set_pgfault_upcall+0x41>
		return result;
  800420d701:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d704:	eb 14                	jmp    800420d71a <sys_env_set_pgfault_upcall+0x55>

	env_store->env_pgfault_upcall = func;
  800420d706:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420d70a:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d70e:	48 89 90 f0 00 00 00 	mov    %rdx,0xf0(%rax)
	return 0;
  800420d715:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_env_set_pgfault_upcall not implemented");
}
  800420d71a:	c9                   	leaveq 
  800420d71b:	c3                   	retq   

000000800420d71c <sys_page_alloc>:
//	-E_INVAL if perm is inappropriate (see above).
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  800420d71c:	55                   	push   %rbp
  800420d71d:	48 89 e5             	mov    %rsp,%rbp
  800420d720:	48 83 ec 30          	sub    $0x30,%rsp
  800420d724:	89 7d dc             	mov    %edi,-0x24(%rbp)
  800420d727:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420d72b:	89 55 d8             	mov    %edx,-0x28(%rbp)
	//   parameters for correctness.
	//   If page_insert() fails, remember to free the page you
	//   allocated!

	// LAB 4: Your code here.
	uint32_t  result =0;
  800420d72e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store;
	struct PageInfo * pp;
	pte_t *pte_store;
	//cprintf("sys page alloc [%d]",result);
	result = envid2env(envid,&env_store,1);
  800420d735:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420d739:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420d73c:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d741:	48 89 ce             	mov    %rcx,%rsi
  800420d744:	89 c7                	mov    %eax,%edi
  800420d746:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420d74d:	00 00 00 
  800420d750:	ff d0                	callq  *%rax
  800420d752:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0)
  800420d755:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d759:	74 08                	je     800420d763 <sys_page_alloc+0x47>
		return result;
  800420d75b:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d75e:	e9 a2 00 00 00       	jmpq   800420d805 <sys_page_alloc+0xe9>

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420d763:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d766:	83 e0 04             	and    $0x4,%eax
  800420d769:	85 c0                	test   %eax,%eax
  800420d76b:	74 16                	je     800420d783 <sys_page_alloc+0x67>
  800420d76d:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d770:	83 e0 01             	and    $0x1,%eax
  800420d773:	85 c0                	test   %eax,%eax
  800420d775:	74 0c                	je     800420d783 <sys_page_alloc+0x67>
  800420d777:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d77a:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420d77f:	85 c0                	test   %eax,%eax
  800420d781:	74 07                	je     800420d78a <sys_page_alloc+0x6e>
		return -E_INVAL;
  800420d783:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d788:	eb 7b                	jmp    800420d805 <sys_page_alloc+0xe9>

	if(((uint64_t)va%PGSIZE !=0) ||((uint64_t)va> UTOP))
  800420d78a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420d78e:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d793:	48 85 c0             	test   %rax,%rax
  800420d796:	75 13                	jne    800420d7ab <sys_page_alloc+0x8f>
  800420d798:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d79c:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d7a3:	00 00 00 
  800420d7a6:	48 39 c2             	cmp    %rax,%rdx
  800420d7a9:	76 07                	jbe    800420d7b2 <sys_page_alloc+0x96>
		return -E_INVAL;
  800420d7ab:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d7b0:	eb 53                	jmp    800420d805 <sys_page_alloc+0xe9>
	
    pp = page_alloc(0);
  800420d7b2:	bf 00 00 00 00       	mov    $0x0,%edi
  800420d7b7:	48 b8 95 30 20 04 80 	movabs $0x8004203095,%rax
  800420d7be:	00 00 00 
  800420d7c1:	ff d0                	callq  *%rax
  800420d7c3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(!pp)
  800420d7c7:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d7cc:	75 07                	jne    800420d7d5 <sys_page_alloc+0xb9>
		return -E_NO_MEM;
  800420d7ce:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420d7d3:	eb 30                	jmp    800420d805 <sys_page_alloc+0xe9>
	

	result = page_insert(env_store->env_pml4e,pp,va,perm|PTE_P);
  800420d7d5:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420d7d8:	83 c8 01             	or     $0x1,%eax
  800420d7db:	89 c1                	mov    %eax,%ecx
  800420d7dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d7e1:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d7e8:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420d7ec:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420d7f0:	48 89 c7             	mov    %rax,%rdi
  800420d7f3:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  800420d7fa:	00 00 00 
  800420d7fd:	ff d0                	callq  *%rax
  800420d7ff:	89 45 fc             	mov    %eax,-0x4(%rbp)
	//cprintf("sys page alloc [%d]",result);
	return result;
  800420d802:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_alloc not implemented");
}
  800420d805:	c9                   	leaveq 
  800420d806:	c3                   	retq   

000000800420d807 <sys_page_map>:
//		address space.
//	-E_NO_MEM if there's no memory to allocate any necessary page tables.
static int
sys_page_map(envid_t srcenvid, void *srcva,
	     envid_t dstenvid, void *dstva, int perm)
{
  800420d807:	55                   	push   %rbp
  800420d808:	48 89 e5             	mov    %rsp,%rbp
  800420d80b:	48 83 ec 50          	sub    $0x50,%rsp
  800420d80f:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420d812:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800420d816:	89 55 c8             	mov    %edx,-0x38(%rbp)
  800420d819:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  800420d81d:	44 89 45 b4          	mov    %r8d,-0x4c(%rbp)
	//   check the current permissions on the page.

	// LAB 4: Your code here.

	
	uint32_t  result =0;
  800420d821:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct Env *env_store_src;
	struct Env *env_store_dst;
	struct PageInfo * pp;
	pte_t *pte_store;
	result = envid2env(srcenvid,&env_store_src,1);
  800420d828:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420d82c:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420d82f:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d834:	48 89 ce             	mov    %rcx,%rsi
  800420d837:	89 c7                	mov    %eax,%edi
  800420d839:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420d840:	00 00 00 
  800420d843:	ff d0                	callq  *%rax
  800420d845:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if(result != 0){
  800420d848:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d84c:	74 08                	je     800420d856 <sys_page_map+0x4f>
		//cprintf("need 1stcheckperm to be 0\n");
		return result;
  800420d84e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d851:	e9 1c 01 00 00       	jmpq   800420d972 <sys_page_map+0x16b>
	}
	result = envid2env(dstenvid,&env_store_dst,0);
  800420d856:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
  800420d85a:	8b 45 c8             	mov    -0x38(%rbp),%eax
  800420d85d:	ba 00 00 00 00       	mov    $0x0,%edx
  800420d862:	48 89 ce             	mov    %rcx,%rsi
  800420d865:	89 c7                	mov    %eax,%edi
  800420d867:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420d86e:	00 00 00 
  800420d871:	ff d0                	callq  *%rax
  800420d873:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if(result != 0){
  800420d876:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420d87a:	74 08                	je     800420d884 <sys_page_map+0x7d>
		//cprintf("need 2ndcheckperm to be 0\n");
		return result;
  800420d87c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420d87f:	e9 ee 00 00 00       	jmpq   800420d972 <sys_page_map+0x16b>
	}

	if(!(perm & PTE_U) || !(perm & PTE_P) || (perm & ~PTE_SYSCALL))
  800420d884:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d887:	83 e0 04             	and    $0x4,%eax
  800420d88a:	85 c0                	test   %eax,%eax
  800420d88c:	74 16                	je     800420d8a4 <sys_page_map+0x9d>
  800420d88e:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d891:	83 e0 01             	and    $0x1,%eax
  800420d894:	85 c0                	test   %eax,%eax
  800420d896:	74 0c                	je     800420d8a4 <sys_page_map+0x9d>
  800420d898:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d89b:	25 f8 f1 ff ff       	and    $0xfffff1f8,%eax
  800420d8a0:	85 c0                	test   %eax,%eax
  800420d8a2:	74 0a                	je     800420d8ae <sys_page_map+0xa7>
		return -E_INVAL;
  800420d8a4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d8a9:	e9 c4 00 00 00       	jmpq   800420d972 <sys_page_map+0x16b>

	
	if(((uint64_t)dstva%PGSIZE !=0 || (uint64_t)dstva> UTOP)||((uint64_t)srcva%PGSIZE !=0 || (uint64_t)srcva> UTOP))
  800420d8ae:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800420d8b2:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d8b7:	48 85 c0             	test   %rax,%rax
  800420d8ba:	75 34                	jne    800420d8f0 <sys_page_map+0xe9>
  800420d8bc:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d8c0:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d8c7:	00 00 00 
  800420d8ca:	48 39 c2             	cmp    %rax,%rdx
  800420d8cd:	77 21                	ja     800420d8f0 <sys_page_map+0xe9>
  800420d8cf:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420d8d3:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d8d8:	48 85 c0             	test   %rax,%rax
  800420d8db:	75 13                	jne    800420d8f0 <sys_page_map+0xe9>
  800420d8dd:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420d8e1:	48 b8 00 00 80 00 80 	movabs $0x8000800000,%rax
  800420d8e8:	00 00 00 
  800420d8eb:	48 39 c2             	cmp    %rax,%rdx
  800420d8ee:	76 07                	jbe    800420d8f7 <sys_page_map+0xf0>
		return -E_INVAL;
  800420d8f0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d8f5:	eb 7b                	jmp    800420d972 <sys_page_map+0x16b>
	pp = page_lookup(env_store_src->env_pml4e, srcva, &pte_store);
  800420d8f7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420d8fb:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d902:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420d906:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420d90a:	48 89 ce             	mov    %rcx,%rsi
  800420d90d:	48 89 c7             	mov    %rax,%rdi
  800420d910:	48 b8 7e 3a 20 04 80 	movabs $0x8004203a7e,%rax
  800420d917:	00 00 00 
  800420d91a:	ff d0                	callq  *%rax
  800420d91c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if(NULL == pp || (((*(pte_store) & PTE_W) == 0) && ((perm & PTE_W) != 0)))
  800420d920:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
  800420d925:	74 19                	je     800420d940 <sys_page_map+0x139>
  800420d927:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420d92b:	48 8b 00             	mov    (%rax),%rax
  800420d92e:	83 e0 02             	and    $0x2,%eax
  800420d931:	48 85 c0             	test   %rax,%rax
  800420d934:	75 11                	jne    800420d947 <sys_page_map+0x140>
  800420d936:	8b 45 b4             	mov    -0x4c(%rbp),%eax
  800420d939:	83 e0 02             	and    $0x2,%eax
  800420d93c:	85 c0                	test   %eax,%eax
  800420d93e:	74 07                	je     800420d947 <sys_page_map+0x140>
		return -E_INVAL;	
  800420d940:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d945:	eb 2b                	jmp    800420d972 <sys_page_map+0x16b>

	
	result = page_insert(env_store_dst->env_pml4e,pp,dstva,perm);
  800420d947:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d94b:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d952:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
  800420d955:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420d959:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800420d95d:	48 89 c7             	mov    %rax,%rdi
  800420d960:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  800420d967:	00 00 00 
  800420d96a:	ff d0                	callq  *%rax
  800420d96c:	89 45 fc             	mov    %eax,-0x4(%rbp)
	
	return result;
  800420d96f:	8b 45 fc             	mov    -0x4(%rbp),%eax
	//panic("sys_page_map not implemented");
}
  800420d972:	c9                   	leaveq 
  800420d973:	c3                   	retq   

000000800420d974 <sys_page_unmap>:
//		or the caller doesn't have permission to change envid.
//	-E_INVAL if va >= UTOP, or va is not page-aligned.

static int
sys_page_unmap(envid_t envid, void *va)
{
  800420d974:	55                   	push   %rbp
  800420d975:	48 89 e5             	mov    %rsp,%rbp
  800420d978:	48 83 ec 20          	sub    $0x20,%rsp
  800420d97c:	89 7d ec             	mov    %edi,-0x14(%rbp)
  800420d97f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	// Hint: This function is a wrapper around page_remove().
	
	// LAB 4: Your code here.
	struct Env* env;
	if(envid2env(envid, &env,1) != 0)
  800420d983:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  800420d987:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420d98a:	ba 01 00 00 00       	mov    $0x1,%edx
  800420d98f:	48 89 ce             	mov    %rcx,%rsi
  800420d992:	89 c7                	mov    %eax,%edi
  800420d994:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420d99b:	00 00 00 
  800420d99e:	ff d0                	callq  *%rax
  800420d9a0:	85 c0                	test   %eax,%eax
  800420d9a2:	74 07                	je     800420d9ab <sys_page_unmap+0x37>
	{
		return -E_BAD_ENV;
  800420d9a4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420d9a9:	eb 55                	jmp    800420da00 <sys_page_unmap+0x8c>
	}
	if(va == NULL || (uint64_t)va >= UTOP || (uint64_t)va  % PGSIZE != 0)
  800420d9ab:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420d9b0:	74 21                	je     800420d9d3 <sys_page_unmap+0x5f>
  800420d9b2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d9b6:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420d9bd:	00 00 00 
  800420d9c0:	48 39 c2             	cmp    %rax,%rdx
  800420d9c3:	77 0e                	ja     800420d9d3 <sys_page_unmap+0x5f>
  800420d9c5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420d9c9:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420d9ce:	48 85 c0             	test   %rax,%rax
  800420d9d1:	74 07                	je     800420d9da <sys_page_unmap+0x66>
	{
		return -E_INVAL;
  800420d9d3:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420d9d8:	eb 26                	jmp    800420da00 <sys_page_unmap+0x8c>
	}
	page_remove(env->env_pml4e, va);
  800420d9da:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420d9de:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420d9e5:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420d9e9:	48 89 d6             	mov    %rdx,%rsi
  800420d9ec:	48 89 c7             	mov    %rax,%rdi
  800420d9ef:	48 b8 18 3b 20 04 80 	movabs $0x8004203b18,%rax
  800420d9f6:	00 00 00 
  800420d9f9:	ff d0                	callq  *%rax
	return 0;
  800420d9fb:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_page_unmap not implemented");
}
  800420da00:	c9                   	leaveq 
  800420da01:	c3                   	retq   

000000800420da02 <sys_ipc_try_send>:
//		current environment's address space.
//	-E_NO_MEM if there's not enough memory to map srcva in envid's
//		address space.
static int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)
{
  800420da02:	55                   	push   %rbp
  800420da03:	48 89 e5             	mov    %rsp,%rbp
  800420da06:	48 83 ec 50          	sub    $0x50,%rsp
  800420da0a:	89 7d cc             	mov    %edi,-0x34(%rbp)
  800420da0d:	89 75 c8             	mov    %esi,-0x38(%rbp)
  800420da10:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420da14:	89 4d bc             	mov    %ecx,-0x44(%rbp)
	// LAB 4: Your code here.
	struct Env* dstenv;
	struct Env* srcenv;
	pte_t* pte_store;
	int srcperm , result;
	struct PageInfo *pp = NULL;
  800420da17:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420da1e:	00 
	perm|= PTE_P;
  800420da1f:	83 4d bc 01          	orl    $0x1,-0x44(%rbp)
	if(envid2env(envid, &dstenv,0) != 0)
  800420da23:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420da27:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420da2a:	ba 00 00 00 00       	mov    $0x0,%edx
  800420da2f:	48 89 ce             	mov    %rcx,%rsi
  800420da32:	89 c7                	mov    %eax,%edi
  800420da34:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420da3b:	00 00 00 
  800420da3e:	ff d0                	callq  *%rax
  800420da40:	85 c0                	test   %eax,%eax
  800420da42:	74 0a                	je     800420da4e <sys_ipc_try_send+0x4c>
		return -E_BAD_ENV;
  800420da44:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420da49:	e9 2e 02 00 00       	jmpq   800420dc7c <sys_ipc_try_send+0x27a>

	if(envid2env(0, &srcenv,0) != 0)
  800420da4e:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800420da52:	ba 00 00 00 00       	mov    $0x0,%edx
  800420da57:	48 89 c6             	mov    %rax,%rsi
  800420da5a:	bf 00 00 00 00       	mov    $0x0,%edi
  800420da5f:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420da66:	00 00 00 
  800420da69:	ff d0                	callq  *%rax
  800420da6b:	85 c0                	test   %eax,%eax
  800420da6d:	74 0a                	je     800420da79 <sys_ipc_try_send+0x77>
		return -E_BAD_ENV;
  800420da6f:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420da74:	e9 03 02 00 00       	jmpq   800420dc7c <sys_ipc_try_send+0x27a>
	
	if(!dstenv->env_ipc_recving)
  800420da79:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420da7d:	0f b6 80 f8 00 00 00 	movzbl 0xf8(%rax),%eax
  800420da84:	83 f0 01             	xor    $0x1,%eax
  800420da87:	84 c0                	test   %al,%al
  800420da89:	74 0a                	je     800420da95 <sys_ipc_try_send+0x93>
		return -E_IPC_NOT_RECV;
  800420da8b:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  800420da90:	e9 e7 01 00 00       	jmpq   800420dc7c <sys_ipc_try_send+0x27a>
//#ifndef VMM_GUEST
		pp =page_lookup(srcenv->env_pml4e,srcva,&pte_store); 
  800420da95:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420da99:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420daa0:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
  800420daa4:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  800420daa8:	48 89 ce             	mov    %rcx,%rsi
  800420daab:	48 89 c7             	mov    %rax,%rdi
  800420daae:	48 b8 7e 3a 20 04 80 	movabs $0x8004203a7e,%rax
  800420dab5:	00 00 00 
  800420dab8:	ff d0                	callq  *%rax
  800420daba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if(!pp)
  800420dabe:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800420dac3:	75 1a                	jne    800420dadf <sys_ipc_try_send+0xdd>
			if(srcva <(void*)UTOP)
  800420dac5:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dacc:	00 00 00 
  800420dacf:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420dad3:	77 0a                	ja     800420dadf <sys_ipc_try_send+0xdd>
				return -E_INVAL;
  800420dad5:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dada:	e9 9d 01 00 00       	jmpq   800420dc7c <sys_ipc_try_send+0x27a>
//#else
		;;//result = ept_lookup_gpa(srcenv->env_pml4e, srcva,0,&pte_store);

//#endif
	srcperm = *pte_store&PTE_SYSCALL;
  800420dadf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dae3:	48 8b 00             	mov    (%rax),%rax
  800420dae6:	25 07 0e 00 00       	and    $0xe07,%eax
  800420daeb:	89 45 f4             	mov    %eax,-0xc(%rbp)
	if(srcva <(void*)UTOP)
  800420daee:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420daf5:	00 00 00 
  800420daf8:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420dafc:	77 23                	ja     800420db21 <sys_ipc_try_send+0x11f>
		if((((uint64_t)srcva)%PGSIZE!=0) || ((srcperm & (PTE_U | PTE_P))!=(PTE_U | PTE_P)))
  800420dafe:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420db02:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420db07:	48 85 c0             	test   %rax,%rax
  800420db0a:	75 0b                	jne    800420db17 <sys_ipc_try_send+0x115>
  800420db0c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420db0f:	83 e0 05             	and    $0x5,%eax
  800420db12:	83 f8 05             	cmp    $0x5,%eax
  800420db15:	74 0a                	je     800420db21 <sys_ipc_try_send+0x11f>
			return -E_INVAL;
  800420db17:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420db1c:	e9 5b 01 00 00       	jmpq   800420dc7c <sys_ipc_try_send+0x27a>
	if((srcva <(void*)UTOP) && ((perm & PTE_W) !=0) &&(((srcperm& PTE_W) == 0)))
  800420db21:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420db28:	00 00 00 
  800420db2b:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420db2f:	77 1e                	ja     800420db4f <sys_ipc_try_send+0x14d>
  800420db31:	8b 45 bc             	mov    -0x44(%rbp),%eax
  800420db34:	83 e0 02             	and    $0x2,%eax
  800420db37:	85 c0                	test   %eax,%eax
  800420db39:	74 14                	je     800420db4f <sys_ipc_try_send+0x14d>
  800420db3b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420db3e:	83 e0 02             	and    $0x2,%eax
  800420db41:	85 c0                	test   %eax,%eax
  800420db43:	75 0a                	jne    800420db4f <sys_ipc_try_send+0x14d>
		return -E_INVAL;
  800420db45:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420db4a:	e9 2d 01 00 00       	jmpq   800420dc7c <sys_ipc_try_send+0x27a>

	if(envid == curenv->env_id)
  800420db4f:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420db56:	00 00 00 
  800420db59:	ff d0                	callq  *%rax
  800420db5b:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420db62:	00 00 00 
  800420db65:	48 98                	cltq   
  800420db67:	48 c1 e0 03          	shl    $0x3,%rax
  800420db6b:	48 89 c1             	mov    %rax,%rcx
  800420db6e:	48 c1 e1 04          	shl    $0x4,%rcx
  800420db72:	48 01 c8             	add    %rcx,%rax
  800420db75:	48 01 d0             	add    %rdx,%rax
  800420db78:	48 83 c0 08          	add    $0x8,%rax
  800420db7c:	48 8b 00             	mov    (%rax),%rax
  800420db7f:	8b 80 c8 00 00 00    	mov    0xc8(%rax),%eax
  800420db85:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420db88:	75 2a                	jne    800420dbb4 <sys_ipc_try_send+0x1b2>
		panic("what the hell. how can this be????");
  800420db8a:	48 ba 70 96 21 04 80 	movabs $0x8004219670,%rdx
  800420db91:	00 00 00 
  800420db94:	be 9b 01 00 00       	mov    $0x19b,%esi
  800420db99:	48 bf 93 96 21 04 80 	movabs $0x8004219693,%rdi
  800420dba0:	00 00 00 
  800420dba3:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dba8:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  800420dbaf:	00 00 00 
  800420dbb2:	ff d1                	callq  *%rcx

	dstenv->env_ipc_recving = 0;
  800420dbb4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dbb8:	c6 80 f8 00 00 00 00 	movb   $0x0,0xf8(%rax)
	dstenv->env_ipc_from = srcenv->env_id;
  800420dbbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dbc3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420dbc7:	8b 92 c8 00 00 00    	mov    0xc8(%rdx),%edx
  800420dbcd:	89 90 0c 01 00 00    	mov    %edx,0x10c(%rax)
	dstenv->env_ipc_value = value;
  800420dbd3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dbd7:	8b 55 c8             	mov    -0x38(%rbp),%edx
  800420dbda:	89 90 08 01 00 00    	mov    %edx,0x108(%rax)
	//cprintf("dstenv -> envID is:[%d]\n",dstenv->env_id);
	if(srcva <(void*)UTOP && dstenv->env_ipc_dstva <(void*)UTOP){
  800420dbe0:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dbe7:	00 00 00 
  800420dbea:	48 39 45 c0          	cmp    %rax,-0x40(%rbp)
  800420dbee:	77 79                	ja     800420dc69 <sys_ipc_try_send+0x267>
  800420dbf0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dbf4:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420dbfb:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dc02:	00 00 00 
  800420dc05:	48 39 c2             	cmp    %rax,%rdx
  800420dc08:	77 5f                	ja     800420dc69 <sys_ipc_try_send+0x267>
		dstenv->env_ipc_perm = perm;
  800420dc0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc0e:	8b 55 bc             	mov    -0x44(%rbp),%edx
  800420dc11:	89 90 10 01 00 00    	mov    %edx,0x110(%rax)
#ifndef VMM_GUEST
				// guest OS related changes : Lab7-ex7
				if ( curenv->env_type != ENV_TYPE_GUEST) {
#endif
					if(page_insert(dstenv->env_pml4e, pp, dstenv->env_ipc_dstva , perm) < 0) {
  800420dc17:	8b 4d bc             	mov    -0x44(%rbp),%ecx
  800420dc1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc1e:	48 8b 90 00 01 00 00 	mov    0x100(%rax),%rdx
  800420dc25:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc29:	48 8b 80 e0 00 00 00 	mov    0xe0(%rax),%rax
  800420dc30:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  800420dc34:	48 89 c7             	mov    %rax,%rdi
  800420dc37:	48 b8 21 39 20 04 80 	movabs $0x8004203921,%rax
  800420dc3e:	00 00 00 
  800420dc41:	ff d0                	callq  *%rax
  800420dc43:	85 c0                	test   %eax,%eax
  800420dc45:	79 22                	jns    800420dc69 <sys_ipc_try_send+0x267>
						cprintf("\n No memory to map the page to target env\n");
  800420dc47:	48 bf a8 96 21 04 80 	movabs $0x80042196a8,%rdi
  800420dc4e:	00 00 00 
  800420dc51:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dc56:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420dc5d:	00 00 00 
  800420dc60:	ff d2                	callq  *%rdx
						return -E_NO_MEM;
  800420dc62:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  800420dc67:	eb 13                	jmp    800420dc7c <sys_ipc_try_send+0x27a>
								}
				}
#endif

	}
	dstenv->env_status = ENV_RUNNABLE;
  800420dc69:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dc6d:	c7 80 d4 00 00 00 02 	movl   $0x2,0xd4(%rax)
  800420dc74:	00 00 00 
	return 0;
  800420dc77:	b8 00 00 00 00       	mov    $0x0,%eax
	//panic("sys_ipc_try_send not implemented");
}
  800420dc7c:	c9                   	leaveq 
  800420dc7d:	c3                   	retq   

000000800420dc7e <sys_ipc_recv>:
// return 0 on success.
// Return < 0 on error.  Errors are:

static int
sys_ipc_recv(void *dstva)
{
  800420dc7e:	55                   	push   %rbp
  800420dc7f:	48 89 e5             	mov    %rsp,%rbp
  800420dc82:	48 83 ec 20          	sub    $0x20,%rsp
  800420dc86:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	// LAB 4: Your code here.
	struct Env* env;
	void *addr;
	addr = 0 ;
  800420dc8a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420dc91:	00 
	if(envid2env(0, &env,0) != 0)
  800420dc92:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
  800420dc96:	ba 00 00 00 00       	mov    $0x0,%edx
  800420dc9b:	48 89 c6             	mov    %rax,%rsi
  800420dc9e:	bf 00 00 00 00       	mov    $0x0,%edi
  800420dca3:	48 b8 be 79 20 04 80 	movabs $0x80042079be,%rax
  800420dcaa:	00 00 00 
  800420dcad:	ff d0                	callq  *%rax
  800420dcaf:	85 c0                	test   %eax,%eax
  800420dcb1:	74 07                	je     800420dcba <sys_ipc_recv+0x3c>
	{
		return -E_BAD_ENV;
  800420dcb3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  800420dcb8:	eb 7a                	jmp    800420dd34 <sys_ipc_recv+0xb6>
	}
	if(dstva <(void*)UTOP && (uint64_t)dstva%PGSIZE!=0)
  800420dcba:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dcc1:	00 00 00 
  800420dcc4:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420dcc8:	77 15                	ja     800420dcdf <sys_ipc_recv+0x61>
  800420dcca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dcce:	25 ff 0f 00 00       	and    $0xfff,%eax
  800420dcd3:	48 85 c0             	test   %rax,%rax
  800420dcd6:	74 07                	je     800420dcdf <sys_ipc_recv+0x61>
		return -E_INVAL;
  800420dcd8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420dcdd:	eb 55                	jmp    800420dd34 <sys_ipc_recv+0xb6>
	if(dstva <(void*)UTOP)
  800420dcdf:	48 b8 ff ff 7f 00 80 	movabs $0x80007fffff,%rax
  800420dce6:	00 00 00 
  800420dce9:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  800420dced:	77 0f                	ja     800420dcfe <sys_ipc_recv+0x80>
		env->env_ipc_dstva = dstva;
  800420dcef:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dcf3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420dcf7:	48 89 90 00 01 00 00 	mov    %rdx,0x100(%rax)

	env->env_ipc_recving = 1;
  800420dcfe:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd02:	c6 80 f8 00 00 00 01 	movb   $0x1,0xf8(%rax)
	}
	else
		curenv->env_ipc_dstva = dstva;	
#endif

	env->env_status = ENV_NOT_RUNNABLE;
  800420dd09:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd0d:	c7 80 d4 00 00 00 04 	movl   $0x4,0xd4(%rax)
  800420dd14:	00 00 00 
	env->env_tf.tf_regs.reg_rax = 0;
  800420dd17:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420dd1b:	48 c7 40 70 00 00 00 	movq   $0x0,0x70(%rax)
  800420dd22:	00 
	sys_yield();
  800420dd23:	48 b8 db d4 20 04 80 	movabs $0x800420d4db,%rax
  800420dd2a:	00 00 00 
  800420dd2d:	ff d0                	callq  *%rax
	
	//panic("sys_ipc_recv not implemented");
	return 0;
  800420dd2f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420dd34:	c9                   	leaveq 
  800420dd35:	c3                   	retq   

000000800420dd36 <sys_time_msec>:


static int
sys_time_msec(void)
{
  800420dd36:	55                   	push   %rbp
  800420dd37:	48 89 e5             	mov    %rsp,%rbp
	// LAB 6: Your code here.
	panic("sys_time_msec not implemented");
  800420dd3a:	48 ba d3 96 21 04 80 	movabs $0x80042196d3,%rdx
  800420dd41:	00 00 00 
  800420dd44:	be ed 01 00 00       	mov    $0x1ed,%esi
  800420dd49:	48 bf 93 96 21 04 80 	movabs $0x8004219693,%rdi
  800420dd50:	00 00 00 
  800420dd53:	b8 00 00 00 00       	mov    $0x0,%eax
  800420dd58:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  800420dd5f:	00 00 00 
  800420dd62:	ff d1                	callq  *%rcx

000000800420dd64 <syscall>:


// Dispatches to the correct kernel function, passing the arguments.
int64_t
syscall(uint64_t syscallno, uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  800420dd64:	55                   	push   %rbp
  800420dd65:	48 89 e5             	mov    %rsp,%rbp
  800420dd68:	48 83 ec 40          	sub    $0x40,%rsp
  800420dd6c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420dd70:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420dd74:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420dd78:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  800420dd7c:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  800420dd80:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	// LAB 3: Your code here.

	//panic("syscall not implemented");
	int64_t result = -E_NO_SYS;
  800420dd84:	48 c7 45 f8 f9 ff ff 	movq   $0xfffffffffffffff9,-0x8(%rbp)
  800420dd8b:	ff 

	switch (syscallno) {
  800420dd8c:	48 83 7d e8 0e       	cmpq   $0xe,-0x18(%rbp)
  800420dd91:	0f 87 dd 01 00 00    	ja     800420df74 <syscall+0x210>
  800420dd97:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420dd9b:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420dda2:	00 
  800420dda3:	48 b8 f8 96 21 04 80 	movabs $0x80042196f8,%rax
  800420ddaa:	00 00 00 
  800420ddad:	48 01 d0             	add    %rdx,%rax
  800420ddb0:	48 8b 00             	mov    (%rax),%rax
  800420ddb3:	ff e0                	jmpq   *%rax
		sys_vmx_incr_vmdisk_number();
		return 0;
#endif
		
		case SYS_cputs:
			sys_cputs((const char *)a1, a2);
  800420ddb5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ddb9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420ddbd:	48 89 d6             	mov    %rdx,%rsi
  800420ddc0:	48 89 c7             	mov    %rax,%rdi
  800420ddc3:	48 b8 b9 d3 20 04 80 	movabs $0x800420d3b9,%rax
  800420ddca:	00 00 00 
  800420ddcd:	ff d0                	callq  *%rax
			result = 0;
  800420ddcf:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ddd6:	00 
			break;
  800420ddd7:	e9 a1 01 00 00       	jmpq   800420df7d <syscall+0x219>
		case SYS_cgetc:
			result = sys_cgetc();
  800420dddc:	48 b8 3d d4 20 04 80 	movabs $0x800420d43d,%rax
  800420dde3:	00 00 00 
  800420dde6:	ff d0                	callq  *%rax
  800420dde8:	48 98                	cltq   
  800420ddea:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420ddee:	e9 8a 01 00 00       	jmpq   800420df7d <syscall+0x219>
		case SYS_getenvid:
			result = sys_getenvid();
  800420ddf3:	48 b8 4f d4 20 04 80 	movabs $0x800420d44f,%rax
  800420ddfa:	00 00 00 
  800420ddfd:	ff d0                	callq  *%rax
  800420ddff:	48 98                	cltq   
  800420de01:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420de05:	e9 73 01 00 00       	jmpq   800420df7d <syscall+0x219>
		case SYS_env_destroy:
			result = sys_env_destroy(a1);
  800420de0a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de0e:	89 c7                	mov    %eax,%edi
  800420de10:	48 b8 8b d4 20 04 80 	movabs $0x800420d48b,%rax
  800420de17:	00 00 00 
  800420de1a:	ff d0                	callq  *%rax
  800420de1c:	48 98                	cltq   
  800420de1e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  800420de22:	e9 56 01 00 00       	jmpq   800420df7d <syscall+0x219>
		case SYS_yield:
			sys_yield();
  800420de27:	48 b8 db d4 20 04 80 	movabs $0x800420d4db,%rax
  800420de2e:	00 00 00 
  800420de31:	ff d0                	callq  *%rax
			result = 0;
  800420de33:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420de3a:	00 
			break;
  800420de3b:	e9 3d 01 00 00       	jmpq   800420df7d <syscall+0x219>
		case SYS_exofork:
			return sys_exofork();
  800420de40:	48 b8 eb d4 20 04 80 	movabs $0x800420d4eb,%rax
  800420de47:	00 00 00 
  800420de4a:	ff d0                	callq  *%rax
  800420de4c:	48 98                	cltq   
  800420de4e:	e9 2e 01 00 00       	jmpq   800420df81 <syscall+0x21d>
			break;
		case SYS_env_set_status:
			return sys_env_set_status(a1, a2);
  800420de53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420de57:	89 c2                	mov    %eax,%edx
  800420de59:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de5d:	89 d6                	mov    %edx,%esi
  800420de5f:	89 c7                	mov    %eax,%edi
  800420de61:	48 b8 c7 d5 20 04 80 	movabs $0x800420d5c7,%rax
  800420de68:	00 00 00 
  800420de6b:	ff d0                	callq  *%rax
  800420de6d:	48 98                	cltq   
  800420de6f:	e9 0d 01 00 00       	jmpq   800420df81 <syscall+0x21d>
			break;
		case SYS_env_set_pgfault_upcall:
			return sys_env_set_pgfault_upcall(a1, (void*)a2);
  800420de74:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420de78:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420de7c:	48 89 d6             	mov    %rdx,%rsi
  800420de7f:	89 c7                	mov    %eax,%edi
  800420de81:	48 b8 c5 d6 20 04 80 	movabs $0x800420d6c5,%rax
  800420de88:	00 00 00 
  800420de8b:	ff d0                	callq  *%rax
  800420de8d:	48 98                	cltq   
  800420de8f:	e9 ed 00 00 00       	jmpq   800420df81 <syscall+0x21d>
			break;
		case SYS_ipc_try_send:
			return sys_ipc_try_send(a1, a2, (void*)a3, a4);
  800420de94:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420de98:	89 c1                	mov    %eax,%ecx
  800420de9a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420de9e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420dea2:	89 c6                	mov    %eax,%esi
  800420dea4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dea8:	89 c7                	mov    %eax,%edi
  800420deaa:	48 b8 02 da 20 04 80 	movabs $0x800420da02,%rax
  800420deb1:	00 00 00 
  800420deb4:	ff d0                	callq  *%rax
  800420deb6:	48 98                	cltq   
  800420deb8:	e9 c4 00 00 00       	jmpq   800420df81 <syscall+0x21d>
			break;
		case SYS_ipc_recv:
			return sys_ipc_recv((void*)a1);
  800420debd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dec1:	48 89 c7             	mov    %rax,%rdi
  800420dec4:	48 b8 7e dc 20 04 80 	movabs $0x800420dc7e,%rax
  800420decb:	00 00 00 
  800420dece:	ff d0                	callq  *%rax
  800420ded0:	48 98                	cltq   
  800420ded2:	e9 aa 00 00 00       	jmpq   800420df81 <syscall+0x21d>
			break;
		case SYS_page_alloc:
			return sys_page_alloc(a1, (void*)a2, a3);
  800420ded7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420dedb:	89 c2                	mov    %eax,%edx
  800420dedd:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420dee1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420dee5:	48 89 ce             	mov    %rcx,%rsi
  800420dee8:	89 c7                	mov    %eax,%edi
  800420deea:	48 b8 1c d7 20 04 80 	movabs $0x800420d71c,%rax
  800420def1:	00 00 00 
  800420def4:	ff d0                	callq  *%rax
  800420def6:	48 98                	cltq   
  800420def8:	e9 84 00 00 00       	jmpq   800420df81 <syscall+0x21d>
			break;	
		case SYS_page_map:
			return sys_page_map(a1, (void*)a2, a3, (void*)a4, a5);
  800420defd:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800420df01:	89 c7                	mov    %eax,%edi
  800420df03:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800420df07:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420df0b:	89 c2                	mov    %eax,%edx
  800420df0d:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
  800420df11:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df15:	41 89 f8             	mov    %edi,%r8d
  800420df18:	89 c7                	mov    %eax,%edi
  800420df1a:	48 b8 07 d8 20 04 80 	movabs $0x800420d807,%rax
  800420df21:	00 00 00 
  800420df24:	ff d0                	callq  *%rax
  800420df26:	48 98                	cltq   
  800420df28:	eb 57                	jmp    800420df81 <syscall+0x21d>
			break;
		case SYS_page_unmap:
			return sys_page_unmap(a1, (void*)a2);
  800420df2a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420df2e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df32:	48 89 d6             	mov    %rdx,%rsi
  800420df35:	89 c7                	mov    %eax,%edi
  800420df37:	48 b8 74 d9 20 04 80 	movabs $0x800420d974,%rax
  800420df3e:	00 00 00 
  800420df41:	ff d0                	callq  *%rax
  800420df43:	48 98                	cltq   
  800420df45:	eb 3a                	jmp    800420df81 <syscall+0x21d>
			break;
		case SYS_env_set_trapframe:
			return sys_env_set_trapframe(a1, (struct Trapframe *)a2);
  800420df47:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420df4b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420df4f:	48 89 d6             	mov    %rdx,%rsi
  800420df52:	89 c7                	mov    %eax,%edi
  800420df54:	48 b8 2c d6 20 04 80 	movabs $0x800420d62c,%rax
  800420df5b:	00 00 00 
  800420df5e:	ff d0                	callq  *%rax
  800420df60:	48 98                	cltq   
  800420df62:	eb 1d                	jmp    800420df81 <syscall+0x21d>
		case SYS_time_msec:
			return sys_time_msec();
  800420df64:	48 b8 36 dd 20 04 80 	movabs $0x800420dd36,%rax
  800420df6b:	00 00 00 
  800420df6e:	ff d0                	callq  *%rax
  800420df70:	48 98                	cltq   
  800420df72:	eb 0d                	jmp    800420df81 <syscall+0x21d>
		default:		
			return -E_NO_SYS;
  800420df74:	48 c7 c0 f9 ff ff ff 	mov    $0xfffffffffffffff9,%rax
  800420df7b:	eb 04                	jmp    800420df81 <syscall+0x21d>
	}
	return result;	
  800420df7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420df81:	c9                   	leaveq 
  800420df82:	c3                   	retq   

000000800420df83 <list_func_die>:
	const char *stabstr;
	const char *stabstr_end;
};

int list_func_die(struct Ripdebuginfo *info, Dwarf_Die *die, uint64_t addr)
{
  800420df83:	55                   	push   %rbp
  800420df84:	48 89 e5             	mov    %rsp,%rbp
  800420df87:	48 81 ec f0 61 00 00 	sub    $0x61f0,%rsp
  800420df8e:	48 89 bd 58 9e ff ff 	mov    %rdi,-0x61a8(%rbp)
  800420df95:	48 89 b5 50 9e ff ff 	mov    %rsi,-0x61b0(%rbp)
  800420df9c:	48 89 95 48 9e ff ff 	mov    %rdx,-0x61b8(%rbp)
	_Dwarf_Line ln;
	Dwarf_Attribute *low;
	Dwarf_Attribute *high;
	Dwarf_CU *cu = die->cu_header;
  800420dfa3:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420dfaa:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  800420dfb1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Dwarf_Die *cudie = die->cu_die; 
  800420dfb5:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420dfbc:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420dfc3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	Dwarf_Die ret, sib=*die; 
  800420dfc7:	48 8b 95 50 9e ff ff 	mov    -0x61b0(%rbp),%rdx
  800420dfce:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420dfd5:	48 89 d1             	mov    %rdx,%rcx
  800420dfd8:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420dfdd:	48 89 ce             	mov    %rcx,%rsi
  800420dfe0:	48 89 c7             	mov    %rax,%rdi
  800420dfe3:	48 b8 1f fc 20 04 80 	movabs $0x800420fc1f,%rax
  800420dfea:	00 00 00 
  800420dfed:	ff d0                	callq  *%rax
	Dwarf_Attribute *attr;
	uint64_t offset;
	uint64_t ret_val=8;
  800420dfef:	48 c7 45 f8 08 00 00 	movq   $0x8,-0x8(%rbp)
  800420dff6:	00 
	uint64_t ret_offset=0;
  800420dff7:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420dffe:	00 

	if(die->die_tag != DW_TAG_subprogram)
  800420dfff:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e006:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e00a:	48 83 f8 2e          	cmp    $0x2e,%rax
  800420e00e:	74 0a                	je     800420e01a <list_func_die+0x97>
		return 0;
  800420e010:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e015:	e9 cd 06 00 00       	jmpq   800420e6e7 <list_func_die+0x764>

	memset(&ln, 0, sizeof(_Dwarf_Line));
  800420e01a:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420e021:	ba 38 00 00 00       	mov    $0x38,%edx
  800420e026:	be 00 00 00 00       	mov    $0x0,%esi
  800420e02b:	48 89 c7             	mov    %rax,%rdi
  800420e02e:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  800420e035:	00 00 00 
  800420e038:	ff d0                	callq  *%rax

	low  = _dwarf_attr_find(die, DW_AT_low_pc);
  800420e03a:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e041:	be 11 00 00 00       	mov    $0x11,%esi
  800420e046:	48 89 c7             	mov    %rax,%rdi
  800420e049:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  800420e050:	00 00 00 
  800420e053:	ff d0                	callq  *%rax
  800420e055:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	high = _dwarf_attr_find(die, DW_AT_high_pc);
  800420e059:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e060:	be 12 00 00 00       	mov    $0x12,%esi
  800420e065:	48 89 c7             	mov    %rax,%rdi
  800420e068:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  800420e06f:	00 00 00 
  800420e072:	ff d0                	callq  *%rax
  800420e074:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

	if((low && (low->u[0].u64 < addr)) && (high && (high->u[0].u64 > addr)))
  800420e078:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420e07d:	0f 84 5f 06 00 00    	je     800420e6e2 <list_func_die+0x75f>
  800420e083:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e087:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e08b:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420e092:	0f 83 4a 06 00 00    	jae    800420e6e2 <list_func_die+0x75f>
  800420e098:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420e09d:	0f 84 3f 06 00 00    	je     800420e6e2 <list_func_die+0x75f>
  800420e0a3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420e0a7:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e0ab:	48 3b 85 48 9e ff ff 	cmp    -0x61b8(%rbp),%rax
  800420e0b2:	0f 86 2a 06 00 00    	jbe    800420e6e2 <list_func_die+0x75f>
	{
		info->rip_file = die->cu_die->die_name;
  800420e0b8:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e0bf:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e0c6:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420e0cd:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e0d4:	48 89 10             	mov    %rdx,(%rax)

		info->rip_fn_name = die->die_name;
  800420e0d7:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e0de:	48 8b 90 50 03 00 00 	mov    0x350(%rax),%rdx
  800420e0e5:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e0ec:	48 89 50 10          	mov    %rdx,0x10(%rax)
		info->rip_fn_namelen = strlen(die->die_name);
  800420e0f0:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e0f7:	48 8b 80 50 03 00 00 	mov    0x350(%rax),%rax
  800420e0fe:	48 89 c7             	mov    %rax,%rdi
  800420e101:	48 b8 78 f7 20 04 80 	movabs $0x800420f778,%rax
  800420e108:	00 00 00 
  800420e10b:	ff d0                	callq  *%rax
  800420e10d:	48 8b 95 58 9e ff ff 	mov    -0x61a8(%rbp),%rdx
  800420e114:	89 42 18             	mov    %eax,0x18(%rdx)

		info->rip_fn_addr = (uintptr_t)low->u[0].u64;
  800420e117:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420e11b:	48 8b 50 28          	mov    0x28(%rax),%rdx
  800420e11f:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e126:	48 89 50 20          	mov    %rdx,0x20(%rax)

		assert(die->cu_die);	
  800420e12a:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e131:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e138:	48 85 c0             	test   %rax,%rax
  800420e13b:	75 35                	jne    800420e172 <list_func_die+0x1ef>
  800420e13d:	48 b9 a0 9a 21 04 80 	movabs $0x8004219aa0,%rcx
  800420e144:	00 00 00 
  800420e147:	48 ba ac 9a 21 04 80 	movabs $0x8004219aac,%rdx
  800420e14e:	00 00 00 
  800420e151:	be 90 00 00 00       	mov    $0x90,%esi
  800420e156:	48 bf c1 9a 21 04 80 	movabs $0x8004219ac1,%rdi
  800420e15d:	00 00 00 
  800420e160:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e165:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420e16c:	00 00 00 
  800420e16f:	41 ff d0             	callq  *%r8
		dwarf_srclines(die->cu_die, &ln, addr, NULL); 
  800420e172:	48 8b 85 50 9e ff ff 	mov    -0x61b0(%rbp),%rax
  800420e179:	48 8b 80 68 03 00 00 	mov    0x368(%rax),%rax
  800420e180:	48 8b 95 48 9e ff ff 	mov    -0x61b8(%rbp),%rdx
  800420e187:	48 8d b5 50 ff ff ff 	lea    -0xb0(%rbp),%rsi
  800420e18e:	b9 00 00 00 00       	mov    $0x0,%ecx
  800420e193:	48 89 c7             	mov    %rax,%rdi
  800420e196:	48 b8 e8 4f 21 04 80 	movabs $0x8004214fe8,%rax
  800420e19d:	00 00 00 
  800420e1a0:	ff d0                	callq  *%rax

		info->rip_line = ln.ln_lineno;
  800420e1a2:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800420e1a9:	89 c2                	mov    %eax,%edx
  800420e1ab:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e1b2:	89 50 08             	mov    %edx,0x8(%rax)
		info->rip_fn_narg = 0;
  800420e1b5:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e1bc:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)

		Dwarf_Attribute* attr;

		if(dwarf_child(dbg, cu, &sib, &ret) != DW_DLE_NO_ENTRY)
  800420e1c3:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e1ca:	00 00 00 
  800420e1cd:	48 8b 00             	mov    (%rax),%rax
  800420e1d0:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e1d7:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e1de:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420e1e2:	48 89 c7             	mov    %rax,%rdi
  800420e1e5:	48 b8 89 1c 21 04 80 	movabs $0x8004211c89,%rax
  800420e1ec:	00 00 00 
  800420e1ef:	ff d0                	callq  *%rax
  800420e1f1:	83 f8 04             	cmp    $0x4,%eax
  800420e1f4:	0f 84 e1 04 00 00    	je     800420e6db <list_func_die+0x758>
		{
			if(ret.die_tag != DW_TAG_formal_parameter)
  800420e1fa:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420e201:	48 83 f8 05          	cmp    $0x5,%rax
  800420e205:	74 05                	je     800420e20c <list_func_die+0x289>
				goto last;
  800420e207:	e9 cf 04 00 00       	jmpq   800420e6db <list_func_die+0x758>

			attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e20c:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e213:	be 49 00 00 00       	mov    $0x49,%esi
  800420e218:	48 89 c7             	mov    %rax,%rdi
  800420e21b:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  800420e222:	00 00 00 
  800420e225:	ff d0                	callq  *%rax
  800420e227:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	
		try_again:
			if(attr != NULL)
  800420e22b:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e230:	0f 84 d7 00 00 00    	je     800420e30d <list_func_die+0x38a>
			{
				offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e236:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e23a:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e23e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e242:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e246:	48 01 d0             	add    %rdx,%rax
  800420e249:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
				dwarf_offdie(dbg, offset, &sib, *cu);
  800420e24d:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e254:	00 00 00 
  800420e257:	48 8b 08             	mov    (%rax),%rcx
  800420e25a:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e261:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420e265:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e269:	48 8b 38             	mov    (%rax),%rdi
  800420e26c:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e270:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e274:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e279:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e27d:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e282:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e286:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e28b:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e28f:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e294:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e298:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e29d:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e2a1:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e2a6:	48 89 cf             	mov    %rcx,%rdi
  800420e2a9:	48 b8 af 18 21 04 80 	movabs $0x80042118af,%rax
  800420e2b0:	00 00 00 
  800420e2b3:	ff d0                	callq  *%rax
				attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e2b5:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e2bc:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e2c1:	48 89 c7             	mov    %rax,%rdi
  800420e2c4:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  800420e2cb:	00 00 00 
  800420e2ce:	ff d0                	callq  *%rax
  800420e2d0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
		
				if(attr != NULL)
  800420e2d4:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e2d9:	74 0e                	je     800420e2e9 <list_func_die+0x366>
				{
					ret_val = attr->u[0].u64;
  800420e2db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e2df:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e2e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420e2e7:	eb 24                	jmp    800420e30d <list_func_die+0x38a>
				}
				else
				{
					attr = _dwarf_attr_find(&sib, DW_AT_type);
  800420e2e9:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e2f0:	be 49 00 00 00       	mov    $0x49,%esi
  800420e2f5:	48 89 c7             	mov    %rax,%rdi
  800420e2f8:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  800420e2ff:	00 00 00 
  800420e302:	ff d0                	callq  *%rax
  800420e304:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
					goto try_again;
  800420e308:	e9 1e ff ff ff       	jmpq   800420e22b <list_func_die+0x2a8>
				}
			}

			ret_offset = 0;
  800420e30d:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e314:	00 
			attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420e315:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e31c:	be 02 00 00 00       	mov    $0x2,%esi
  800420e321:	48 89 c7             	mov    %rax,%rdi
  800420e324:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  800420e32b:	00 00 00 
  800420e32e:	ff d0                	callq  *%rax
  800420e330:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if (attr != NULL)
  800420e334:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e339:	0f 84 a2 00 00 00    	je     800420e3e1 <list_func_die+0x45e>
			{
				Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420e33f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e343:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420e347:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
				Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420e34b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e34f:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420e353:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
				Dwarf_Small atom;
				Dwarf_Unsigned op1, op2;

				switch(attr->at_form) {
  800420e357:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e35b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e35f:	48 83 f8 03          	cmp    $0x3,%rax
  800420e363:	72 7c                	jb     800420e3e1 <list_func_die+0x45e>
  800420e365:	48 83 f8 04          	cmp    $0x4,%rax
  800420e369:	76 06                	jbe    800420e371 <list_func_die+0x3ee>
  800420e36b:	48 83 f8 0a          	cmp    $0xa,%rax
  800420e36f:	75 70                	jne    800420e3e1 <list_func_die+0x45e>
					case DW_FORM_block1:
					case DW_FORM_block2:
					case DW_FORM_block4:
						offset = 0;
  800420e371:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420e378:	00 
						atom = *(loc_ptr++);
  800420e379:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e37d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e381:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
  800420e385:	0f b6 00             	movzbl (%rax),%eax
  800420e388:	88 45 af             	mov    %al,-0x51(%rbp)
						offset++;
  800420e38b:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
						if (atom == DW_OP_fbreg) {
  800420e390:	80 7d af 91          	cmpb   $0x91,-0x51(%rbp)
  800420e394:	75 4a                	jne    800420e3e0 <list_func_die+0x45d>
							uint8_t *p = loc_ptr;
  800420e396:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e39a:	48 89 85 68 9e ff ff 	mov    %rax,-0x6198(%rbp)
							ret_offset = _dwarf_decode_sleb128(&p);
  800420e3a1:	48 8d 85 68 9e ff ff 	lea    -0x6198(%rbp),%rax
  800420e3a8:	48 89 c7             	mov    %rax,%rdi
  800420e3ab:	48 b8 0e 06 21 04 80 	movabs $0x800421060e,%rax
  800420e3b2:	00 00 00 
  800420e3b5:	ff d0                	callq  *%rax
  800420e3b7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
							offset += p - loc_ptr;
  800420e3bb:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420e3c2:	48 89 c2             	mov    %rax,%rdx
  800420e3c5:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800420e3c9:	48 29 c2             	sub    %rax,%rdx
  800420e3cc:	48 89 d0             	mov    %rdx,%rax
  800420e3cf:	48 01 45 c0          	add    %rax,-0x40(%rbp)
							loc_ptr = p;
  800420e3d3:	48 8b 85 68 9e ff ff 	mov    -0x6198(%rbp),%rax
  800420e3da:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
						}
						break;
  800420e3de:	eb 00                	jmp    800420e3e0 <list_func_die+0x45d>
  800420e3e0:	90                   	nop
				}
			}

			info->size_fn_arg[info->rip_fn_narg] = ret_val;
  800420e3e1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e3e8:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e3eb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e3ef:	89 c2                	mov    %eax,%edx
  800420e3f1:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e3f8:	48 63 c9             	movslq %ecx,%rcx
  800420e3fb:	48 83 c1 08          	add    $0x8,%rcx
  800420e3ff:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
  800420e403:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e40a:	8b 50 28             	mov    0x28(%rax),%edx
  800420e40d:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e414:	48 63 d2             	movslq %edx,%rdx
  800420e417:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420e41b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e41f:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
			info->rip_fn_narg++;
  800420e424:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e42b:	8b 40 28             	mov    0x28(%rax),%eax
  800420e42e:	8d 50 01             	lea    0x1(%rax),%edx
  800420e431:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e438:	89 50 28             	mov    %edx,0x28(%rax)
			sib = ret; 
  800420e43b:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e442:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e449:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e44e:	48 89 ce             	mov    %rcx,%rsi
  800420e451:	48 89 c7             	mov    %rax,%rdi
  800420e454:	48 b8 1f fc 20 04 80 	movabs $0x800420fc1f,%rax
  800420e45b:	00 00 00 
  800420e45e:	ff d0                	callq  *%rax

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e460:	e9 40 02 00 00       	jmpq   800420e6a5 <list_func_die+0x722>
			{
				if(ret.die_tag != DW_TAG_formal_parameter)
  800420e465:	48 8b 85 f8 ce ff ff 	mov    -0x3108(%rbp),%rax
  800420e46c:	48 83 f8 05          	cmp    $0x5,%rax
  800420e470:	74 05                	je     800420e477 <list_func_die+0x4f4>
					break;
  800420e472:	e9 64 02 00 00       	jmpq   800420e6db <list_func_die+0x758>

				attr = _dwarf_attr_find(&ret, DW_AT_type);
  800420e477:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e47e:	be 49 00 00 00       	mov    $0x49,%esi
  800420e483:	48 89 c7             	mov    %rax,%rdi
  800420e486:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  800420e48d:	00 00 00 
  800420e490:	ff d0                	callq  *%rax
  800420e492:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    
				if(attr != NULL)
  800420e496:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e49b:	0f 84 b1 00 00 00    	je     800420e552 <list_func_die+0x5cf>
				{	   
					offset = (uint64_t)cu->cu_offset + attr->u[0].u64;
  800420e4a1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e4a5:	48 8b 50 30          	mov    0x30(%rax),%rdx
  800420e4a9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e4ad:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e4b1:	48 01 d0             	add    %rdx,%rax
  800420e4b4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
					dwarf_offdie(dbg, offset, &sib, *cu);
  800420e4b8:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e4bf:	00 00 00 
  800420e4c2:	48 8b 08             	mov    (%rax),%rcx
  800420e4c5:	48 8d 95 70 9e ff ff 	lea    -0x6190(%rbp),%rdx
  800420e4cc:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  800420e4d0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420e4d4:	48 8b 38             	mov    (%rax),%rdi
  800420e4d7:	48 89 3c 24          	mov    %rdi,(%rsp)
  800420e4db:	48 8b 78 08          	mov    0x8(%rax),%rdi
  800420e4df:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  800420e4e4:	48 8b 78 10          	mov    0x10(%rax),%rdi
  800420e4e8:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  800420e4ed:	48 8b 78 18          	mov    0x18(%rax),%rdi
  800420e4f1:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  800420e4f6:	48 8b 78 20          	mov    0x20(%rax),%rdi
  800420e4fa:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  800420e4ff:	48 8b 78 28          	mov    0x28(%rax),%rdi
  800420e503:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  800420e508:	48 8b 40 30          	mov    0x30(%rax),%rax
  800420e50c:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  800420e511:	48 89 cf             	mov    %rcx,%rdi
  800420e514:	48 b8 af 18 21 04 80 	movabs $0x80042118af,%rax
  800420e51b:	00 00 00 
  800420e51e:	ff d0                	callq  *%rax
					attr = _dwarf_attr_find(&sib, DW_AT_byte_size);
  800420e520:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e527:	be 0b 00 00 00       	mov    $0xb,%esi
  800420e52c:	48 89 c7             	mov    %rax,%rdi
  800420e52f:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  800420e536:	00 00 00 
  800420e539:	ff d0                	callq  *%rax
  800420e53b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        
					if(attr != NULL)
  800420e53f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e544:	74 0c                	je     800420e552 <list_func_die+0x5cf>
					{
						ret_val = attr->u[0].u64;
  800420e546:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e54a:	48 8b 40 28          	mov    0x28(%rax),%rax
  800420e54e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
					}
				}
	
				ret_offset = 0;
  800420e552:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420e559:	00 
				attr = _dwarf_attr_find(&ret, DW_AT_location);
  800420e55a:	48 8d 85 e0 ce ff ff 	lea    -0x3120(%rbp),%rax
  800420e561:	be 02 00 00 00       	mov    $0x2,%esi
  800420e566:	48 89 c7             	mov    %rax,%rdi
  800420e569:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  800420e570:	00 00 00 
  800420e573:	ff d0                	callq  *%rax
  800420e575:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				if (attr != NULL)
  800420e579:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420e57e:	0f 84 a2 00 00 00    	je     800420e626 <list_func_die+0x6a3>
				{
					Dwarf_Unsigned loc_len = attr->at_block.bl_len;
  800420e584:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e588:	48 8b 40 38          	mov    0x38(%rax),%rax
  800420e58c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
					Dwarf_Small *loc_ptr = attr->at_block.bl_data;
  800420e590:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e594:	48 8b 40 40          	mov    0x40(%rax),%rax
  800420e598:	48 89 45 98          	mov    %rax,-0x68(%rbp)
					Dwarf_Small atom;
					Dwarf_Unsigned op1, op2;

					switch(attr->at_form) {
  800420e59c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420e5a0:	48 8b 40 18          	mov    0x18(%rax),%rax
  800420e5a4:	48 83 f8 03          	cmp    $0x3,%rax
  800420e5a8:	72 7c                	jb     800420e626 <list_func_die+0x6a3>
  800420e5aa:	48 83 f8 04          	cmp    $0x4,%rax
  800420e5ae:	76 06                	jbe    800420e5b6 <list_func_die+0x633>
  800420e5b0:	48 83 f8 0a          	cmp    $0xa,%rax
  800420e5b4:	75 70                	jne    800420e626 <list_func_die+0x6a3>
						case DW_FORM_block1:
						case DW_FORM_block2:
						case DW_FORM_block4:
							offset = 0;
  800420e5b6:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
  800420e5bd:	00 
							atom = *(loc_ptr++);
  800420e5be:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e5c2:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420e5c6:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420e5ca:	0f b6 00             	movzbl (%rax),%eax
  800420e5cd:	88 45 97             	mov    %al,-0x69(%rbp)
							offset++;
  800420e5d0:	48 83 45 c0 01       	addq   $0x1,-0x40(%rbp)
							if (atom == DW_OP_fbreg) {
  800420e5d5:	80 7d 97 91          	cmpb   $0x91,-0x69(%rbp)
  800420e5d9:	75 4a                	jne    800420e625 <list_func_die+0x6a2>
								uint8_t *p = loc_ptr;
  800420e5db:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e5df:	48 89 85 60 9e ff ff 	mov    %rax,-0x61a0(%rbp)
								ret_offset = _dwarf_decode_sleb128(&p);
  800420e5e6:	48 8d 85 60 9e ff ff 	lea    -0x61a0(%rbp),%rax
  800420e5ed:	48 89 c7             	mov    %rax,%rdi
  800420e5f0:	48 b8 0e 06 21 04 80 	movabs $0x800421060e,%rax
  800420e5f7:	00 00 00 
  800420e5fa:	ff d0                	callq  *%rax
  800420e5fc:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
								offset += p - loc_ptr;
  800420e600:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420e607:	48 89 c2             	mov    %rax,%rdx
  800420e60a:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420e60e:	48 29 c2             	sub    %rax,%rdx
  800420e611:	48 89 d0             	mov    %rdx,%rax
  800420e614:	48 01 45 c0          	add    %rax,-0x40(%rbp)
								loc_ptr = p;
  800420e618:	48 8b 85 60 9e ff ff 	mov    -0x61a0(%rbp),%rax
  800420e61f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
							}
							break;
  800420e623:	eb 00                	jmp    800420e625 <list_func_die+0x6a2>
  800420e625:	90                   	nop
					}
				}

				info->size_fn_arg[info->rip_fn_narg]=ret_val;// _get_arg_size(ret);
  800420e626:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e62d:	8b 48 28             	mov    0x28(%rax),%ecx
  800420e630:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420e634:	89 c2                	mov    %eax,%edx
  800420e636:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e63d:	48 63 c9             	movslq %ecx,%rcx
  800420e640:	48 83 c1 08          	add    $0x8,%rcx
  800420e644:	89 54 88 0c          	mov    %edx,0xc(%rax,%rcx,4)
				info->offset_fn_arg[info->rip_fn_narg]=ret_offset;
  800420e648:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e64f:	8b 50 28             	mov    0x28(%rax),%edx
  800420e652:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e659:	48 63 d2             	movslq %edx,%rdx
  800420e65c:	48 8d 4a 0a          	lea    0xa(%rdx),%rcx
  800420e660:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420e664:	48 89 54 c8 08       	mov    %rdx,0x8(%rax,%rcx,8)
				info->rip_fn_narg++;
  800420e669:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e670:	8b 40 28             	mov    0x28(%rax),%eax
  800420e673:	8d 50 01             	lea    0x1(%rax),%edx
  800420e676:	48 8b 85 58 9e ff ff 	mov    -0x61a8(%rbp),%rax
  800420e67d:	89 50 28             	mov    %edx,0x28(%rax)
				sib = ret; 
  800420e680:	48 8d 85 70 9e ff ff 	lea    -0x6190(%rbp),%rax
  800420e687:	48 8d 8d e0 ce ff ff 	lea    -0x3120(%rbp),%rcx
  800420e68e:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420e693:	48 89 ce             	mov    %rcx,%rsi
  800420e696:	48 89 c7             	mov    %rax,%rdi
  800420e699:	48 b8 1f fc 20 04 80 	movabs $0x800420fc1f,%rax
  800420e6a0:	00 00 00 
  800420e6a3:	ff d0                	callq  *%rax
			info->size_fn_arg[info->rip_fn_narg] = ret_val;
			info->offset_fn_arg[info->rip_fn_narg] = ret_offset;
			info->rip_fn_narg++;
			sib = ret; 

			while(dwarf_siblingof(dbg, &sib, &ret, cu) == DW_DLV_OK)	
  800420e6a5:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e6ac:	00 00 00 
  800420e6af:	48 8b 00             	mov    (%rax),%rax
  800420e6b2:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420e6b6:	48 8d 95 e0 ce ff ff 	lea    -0x3120(%rbp),%rdx
  800420e6bd:	48 8d b5 70 9e ff ff 	lea    -0x6190(%rbp),%rsi
  800420e6c4:	48 89 c7             	mov    %rax,%rdi
  800420e6c7:	48 b8 45 1a 21 04 80 	movabs $0x8004211a45,%rax
  800420e6ce:	00 00 00 
  800420e6d1:	ff d0                	callq  *%rax
  800420e6d3:	85 c0                	test   %eax,%eax
  800420e6d5:	0f 84 8a fd ff ff    	je     800420e465 <list_func_die+0x4e2>
				info->rip_fn_narg++;
				sib = ret; 
			}
		}
	last:	
		return 1;
  800420e6db:	b8 01 00 00 00       	mov    $0x1,%eax
  800420e6e0:	eb 05                	jmp    800420e6e7 <list_func_die+0x764>
	}

	return 0;
  800420e6e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420e6e7:	c9                   	leaveq 
  800420e6e8:	c3                   	retq   

000000800420e6e9 <debuginfo_rip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_rip(uintptr_t addr, struct Ripdebuginfo *info)
{
  800420e6e9:	55                   	push   %rbp
  800420e6ea:	48 89 e5             	mov    %rsp,%rbp
  800420e6ed:	53                   	push   %rbx
  800420e6ee:	48 81 ec c8 91 00 00 	sub    $0x91c8,%rsp
  800420e6f5:	48 89 bd 38 6e ff ff 	mov    %rdi,-0x91c8(%rbp)
  800420e6fc:	48 89 b5 30 6e ff ff 	mov    %rsi,-0x91d0(%rbp)
	static struct Env* lastenv = NULL;
	void* elf;    
	Dwarf_Section *sect;
	Dwarf_CU cu;
	Dwarf_Die die, cudie, die2;
	Dwarf_Regtable *rt = NULL;
  800420e703:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
  800420e70a:	00 
	//Set up initial pc
	uint64_t pc  = (uintptr_t)addr;
  800420e70b:	48 8b 85 38 6e ff ff 	mov    -0x91c8(%rbp),%rax
  800420e712:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

    
	// Initialize *info
	info->rip_file = "<unknown>";
  800420e716:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e71d:	48 bb cf 9a 21 04 80 	movabs $0x8004219acf,%rbx
  800420e724:	00 00 00 
  800420e727:	48 89 18             	mov    %rbx,(%rax)
	info->rip_line = 0;
  800420e72a:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e731:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
	info->rip_fn_name = "<unknown>";
  800420e738:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e73f:	48 bb cf 9a 21 04 80 	movabs $0x8004219acf,%rbx
  800420e746:	00 00 00 
  800420e749:	48 89 58 10          	mov    %rbx,0x10(%rax)
	info->rip_fn_namelen = 9;
  800420e74d:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e754:	c7 40 18 09 00 00 00 	movl   $0x9,0x18(%rax)
	info->rip_fn_addr = addr;
  800420e75b:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e762:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420e769:	48 89 50 20          	mov    %rdx,0x20(%rax)
	info->rip_fn_narg = 0;
  800420e76d:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420e774:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%rax)
    
	// Find the relevant set of stabs
	if (addr >= ULIM) {
  800420e77b:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  800420e782:	00 00 00 
  800420e785:	48 39 85 38 6e ff ff 	cmp    %rax,-0x91c8(%rbp)
  800420e78c:	76 13                	jbe    800420e7a1 <debuginfo_rip+0xb8>
		elf = (void *)0x10000 + KERNBASE;
  800420e78e:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800420e795:	00 00 00 
  800420e798:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  800420e79c:	e9 04 01 00 00       	jmpq   800420e8a5 <debuginfo_rip+0x1bc>
	} else {
		if(curenv != lastenv) {
  800420e7a1:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420e7a8:	00 00 00 
  800420e7ab:	ff d0                	callq  *%rax
  800420e7ad:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420e7b4:	00 00 00 
  800420e7b7:	48 98                	cltq   
  800420e7b9:	48 c1 e0 03          	shl    $0x3,%rax
  800420e7bd:	48 89 c1             	mov    %rax,%rcx
  800420e7c0:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e7c4:	48 01 c8             	add    %rcx,%rax
  800420e7c7:	48 01 d0             	add    %rdx,%rax
  800420e7ca:	48 83 c0 08          	add    $0x8,%rax
  800420e7ce:	48 8b 10             	mov    (%rax),%rdx
  800420e7d1:	48 b8 a0 92 37 04 80 	movabs $0x80043792a0,%rax
  800420e7d8:	00 00 00 
  800420e7db:	48 8b 00             	mov    (%rax),%rax
  800420e7de:	48 39 c2             	cmp    %rax,%rdx
  800420e7e1:	0f 84 83 00 00 00    	je     800420e86a <debuginfo_rip+0x181>
			find_debug_sections((uintptr_t)curenv->elf);
  800420e7e7:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420e7ee:	00 00 00 
  800420e7f1:	ff d0                	callq  *%rax
  800420e7f3:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420e7fa:	00 00 00 
  800420e7fd:	48 98                	cltq   
  800420e7ff:	48 c1 e0 03          	shl    $0x3,%rax
  800420e803:	48 89 c1             	mov    %rax,%rcx
  800420e806:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e80a:	48 01 c8             	add    %rcx,%rax
  800420e80d:	48 01 d0             	add    %rdx,%rax
  800420e810:	48 83 c0 08          	add    $0x8,%rax
  800420e814:	48 8b 00             	mov    (%rax),%rax
  800420e817:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420e81e:	48 89 c7             	mov    %rax,%rdi
  800420e821:	48 b8 e3 51 21 04 80 	movabs $0x80042151e3,%rax
  800420e828:	00 00 00 
  800420e82b:	ff d0                	callq  *%rax
			lastenv = curenv;
  800420e82d:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420e834:	00 00 00 
  800420e837:	ff d0                	callq  *%rax
  800420e839:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420e840:	00 00 00 
  800420e843:	48 98                	cltq   
  800420e845:	48 c1 e0 03          	shl    $0x3,%rax
  800420e849:	48 89 c1             	mov    %rax,%rcx
  800420e84c:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e850:	48 01 c8             	add    %rcx,%rax
  800420e853:	48 01 d0             	add    %rdx,%rax
  800420e856:	48 83 c0 08          	add    $0x8,%rax
  800420e85a:	48 8b 10             	mov    (%rax),%rdx
  800420e85d:	48 b8 a0 92 37 04 80 	movabs $0x80043792a0,%rax
  800420e864:	00 00 00 
  800420e867:	48 89 10             	mov    %rdx,(%rax)
		}
		elf = curenv->elf;
  800420e86a:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800420e871:	00 00 00 
  800420e874:	ff d0                	callq  *%rax
  800420e876:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  800420e87d:	00 00 00 
  800420e880:	48 98                	cltq   
  800420e882:	48 c1 e0 03          	shl    $0x3,%rax
  800420e886:	48 89 c1             	mov    %rax,%rcx
  800420e889:	48 c1 e1 04          	shl    $0x4,%rcx
  800420e88d:	48 01 c8             	add    %rcx,%rax
  800420e890:	48 01 d0             	add    %rdx,%rax
  800420e893:	48 83 c0 08          	add    $0x8,%rax
  800420e897:	48 8b 00             	mov    (%rax),%rax
  800420e89a:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
  800420e8a1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	}
	_dwarf_init(dbg, elf);
  800420e8a5:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e8ac:	00 00 00 
  800420e8af:	48 8b 00             	mov    (%rax),%rax
  800420e8b2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420e8b6:	48 89 d6             	mov    %rdx,%rsi
  800420e8b9:	48 89 c7             	mov    %rax,%rdi
  800420e8bc:	48 b8 bd 08 21 04 80 	movabs $0x80042108bd,%rax
  800420e8c3:	00 00 00 
  800420e8c6:	ff d0                	callq  *%rax

	sect = _dwarf_find_section(".debug_info");	
  800420e8c8:	48 bf d9 9a 21 04 80 	movabs $0x8004219ad9,%rdi
  800420e8cf:	00 00 00 
  800420e8d2:	48 b8 63 51 21 04 80 	movabs $0x8004215163,%rax
  800420e8d9:	00 00 00 
  800420e8dc:	ff d0                	callq  *%rax
  800420e8de:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
  800420e8e2:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e8e9:	00 00 00 
  800420e8ec:	48 8b 00             	mov    (%rax),%rax
  800420e8ef:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e8f3:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  800420e8f7:	48 89 50 08          	mov    %rdx,0x8(%rax)
	dbg->dbg_info_size = sect->ds_size;
  800420e8fb:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e902:	00 00 00 
  800420e905:	48 8b 00             	mov    (%rax),%rax
  800420e908:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800420e90c:	48 8b 52 18          	mov    0x18(%rdx),%rdx
  800420e910:	48 89 50 10          	mov    %rdx,0x10(%rax)
    
	assert(dbg->dbg_info_size);
  800420e914:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e91b:	00 00 00 
  800420e91e:	48 8b 00             	mov    (%rax),%rax
  800420e921:	48 8b 40 10          	mov    0x10(%rax),%rax
  800420e925:	48 85 c0             	test   %rax,%rax
  800420e928:	75 35                	jne    800420e95f <debuginfo_rip+0x276>
  800420e92a:	48 b9 e5 9a 21 04 80 	movabs $0x8004219ae5,%rcx
  800420e931:	00 00 00 
  800420e934:	48 ba ac 9a 21 04 80 	movabs $0x8004219aac,%rdx
  800420e93b:	00 00 00 
  800420e93e:	be 36 01 00 00       	mov    $0x136,%esi
  800420e943:	48 bf c1 9a 21 04 80 	movabs $0x8004219ac1,%rdi
  800420e94a:	00 00 00 
  800420e94d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420e952:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800420e959:	00 00 00 
  800420e95c:	41 ff d0             	callq  *%r8
	while(_get_next_cu(dbg, &cu) == 0)
  800420e95f:	e9 6f 01 00 00       	jmpq   800420ead3 <debuginfo_rip+0x3ea>
	{
		if(dwarf_siblingof(dbg, NULL, &cudie, &cu) == DW_DLE_NO_ENTRY)
  800420e964:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e96b:	00 00 00 
  800420e96e:	48 8b 00             	mov    (%rax),%rax
  800420e971:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420e975:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e97c:	be 00 00 00 00       	mov    $0x0,%esi
  800420e981:	48 89 c7             	mov    %rax,%rdi
  800420e984:	48 b8 45 1a 21 04 80 	movabs $0x8004211a45,%rax
  800420e98b:	00 00 00 
  800420e98e:	ff d0                	callq  *%rax
  800420e990:	83 f8 04             	cmp    $0x4,%eax
  800420e993:	75 05                	jne    800420e99a <debuginfo_rip+0x2b1>
		{
			continue;
  800420e995:	e9 39 01 00 00       	jmpq   800420ead3 <debuginfo_rip+0x3ea>
		}	
		cudie.cu_header = &cu;
  800420e99a:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e99e:	48 89 85 10 a2 ff ff 	mov    %rax,-0x5df0(%rbp)
		cudie.cu_die = NULL;
  800420e9a5:	48 c7 85 18 a2 ff ff 	movq   $0x0,-0x5de8(%rbp)
  800420e9ac:	00 00 00 00 
	    
		if(dwarf_child(dbg, &cu, &cudie, &die) == DW_DLE_NO_ENTRY)
  800420e9b0:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420e9b7:	00 00 00 
  800420e9ba:	48 8b 00             	mov    (%rax),%rax
  800420e9bd:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420e9c4:	48 8d 95 b0 9e ff ff 	lea    -0x6150(%rbp),%rdx
  800420e9cb:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800420e9cf:	48 89 c7             	mov    %rax,%rdi
  800420e9d2:	48 b8 89 1c 21 04 80 	movabs $0x8004211c89,%rax
  800420e9d9:	00 00 00 
  800420e9dc:	ff d0                	callq  *%rax
  800420e9de:	83 f8 04             	cmp    $0x4,%eax
  800420e9e1:	75 05                	jne    800420e9e8 <debuginfo_rip+0x2ff>
		{
			continue;
  800420e9e3:	e9 eb 00 00 00       	jmpq   800420ead3 <debuginfo_rip+0x3ea>
		}	
		die.cu_header = &cu;
  800420e9e8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420e9ec:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
		die.cu_die = &cudie;
  800420e9f3:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420e9fa:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		while(1)
		{
			if(list_func_die(info, &die, addr))
  800420ea01:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420ea08:	48 8d 8d 20 cf ff ff 	lea    -0x30e0(%rbp),%rcx
  800420ea0f:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420ea16:	48 89 ce             	mov    %rcx,%rsi
  800420ea19:	48 89 c7             	mov    %rax,%rdi
  800420ea1c:	48 b8 83 df 20 04 80 	movabs $0x800420df83,%rax
  800420ea23:	00 00 00 
  800420ea26:	ff d0                	callq  *%rax
  800420ea28:	85 c0                	test   %eax,%eax
  800420ea2a:	74 30                	je     800420ea5c <debuginfo_rip+0x373>
				goto find_done;
  800420ea2c:	90                   	nop
    
	return -1;

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
  800420ea2d:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420ea34:	00 00 00 
  800420ea37:	48 8b 00             	mov    (%rax),%rax
  800420ea3a:	be 00 00 00 00       	mov    $0x0,%esi
  800420ea3f:	48 89 c7             	mov    %rax,%rdi
  800420ea42:	48 b8 70 43 21 04 80 	movabs $0x8004214370,%rax
  800420ea49:	00 00 00 
  800420ea4c:	ff d0                	callq  *%rax
  800420ea4e:	83 f8 01             	cmp    $0x1,%eax
  800420ea51:	0f 85 bb 00 00 00    	jne    800420eb12 <debuginfo_rip+0x429>
  800420ea57:	e9 ac 00 00 00       	jmpq   800420eb08 <debuginfo_rip+0x41f>
		die.cu_die = &cudie;
		while(1)
		{
			if(list_func_die(info, &die, addr))
				goto find_done;
			if(dwarf_siblingof(dbg, &die, &die2, &cu) < 0)
  800420ea5c:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420ea63:	00 00 00 
  800420ea66:	48 8b 00             	mov    (%rax),%rax
  800420ea69:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  800420ea6d:	48 8d 95 40 6e ff ff 	lea    -0x91c0(%rbp),%rdx
  800420ea74:	48 8d b5 20 cf ff ff 	lea    -0x30e0(%rbp),%rsi
  800420ea7b:	48 89 c7             	mov    %rax,%rdi
  800420ea7e:	48 b8 45 1a 21 04 80 	movabs $0x8004211a45,%rax
  800420ea85:	00 00 00 
  800420ea88:	ff d0                	callq  *%rax
  800420ea8a:	85 c0                	test   %eax,%eax
  800420ea8c:	79 02                	jns    800420ea90 <debuginfo_rip+0x3a7>
				break; 
  800420ea8e:	eb 43                	jmp    800420ead3 <debuginfo_rip+0x3ea>
			die = die2;
  800420ea90:	48 8d 85 20 cf ff ff 	lea    -0x30e0(%rbp),%rax
  800420ea97:	48 8d 8d 40 6e ff ff 	lea    -0x91c0(%rbp),%rcx
  800420ea9e:	ba 70 30 00 00       	mov    $0x3070,%edx
  800420eaa3:	48 89 ce             	mov    %rcx,%rsi
  800420eaa6:	48 89 c7             	mov    %rax,%rdi
  800420eaa9:	48 b8 1f fc 20 04 80 	movabs $0x800420fc1f,%rax
  800420eab0:	00 00 00 
  800420eab3:	ff d0                	callq  *%rax
			die.cu_header = &cu;
  800420eab5:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  800420eab9:	48 89 85 80 d2 ff ff 	mov    %rax,-0x2d80(%rbp)
			die.cu_die = &cudie;
  800420eac0:	48 8d 85 b0 9e ff ff 	lea    -0x6150(%rbp),%rax
  800420eac7:	48 89 85 88 d2 ff ff 	mov    %rax,-0x2d78(%rbp)
		}
  800420eace:	e9 2e ff ff ff       	jmpq   800420ea01 <debuginfo_rip+0x318>
	sect = _dwarf_find_section(".debug_info");	
	dbg->dbg_info_offset_elf = (uint64_t)sect->ds_data; 
	dbg->dbg_info_size = sect->ds_size;
    
	assert(dbg->dbg_info_size);
	while(_get_next_cu(dbg, &cu) == 0)
  800420ead3:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420eada:	00 00 00 
  800420eadd:	48 8b 00             	mov    (%rax),%rax
  800420eae0:	48 8d 55 90          	lea    -0x70(%rbp),%rdx
  800420eae4:	48 89 d6             	mov    %rdx,%rsi
  800420eae7:	48 89 c7             	mov    %rax,%rdi
  800420eaea:	48 b8 9f 09 21 04 80 	movabs $0x800421099f,%rax
  800420eaf1:	00 00 00 
  800420eaf4:	ff d0                	callq  *%rax
  800420eaf6:	85 c0                	test   %eax,%eax
  800420eaf8:	0f 84 66 fe ff ff    	je     800420e964 <debuginfo_rip+0x27b>
			die.cu_header = &cu;
			die.cu_die = &cudie;
		}
	}
    
	return -1;
  800420eafe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420eb03:	e9 a0 00 00 00       	jmpq   800420eba8 <debuginfo_rip+0x4bf>

find_done:

	if (dwarf_init_eh_section(dbg, NULL) == DW_DLV_ERROR)
		return -1;
  800420eb08:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800420eb0d:	e9 96 00 00 00       	jmpq   800420eba8 <debuginfo_rip+0x4bf>

	if (dwarf_get_fde_at_pc(dbg, addr, fde, cie, NULL) == DW_DLV_OK) {
  800420eb12:	48 b8 60 b6 22 04 80 	movabs $0x800422b660,%rax
  800420eb19:	00 00 00 
  800420eb1c:	48 8b 08             	mov    (%rax),%rcx
  800420eb1f:	48 b8 58 b6 22 04 80 	movabs $0x800422b658,%rax
  800420eb26:	00 00 00 
  800420eb29:	48 8b 10             	mov    (%rax),%rdx
  800420eb2c:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420eb33:	00 00 00 
  800420eb36:	48 8b 00             	mov    (%rax),%rax
  800420eb39:	48 8b b5 38 6e ff ff 	mov    -0x91c8(%rbp),%rsi
  800420eb40:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420eb46:	48 89 c7             	mov    %rax,%rdi
  800420eb49:	48 b8 ca 1e 21 04 80 	movabs $0x8004211eca,%rax
  800420eb50:	00 00 00 
  800420eb53:	ff d0                	callq  *%rax
  800420eb55:	85 c0                	test   %eax,%eax
  800420eb57:	75 4a                	jne    800420eba3 <debuginfo_rip+0x4ba>
		dwarf_get_fde_info_for_all_regs(dbg, fde, addr, &info->reg_table,
  800420eb59:	48 8b 85 30 6e ff ff 	mov    -0x91d0(%rbp),%rax
  800420eb60:	48 8d 88 a8 00 00 00 	lea    0xa8(%rax),%rcx
  800420eb67:	48 b8 58 b6 22 04 80 	movabs $0x800422b658,%rax
  800420eb6e:	00 00 00 
  800420eb71:	48 8b 30             	mov    (%rax),%rsi
  800420eb74:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  800420eb7b:	00 00 00 
  800420eb7e:	48 8b 00             	mov    (%rax),%rax
  800420eb81:	48 8b 95 38 6e ff ff 	mov    -0x91c8(%rbp),%rdx
  800420eb88:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  800420eb8e:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  800420eb94:	48 89 c7             	mov    %rax,%rdi
  800420eb97:	48 b8 eb 31 21 04 80 	movabs $0x80042131eb,%rax
  800420eb9e:	00 00 00 
  800420eba1:	ff d0                	callq  *%rax
					break;
			}
		}
#endif
	}
	return 0;
  800420eba3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420eba8:	48 81 c4 c8 91 00 00 	add    $0x91c8,%rsp
  800420ebaf:	5b                   	pop    %rbx
  800420ebb0:	5d                   	pop    %rbp
  800420ebb1:	c3                   	retq   

000000800420ebb2 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800420ebb2:	55                   	push   %rbp
  800420ebb3:	48 89 e5             	mov    %rsp,%rbp
  800420ebb6:	53                   	push   %rbx
  800420ebb7:	48 83 ec 38          	sub    $0x38,%rsp
  800420ebbb:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ebbf:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ebc3:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420ebc7:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  800420ebca:	44 89 45 d0          	mov    %r8d,-0x30(%rbp)
  800420ebce:	44 89 4d cc          	mov    %r9d,-0x34(%rbp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800420ebd2:	8b 45 d4             	mov    -0x2c(%rbp),%eax
  800420ebd5:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420ebd9:	77 3b                	ja     800420ec16 <printnum+0x64>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800420ebdb:	8b 45 d0             	mov    -0x30(%rbp),%eax
  800420ebde:	44 8d 40 ff          	lea    -0x1(%rax),%r8d
  800420ebe2:	8b 5d d4             	mov    -0x2c(%rbp),%ebx
  800420ebe5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ebe9:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ebee:	48 f7 f3             	div    %rbx
  800420ebf1:	48 89 c2             	mov    %rax,%rdx
  800420ebf4:	8b 7d cc             	mov    -0x34(%rbp),%edi
  800420ebf7:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ebfa:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800420ebfe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec02:	41 89 f9             	mov    %edi,%r9d
  800420ec05:	48 89 c7             	mov    %rax,%rdi
  800420ec08:	48 b8 b2 eb 20 04 80 	movabs $0x800420ebb2,%rax
  800420ec0f:	00 00 00 
  800420ec12:	ff d0                	callq  *%rax
  800420ec14:	eb 1e                	jmp    800420ec34 <printnum+0x82>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ec16:	eb 12                	jmp    800420ec2a <printnum+0x78>
			putch(padc, putdat);
  800420ec18:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ec1c:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800420ec1f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec23:	48 89 ce             	mov    %rcx,%rsi
  800420ec26:	89 d7                	mov    %edx,%edi
  800420ec28:	ff d0                	callq  *%rax
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800420ec2a:	83 6d d0 01          	subl   $0x1,-0x30(%rbp)
  800420ec2e:	83 7d d0 00          	cmpl   $0x0,-0x30(%rbp)
  800420ec32:	7f e4                	jg     800420ec18 <printnum+0x66>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800420ec34:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
  800420ec37:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ec3b:	ba 00 00 00 00       	mov    $0x0,%edx
  800420ec40:	48 f7 f1             	div    %rcx
  800420ec43:	48 89 d0             	mov    %rdx,%rax
  800420ec46:	48 ba f0 9c 21 04 80 	movabs $0x8004219cf0,%rdx
  800420ec4d:	00 00 00 
  800420ec50:	0f b6 04 02          	movzbl (%rdx,%rax,1),%eax
  800420ec54:	0f be d0             	movsbl %al,%edx
  800420ec57:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
  800420ec5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec5f:	48 89 ce             	mov    %rcx,%rsi
  800420ec62:	89 d7                	mov    %edx,%edi
  800420ec64:	ff d0                	callq  *%rax
}
  800420ec66:	48 83 c4 38          	add    $0x38,%rsp
  800420ec6a:	5b                   	pop    %rbx
  800420ec6b:	5d                   	pop    %rbp
  800420ec6c:	c3                   	retq   

000000800420ec6d <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800420ec6d:	55                   	push   %rbp
  800420ec6e:	48 89 e5             	mov    %rsp,%rbp
  800420ec71:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ec75:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ec79:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	unsigned long long x;    
	if (lflag >= 2)
  800420ec7c:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ec80:	7e 52                	jle    800420ecd4 <getuint+0x67>
		x= va_arg(*ap, unsigned long long);
  800420ec82:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec86:	8b 00                	mov    (%rax),%eax
  800420ec88:	83 f8 30             	cmp    $0x30,%eax
  800420ec8b:	73 24                	jae    800420ecb1 <getuint+0x44>
  800420ec8d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec91:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ec95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ec99:	8b 00                	mov    (%rax),%eax
  800420ec9b:	89 c0                	mov    %eax,%eax
  800420ec9d:	48 01 d0             	add    %rdx,%rax
  800420eca0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420eca4:	8b 12                	mov    (%rdx),%edx
  800420eca6:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420eca9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ecad:	89 0a                	mov    %ecx,(%rdx)
  800420ecaf:	eb 17                	jmp    800420ecc8 <getuint+0x5b>
  800420ecb1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecb5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ecb9:	48 89 d0             	mov    %rdx,%rax
  800420ecbc:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ecc0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ecc4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ecc8:	48 8b 00             	mov    (%rax),%rax
  800420eccb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420eccf:	e9 a3 00 00 00       	jmpq   800420ed77 <getuint+0x10a>
	else if (lflag)
  800420ecd4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ecd8:	74 4f                	je     800420ed29 <getuint+0xbc>
		x= va_arg(*ap, unsigned long);
  800420ecda:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecde:	8b 00                	mov    (%rax),%eax
  800420ece0:	83 f8 30             	cmp    $0x30,%eax
  800420ece3:	73 24                	jae    800420ed09 <getuint+0x9c>
  800420ece5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ece9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420eced:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ecf1:	8b 00                	mov    (%rax),%eax
  800420ecf3:	89 c0                	mov    %eax,%eax
  800420ecf5:	48 01 d0             	add    %rdx,%rax
  800420ecf8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ecfc:	8b 12                	mov    (%rdx),%edx
  800420ecfe:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ed01:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed05:	89 0a                	mov    %ecx,(%rdx)
  800420ed07:	eb 17                	jmp    800420ed20 <getuint+0xb3>
  800420ed09:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed0d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ed11:	48 89 d0             	mov    %rdx,%rax
  800420ed14:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ed18:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed1c:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ed20:	48 8b 00             	mov    (%rax),%rax
  800420ed23:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ed27:	eb 4e                	jmp    800420ed77 <getuint+0x10a>
	else
		x= va_arg(*ap, unsigned int);
  800420ed29:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed2d:	8b 00                	mov    (%rax),%eax
  800420ed2f:	83 f8 30             	cmp    $0x30,%eax
  800420ed32:	73 24                	jae    800420ed58 <getuint+0xeb>
  800420ed34:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed38:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ed3c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed40:	8b 00                	mov    (%rax),%eax
  800420ed42:	89 c0                	mov    %eax,%eax
  800420ed44:	48 01 d0             	add    %rdx,%rax
  800420ed47:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed4b:	8b 12                	mov    (%rdx),%edx
  800420ed4d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ed50:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed54:	89 0a                	mov    %ecx,(%rdx)
  800420ed56:	eb 17                	jmp    800420ed6f <getuint+0x102>
  800420ed58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed5c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ed60:	48 89 d0             	mov    %rdx,%rax
  800420ed63:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ed67:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ed6b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ed6f:	8b 00                	mov    (%rax),%eax
  800420ed71:	89 c0                	mov    %eax,%eax
  800420ed73:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ed77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ed7b:	c9                   	leaveq 
  800420ed7c:	c3                   	retq   

000000800420ed7d <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
  800420ed7d:	55                   	push   %rbp
  800420ed7e:	48 89 e5             	mov    %rsp,%rbp
  800420ed81:	48 83 ec 1c          	sub    $0x1c,%rsp
  800420ed85:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ed89:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	long long x;
	if (lflag >= 2)
  800420ed8c:	83 7d e4 01          	cmpl   $0x1,-0x1c(%rbp)
  800420ed90:	7e 52                	jle    800420ede4 <getint+0x67>
		x=va_arg(*ap, long long);
  800420ed92:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ed96:	8b 00                	mov    (%rax),%eax
  800420ed98:	83 f8 30             	cmp    $0x30,%eax
  800420ed9b:	73 24                	jae    800420edc1 <getint+0x44>
  800420ed9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eda1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420eda5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420eda9:	8b 00                	mov    (%rax),%eax
  800420edab:	89 c0                	mov    %eax,%eax
  800420edad:	48 01 d0             	add    %rdx,%rax
  800420edb0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420edb4:	8b 12                	mov    (%rdx),%edx
  800420edb6:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420edb9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420edbd:	89 0a                	mov    %ecx,(%rdx)
  800420edbf:	eb 17                	jmp    800420edd8 <getint+0x5b>
  800420edc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edc5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420edc9:	48 89 d0             	mov    %rdx,%rax
  800420edcc:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420edd0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420edd4:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420edd8:	48 8b 00             	mov    (%rax),%rax
  800420eddb:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420eddf:	e9 a3 00 00 00       	jmpq   800420ee87 <getint+0x10a>
	else if (lflag)
  800420ede4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800420ede8:	74 4f                	je     800420ee39 <getint+0xbc>
		x=va_arg(*ap, long);
  800420edea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edee:	8b 00                	mov    (%rax),%eax
  800420edf0:	83 f8 30             	cmp    $0x30,%eax
  800420edf3:	73 24                	jae    800420ee19 <getint+0x9c>
  800420edf5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420edf9:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420edfd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee01:	8b 00                	mov    (%rax),%eax
  800420ee03:	89 c0                	mov    %eax,%eax
  800420ee05:	48 01 d0             	add    %rdx,%rax
  800420ee08:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee0c:	8b 12                	mov    (%rdx),%edx
  800420ee0e:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ee11:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee15:	89 0a                	mov    %ecx,(%rdx)
  800420ee17:	eb 17                	jmp    800420ee30 <getint+0xb3>
  800420ee19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee1d:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ee21:	48 89 d0             	mov    %rdx,%rax
  800420ee24:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ee28:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee2c:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ee30:	48 8b 00             	mov    (%rax),%rax
  800420ee33:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800420ee37:	eb 4e                	jmp    800420ee87 <getint+0x10a>
	else
		x=va_arg(*ap, int);
  800420ee39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee3d:	8b 00                	mov    (%rax),%eax
  800420ee3f:	83 f8 30             	cmp    $0x30,%eax
  800420ee42:	73 24                	jae    800420ee68 <getint+0xeb>
  800420ee44:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee48:	48 8b 50 10          	mov    0x10(%rax),%rdx
  800420ee4c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee50:	8b 00                	mov    (%rax),%eax
  800420ee52:	89 c0                	mov    %eax,%eax
  800420ee54:	48 01 d0             	add    %rdx,%rax
  800420ee57:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee5b:	8b 12                	mov    (%rdx),%edx
  800420ee5d:	8d 4a 08             	lea    0x8(%rdx),%ecx
  800420ee60:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee64:	89 0a                	mov    %ecx,(%rdx)
  800420ee66:	eb 17                	jmp    800420ee7f <getint+0x102>
  800420ee68:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ee6c:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800420ee70:	48 89 d0             	mov    %rdx,%rax
  800420ee73:	48 8d 4a 08          	lea    0x8(%rdx),%rcx
  800420ee77:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420ee7b:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  800420ee7f:	8b 00                	mov    (%rax),%eax
  800420ee81:	48 98                	cltq   
  800420ee83:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	return x;
  800420ee87:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420ee8b:	c9                   	leaveq 
  800420ee8c:	c3                   	retq   

000000800420ee8d <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800420ee8d:	55                   	push   %rbp
  800420ee8e:	48 89 e5             	mov    %rsp,%rbp
  800420ee91:	41 54                	push   %r12
  800420ee93:	53                   	push   %rbx
  800420ee94:	48 83 ec 60          	sub    $0x60,%rsp
  800420ee98:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  800420ee9c:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
  800420eea0:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420eea4:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
	register int ch, err;
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
  800420eea8:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420eeac:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  800420eeb0:	48 8b 0a             	mov    (%rdx),%rcx
  800420eeb3:	48 89 08             	mov    %rcx,(%rax)
  800420eeb6:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420eeba:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420eebe:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420eec2:	48 89 50 10          	mov    %rdx,0x10(%rax)
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420eec6:	eb 17                	jmp    800420eedf <vprintfmt+0x52>
			if (ch == '\0')
  800420eec8:	85 db                	test   %ebx,%ebx
  800420eeca:	0f 84 cc 04 00 00    	je     800420f39c <vprintfmt+0x50f>
				return;
			putch(ch, putdat);
  800420eed0:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420eed4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420eed8:	48 89 d6             	mov    %rdx,%rsi
  800420eedb:	89 df                	mov    %ebx,%edi
  800420eedd:	ff d0                	callq  *%rax
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420eedf:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420eee3:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420eee7:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420eeeb:	0f b6 00             	movzbl (%rax),%eax
  800420eeee:	0f b6 d8             	movzbl %al,%ebx
  800420eef1:	83 fb 25             	cmp    $0x25,%ebx
  800420eef4:	75 d2                	jne    800420eec8 <vprintfmt+0x3b>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
  800420eef6:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
		width = -1;
  800420eefa:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%rbp)
		precision = -1;
  800420ef01:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
		lflag = 0;
  800420ef08:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
		altflag = 0;
  800420ef0f:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800420ef16:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ef1a:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420ef1e:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
  800420ef22:	0f b6 00             	movzbl (%rax),%eax
  800420ef25:	0f b6 d8             	movzbl %al,%ebx
  800420ef28:	8d 43 dd             	lea    -0x23(%rbx),%eax
  800420ef2b:	83 f8 55             	cmp    $0x55,%eax
  800420ef2e:	0f 87 34 04 00 00    	ja     800420f368 <vprintfmt+0x4db>
  800420ef34:	89 c0                	mov    %eax,%eax
  800420ef36:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800420ef3d:	00 
  800420ef3e:	48 b8 18 9d 21 04 80 	movabs $0x8004219d18,%rax
  800420ef45:	00 00 00 
  800420ef48:	48 01 d0             	add    %rdx,%rax
  800420ef4b:	48 8b 00             	mov    (%rax),%rax
  800420ef4e:	ff e0                	jmpq   *%rax

			// flag to pad on the right
		case '-':
			padc = '-';
  800420ef50:	c6 45 d3 2d          	movb   $0x2d,-0x2d(%rbp)
			goto reswitch;
  800420ef54:	eb c0                	jmp    800420ef16 <vprintfmt+0x89>

			// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800420ef56:	c6 45 d3 30          	movb   $0x30,-0x2d(%rbp)
			goto reswitch;
  800420ef5a:	eb ba                	jmp    800420ef16 <vprintfmt+0x89>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420ef5c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
				precision = precision * 10 + ch - '0';
  800420ef63:	8b 55 d8             	mov    -0x28(%rbp),%edx
  800420ef66:	89 d0                	mov    %edx,%eax
  800420ef68:	c1 e0 02             	shl    $0x2,%eax
  800420ef6b:	01 d0                	add    %edx,%eax
  800420ef6d:	01 c0                	add    %eax,%eax
  800420ef6f:	01 d8                	add    %ebx,%eax
  800420ef71:	83 e8 30             	sub    $0x30,%eax
  800420ef74:	89 45 d8             	mov    %eax,-0x28(%rbp)
				ch = *fmt;
  800420ef77:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420ef7b:	0f b6 00             	movzbl (%rax),%eax
  800420ef7e:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
  800420ef81:	83 fb 2f             	cmp    $0x2f,%ebx
  800420ef84:	7e 0c                	jle    800420ef92 <vprintfmt+0x105>
  800420ef86:	83 fb 39             	cmp    $0x39,%ebx
  800420ef89:	7f 07                	jg     800420ef92 <vprintfmt+0x105>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800420ef8b:	48 83 45 98 01       	addq   $0x1,-0x68(%rbp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  800420ef90:	eb d1                	jmp    800420ef63 <vprintfmt+0xd6>
			goto process_precision;
  800420ef92:	eb 58                	jmp    800420efec <vprintfmt+0x15f>

		case '*':
			precision = va_arg(aq, int);
  800420ef94:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420ef97:	83 f8 30             	cmp    $0x30,%eax
  800420ef9a:	73 17                	jae    800420efb3 <vprintfmt+0x126>
  800420ef9c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420efa0:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420efa3:	89 c0                	mov    %eax,%eax
  800420efa5:	48 01 d0             	add    %rdx,%rax
  800420efa8:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420efab:	83 c2 08             	add    $0x8,%edx
  800420efae:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420efb1:	eb 0f                	jmp    800420efc2 <vprintfmt+0x135>
  800420efb3:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420efb7:	48 89 d0             	mov    %rdx,%rax
  800420efba:	48 83 c2 08          	add    $0x8,%rdx
  800420efbe:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420efc2:	8b 00                	mov    (%rax),%eax
  800420efc4:	89 45 d8             	mov    %eax,-0x28(%rbp)
			goto process_precision;
  800420efc7:	eb 23                	jmp    800420efec <vprintfmt+0x15f>

		case '.':
			if (width < 0)
  800420efc9:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420efcd:	79 0c                	jns    800420efdb <vprintfmt+0x14e>
				width = 0;
  800420efcf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
			goto reswitch;
  800420efd6:	e9 3b ff ff ff       	jmpq   800420ef16 <vprintfmt+0x89>
  800420efdb:	e9 36 ff ff ff       	jmpq   800420ef16 <vprintfmt+0x89>

		case '#':
			altflag = 1;
  800420efe0:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%rbp)
			goto reswitch;
  800420efe7:	e9 2a ff ff ff       	jmpq   800420ef16 <vprintfmt+0x89>

		process_precision:
			if (width < 0)
  800420efec:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420eff0:	79 12                	jns    800420f004 <vprintfmt+0x177>
				width = precision, precision = -1;
  800420eff2:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420eff5:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800420eff8:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%rbp)
			goto reswitch;
  800420efff:	e9 12 ff ff ff       	jmpq   800420ef16 <vprintfmt+0x89>
  800420f004:	e9 0d ff ff ff       	jmpq   800420ef16 <vprintfmt+0x89>

			// long flag (doubled for long long)
		case 'l':
			lflag++;
  800420f009:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
			goto reswitch;
  800420f00d:	e9 04 ff ff ff       	jmpq   800420ef16 <vprintfmt+0x89>

			// character
		case 'c':
			putch(va_arg(aq, int), putdat);
  800420f012:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f015:	83 f8 30             	cmp    $0x30,%eax
  800420f018:	73 17                	jae    800420f031 <vprintfmt+0x1a4>
  800420f01a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f01e:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f021:	89 c0                	mov    %eax,%eax
  800420f023:	48 01 d0             	add    %rdx,%rax
  800420f026:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f029:	83 c2 08             	add    $0x8,%edx
  800420f02c:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f02f:	eb 0f                	jmp    800420f040 <vprintfmt+0x1b3>
  800420f031:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f035:	48 89 d0             	mov    %rdx,%rax
  800420f038:	48 83 c2 08          	add    $0x8,%rdx
  800420f03c:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f040:	8b 10                	mov    (%rax),%edx
  800420f042:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f046:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f04a:	48 89 ce             	mov    %rcx,%rsi
  800420f04d:	89 d7                	mov    %edx,%edi
  800420f04f:	ff d0                	callq  *%rax
			break;
  800420f051:	e9 40 03 00 00       	jmpq   800420f396 <vprintfmt+0x509>

			// error message
		case 'e':
			err = va_arg(aq, int);
  800420f056:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f059:	83 f8 30             	cmp    $0x30,%eax
  800420f05c:	73 17                	jae    800420f075 <vprintfmt+0x1e8>
  800420f05e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f062:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f065:	89 c0                	mov    %eax,%eax
  800420f067:	48 01 d0             	add    %rdx,%rax
  800420f06a:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f06d:	83 c2 08             	add    $0x8,%edx
  800420f070:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f073:	eb 0f                	jmp    800420f084 <vprintfmt+0x1f7>
  800420f075:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f079:	48 89 d0             	mov    %rdx,%rax
  800420f07c:	48 83 c2 08          	add    $0x8,%rdx
  800420f080:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f084:	8b 18                	mov    (%rax),%ebx
			if (err < 0)
  800420f086:	85 db                	test   %ebx,%ebx
  800420f088:	79 02                	jns    800420f08c <vprintfmt+0x1ff>
				err = -err;
  800420f08a:	f7 db                	neg    %ebx
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  800420f08c:	83 fb 15             	cmp    $0x15,%ebx
  800420f08f:	7f 16                	jg     800420f0a7 <vprintfmt+0x21a>
  800420f091:	48 b8 40 9c 21 04 80 	movabs $0x8004219c40,%rax
  800420f098:	00 00 00 
  800420f09b:	48 63 d3             	movslq %ebx,%rdx
  800420f09e:	4c 8b 24 d0          	mov    (%rax,%rdx,8),%r12
  800420f0a2:	4d 85 e4             	test   %r12,%r12
  800420f0a5:	75 2e                	jne    800420f0d5 <vprintfmt+0x248>
				printfmt(putch, putdat, "error %d", err);
  800420f0a7:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f0ab:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f0af:	89 d9                	mov    %ebx,%ecx
  800420f0b1:	48 ba 01 9d 21 04 80 	movabs $0x8004219d01,%rdx
  800420f0b8:	00 00 00 
  800420f0bb:	48 89 c7             	mov    %rax,%rdi
  800420f0be:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f0c3:	49 b8 a5 f3 20 04 80 	movabs $0x800420f3a5,%r8
  800420f0ca:	00 00 00 
  800420f0cd:	41 ff d0             	callq  *%r8
			else
				printfmt(putch, putdat, "%s", p);
			break;
  800420f0d0:	e9 c1 02 00 00       	jmpq   800420f396 <vprintfmt+0x509>
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800420f0d5:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f0d9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f0dd:	4c 89 e1             	mov    %r12,%rcx
  800420f0e0:	48 ba 0a 9d 21 04 80 	movabs $0x8004219d0a,%rdx
  800420f0e7:	00 00 00 
  800420f0ea:	48 89 c7             	mov    %rax,%rdi
  800420f0ed:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f0f2:	49 b8 a5 f3 20 04 80 	movabs $0x800420f3a5,%r8
  800420f0f9:	00 00 00 
  800420f0fc:	41 ff d0             	callq  *%r8
			break;
  800420f0ff:	e9 92 02 00 00       	jmpq   800420f396 <vprintfmt+0x509>

			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
  800420f104:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f107:	83 f8 30             	cmp    $0x30,%eax
  800420f10a:	73 17                	jae    800420f123 <vprintfmt+0x296>
  800420f10c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f110:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f113:	89 c0                	mov    %eax,%eax
  800420f115:	48 01 d0             	add    %rdx,%rax
  800420f118:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f11b:	83 c2 08             	add    $0x8,%edx
  800420f11e:	89 55 b8             	mov    %edx,-0x48(%rbp)
  800420f121:	eb 0f                	jmp    800420f132 <vprintfmt+0x2a5>
  800420f123:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f127:	48 89 d0             	mov    %rdx,%rax
  800420f12a:	48 83 c2 08          	add    $0x8,%rdx
  800420f12e:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f132:	4c 8b 20             	mov    (%rax),%r12
  800420f135:	4d 85 e4             	test   %r12,%r12
  800420f138:	75 0a                	jne    800420f144 <vprintfmt+0x2b7>
				p = "(null)";
  800420f13a:	49 bc 0d 9d 21 04 80 	movabs $0x8004219d0d,%r12
  800420f141:	00 00 00 
			if (width > 0 && padc != '-')
  800420f144:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f148:	7e 3f                	jle    800420f189 <vprintfmt+0x2fc>
  800420f14a:	80 7d d3 2d          	cmpb   $0x2d,-0x2d(%rbp)
  800420f14e:	74 39                	je     800420f189 <vprintfmt+0x2fc>
				for (width -= strnlen(p, precision); width > 0; width--)
  800420f150:	8b 45 d8             	mov    -0x28(%rbp),%eax
  800420f153:	48 98                	cltq   
  800420f155:	48 89 c6             	mov    %rax,%rsi
  800420f158:	4c 89 e7             	mov    %r12,%rdi
  800420f15b:	48 b8 a6 f7 20 04 80 	movabs $0x800420f7a6,%rax
  800420f162:	00 00 00 
  800420f165:	ff d0                	callq  *%rax
  800420f167:	29 45 dc             	sub    %eax,-0x24(%rbp)
  800420f16a:	eb 17                	jmp    800420f183 <vprintfmt+0x2f6>
					putch(padc, putdat);
  800420f16c:	0f be 55 d3          	movsbl -0x2d(%rbp),%edx
  800420f170:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  800420f174:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f178:	48 89 ce             	mov    %rcx,%rsi
  800420f17b:	89 d7                	mov    %edx,%edi
  800420f17d:	ff d0                	callq  *%rax
			// string
		case 's':
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800420f17f:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f183:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f187:	7f e3                	jg     800420f16c <vprintfmt+0x2df>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420f189:	eb 37                	jmp    800420f1c2 <vprintfmt+0x335>
				if (altflag && (ch < ' ' || ch > '~'))
  800420f18b:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
  800420f18f:	74 1e                	je     800420f1af <vprintfmt+0x322>
  800420f191:	83 fb 1f             	cmp    $0x1f,%ebx
  800420f194:	7e 05                	jle    800420f19b <vprintfmt+0x30e>
  800420f196:	83 fb 7e             	cmp    $0x7e,%ebx
  800420f199:	7e 14                	jle    800420f1af <vprintfmt+0x322>
					putch('?', putdat);
  800420f19b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f19f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f1a3:	48 89 d6             	mov    %rdx,%rsi
  800420f1a6:	bf 3f 00 00 00       	mov    $0x3f,%edi
  800420f1ab:	ff d0                	callq  *%rax
  800420f1ad:	eb 0f                	jmp    800420f1be <vprintfmt+0x331>
				else
					putch(ch, putdat);
  800420f1af:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f1b3:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f1b7:	48 89 d6             	mov    %rdx,%rsi
  800420f1ba:	89 df                	mov    %ebx,%edi
  800420f1bc:	ff d0                	callq  *%rax
			if ((p = va_arg(aq, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800420f1be:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f1c2:	4c 89 e0             	mov    %r12,%rax
  800420f1c5:	4c 8d 60 01          	lea    0x1(%rax),%r12
  800420f1c9:	0f b6 00             	movzbl (%rax),%eax
  800420f1cc:	0f be d8             	movsbl %al,%ebx
  800420f1cf:	85 db                	test   %ebx,%ebx
  800420f1d1:	74 10                	je     800420f1e3 <vprintfmt+0x356>
  800420f1d3:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f1d7:	78 b2                	js     800420f18b <vprintfmt+0x2fe>
  800420f1d9:	83 6d d8 01          	subl   $0x1,-0x28(%rbp)
  800420f1dd:	83 7d d8 00          	cmpl   $0x0,-0x28(%rbp)
  800420f1e1:	79 a8                	jns    800420f18b <vprintfmt+0x2fe>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f1e3:	eb 16                	jmp    800420f1fb <vprintfmt+0x36e>
				putch(' ', putdat);
  800420f1e5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f1e9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f1ed:	48 89 d6             	mov    %rdx,%rsi
  800420f1f0:	bf 20 00 00 00       	mov    $0x20,%edi
  800420f1f5:	ff d0                	callq  *%rax
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800420f1f7:	83 6d dc 01          	subl   $0x1,-0x24(%rbp)
  800420f1fb:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  800420f1ff:	7f e4                	jg     800420f1e5 <vprintfmt+0x358>
				putch(' ', putdat);
			break;
  800420f201:	e9 90 01 00 00       	jmpq   800420f396 <vprintfmt+0x509>

			// (signed) decimal
		case 'd':
			num = getint(&aq, 3);
  800420f206:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f20a:	be 03 00 00 00       	mov    $0x3,%esi
  800420f20f:	48 89 c7             	mov    %rax,%rdi
  800420f212:	48 b8 7d ed 20 04 80 	movabs $0x800420ed7d,%rax
  800420f219:	00 00 00 
  800420f21c:	ff d0                	callq  *%rax
  800420f21e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			if ((long long) num < 0) {
  800420f222:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f226:	48 85 c0             	test   %rax,%rax
  800420f229:	79 1d                	jns    800420f248 <vprintfmt+0x3bb>
				putch('-', putdat);
  800420f22b:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f22f:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f233:	48 89 d6             	mov    %rdx,%rsi
  800420f236:	bf 2d 00 00 00       	mov    $0x2d,%edi
  800420f23b:	ff d0                	callq  *%rax
				num = -(long long) num;
  800420f23d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f241:	48 f7 d8             	neg    %rax
  800420f244:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			}
			base = 10;
  800420f248:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f24f:	e9 d5 00 00 00       	jmpq   800420f329 <vprintfmt+0x49c>

			// unsigned decimal
		case 'u':
			num = getuint(&aq, 3);
  800420f254:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f258:	be 03 00 00 00       	mov    $0x3,%esi
  800420f25d:	48 89 c7             	mov    %rax,%rdi
  800420f260:	48 b8 6d ec 20 04 80 	movabs $0x800420ec6d,%rax
  800420f267:	00 00 00 
  800420f26a:	ff d0                	callq  *%rax
  800420f26c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 10;
  800420f270:	c7 45 e4 0a 00 00 00 	movl   $0xa,-0x1c(%rbp)
			goto number;
  800420f277:	e9 ad 00 00 00       	jmpq   800420f329 <vprintfmt+0x49c>

			// (unsigned) octal
		case 'o':
			// Replace this with your code.
			num = getint(&aq, lflag);
  800420f27c:	8b 55 e0             	mov    -0x20(%rbp),%edx
  800420f27f:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f283:	89 d6                	mov    %edx,%esi
  800420f285:	48 89 c7             	mov    %rax,%rdi
  800420f288:	48 b8 7d ed 20 04 80 	movabs $0x800420ed7d,%rax
  800420f28f:	00 00 00 
  800420f292:	ff d0                	callq  *%rax
  800420f294:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 8;
  800420f298:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
			goto number;
  800420f29f:	e9 85 00 00 00       	jmpq   800420f329 <vprintfmt+0x49c>


			// pointer
		case 'p':
			putch('0', putdat);
  800420f2a4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f2a8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f2ac:	48 89 d6             	mov    %rdx,%rsi
  800420f2af:	bf 30 00 00 00       	mov    $0x30,%edi
  800420f2b4:	ff d0                	callq  *%rax
			putch('x', putdat);
  800420f2b6:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f2ba:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f2be:	48 89 d6             	mov    %rdx,%rsi
  800420f2c1:	bf 78 00 00 00       	mov    $0x78,%edi
  800420f2c6:	ff d0                	callq  *%rax
			num = (unsigned long long)
				(uintptr_t) va_arg(aq, void *);
  800420f2c8:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f2cb:	83 f8 30             	cmp    $0x30,%eax
  800420f2ce:	73 17                	jae    800420f2e7 <vprintfmt+0x45a>
  800420f2d0:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800420f2d4:	8b 45 b8             	mov    -0x48(%rbp),%eax
  800420f2d7:	89 c0                	mov    %eax,%eax
  800420f2d9:	48 01 d0             	add    %rdx,%rax
  800420f2dc:	8b 55 b8             	mov    -0x48(%rbp),%edx
  800420f2df:	83 c2 08             	add    $0x8,%edx
  800420f2e2:	89 55 b8             	mov    %edx,-0x48(%rbp)

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f2e5:	eb 0f                	jmp    800420f2f6 <vprintfmt+0x469>
				(uintptr_t) va_arg(aq, void *);
  800420f2e7:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800420f2eb:	48 89 d0             	mov    %rdx,%rax
  800420f2ee:	48 83 c2 08          	add    $0x8,%rdx
  800420f2f2:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
  800420f2f6:	48 8b 00             	mov    (%rax),%rax

			// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  800420f2f9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				(uintptr_t) va_arg(aq, void *);
			base = 16;
  800420f2fd:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
			goto number;
  800420f304:	eb 23                	jmp    800420f329 <vprintfmt+0x49c>

			// (unsigned) hexadecimal
		case 'x':
			num = getuint(&aq, 3);
  800420f306:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
  800420f30a:	be 03 00 00 00       	mov    $0x3,%esi
  800420f30f:	48 89 c7             	mov    %rax,%rdi
  800420f312:	48 b8 6d ec 20 04 80 	movabs $0x800420ec6d,%rax
  800420f319:	00 00 00 
  800420f31c:	ff d0                	callq  *%rax
  800420f31e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
			base = 16;
  800420f322:	c7 45 e4 10 00 00 00 	movl   $0x10,-0x1c(%rbp)
		number:
			printnum(putch, putdat, num, base, width, padc);
  800420f329:	44 0f be 45 d3       	movsbl -0x2d(%rbp),%r8d
  800420f32e:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800420f331:	8b 7d dc             	mov    -0x24(%rbp),%edi
  800420f334:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f338:	48 8b 75 a0          	mov    -0x60(%rbp),%rsi
  800420f33c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f340:	45 89 c1             	mov    %r8d,%r9d
  800420f343:	41 89 f8             	mov    %edi,%r8d
  800420f346:	48 89 c7             	mov    %rax,%rdi
  800420f349:	48 b8 b2 eb 20 04 80 	movabs $0x800420ebb2,%rax
  800420f350:	00 00 00 
  800420f353:	ff d0                	callq  *%rax
			break;
  800420f355:	eb 3f                	jmp    800420f396 <vprintfmt+0x509>

			// escaped '%' character
		case '%':
			putch(ch, putdat);
  800420f357:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f35b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f35f:	48 89 d6             	mov    %rdx,%rsi
  800420f362:	89 df                	mov    %ebx,%edi
  800420f364:	ff d0                	callq  *%rax
			break;
  800420f366:	eb 2e                	jmp    800420f396 <vprintfmt+0x509>

			// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800420f368:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800420f36c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800420f370:	48 89 d6             	mov    %rdx,%rsi
  800420f373:	bf 25 00 00 00       	mov    $0x25,%edi
  800420f378:	ff d0                	callq  *%rax
			for (fmt--; fmt[-1] != '%'; fmt--)
  800420f37a:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f37f:	eb 05                	jmp    800420f386 <vprintfmt+0x4f9>
  800420f381:	48 83 6d 98 01       	subq   $0x1,-0x68(%rbp)
  800420f386:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800420f38a:	48 83 e8 01          	sub    $0x1,%rax
  800420f38e:	0f b6 00             	movzbl (%rax),%eax
  800420f391:	3c 25                	cmp    $0x25,%al
  800420f393:	75 ec                	jne    800420f381 <vprintfmt+0x4f4>
				/* do nothing */;
			break;
  800420f395:	90                   	nop
		}
	}
  800420f396:	90                   	nop
	int base, lflag, width, precision, altflag;
	char padc;
	va_list aq;
	va_copy(aq,ap);
	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800420f397:	e9 43 fb ff ff       	jmpq   800420eedf <vprintfmt+0x52>
				/* do nothing */;
			break;
		}
	}
	va_end(aq);
}
  800420f39c:	48 83 c4 60          	add    $0x60,%rsp
  800420f3a0:	5b                   	pop    %rbx
  800420f3a1:	41 5c                	pop    %r12
  800420f3a3:	5d                   	pop    %rbp
  800420f3a4:	c3                   	retq   

000000800420f3a5 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800420f3a5:	55                   	push   %rbp
  800420f3a6:	48 89 e5             	mov    %rsp,%rbp
  800420f3a9:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
  800420f3b0:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
  800420f3b7:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
  800420f3be:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f3c5:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f3cc:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f3d3:	84 c0                	test   %al,%al
  800420f3d5:	74 20                	je     800420f3f7 <printfmt+0x52>
  800420f3d7:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f3db:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f3df:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f3e3:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f3e7:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f3eb:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f3ef:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f3f3:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f3f7:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
	va_list ap;

	va_start(ap, fmt);
  800420f3fe:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
  800420f405:	00 00 00 
  800420f408:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
  800420f40f:	00 00 00 
  800420f412:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f416:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  800420f41d:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f424:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
	vprintfmt(putch, putdat, fmt, ap);
  800420f42b:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
  800420f432:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
  800420f439:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
  800420f440:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800420f447:	48 89 c7             	mov    %rax,%rdi
  800420f44a:	48 b8 8d ee 20 04 80 	movabs $0x800420ee8d,%rax
  800420f451:	00 00 00 
  800420f454:	ff d0                	callq  *%rax
	va_end(ap);
}
  800420f456:	c9                   	leaveq 
  800420f457:	c3                   	retq   

000000800420f458 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800420f458:	55                   	push   %rbp
  800420f459:	48 89 e5             	mov    %rsp,%rbp
  800420f45c:	48 83 ec 10          	sub    $0x10,%rsp
  800420f460:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800420f463:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	b->cnt++;
  800420f467:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f46b:	8b 40 10             	mov    0x10(%rax),%eax
  800420f46e:	8d 50 01             	lea    0x1(%rax),%edx
  800420f471:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f475:	89 50 10             	mov    %edx,0x10(%rax)
	if (b->buf < b->ebuf)
  800420f478:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f47c:	48 8b 10             	mov    (%rax),%rdx
  800420f47f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f483:	48 8b 40 08          	mov    0x8(%rax),%rax
  800420f487:	48 39 c2             	cmp    %rax,%rdx
  800420f48a:	73 17                	jae    800420f4a3 <sprintputch+0x4b>
		*b->buf++ = ch;
  800420f48c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f490:	48 8b 00             	mov    (%rax),%rax
  800420f493:	48 8d 48 01          	lea    0x1(%rax),%rcx
  800420f497:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420f49b:	48 89 0a             	mov    %rcx,(%rdx)
  800420f49e:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800420f4a1:	88 10                	mov    %dl,(%rax)
}
  800420f4a3:	c9                   	leaveq 
  800420f4a4:	c3                   	retq   

000000800420f4a5 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  800420f4a5:	55                   	push   %rbp
  800420f4a6:	48 89 e5             	mov    %rsp,%rbp
  800420f4a9:	48 83 ec 50          	sub    $0x50,%rsp
  800420f4ad:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  800420f4b1:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  800420f4b4:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  800420f4b8:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	va_list aq;
	va_copy(aq,ap);
  800420f4bc:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
  800420f4c0:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  800420f4c4:	48 8b 0a             	mov    (%rdx),%rcx
  800420f4c7:	48 89 08             	mov    %rcx,(%rax)
  800420f4ca:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f4ce:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f4d2:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f4d6:	48 89 50 10          	mov    %rdx,0x10(%rax)
	struct sprintbuf b = {buf, buf+n-1, 0};
  800420f4da:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f4de:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  800420f4e2:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  800420f4e5:	48 98                	cltq   
  800420f4e7:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420f4eb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800420f4ef:	48 01 d0             	add    %rdx,%rax
  800420f4f2:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800420f4f6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)

	if (buf == NULL || n < 1)
  800420f4fd:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800420f502:	74 06                	je     800420f50a <vsnprintf+0x65>
  800420f504:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  800420f508:	7f 07                	jg     800420f511 <vsnprintf+0x6c>
		return -E_INVAL;
  800420f50a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  800420f50f:	eb 2f                	jmp    800420f540 <vsnprintf+0x9b>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, aq);
  800420f511:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800420f515:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800420f519:	48 8d 45 d0          	lea    -0x30(%rbp),%rax
  800420f51d:	48 89 c6             	mov    %rax,%rsi
  800420f520:	48 bf 58 f4 20 04 80 	movabs $0x800420f458,%rdi
  800420f527:	00 00 00 
  800420f52a:	48 b8 8d ee 20 04 80 	movabs $0x800420ee8d,%rax
  800420f531:	00 00 00 
  800420f534:	ff d0                	callq  *%rax
	va_end(aq);
	// null terminate the buffer
	*b.buf = '\0';
  800420f536:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420f53a:	c6 00 00             	movb   $0x0,(%rax)

	return b.cnt;
  800420f53d:	8b 45 e0             	mov    -0x20(%rbp),%eax
}
  800420f540:	c9                   	leaveq 
  800420f541:	c3                   	retq   

000000800420f542 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  800420f542:	55                   	push   %rbp
  800420f543:	48 89 e5             	mov    %rsp,%rbp
  800420f546:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  800420f54d:	48 89 bd 08 ff ff ff 	mov    %rdi,-0xf8(%rbp)
  800420f554:	89 b5 04 ff ff ff    	mov    %esi,-0xfc(%rbp)
  800420f55a:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
  800420f561:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
  800420f568:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
  800420f56f:	84 c0                	test   %al,%al
  800420f571:	74 20                	je     800420f593 <snprintf+0x51>
  800420f573:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
  800420f577:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
  800420f57b:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
  800420f57f:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
  800420f583:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
  800420f587:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
  800420f58b:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
  800420f58f:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
  800420f593:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
	va_list ap;
	int rc;
	va_list aq;
	va_start(ap, fmt);
  800420f59a:	c7 85 30 ff ff ff 18 	movl   $0x18,-0xd0(%rbp)
  800420f5a1:	00 00 00 
  800420f5a4:	c7 85 34 ff ff ff 30 	movl   $0x30,-0xcc(%rbp)
  800420f5ab:	00 00 00 
  800420f5ae:	48 8d 45 10          	lea    0x10(%rbp),%rax
  800420f5b2:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  800420f5b9:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800420f5c0:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
	va_copy(aq,ap);
  800420f5c7:	48 8d 85 18 ff ff ff 	lea    -0xe8(%rbp),%rax
  800420f5ce:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
  800420f5d5:	48 8b 0a             	mov    (%rdx),%rcx
  800420f5d8:	48 89 08             	mov    %rcx,(%rax)
  800420f5db:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  800420f5df:	48 89 48 08          	mov    %rcx,0x8(%rax)
  800420f5e3:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  800420f5e7:	48 89 50 10          	mov    %rdx,0x10(%rax)
	rc = vsnprintf(buf, n, fmt, aq);
  800420f5eb:	48 8d 8d 18 ff ff ff 	lea    -0xe8(%rbp),%rcx
  800420f5f2:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  800420f5f9:	8b b5 04 ff ff ff    	mov    -0xfc(%rbp),%esi
  800420f5ff:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  800420f606:	48 89 c7             	mov    %rax,%rdi
  800420f609:	48 b8 a5 f4 20 04 80 	movabs $0x800420f4a5,%rax
  800420f610:	00 00 00 
  800420f613:	ff d0                	callq  *%rax
  800420f615:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
	va_end(aq);

	return rc;
  800420f61b:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
}
  800420f621:	c9                   	leaveq 
  800420f622:	c3                   	retq   

000000800420f623 <readline>:
#define BUFLEN 1024
static char buf[BUFLEN];

char *
readline(const char *prompt)
{
  800420f623:	55                   	push   %rbp
  800420f624:	48 89 e5             	mov    %rsp,%rbp
  800420f627:	48 83 ec 20          	sub    $0x20,%rsp
  800420f62b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int i, c, echoing;

#if JOS_KERNEL
	if (prompt != NULL)
  800420f62f:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f634:	74 22                	je     800420f658 <readline+0x35>
		cprintf("%s", prompt);
  800420f636:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f63a:	48 89 c6             	mov    %rax,%rsi
  800420f63d:	48 bf c8 9f 21 04 80 	movabs $0x8004219fc8,%rdi
  800420f644:	00 00 00 
  800420f647:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f64c:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420f653:	00 00 00 
  800420f656:	ff d2                	callq  *%rdx
#else
	if (prompt != NULL)
		fprintf(1, "%s", prompt);
#endif

	i = 0;
  800420f658:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	echoing = iscons(0);
  800420f65f:	bf 00 00 00 00       	mov    $0x0,%edi
  800420f664:	48 b8 ef 13 20 04 80 	movabs $0x80042013ef,%rax
  800420f66b:	00 00 00 
  800420f66e:	ff d0                	callq  *%rax
  800420f670:	89 45 f8             	mov    %eax,-0x8(%rbp)
	while (1) {
		c = getchar();
  800420f673:	48 b8 cd 13 20 04 80 	movabs $0x80042013cd,%rax
  800420f67a:	00 00 00 
  800420f67d:	ff d0                	callq  *%rax
  800420f67f:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (c < 0) {
  800420f682:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  800420f686:	79 30                	jns    800420f6b8 <readline+0x95>
			if (c != -E_EOF)
  800420f688:	83 7d f4 f7          	cmpl   $0xfffffff7,-0xc(%rbp)
  800420f68c:	74 20                	je     800420f6ae <readline+0x8b>
				cprintf("read error: %e\n", c);
  800420f68e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f691:	89 c6                	mov    %eax,%esi
  800420f693:	48 bf cb 9f 21 04 80 	movabs $0x8004219fcb,%rdi
  800420f69a:	00 00 00 
  800420f69d:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6a2:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800420f6a9:	00 00 00 
  800420f6ac:	ff d2                	callq  *%rdx
			return NULL;
  800420f6ae:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f6b3:	e9 be 00 00 00       	jmpq   800420f776 <readline+0x153>
		} else if ((c == '\b' || c == '\x7f') && i > 0) {
  800420f6b8:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  800420f6bc:	74 06                	je     800420f6c4 <readline+0xa1>
  800420f6be:	83 7d f4 7f          	cmpl   $0x7f,-0xc(%rbp)
  800420f6c2:	75 26                	jne    800420f6ea <readline+0xc7>
  800420f6c4:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420f6c8:	7e 20                	jle    800420f6ea <readline+0xc7>
			if (echoing)
  800420f6ca:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f6ce:	74 11                	je     800420f6e1 <readline+0xbe>
				cputchar('\b');
  800420f6d0:	bf 08 00 00 00       	mov    $0x8,%edi
  800420f6d5:	48 b8 af 13 20 04 80 	movabs $0x80042013af,%rax
  800420f6dc:	00 00 00 
  800420f6df:	ff d0                	callq  *%rax
			i--;
  800420f6e1:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
  800420f6e5:	e9 87 00 00 00       	jmpq   800420f771 <readline+0x14e>
		} else if (c >= ' ' && i < BUFLEN-1) {
  800420f6ea:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800420f6ee:	7e 3f                	jle    800420f72f <readline+0x10c>
  800420f6f0:	81 7d fc fe 03 00 00 	cmpl   $0x3fe,-0x4(%rbp)
  800420f6f7:	7f 36                	jg     800420f72f <readline+0x10c>
			if (echoing)
  800420f6f9:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f6fd:	74 11                	je     800420f710 <readline+0xed>
				cputchar(c);
  800420f6ff:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420f702:	89 c7                	mov    %eax,%edi
  800420f704:	48 b8 af 13 20 04 80 	movabs $0x80042013af,%rax
  800420f70b:	00 00 00 
  800420f70e:	ff d0                	callq  *%rax
			buf[i++] = c;
  800420f710:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f713:	8d 50 01             	lea    0x1(%rax),%edx
  800420f716:	89 55 fc             	mov    %edx,-0x4(%rbp)
  800420f719:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800420f71c:	89 d1                	mov    %edx,%ecx
  800420f71e:	48 ba c0 92 37 04 80 	movabs $0x80043792c0,%rdx
  800420f725:	00 00 00 
  800420f728:	48 98                	cltq   
  800420f72a:	88 0c 02             	mov    %cl,(%rdx,%rax,1)
  800420f72d:	eb 42                	jmp    800420f771 <readline+0x14e>
		} else if (c == '\n' || c == '\r') {
  800420f72f:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
  800420f733:	74 06                	je     800420f73b <readline+0x118>
  800420f735:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
  800420f739:	75 36                	jne    800420f771 <readline+0x14e>
			if (echoing)
  800420f73b:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  800420f73f:	74 11                	je     800420f752 <readline+0x12f>
				cputchar('\n');
  800420f741:	bf 0a 00 00 00       	mov    $0xa,%edi
  800420f746:	48 b8 af 13 20 04 80 	movabs $0x80042013af,%rax
  800420f74d:	00 00 00 
  800420f750:	ff d0                	callq  *%rax
			buf[i] = 0;
  800420f752:	48 ba c0 92 37 04 80 	movabs $0x80043792c0,%rdx
  800420f759:	00 00 00 
  800420f75c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f75f:	48 98                	cltq   
  800420f761:	c6 04 02 00          	movb   $0x0,(%rdx,%rax,1)
			return buf;
  800420f765:	48 b8 c0 92 37 04 80 	movabs $0x80043792c0,%rax
  800420f76c:	00 00 00 
  800420f76f:	eb 05                	jmp    800420f776 <readline+0x153>
		}
	}
  800420f771:	e9 fd fe ff ff       	jmpq   800420f673 <readline+0x50>
}
  800420f776:	c9                   	leaveq 
  800420f777:	c3                   	retq   

000000800420f778 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  800420f778:	55                   	push   %rbp
  800420f779:	48 89 e5             	mov    %rsp,%rbp
  800420f77c:	48 83 ec 18          	sub    $0x18,%rsp
  800420f780:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f784:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f78b:	eb 09                	jmp    800420f796 <strlen+0x1e>
		n++;
  800420f78d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  800420f791:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f796:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f79a:	0f b6 00             	movzbl (%rax),%eax
  800420f79d:	84 c0                	test   %al,%al
  800420f79f:	75 ec                	jne    800420f78d <strlen+0x15>
		n++;
	return n;
  800420f7a1:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f7a4:	c9                   	leaveq 
  800420f7a5:	c3                   	retq   

000000800420f7a6 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  800420f7a6:	55                   	push   %rbp
  800420f7a7:	48 89 e5             	mov    %rsp,%rbp
  800420f7aa:	48 83 ec 20          	sub    $0x20,%rsp
  800420f7ae:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f7b2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f7b6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800420f7bd:	eb 0e                	jmp    800420f7cd <strnlen+0x27>
		n++;
  800420f7bf:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  800420f7c3:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420f7c8:	48 83 6d e0 01       	subq   $0x1,-0x20(%rbp)
  800420f7cd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800420f7d2:	74 0b                	je     800420f7df <strnlen+0x39>
  800420f7d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7d8:	0f b6 00             	movzbl (%rax),%eax
  800420f7db:	84 c0                	test   %al,%al
  800420f7dd:	75 e0                	jne    800420f7bf <strnlen+0x19>
		n++;
	return n;
  800420f7df:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  800420f7e2:	c9                   	leaveq 
  800420f7e3:	c3                   	retq   

000000800420f7e4 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  800420f7e4:	55                   	push   %rbp
  800420f7e5:	48 89 e5             	mov    %rsp,%rbp
  800420f7e8:	48 83 ec 20          	sub    $0x20,%rsp
  800420f7ec:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f7f0:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	char *ret;

	ret = dst;
  800420f7f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f7f8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	while ((*dst++ = *src++) != '\0')
  800420f7fc:	90                   	nop
  800420f7fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f801:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f805:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f809:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f80d:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420f811:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f815:	0f b6 12             	movzbl (%rdx),%edx
  800420f818:	88 10                	mov    %dl,(%rax)
  800420f81a:	0f b6 00             	movzbl (%rax),%eax
  800420f81d:	84 c0                	test   %al,%al
  800420f81f:	75 dc                	jne    800420f7fd <strcpy+0x19>
		/* do nothing */;
	return ret;
  800420f821:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420f825:	c9                   	leaveq 
  800420f826:	c3                   	retq   

000000800420f827 <strcat>:

char *
strcat(char *dst, const char *src)
{
  800420f827:	55                   	push   %rbp
  800420f828:	48 89 e5             	mov    %rsp,%rbp
  800420f82b:	48 83 ec 20          	sub    $0x20,%rsp
  800420f82f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f833:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	int len = strlen(dst);
  800420f837:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f83b:	48 89 c7             	mov    %rax,%rdi
  800420f83e:	48 b8 78 f7 20 04 80 	movabs $0x800420f778,%rax
  800420f845:	00 00 00 
  800420f848:	ff d0                	callq  *%rax
  800420f84a:	89 45 fc             	mov    %eax,-0x4(%rbp)
	strcpy(dst + len, src);
  800420f84d:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800420f850:	48 63 d0             	movslq %eax,%rdx
  800420f853:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f857:	48 01 c2             	add    %rax,%rdx
  800420f85a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f85e:	48 89 c6             	mov    %rax,%rsi
  800420f861:	48 89 d7             	mov    %rdx,%rdi
  800420f864:	48 b8 e4 f7 20 04 80 	movabs $0x800420f7e4,%rax
  800420f86b:	00 00 00 
  800420f86e:	ff d0                	callq  *%rax
	return dst;
  800420f870:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420f874:	c9                   	leaveq 
  800420f875:	c3                   	retq   

000000800420f876 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  800420f876:	55                   	push   %rbp
  800420f877:	48 89 e5             	mov    %rsp,%rbp
  800420f87a:	48 83 ec 28          	sub    $0x28,%rsp
  800420f87e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f882:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f886:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	size_t i;
	char *ret;

	ret = dst;
  800420f88a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f88e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	for (i = 0; i < size; i++) {
  800420f892:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420f899:	00 
  800420f89a:	eb 2a                	jmp    800420f8c6 <strncpy+0x50>
		*dst++ = *src;
  800420f89c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8a0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f8a4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f8a8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f8ac:	0f b6 12             	movzbl (%rdx),%edx
  800420f8af:	88 10                	mov    %dl,(%rax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
  800420f8b1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f8b5:	0f b6 00             	movzbl (%rax),%eax
  800420f8b8:	84 c0                	test   %al,%al
  800420f8ba:	74 05                	je     800420f8c1 <strncpy+0x4b>
			src++;
  800420f8bc:	48 83 45 e0 01       	addq   $0x1,-0x20(%rbp)
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  800420f8c1:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f8c6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f8ca:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  800420f8ce:	72 cc                	jb     800420f89c <strncpy+0x26>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
  800420f8d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420f8d4:	c9                   	leaveq 
  800420f8d5:	c3                   	retq   

000000800420f8d6 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  800420f8d6:	55                   	push   %rbp
  800420f8d7:	48 89 e5             	mov    %rsp,%rbp
  800420f8da:	48 83 ec 28          	sub    $0x28,%rsp
  800420f8de:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420f8e2:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420f8e6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *dst_in;

	dst_in = dst;
  800420f8ea:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8ee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (size > 0) {
  800420f8f2:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f8f7:	74 3d                	je     800420f936 <strlcpy+0x60>
		while (--size > 0 && *src != '\0')
  800420f8f9:	eb 1d                	jmp    800420f918 <strlcpy+0x42>
			*dst++ = *src++;
  800420f8fb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f8ff:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420f903:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  800420f907:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800420f90b:	48 8d 4a 01          	lea    0x1(%rdx),%rcx
  800420f90f:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  800420f913:	0f b6 12             	movzbl (%rdx),%edx
  800420f916:	88 10                	mov    %dl,(%rax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  800420f918:	48 83 6d d8 01       	subq   $0x1,-0x28(%rbp)
  800420f91d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  800420f922:	74 0b                	je     800420f92f <strlcpy+0x59>
  800420f924:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420f928:	0f b6 00             	movzbl (%rax),%eax
  800420f92b:	84 c0                	test   %al,%al
  800420f92d:	75 cc                	jne    800420f8fb <strlcpy+0x25>
			*dst++ = *src++;
		*dst = '\0';
  800420f92f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420f933:	c6 00 00             	movb   $0x0,(%rax)
	}
	return dst - dst_in;
  800420f936:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420f93a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f93e:	48 29 c2             	sub    %rax,%rdx
  800420f941:	48 89 d0             	mov    %rdx,%rax
}
  800420f944:	c9                   	leaveq 
  800420f945:	c3                   	retq   

000000800420f946 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  800420f946:	55                   	push   %rbp
  800420f947:	48 89 e5             	mov    %rsp,%rbp
  800420f94a:	48 83 ec 10          	sub    $0x10,%rsp
  800420f94e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f952:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	while (*p && *p == *q)
  800420f956:	eb 0a                	jmp    800420f962 <strcmp+0x1c>
		p++, q++;
  800420f958:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f95d:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  800420f962:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f966:	0f b6 00             	movzbl (%rax),%eax
  800420f969:	84 c0                	test   %al,%al
  800420f96b:	74 12                	je     800420f97f <strcmp+0x39>
  800420f96d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f971:	0f b6 10             	movzbl (%rax),%edx
  800420f974:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f978:	0f b6 00             	movzbl (%rax),%eax
  800420f97b:	38 c2                	cmp    %al,%dl
  800420f97d:	74 d9                	je     800420f958 <strcmp+0x12>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  800420f97f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f983:	0f b6 00             	movzbl (%rax),%eax
  800420f986:	0f b6 d0             	movzbl %al,%edx
  800420f989:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f98d:	0f b6 00             	movzbl (%rax),%eax
  800420f990:	0f b6 c0             	movzbl %al,%eax
  800420f993:	29 c2                	sub    %eax,%edx
  800420f995:	89 d0                	mov    %edx,%eax
}
  800420f997:	c9                   	leaveq 
  800420f998:	c3                   	retq   

000000800420f999 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  800420f999:	55                   	push   %rbp
  800420f99a:	48 89 e5             	mov    %rsp,%rbp
  800420f99d:	48 83 ec 18          	sub    $0x18,%rsp
  800420f9a1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420f9a5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420f9a9:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	while (n > 0 && *p && *p == *q)
  800420f9ad:	eb 0f                	jmp    800420f9be <strncmp+0x25>
		n--, p++, q++;
  800420f9af:	48 83 6d e8 01       	subq   $0x1,-0x18(%rbp)
  800420f9b4:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420f9b9:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  800420f9be:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f9c3:	74 1d                	je     800420f9e2 <strncmp+0x49>
  800420f9c5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9c9:	0f b6 00             	movzbl (%rax),%eax
  800420f9cc:	84 c0                	test   %al,%al
  800420f9ce:	74 12                	je     800420f9e2 <strncmp+0x49>
  800420f9d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9d4:	0f b6 10             	movzbl (%rax),%edx
  800420f9d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9db:	0f b6 00             	movzbl (%rax),%eax
  800420f9de:	38 c2                	cmp    %al,%dl
  800420f9e0:	74 cd                	je     800420f9af <strncmp+0x16>
		n--, p++, q++;
	if (n == 0)
  800420f9e2:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420f9e7:	75 07                	jne    800420f9f0 <strncmp+0x57>
		return 0;
  800420f9e9:	b8 00 00 00 00       	mov    $0x0,%eax
  800420f9ee:	eb 18                	jmp    800420fa08 <strncmp+0x6f>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  800420f9f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420f9f4:	0f b6 00             	movzbl (%rax),%eax
  800420f9f7:	0f b6 d0             	movzbl %al,%edx
  800420f9fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420f9fe:	0f b6 00             	movzbl (%rax),%eax
  800420fa01:	0f b6 c0             	movzbl %al,%eax
  800420fa04:	29 c2                	sub    %eax,%edx
  800420fa06:	89 d0                	mov    %edx,%eax
}
  800420fa08:	c9                   	leaveq 
  800420fa09:	c3                   	retq   

000000800420fa0a <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  800420fa0a:	55                   	push   %rbp
  800420fa0b:	48 89 e5             	mov    %rsp,%rbp
  800420fa0e:	48 83 ec 0c          	sub    $0xc,%rsp
  800420fa12:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fa16:	89 f0                	mov    %esi,%eax
  800420fa18:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420fa1b:	eb 17                	jmp    800420fa34 <strchr+0x2a>
		if (*s == c)
  800420fa1d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa21:	0f b6 00             	movzbl (%rax),%eax
  800420fa24:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420fa27:	75 06                	jne    800420fa2f <strchr+0x25>
			return (char *) s;
  800420fa29:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa2d:	eb 15                	jmp    800420fa44 <strchr+0x3a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  800420fa2f:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fa34:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa38:	0f b6 00             	movzbl (%rax),%eax
  800420fa3b:	84 c0                	test   %al,%al
  800420fa3d:	75 de                	jne    800420fa1d <strchr+0x13>
		if (*s == c)
			return (char *) s;
	return 0;
  800420fa3f:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fa44:	c9                   	leaveq 
  800420fa45:	c3                   	retq   

000000800420fa46 <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  800420fa46:	55                   	push   %rbp
  800420fa47:	48 89 e5             	mov    %rsp,%rbp
  800420fa4a:	48 83 ec 0c          	sub    $0xc,%rsp
  800420fa4e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fa52:	89 f0                	mov    %esi,%eax
  800420fa54:	88 45 f4             	mov    %al,-0xc(%rbp)
	for (; *s; s++)
  800420fa57:	eb 13                	jmp    800420fa6c <strfind+0x26>
		if (*s == c)
  800420fa59:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa5d:	0f b6 00             	movzbl (%rax),%eax
  800420fa60:	3a 45 f4             	cmp    -0xc(%rbp),%al
  800420fa63:	75 02                	jne    800420fa67 <strfind+0x21>
			break;
  800420fa65:	eb 10                	jmp    800420fa77 <strfind+0x31>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  800420fa67:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fa6c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa70:	0f b6 00             	movzbl (%rax),%eax
  800420fa73:	84 c0                	test   %al,%al
  800420fa75:	75 e2                	jne    800420fa59 <strfind+0x13>
		if (*s == c)
			break;
	return (char *) s;
  800420fa77:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fa7b:	c9                   	leaveq 
  800420fa7c:	c3                   	retq   

000000800420fa7d <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  800420fa7d:	55                   	push   %rbp
  800420fa7e:	48 89 e5             	mov    %rsp,%rbp
  800420fa81:	48 83 ec 18          	sub    $0x18,%rsp
  800420fa85:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fa89:	89 75 f4             	mov    %esi,-0xc(%rbp)
  800420fa8c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	char *p;

	if (n == 0)
  800420fa90:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800420fa95:	75 06                	jne    800420fa9d <memset+0x20>
		return v;
  800420fa97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fa9b:	eb 69                	jmp    800420fb06 <memset+0x89>
	if ((int64_t)v%4 == 0 && n%4 == 0) {
  800420fa9d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420faa1:	83 e0 03             	and    $0x3,%eax
  800420faa4:	48 85 c0             	test   %rax,%rax
  800420faa7:	75 48                	jne    800420faf1 <memset+0x74>
  800420faa9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420faad:	83 e0 03             	and    $0x3,%eax
  800420fab0:	48 85 c0             	test   %rax,%rax
  800420fab3:	75 3c                	jne    800420faf1 <memset+0x74>
		c &= 0xFF;
  800420fab5:	81 65 f4 ff 00 00 00 	andl   $0xff,-0xc(%rbp)
		c = (c<<24)|(c<<16)|(c<<8)|c;
  800420fabc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fabf:	c1 e0 18             	shl    $0x18,%eax
  800420fac2:	89 c2                	mov    %eax,%edx
  800420fac4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fac7:	c1 e0 10             	shl    $0x10,%eax
  800420faca:	09 c2                	or     %eax,%edx
  800420facc:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420facf:	c1 e0 08             	shl    $0x8,%eax
  800420fad2:	09 d0                	or     %edx,%eax
  800420fad4:	09 45 f4             	or     %eax,-0xc(%rbp)
		asm volatile("cld; rep stosl\n"
			     :: "D" (v), "a" (c), "c" (n/4)
  800420fad7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fadb:	48 c1 e8 02          	shr    $0x2,%rax
  800420fadf:	48 89 c1             	mov    %rax,%rcx
	if (n == 0)
		return v;
	if ((int64_t)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  800420fae2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fae6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420fae9:	48 89 d7             	mov    %rdx,%rdi
  800420faec:	fc                   	cld    
  800420faed:	f3 ab                	rep stos %eax,%es:(%rdi)
  800420faef:	eb 11                	jmp    800420fb02 <memset+0x85>
			     :: "D" (v), "a" (c), "c" (n/4)
			     : "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  800420faf1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420faf5:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800420faf8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800420fafc:	48 89 d7             	mov    %rdx,%rdi
  800420faff:	fc                   	cld    
  800420fb00:	f3 aa                	rep stos %al,%es:(%rdi)
			     :: "D" (v), "a" (c), "c" (n)
			     : "cc", "memory");
	return v;
  800420fb02:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800420fb06:	c9                   	leaveq 
  800420fb07:	c3                   	retq   

000000800420fb08 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  800420fb08:	55                   	push   %rbp
  800420fb09:	48 89 e5             	mov    %rsp,%rbp
  800420fb0c:	48 83 ec 28          	sub    $0x28,%rsp
  800420fb10:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fb14:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fb18:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const char *s;
	char *d;

	s = src;
  800420fb1c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fb20:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	d = dst;
  800420fb24:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fb28:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	if (s < d && s + n > d) {
  800420fb2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb30:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420fb34:	0f 83 88 00 00 00    	jae    800420fbc2 <memmove+0xba>
  800420fb3a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb3e:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fb42:	48 01 d0             	add    %rdx,%rax
  800420fb45:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  800420fb49:	76 77                	jbe    800420fbc2 <memmove+0xba>
		s += n;
  800420fb4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb4f:	48 01 45 f8          	add    %rax,-0x8(%rbp)
		d += n;
  800420fb53:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb57:	48 01 45 f0          	add    %rax,-0x10(%rbp)
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420fb5b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fb5f:	83 e0 03             	and    $0x3,%eax
  800420fb62:	48 85 c0             	test   %rax,%rax
  800420fb65:	75 3b                	jne    800420fba2 <memmove+0x9a>
  800420fb67:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb6b:	83 e0 03             	and    $0x3,%eax
  800420fb6e:	48 85 c0             	test   %rax,%rax
  800420fb71:	75 2f                	jne    800420fba2 <memmove+0x9a>
  800420fb73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fb77:	83 e0 03             	and    $0x3,%eax
  800420fb7a:	48 85 c0             	test   %rax,%rax
  800420fb7d:	75 23                	jne    800420fba2 <memmove+0x9a>
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  800420fb7f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fb83:	48 83 e8 04          	sub    $0x4,%rax
  800420fb87:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fb8b:	48 83 ea 04          	sub    $0x4,%rdx
  800420fb8f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fb93:	48 c1 e9 02          	shr    $0x2,%rcx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  800420fb97:	48 89 c7             	mov    %rax,%rdi
  800420fb9a:	48 89 d6             	mov    %rdx,%rsi
  800420fb9d:	fd                   	std    
  800420fb9e:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420fba0:	eb 1d                	jmp    800420fbbf <memmove+0xb7>
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  800420fba2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fba6:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fbaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fbae:	48 8d 70 ff          	lea    -0x1(%rax),%rsi
		d += n;
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				     :: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  800420fbb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbb6:	48 89 d7             	mov    %rdx,%rdi
  800420fbb9:	48 89 c1             	mov    %rax,%rcx
  800420fbbc:	fd                   	std    
  800420fbbd:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  800420fbbf:	fc                   	cld    
  800420fbc0:	eb 57                	jmp    800420fc19 <memmove+0x111>
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
  800420fbc2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fbc6:	83 e0 03             	and    $0x3,%eax
  800420fbc9:	48 85 c0             	test   %rax,%rax
  800420fbcc:	75 36                	jne    800420fc04 <memmove+0xfc>
  800420fbce:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fbd2:	83 e0 03             	and    $0x3,%eax
  800420fbd5:	48 85 c0             	test   %rax,%rax
  800420fbd8:	75 2a                	jne    800420fc04 <memmove+0xfc>
  800420fbda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbde:	83 e0 03             	and    $0x3,%eax
  800420fbe1:	48 85 c0             	test   %rax,%rax
  800420fbe4:	75 1e                	jne    800420fc04 <memmove+0xfc>
			asm volatile("cld; rep movsl\n"
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  800420fbe6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fbea:	48 c1 e8 02          	shr    $0x2,%rax
  800420fbee:	48 89 c1             	mov    %rax,%rcx
				     :: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int64_t)s%4 == 0 && (int64_t)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  800420fbf1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fbf5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fbf9:	48 89 c7             	mov    %rax,%rdi
  800420fbfc:	48 89 d6             	mov    %rdx,%rsi
  800420fbff:	fc                   	cld    
  800420fc00:	f3 a5                	rep movsl %ds:(%rsi),%es:(%rdi)
  800420fc02:	eb 15                	jmp    800420fc19 <memmove+0x111>
				     :: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  800420fc04:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fc08:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800420fc0c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800420fc10:	48 89 c7             	mov    %rax,%rdi
  800420fc13:	48 89 d6             	mov    %rdx,%rsi
  800420fc16:	fc                   	cld    
  800420fc17:	f3 a4                	rep movsb %ds:(%rsi),%es:(%rdi)
				     :: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
  800420fc19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fc1d:	c9                   	leaveq 
  800420fc1e:	c3                   	retq   

000000800420fc1f <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  800420fc1f:	55                   	push   %rbp
  800420fc20:	48 89 e5             	mov    %rsp,%rbp
  800420fc23:	48 83 ec 18          	sub    $0x18,%rsp
  800420fc27:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800420fc2b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  800420fc2f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
	return memmove(dst, src, n);
  800420fc33:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fc37:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  800420fc3b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc3f:	48 89 ce             	mov    %rcx,%rsi
  800420fc42:	48 89 c7             	mov    %rax,%rdi
  800420fc45:	48 b8 08 fb 20 04 80 	movabs $0x800420fb08,%rax
  800420fc4c:	00 00 00 
  800420fc4f:	ff d0                	callq  *%rax
}
  800420fc51:	c9                   	leaveq 
  800420fc52:	c3                   	retq   

000000800420fc53 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  800420fc53:	55                   	push   %rbp
  800420fc54:	48 89 e5             	mov    %rsp,%rbp
  800420fc57:	48 83 ec 28          	sub    $0x28,%rsp
  800420fc5b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fc5f:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420fc63:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const uint8_t *s1 = (const uint8_t *) v1;
  800420fc67:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fc6b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	const uint8_t *s2 = (const uint8_t *) v2;
  800420fc6f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420fc73:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (n-- > 0) {
  800420fc77:	eb 36                	jmp    800420fcaf <memcmp+0x5c>
		if (*s1 != *s2)
  800420fc79:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc7d:	0f b6 10             	movzbl (%rax),%edx
  800420fc80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fc84:	0f b6 00             	movzbl (%rax),%eax
  800420fc87:	38 c2                	cmp    %al,%dl
  800420fc89:	74 1a                	je     800420fca5 <memcmp+0x52>
			return (int) *s1 - (int) *s2;
  800420fc8b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800420fc8f:	0f b6 00             	movzbl (%rax),%eax
  800420fc92:	0f b6 d0             	movzbl %al,%edx
  800420fc95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fc99:	0f b6 00             	movzbl (%rax),%eax
  800420fc9c:	0f b6 c0             	movzbl %al,%eax
  800420fc9f:	29 c2                	sub    %eax,%edx
  800420fca1:	89 d0                	mov    %edx,%eax
  800420fca3:	eb 20                	jmp    800420fcc5 <memcmp+0x72>
		s1++, s2++;
  800420fca5:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
  800420fcaa:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  800420fcaf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcb3:	48 8d 50 ff          	lea    -0x1(%rax),%rdx
  800420fcb7:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fcbb:	48 85 c0             	test   %rax,%rax
  800420fcbe:	75 b9                	jne    800420fc79 <memcmp+0x26>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  800420fcc0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800420fcc5:	c9                   	leaveq 
  800420fcc6:	c3                   	retq   

000000800420fcc7 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  800420fcc7:	55                   	push   %rbp
  800420fcc8:	48 89 e5             	mov    %rsp,%rbp
  800420fccb:	48 83 ec 28          	sub    $0x28,%rsp
  800420fccf:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420fcd3:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  800420fcd6:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	const void *ends = (const char *) s + n;
  800420fcda:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fcde:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800420fce2:	48 01 d0             	add    %rdx,%rax
  800420fce5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (; s < ends; s++)
  800420fce9:	eb 15                	jmp    800420fd00 <memfind+0x39>
		if (*(const unsigned char *) s == (unsigned char) c)
  800420fceb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fcef:	0f b6 10             	movzbl (%rax),%edx
  800420fcf2:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800420fcf5:	38 c2                	cmp    %al,%dl
  800420fcf7:	75 02                	jne    800420fcfb <memfind+0x34>
			break;
  800420fcf9:	eb 0f                	jmp    800420fd0a <memfind+0x43>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  800420fcfb:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
  800420fd00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420fd04:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800420fd08:	72 e1                	jb     800420fceb <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
  800420fd0a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
}
  800420fd0e:	c9                   	leaveq 
  800420fd0f:	c3                   	retq   

000000800420fd10 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  800420fd10:	55                   	push   %rbp
  800420fd11:	48 89 e5             	mov    %rsp,%rbp
  800420fd14:	48 83 ec 34          	sub    $0x34,%rsp
  800420fd18:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420fd1c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  800420fd20:	89 55 cc             	mov    %edx,-0x34(%rbp)
	int neg = 0;
  800420fd23:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	long val = 0;
  800420fd2a:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
  800420fd31:	00 

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fd32:	eb 05                	jmp    800420fd39 <strtol+0x29>
		s++;
  800420fd34:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  800420fd39:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd3d:	0f b6 00             	movzbl (%rax),%eax
  800420fd40:	3c 20                	cmp    $0x20,%al
  800420fd42:	74 f0                	je     800420fd34 <strtol+0x24>
  800420fd44:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd48:	0f b6 00             	movzbl (%rax),%eax
  800420fd4b:	3c 09                	cmp    $0x9,%al
  800420fd4d:	74 e5                	je     800420fd34 <strtol+0x24>
		s++;

	// plus/minus sign
	if (*s == '+')
  800420fd4f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd53:	0f b6 00             	movzbl (%rax),%eax
  800420fd56:	3c 2b                	cmp    $0x2b,%al
  800420fd58:	75 07                	jne    800420fd61 <strtol+0x51>
		s++;
  800420fd5a:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fd5f:	eb 17                	jmp    800420fd78 <strtol+0x68>
	else if (*s == '-')
  800420fd61:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd65:	0f b6 00             	movzbl (%rax),%eax
  800420fd68:	3c 2d                	cmp    $0x2d,%al
  800420fd6a:	75 0c                	jne    800420fd78 <strtol+0x68>
		s++, neg = 1;
  800420fd6c:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fd71:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  800420fd78:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fd7c:	74 06                	je     800420fd84 <strtol+0x74>
  800420fd7e:	83 7d cc 10          	cmpl   $0x10,-0x34(%rbp)
  800420fd82:	75 28                	jne    800420fdac <strtol+0x9c>
  800420fd84:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd88:	0f b6 00             	movzbl (%rax),%eax
  800420fd8b:	3c 30                	cmp    $0x30,%al
  800420fd8d:	75 1d                	jne    800420fdac <strtol+0x9c>
  800420fd8f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fd93:	48 83 c0 01          	add    $0x1,%rax
  800420fd97:	0f b6 00             	movzbl (%rax),%eax
  800420fd9a:	3c 78                	cmp    $0x78,%al
  800420fd9c:	75 0e                	jne    800420fdac <strtol+0x9c>
		s += 2, base = 16;
  800420fd9e:	48 83 45 d8 02       	addq   $0x2,-0x28(%rbp)
  800420fda3:	c7 45 cc 10 00 00 00 	movl   $0x10,-0x34(%rbp)
  800420fdaa:	eb 2c                	jmp    800420fdd8 <strtol+0xc8>
	else if (base == 0 && s[0] == '0')
  800420fdac:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fdb0:	75 19                	jne    800420fdcb <strtol+0xbb>
  800420fdb2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fdb6:	0f b6 00             	movzbl (%rax),%eax
  800420fdb9:	3c 30                	cmp    $0x30,%al
  800420fdbb:	75 0e                	jne    800420fdcb <strtol+0xbb>
		s++, base = 8;
  800420fdbd:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fdc2:	c7 45 cc 08 00 00 00 	movl   $0x8,-0x34(%rbp)
  800420fdc9:	eb 0d                	jmp    800420fdd8 <strtol+0xc8>
	else if (base == 0)
  800420fdcb:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  800420fdcf:	75 07                	jne    800420fdd8 <strtol+0xc8>
		base = 10;
  800420fdd1:	c7 45 cc 0a 00 00 00 	movl   $0xa,-0x34(%rbp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  800420fdd8:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fddc:	0f b6 00             	movzbl (%rax),%eax
  800420fddf:	3c 2f                	cmp    $0x2f,%al
  800420fde1:	7e 1d                	jle    800420fe00 <strtol+0xf0>
  800420fde3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fde7:	0f b6 00             	movzbl (%rax),%eax
  800420fdea:	3c 39                	cmp    $0x39,%al
  800420fdec:	7f 12                	jg     800420fe00 <strtol+0xf0>
			dig = *s - '0';
  800420fdee:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fdf2:	0f b6 00             	movzbl (%rax),%eax
  800420fdf5:	0f be c0             	movsbl %al,%eax
  800420fdf8:	83 e8 30             	sub    $0x30,%eax
  800420fdfb:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420fdfe:	eb 4e                	jmp    800420fe4e <strtol+0x13e>
		else if (*s >= 'a' && *s <= 'z')
  800420fe00:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe04:	0f b6 00             	movzbl (%rax),%eax
  800420fe07:	3c 60                	cmp    $0x60,%al
  800420fe09:	7e 1d                	jle    800420fe28 <strtol+0x118>
  800420fe0b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe0f:	0f b6 00             	movzbl (%rax),%eax
  800420fe12:	3c 7a                	cmp    $0x7a,%al
  800420fe14:	7f 12                	jg     800420fe28 <strtol+0x118>
			dig = *s - 'a' + 10;
  800420fe16:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe1a:	0f b6 00             	movzbl (%rax),%eax
  800420fe1d:	0f be c0             	movsbl %al,%eax
  800420fe20:	83 e8 57             	sub    $0x57,%eax
  800420fe23:	89 45 ec             	mov    %eax,-0x14(%rbp)
  800420fe26:	eb 26                	jmp    800420fe4e <strtol+0x13e>
		else if (*s >= 'A' && *s <= 'Z')
  800420fe28:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe2c:	0f b6 00             	movzbl (%rax),%eax
  800420fe2f:	3c 40                	cmp    $0x40,%al
  800420fe31:	7e 48                	jle    800420fe7b <strtol+0x16b>
  800420fe33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe37:	0f b6 00             	movzbl (%rax),%eax
  800420fe3a:	3c 5a                	cmp    $0x5a,%al
  800420fe3c:	7f 3d                	jg     800420fe7b <strtol+0x16b>
			dig = *s - 'A' + 10;
  800420fe3e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fe42:	0f b6 00             	movzbl (%rax),%eax
  800420fe45:	0f be c0             	movsbl %al,%eax
  800420fe48:	83 e8 37             	sub    $0x37,%eax
  800420fe4b:	89 45 ec             	mov    %eax,-0x14(%rbp)
		else
			break;
		if (dig >= base)
  800420fe4e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420fe51:	3b 45 cc             	cmp    -0x34(%rbp),%eax
  800420fe54:	7c 02                	jl     800420fe58 <strtol+0x148>
			break;
  800420fe56:	eb 23                	jmp    800420fe7b <strtol+0x16b>
		s++, val = (val * base) + dig;
  800420fe58:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
  800420fe5d:	8b 45 cc             	mov    -0x34(%rbp),%eax
  800420fe60:	48 98                	cltq   
  800420fe62:	48 0f af 45 f0       	imul   -0x10(%rbp),%rax
  800420fe67:	48 89 c2             	mov    %rax,%rdx
  800420fe6a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800420fe6d:	48 98                	cltq   
  800420fe6f:	48 01 d0             	add    %rdx,%rax
  800420fe72:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
		// we don't properly detect overflow!
	}
  800420fe76:	e9 5d ff ff ff       	jmpq   800420fdd8 <strtol+0xc8>

	if (endptr)
  800420fe7b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  800420fe80:	74 0b                	je     800420fe8d <strtol+0x17d>
		*endptr = (char *) s;
  800420fe82:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fe86:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800420fe8a:	48 89 10             	mov    %rdx,(%rax)
	return (neg ? -val : val);
  800420fe8d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800420fe91:	74 09                	je     800420fe9c <strtol+0x18c>
  800420fe93:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fe97:	48 f7 d8             	neg    %rax
  800420fe9a:	eb 04                	jmp    800420fea0 <strtol+0x190>
  800420fe9c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800420fea0:	c9                   	leaveq 
  800420fea1:	c3                   	retq   

000000800420fea2 <strstr>:

char * strstr(const char *in, const char *str)
{
  800420fea2:	55                   	push   %rbp
  800420fea3:	48 89 e5             	mov    %rsp,%rbp
  800420fea6:	48 83 ec 30          	sub    $0x30,%rsp
  800420feaa:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800420feae:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	char c;
	size_t len;

	c = *str++;
  800420feb2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420feb6:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420feba:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  800420febe:	0f b6 00             	movzbl (%rax),%eax
  800420fec1:	88 45 ff             	mov    %al,-0x1(%rbp)
	if (!c)
  800420fec4:	80 7d ff 00          	cmpb   $0x0,-0x1(%rbp)
  800420fec8:	75 06                	jne    800420fed0 <strstr+0x2e>
		return (char *) in;	// Trivial empty string case
  800420feca:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420fece:	eb 6b                	jmp    800420ff3b <strstr+0x99>

	len = strlen(str);
  800420fed0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800420fed4:	48 89 c7             	mov    %rax,%rdi
  800420fed7:	48 b8 78 f7 20 04 80 	movabs $0x800420f778,%rax
  800420fede:	00 00 00 
  800420fee1:	ff d0                	callq  *%rax
  800420fee3:	48 98                	cltq   
  800420fee5:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	do {
		char sc;

		do {
			sc = *in++;
  800420fee9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420feed:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800420fef1:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  800420fef5:	0f b6 00             	movzbl (%rax),%eax
  800420fef8:	88 45 ef             	mov    %al,-0x11(%rbp)
			if (!sc)
  800420fefb:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
  800420feff:	75 07                	jne    800420ff08 <strstr+0x66>
				return (char *) 0;
  800420ff01:	b8 00 00 00 00       	mov    $0x0,%eax
  800420ff06:	eb 33                	jmp    800420ff3b <strstr+0x99>
		} while (sc != c);
  800420ff08:	0f b6 45 ef          	movzbl -0x11(%rbp),%eax
  800420ff0c:	3a 45 ff             	cmp    -0x1(%rbp),%al
  800420ff0f:	75 d8                	jne    800420fee9 <strstr+0x47>
	} while (strncmp(in, str, len) != 0);
  800420ff11:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800420ff15:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
  800420ff19:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff1d:	48 89 ce             	mov    %rcx,%rsi
  800420ff20:	48 89 c7             	mov    %rax,%rdi
  800420ff23:	48 b8 99 f9 20 04 80 	movabs $0x800420f999,%rax
  800420ff2a:	00 00 00 
  800420ff2d:	ff d0                	callq  *%rax
  800420ff2f:	85 c0                	test   %eax,%eax
  800420ff31:	75 b6                	jne    800420fee9 <strstr+0x47>

	return (char *) (in - 1);
  800420ff33:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800420ff37:	48 83 e8 01          	sub    $0x1,%rax
}
  800420ff3b:	c9                   	leaveq 
  800420ff3c:	c3                   	retq   

000000800420ff3d <_dwarf_read_lsb>:
Dwarf_Section *
_dwarf_find_section(const char *name);

uint64_t
_dwarf_read_lsb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800420ff3d:	55                   	push   %rbp
  800420ff3e:	48 89 e5             	mov    %rsp,%rbp
  800420ff41:	48 83 ec 24          	sub    $0x24,%rsp
  800420ff45:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800420ff49:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800420ff4d:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800420ff50:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800420ff54:	48 8b 10             	mov    (%rax),%rdx
  800420ff57:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800420ff5b:	48 01 d0             	add    %rdx,%rax
  800420ff5e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  800420ff62:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800420ff69:	00 
	switch (bytes_to_read) {
  800420ff6a:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800420ff6d:	83 f8 02             	cmp    $0x2,%eax
  800420ff70:	0f 84 ab 00 00 00    	je     8004210021 <_dwarf_read_lsb+0xe4>
  800420ff76:	83 f8 02             	cmp    $0x2,%eax
  800420ff79:	7f 0e                	jg     800420ff89 <_dwarf_read_lsb+0x4c>
  800420ff7b:	83 f8 01             	cmp    $0x1,%eax
  800420ff7e:	0f 84 b3 00 00 00    	je     8004210037 <_dwarf_read_lsb+0xfa>
  800420ff84:	e9 d9 00 00 00       	jmpq   8004210062 <_dwarf_read_lsb+0x125>
  800420ff89:	83 f8 04             	cmp    $0x4,%eax
  800420ff8c:	74 65                	je     800420fff3 <_dwarf_read_lsb+0xb6>
  800420ff8e:	83 f8 08             	cmp    $0x8,%eax
  800420ff91:	0f 85 cb 00 00 00    	jne    8004210062 <_dwarf_read_lsb+0x125>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  800420ff97:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ff9b:	48 83 c0 04          	add    $0x4,%rax
  800420ff9f:	0f b6 00             	movzbl (%rax),%eax
  800420ffa2:	0f b6 c0             	movzbl %al,%eax
  800420ffa5:	48 c1 e0 20          	shl    $0x20,%rax
  800420ffa9:	48 89 c2             	mov    %rax,%rdx
  800420ffac:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffb0:	48 83 c0 05          	add    $0x5,%rax
  800420ffb4:	0f b6 00             	movzbl (%rax),%eax
  800420ffb7:	0f b6 c0             	movzbl %al,%eax
  800420ffba:	48 c1 e0 28          	shl    $0x28,%rax
  800420ffbe:	48 09 d0             	or     %rdx,%rax
  800420ffc1:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  800420ffc5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffc9:	48 83 c0 06          	add    $0x6,%rax
  800420ffcd:	0f b6 00             	movzbl (%rax),%eax
  800420ffd0:	0f b6 c0             	movzbl %al,%eax
  800420ffd3:	48 c1 e0 30          	shl    $0x30,%rax
  800420ffd7:	48 89 c2             	mov    %rax,%rdx
  800420ffda:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420ffde:	48 83 c0 07          	add    $0x7,%rax
  800420ffe2:	0f b6 00             	movzbl (%rax),%eax
  800420ffe5:	0f b6 c0             	movzbl %al,%eax
  800420ffe8:	48 c1 e0 38          	shl    $0x38,%rax
  800420ffec:	48 09 d0             	or     %rdx,%rax
  800420ffef:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  800420fff3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800420fff7:	48 83 c0 02          	add    $0x2,%rax
  800420fffb:	0f b6 00             	movzbl (%rax),%eax
  800420fffe:	0f b6 c0             	movzbl %al,%eax
  8004210001:	48 c1 e0 10          	shl    $0x10,%rax
  8004210005:	48 89 c2             	mov    %rax,%rdx
  8004210008:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421000c:	48 83 c0 03          	add    $0x3,%rax
  8004210010:	0f b6 00             	movzbl (%rax),%eax
  8004210013:	0f b6 c0             	movzbl %al,%eax
  8004210016:	48 c1 e0 18          	shl    $0x18,%rax
  800421001a:	48 09 d0             	or     %rdx,%rax
  800421001d:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004210021:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210025:	48 83 c0 01          	add    $0x1,%rax
  8004210029:	0f b6 00             	movzbl (%rax),%eax
  800421002c:	0f b6 c0             	movzbl %al,%eax
  800421002f:	48 c1 e0 08          	shl    $0x8,%rax
  8004210033:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  8004210037:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421003b:	0f b6 00             	movzbl (%rax),%eax
  800421003e:	0f b6 c0             	movzbl %al,%eax
  8004210041:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210045:	90                   	nop
	default:
		return (0);
	}

	*offsetp += bytes_to_read;
  8004210046:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421004a:	48 8b 10             	mov    (%rax),%rdx
  800421004d:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004210050:	48 98                	cltq   
  8004210052:	48 01 c2             	add    %rax,%rdx
  8004210055:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210059:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421005c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210060:	eb 05                	jmp    8004210067 <_dwarf_read_lsb+0x12a>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004210062:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*offsetp += bytes_to_read;

	return (ret);
}
  8004210067:	c9                   	leaveq 
  8004210068:	c3                   	retq   

0000008004210069 <_dwarf_decode_lsb>:

uint64_t
_dwarf_decode_lsb(uint8_t **data, int bytes_to_read)
{
  8004210069:	55                   	push   %rbp
  800421006a:	48 89 e5             	mov    %rsp,%rbp
  800421006d:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004210071:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210075:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  8004210078:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421007c:	48 8b 00             	mov    (%rax),%rax
  800421007f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004210083:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421008a:	00 
	switch (bytes_to_read) {
  800421008b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421008e:	83 f8 02             	cmp    $0x2,%eax
  8004210091:	0f 84 ab 00 00 00    	je     8004210142 <_dwarf_decode_lsb+0xd9>
  8004210097:	83 f8 02             	cmp    $0x2,%eax
  800421009a:	7f 0e                	jg     80042100aa <_dwarf_decode_lsb+0x41>
  800421009c:	83 f8 01             	cmp    $0x1,%eax
  800421009f:	0f 84 b3 00 00 00    	je     8004210158 <_dwarf_decode_lsb+0xef>
  80042100a5:	e9 d9 00 00 00       	jmpq   8004210183 <_dwarf_decode_lsb+0x11a>
  80042100aa:	83 f8 04             	cmp    $0x4,%eax
  80042100ad:	74 65                	je     8004210114 <_dwarf_decode_lsb+0xab>
  80042100af:	83 f8 08             	cmp    $0x8,%eax
  80042100b2:	0f 85 cb 00 00 00    	jne    8004210183 <_dwarf_decode_lsb+0x11a>
	case 8:
		ret |= ((uint64_t) src[4]) << 32 | ((uint64_t) src[5]) << 40;
  80042100b8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100bc:	48 83 c0 04          	add    $0x4,%rax
  80042100c0:	0f b6 00             	movzbl (%rax),%eax
  80042100c3:	0f b6 c0             	movzbl %al,%eax
  80042100c6:	48 c1 e0 20          	shl    $0x20,%rax
  80042100ca:	48 89 c2             	mov    %rax,%rdx
  80042100cd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100d1:	48 83 c0 05          	add    $0x5,%rax
  80042100d5:	0f b6 00             	movzbl (%rax),%eax
  80042100d8:	0f b6 c0             	movzbl %al,%eax
  80042100db:	48 c1 e0 28          	shl    $0x28,%rax
  80042100df:	48 09 d0             	or     %rdx,%rax
  80042100e2:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[6]) << 48 | ((uint64_t) src[7]) << 56;
  80042100e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100ea:	48 83 c0 06          	add    $0x6,%rax
  80042100ee:	0f b6 00             	movzbl (%rax),%eax
  80042100f1:	0f b6 c0             	movzbl %al,%eax
  80042100f4:	48 c1 e0 30          	shl    $0x30,%rax
  80042100f8:	48 89 c2             	mov    %rax,%rdx
  80042100fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042100ff:	48 83 c0 07          	add    $0x7,%rax
  8004210103:	0f b6 00             	movzbl (%rax),%eax
  8004210106:	0f b6 c0             	movzbl %al,%eax
  8004210109:	48 c1 e0 38          	shl    $0x38,%rax
  800421010d:	48 09 d0             	or     %rdx,%rax
  8004210110:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 4:
		ret |= ((uint64_t) src[2]) << 16 | ((uint64_t) src[3]) << 24;
  8004210114:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210118:	48 83 c0 02          	add    $0x2,%rax
  800421011c:	0f b6 00             	movzbl (%rax),%eax
  800421011f:	0f b6 c0             	movzbl %al,%eax
  8004210122:	48 c1 e0 10          	shl    $0x10,%rax
  8004210126:	48 89 c2             	mov    %rax,%rdx
  8004210129:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421012d:	48 83 c0 03          	add    $0x3,%rax
  8004210131:	0f b6 00             	movzbl (%rax),%eax
  8004210134:	0f b6 c0             	movzbl %al,%eax
  8004210137:	48 c1 e0 18          	shl    $0x18,%rax
  800421013b:	48 09 d0             	or     %rdx,%rax
  800421013e:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 2:
		ret |= ((uint64_t) src[1]) << 8;
  8004210142:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210146:	48 83 c0 01          	add    $0x1,%rax
  800421014a:	0f b6 00             	movzbl (%rax),%eax
  800421014d:	0f b6 c0             	movzbl %al,%eax
  8004210150:	48 c1 e0 08          	shl    $0x8,%rax
  8004210154:	48 09 45 f8          	or     %rax,-0x8(%rbp)
	case 1:
		ret |= src[0];
  8004210158:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421015c:	0f b6 00             	movzbl (%rax),%eax
  800421015f:	0f b6 c0             	movzbl %al,%eax
  8004210162:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210166:	90                   	nop
	default:
		return (0);
	}

	*data += bytes_to_read;
  8004210167:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421016b:	48 8b 10             	mov    (%rax),%rdx
  800421016e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210171:	48 98                	cltq   
  8004210173:	48 01 c2             	add    %rax,%rdx
  8004210176:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421017a:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421017d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210181:	eb 05                	jmp    8004210188 <_dwarf_decode_lsb+0x11f>
		ret |= ((uint64_t) src[1]) << 8;
	case 1:
		ret |= src[0];
		break;
	default:
		return (0);
  8004210183:	b8 00 00 00 00       	mov    $0x0,%eax
	}

	*data += bytes_to_read;

	return (ret);
}
  8004210188:	c9                   	leaveq 
  8004210189:	c3                   	retq   

000000800421018a <_dwarf_read_msb>:

uint64_t
_dwarf_read_msb(uint8_t *data, uint64_t *offsetp, int bytes_to_read)
{
  800421018a:	55                   	push   %rbp
  800421018b:	48 89 e5             	mov    %rsp,%rbp
  800421018e:	48 83 ec 24          	sub    $0x24,%rsp
  8004210192:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210196:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421019a:	89 55 dc             	mov    %edx,-0x24(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = data + *offsetp;
  800421019d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042101a1:	48 8b 10             	mov    (%rax),%rdx
  80042101a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042101a8:	48 01 d0             	add    %rdx,%rax
  80042101ab:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	switch (bytes_to_read) {
  80042101af:	8b 45 dc             	mov    -0x24(%rbp),%eax
  80042101b2:	83 f8 02             	cmp    $0x2,%eax
  80042101b5:	74 35                	je     80042101ec <_dwarf_read_msb+0x62>
  80042101b7:	83 f8 02             	cmp    $0x2,%eax
  80042101ba:	7f 0a                	jg     80042101c6 <_dwarf_read_msb+0x3c>
  80042101bc:	83 f8 01             	cmp    $0x1,%eax
  80042101bf:	74 18                	je     80042101d9 <_dwarf_read_msb+0x4f>
  80042101c1:	e9 53 01 00 00       	jmpq   8004210319 <_dwarf_read_msb+0x18f>
  80042101c6:	83 f8 04             	cmp    $0x4,%eax
  80042101c9:	74 49                	je     8004210214 <_dwarf_read_msb+0x8a>
  80042101cb:	83 f8 08             	cmp    $0x8,%eax
  80042101ce:	0f 84 96 00 00 00    	je     800421026a <_dwarf_read_msb+0xe0>
  80042101d4:	e9 40 01 00 00       	jmpq   8004210319 <_dwarf_read_msb+0x18f>
	case 1:
		ret = src[0];
  80042101d9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101dd:	0f b6 00             	movzbl (%rax),%eax
  80042101e0:	0f b6 c0             	movzbl %al,%eax
  80042101e3:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042101e7:	e9 34 01 00 00       	jmpq   8004210320 <_dwarf_read_msb+0x196>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  80042101ec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101f0:	48 83 c0 01          	add    $0x1,%rax
  80042101f4:	0f b6 00             	movzbl (%rax),%eax
  80042101f7:	0f b6 d0             	movzbl %al,%edx
  80042101fa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042101fe:	0f b6 00             	movzbl (%rax),%eax
  8004210201:	0f b6 c0             	movzbl %al,%eax
  8004210204:	48 c1 e0 08          	shl    $0x8,%rax
  8004210208:	48 09 d0             	or     %rdx,%rax
  800421020b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  800421020f:	e9 0c 01 00 00       	jmpq   8004210320 <_dwarf_read_msb+0x196>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  8004210214:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210218:	48 83 c0 03          	add    $0x3,%rax
  800421021c:	0f b6 00             	movzbl (%rax),%eax
  800421021f:	0f b6 c0             	movzbl %al,%eax
  8004210222:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210226:	48 83 c2 02          	add    $0x2,%rdx
  800421022a:	0f b6 12             	movzbl (%rdx),%edx
  800421022d:	0f b6 d2             	movzbl %dl,%edx
  8004210230:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210234:	48 09 d0             	or     %rdx,%rax
  8004210237:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  800421023b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421023f:	48 83 c0 01          	add    $0x1,%rax
  8004210243:	0f b6 00             	movzbl (%rax),%eax
  8004210246:	0f b6 c0             	movzbl %al,%eax
  8004210249:	48 c1 e0 10          	shl    $0x10,%rax
  800421024d:	48 89 c2             	mov    %rax,%rdx
  8004210250:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210254:	0f b6 00             	movzbl (%rax),%eax
  8004210257:	0f b6 c0             	movzbl %al,%eax
  800421025a:	48 c1 e0 18          	shl    $0x18,%rax
  800421025e:	48 09 d0             	or     %rdx,%rax
  8004210261:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210265:	e9 b6 00 00 00       	jmpq   8004210320 <_dwarf_read_msb+0x196>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  800421026a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421026e:	48 83 c0 07          	add    $0x7,%rax
  8004210272:	0f b6 00             	movzbl (%rax),%eax
  8004210275:	0f b6 c0             	movzbl %al,%eax
  8004210278:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421027c:	48 83 c2 06          	add    $0x6,%rdx
  8004210280:	0f b6 12             	movzbl (%rdx),%edx
  8004210283:	0f b6 d2             	movzbl %dl,%edx
  8004210286:	48 c1 e2 08          	shl    $0x8,%rdx
  800421028a:	48 09 d0             	or     %rdx,%rax
  800421028d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210291:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210295:	48 83 c0 05          	add    $0x5,%rax
  8004210299:	0f b6 00             	movzbl (%rax),%eax
  800421029c:	0f b6 c0             	movzbl %al,%eax
  800421029f:	48 c1 e0 10          	shl    $0x10,%rax
  80042102a3:	48 89 c2             	mov    %rax,%rdx
  80042102a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102aa:	48 83 c0 04          	add    $0x4,%rax
  80042102ae:	0f b6 00             	movzbl (%rax),%eax
  80042102b1:	0f b6 c0             	movzbl %al,%eax
  80042102b4:	48 c1 e0 18          	shl    $0x18,%rax
  80042102b8:	48 09 d0             	or     %rdx,%rax
  80042102bb:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  80042102bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102c3:	48 83 c0 03          	add    $0x3,%rax
  80042102c7:	0f b6 00             	movzbl (%rax),%eax
  80042102ca:	0f b6 c0             	movzbl %al,%eax
  80042102cd:	48 c1 e0 20          	shl    $0x20,%rax
  80042102d1:	48 89 c2             	mov    %rax,%rdx
  80042102d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102d8:	48 83 c0 02          	add    $0x2,%rax
  80042102dc:	0f b6 00             	movzbl (%rax),%eax
  80042102df:	0f b6 c0             	movzbl %al,%eax
  80042102e2:	48 c1 e0 28          	shl    $0x28,%rax
  80042102e6:	48 09 d0             	or     %rdx,%rax
  80042102e9:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  80042102ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042102f1:	48 83 c0 01          	add    $0x1,%rax
  80042102f5:	0f b6 00             	movzbl (%rax),%eax
  80042102f8:	0f b6 c0             	movzbl %al,%eax
  80042102fb:	48 c1 e0 30          	shl    $0x30,%rax
  80042102ff:	48 89 c2             	mov    %rax,%rdx
  8004210302:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210306:	0f b6 00             	movzbl (%rax),%eax
  8004210309:	0f b6 c0             	movzbl %al,%eax
  800421030c:	48 c1 e0 38          	shl    $0x38,%rax
  8004210310:	48 09 d0             	or     %rdx,%rax
  8004210313:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210317:	eb 07                	jmp    8004210320 <_dwarf_read_msb+0x196>
	default:
		return (0);
  8004210319:	b8 00 00 00 00       	mov    $0x0,%eax
  800421031e:	eb 1a                	jmp    800421033a <_dwarf_read_msb+0x1b0>
	}

	*offsetp += bytes_to_read;
  8004210320:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210324:	48 8b 10             	mov    (%rax),%rdx
  8004210327:	8b 45 dc             	mov    -0x24(%rbp),%eax
  800421032a:	48 98                	cltq   
  800421032c:	48 01 c2             	add    %rax,%rdx
  800421032f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210333:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210336:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421033a:	c9                   	leaveq 
  800421033b:	c3                   	retq   

000000800421033c <_dwarf_decode_msb>:

uint64_t
_dwarf_decode_msb(uint8_t **data, int bytes_to_read)
{
  800421033c:	55                   	push   %rbp
  800421033d:	48 89 e5             	mov    %rsp,%rbp
  8004210340:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004210344:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210348:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint64_t ret;
	uint8_t *src;

	src = *data;
  800421034b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421034f:	48 8b 00             	mov    (%rax),%rax
  8004210352:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	ret = 0;
  8004210356:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  800421035d:	00 
	switch (bytes_to_read) {
  800421035e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004210361:	83 f8 02             	cmp    $0x2,%eax
  8004210364:	74 35                	je     800421039b <_dwarf_decode_msb+0x5f>
  8004210366:	83 f8 02             	cmp    $0x2,%eax
  8004210369:	7f 0a                	jg     8004210375 <_dwarf_decode_msb+0x39>
  800421036b:	83 f8 01             	cmp    $0x1,%eax
  800421036e:	74 18                	je     8004210388 <_dwarf_decode_msb+0x4c>
  8004210370:	e9 53 01 00 00       	jmpq   80042104c8 <_dwarf_decode_msb+0x18c>
  8004210375:	83 f8 04             	cmp    $0x4,%eax
  8004210378:	74 49                	je     80042103c3 <_dwarf_decode_msb+0x87>
  800421037a:	83 f8 08             	cmp    $0x8,%eax
  800421037d:	0f 84 96 00 00 00    	je     8004210419 <_dwarf_decode_msb+0xdd>
  8004210383:	e9 40 01 00 00       	jmpq   80042104c8 <_dwarf_decode_msb+0x18c>
	case 1:
		ret = src[0];
  8004210388:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421038c:	0f b6 00             	movzbl (%rax),%eax
  800421038f:	0f b6 c0             	movzbl %al,%eax
  8004210392:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  8004210396:	e9 34 01 00 00       	jmpq   80042104cf <_dwarf_decode_msb+0x193>
	case 2:
		ret = src[1] | ((uint64_t) src[0]) << 8;
  800421039b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421039f:	48 83 c0 01          	add    $0x1,%rax
  80042103a3:	0f b6 00             	movzbl (%rax),%eax
  80042103a6:	0f b6 d0             	movzbl %al,%edx
  80042103a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103ad:	0f b6 00             	movzbl (%rax),%eax
  80042103b0:	0f b6 c0             	movzbl %al,%eax
  80042103b3:	48 c1 e0 08          	shl    $0x8,%rax
  80042103b7:	48 09 d0             	or     %rdx,%rax
  80042103ba:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		break;
  80042103be:	e9 0c 01 00 00       	jmpq   80042104cf <_dwarf_decode_msb+0x193>
	case 4:
		ret = src[3] | ((uint64_t) src[2]) << 8;
  80042103c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103c7:	48 83 c0 03          	add    $0x3,%rax
  80042103cb:	0f b6 00             	movzbl (%rax),%eax
  80042103ce:	0f b6 c0             	movzbl %al,%eax
  80042103d1:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042103d5:	48 83 c2 02          	add    $0x2,%rdx
  80042103d9:	0f b6 12             	movzbl (%rdx),%edx
  80042103dc:	0f b6 d2             	movzbl %dl,%edx
  80042103df:	48 c1 e2 08          	shl    $0x8,%rdx
  80042103e3:	48 09 d0             	or     %rdx,%rax
  80042103e6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 16 | ((uint64_t) src[0]) << 24;
  80042103ea:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042103ee:	48 83 c0 01          	add    $0x1,%rax
  80042103f2:	0f b6 00             	movzbl (%rax),%eax
  80042103f5:	0f b6 c0             	movzbl %al,%eax
  80042103f8:	48 c1 e0 10          	shl    $0x10,%rax
  80042103fc:	48 89 c2             	mov    %rax,%rdx
  80042103ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210403:	0f b6 00             	movzbl (%rax),%eax
  8004210406:	0f b6 c0             	movzbl %al,%eax
  8004210409:	48 c1 e0 18          	shl    $0x18,%rax
  800421040d:	48 09 d0             	or     %rdx,%rax
  8004210410:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  8004210414:	e9 b6 00 00 00       	jmpq   80042104cf <_dwarf_decode_msb+0x193>
	case 8:
		ret = src[7] | ((uint64_t) src[6]) << 8;
  8004210419:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421041d:	48 83 c0 07          	add    $0x7,%rax
  8004210421:	0f b6 00             	movzbl (%rax),%eax
  8004210424:	0f b6 c0             	movzbl %al,%eax
  8004210427:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  800421042b:	48 83 c2 06          	add    $0x6,%rdx
  800421042f:	0f b6 12             	movzbl (%rdx),%edx
  8004210432:	0f b6 d2             	movzbl %dl,%edx
  8004210435:	48 c1 e2 08          	shl    $0x8,%rdx
  8004210439:	48 09 d0             	or     %rdx,%rax
  800421043c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[5]) << 16 | ((uint64_t) src[4]) << 24;
  8004210440:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210444:	48 83 c0 05          	add    $0x5,%rax
  8004210448:	0f b6 00             	movzbl (%rax),%eax
  800421044b:	0f b6 c0             	movzbl %al,%eax
  800421044e:	48 c1 e0 10          	shl    $0x10,%rax
  8004210452:	48 89 c2             	mov    %rax,%rdx
  8004210455:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210459:	48 83 c0 04          	add    $0x4,%rax
  800421045d:	0f b6 00             	movzbl (%rax),%eax
  8004210460:	0f b6 c0             	movzbl %al,%eax
  8004210463:	48 c1 e0 18          	shl    $0x18,%rax
  8004210467:	48 09 d0             	or     %rdx,%rax
  800421046a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[3]) << 32 | ((uint64_t) src[2]) << 40;
  800421046e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210472:	48 83 c0 03          	add    $0x3,%rax
  8004210476:	0f b6 00             	movzbl (%rax),%eax
  8004210479:	0f b6 c0             	movzbl %al,%eax
  800421047c:	48 c1 e0 20          	shl    $0x20,%rax
  8004210480:	48 89 c2             	mov    %rax,%rdx
  8004210483:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210487:	48 83 c0 02          	add    $0x2,%rax
  800421048b:	0f b6 00             	movzbl (%rax),%eax
  800421048e:	0f b6 c0             	movzbl %al,%eax
  8004210491:	48 c1 e0 28          	shl    $0x28,%rax
  8004210495:	48 09 d0             	or     %rdx,%rax
  8004210498:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		ret |= ((uint64_t) src[1]) << 48 | ((uint64_t) src[0]) << 56;
  800421049c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104a0:	48 83 c0 01          	add    $0x1,%rax
  80042104a4:	0f b6 00             	movzbl (%rax),%eax
  80042104a7:	0f b6 c0             	movzbl %al,%eax
  80042104aa:	48 c1 e0 30          	shl    $0x30,%rax
  80042104ae:	48 89 c2             	mov    %rax,%rdx
  80042104b1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042104b5:	0f b6 00             	movzbl (%rax),%eax
  80042104b8:	0f b6 c0             	movzbl %al,%eax
  80042104bb:	48 c1 e0 38          	shl    $0x38,%rax
  80042104bf:	48 09 d0             	or     %rdx,%rax
  80042104c2:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		break;
  80042104c6:	eb 07                	jmp    80042104cf <_dwarf_decode_msb+0x193>
	default:
		return (0);
  80042104c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80042104cd:	eb 1a                	jmp    80042104e9 <_dwarf_decode_msb+0x1ad>
		break;
	}

	*data += bytes_to_read;
  80042104cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104d3:	48 8b 10             	mov    (%rax),%rdx
  80042104d6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042104d9:	48 98                	cltq   
  80042104db:	48 01 c2             	add    %rax,%rdx
  80042104de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042104e2:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042104e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042104e9:	c9                   	leaveq 
  80042104ea:	c3                   	retq   

00000080042104eb <_dwarf_read_sleb128>:

int64_t
_dwarf_read_sleb128(uint8_t *data, uint64_t *offsetp)
{
  80042104eb:	55                   	push   %rbp
  80042104ec:	48 89 e5             	mov    %rsp,%rbp
  80042104ef:	48 83 ec 30          	sub    $0x30,%rsp
  80042104f3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042104f7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	int64_t ret = 0;
  80042104fb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210502:	00 
	uint8_t b;
	int shift = 0;
  8004210503:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  800421050a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421050e:	48 8b 10             	mov    (%rax),%rdx
  8004210511:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210515:	48 01 d0             	add    %rdx,%rax
  8004210518:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  800421051c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210520:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210524:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210528:	0f b6 00             	movzbl (%rax),%eax
  800421052b:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  800421052e:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210532:	83 e0 7f             	and    $0x7f,%eax
  8004210535:	89 c2                	mov    %eax,%edx
  8004210537:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421053a:	89 c1                	mov    %eax,%ecx
  800421053c:	d3 e2                	shl    %cl,%edx
  800421053e:	89 d0                	mov    %edx,%eax
  8004210540:	48 98                	cltq   
  8004210542:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  8004210546:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421054a:	48 8b 00             	mov    (%rax),%rax
  800421054d:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210551:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210555:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  8004210558:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  800421055c:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210560:	84 c0                	test   %al,%al
  8004210562:	78 b8                	js     800421051c <_dwarf_read_sleb128+0x31>

	if (shift < 32 && (b & 0x40) != 0)
  8004210564:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  8004210568:	7f 1f                	jg     8004210589 <_dwarf_read_sleb128+0x9e>
  800421056a:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421056e:	83 e0 40             	and    $0x40,%eax
  8004210571:	85 c0                	test   %eax,%eax
  8004210573:	74 14                	je     8004210589 <_dwarf_read_sleb128+0x9e>
		ret |= (-1 << shift);
  8004210575:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210578:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  800421057d:	89 c1                	mov    %eax,%ecx
  800421057f:	d3 e2                	shl    %cl,%edx
  8004210581:	89 d0                	mov    %edx,%eax
  8004210583:	48 98                	cltq   
  8004210585:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	return (ret);
  8004210589:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421058d:	c9                   	leaveq 
  800421058e:	c3                   	retq   

000000800421058f <_dwarf_read_uleb128>:

uint64_t
_dwarf_read_uleb128(uint8_t *data, uint64_t *offsetp)
{
  800421058f:	55                   	push   %rbp
  8004210590:	48 89 e5             	mov    %rsp,%rbp
  8004210593:	48 83 ec 30          	sub    $0x30,%rsp
  8004210597:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  800421059b:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
	uint64_t ret = 0;
  800421059f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042105a6:	00 
	uint8_t b;
	int shift = 0;
  80042105a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	uint8_t *src;

	src = data + *offsetp;
  80042105ae:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042105b2:	48 8b 10             	mov    (%rax),%rdx
  80042105b5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042105b9:	48 01 d0             	add    %rdx,%rax
  80042105bc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042105c0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042105c4:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042105c8:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042105cc:	0f b6 00             	movzbl (%rax),%eax
  80042105cf:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  80042105d2:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042105d6:	83 e0 7f             	and    $0x7f,%eax
  80042105d9:	89 c2                	mov    %eax,%edx
  80042105db:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042105de:	89 c1                	mov    %eax,%ecx
  80042105e0:	d3 e2                	shl    %cl,%edx
  80042105e2:	89 d0                	mov    %edx,%eax
  80042105e4:	48 98                	cltq   
  80042105e6:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		(*offsetp)++;
  80042105ea:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042105ee:	48 8b 00             	mov    (%rax),%rax
  80042105f1:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042105f5:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042105f9:	48 89 10             	mov    %rdx,(%rax)
		shift += 7;
  80042105fc:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210600:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210604:	84 c0                	test   %al,%al
  8004210606:	78 b8                	js     80042105c0 <_dwarf_read_uleb128+0x31>

	return (ret);
  8004210608:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421060c:	c9                   	leaveq 
  800421060d:	c3                   	retq   

000000800421060e <_dwarf_decode_sleb128>:

int64_t
_dwarf_decode_sleb128(uint8_t **dp)
{
  800421060e:	55                   	push   %rbp
  800421060f:	48 89 e5             	mov    %rsp,%rbp
  8004210612:	48 83 ec 28          	sub    $0x28,%rsp
  8004210616:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	int64_t ret = 0;
  800421061a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004210621:	00 
	uint8_t b;
	int shift = 0;
  8004210622:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  8004210629:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421062d:	48 8b 00             	mov    (%rax),%rax
  8004210630:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  8004210634:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210638:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421063c:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  8004210640:	0f b6 00             	movzbl (%rax),%eax
  8004210643:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  8004210646:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  800421064a:	83 e0 7f             	and    $0x7f,%eax
  800421064d:	89 c2                	mov    %eax,%edx
  800421064f:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210652:	89 c1                	mov    %eax,%ecx
  8004210654:	d3 e2                	shl    %cl,%edx
  8004210656:	89 d0                	mov    %edx,%eax
  8004210658:	48 98                	cltq   
  800421065a:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  800421065e:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  8004210662:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210666:	84 c0                	test   %al,%al
  8004210668:	78 ca                	js     8004210634 <_dwarf_decode_sleb128+0x26>

	if (shift < 32 && (b & 0x40) != 0)
  800421066a:	83 7d f4 1f          	cmpl   $0x1f,-0xc(%rbp)
  800421066e:	7f 1f                	jg     800421068f <_dwarf_decode_sleb128+0x81>
  8004210670:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  8004210674:	83 e0 40             	and    $0x40,%eax
  8004210677:	85 c0                	test   %eax,%eax
  8004210679:	74 14                	je     800421068f <_dwarf_decode_sleb128+0x81>
		ret |= (-1 << shift);
  800421067b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421067e:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  8004210683:	89 c1                	mov    %eax,%ecx
  8004210685:	d3 e2                	shl    %cl,%edx
  8004210687:	89 d0                	mov    %edx,%eax
  8004210689:	48 98                	cltq   
  800421068b:	48 09 45 f8          	or     %rax,-0x8(%rbp)

	*dp = src;
  800421068f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210693:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210697:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  800421069a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421069e:	c9                   	leaveq 
  800421069f:	c3                   	retq   

00000080042106a0 <_dwarf_decode_uleb128>:

uint64_t
_dwarf_decode_uleb128(uint8_t **dp)
{
  80042106a0:	55                   	push   %rbp
  80042106a1:	48 89 e5             	mov    %rsp,%rbp
  80042106a4:	48 83 ec 28          	sub    $0x28,%rsp
  80042106a8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint64_t ret = 0;
  80042106ac:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042106b3:	00 
	uint8_t b;
	int shift = 0;
  80042106b4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)

	uint8_t *src = *dp;
  80042106bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042106bf:	48 8b 00             	mov    (%rax),%rax
  80042106c2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	do {
		b = *src++;
  80042106c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042106ca:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042106ce:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  80042106d2:	0f b6 00             	movzbl (%rax),%eax
  80042106d5:	88 45 e7             	mov    %al,-0x19(%rbp)
		ret |= ((b & 0x7f) << shift);
  80042106d8:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042106dc:	83 e0 7f             	and    $0x7f,%eax
  80042106df:	89 c2                	mov    %eax,%edx
  80042106e1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042106e4:	89 c1                	mov    %eax,%ecx
  80042106e6:	d3 e2                	shl    %cl,%edx
  80042106e8:	89 d0                	mov    %edx,%eax
  80042106ea:	48 98                	cltq   
  80042106ec:	48 09 45 f8          	or     %rax,-0x8(%rbp)
		shift += 7;
  80042106f0:	83 45 f4 07          	addl   $0x7,-0xc(%rbp)
	} while ((b & 0x80) != 0);
  80042106f4:	0f b6 45 e7          	movzbl -0x19(%rbp),%eax
  80042106f8:	84 c0                	test   %al,%al
  80042106fa:	78 ca                	js     80042106c6 <_dwarf_decode_uleb128+0x26>

	*dp = src;
  80042106fc:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210700:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210704:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210707:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  800421070b:	c9                   	leaveq 
  800421070c:	c3                   	retq   

000000800421070d <_dwarf_read_string>:

#define Dwarf_Unsigned uint64_t

char *
_dwarf_read_string(void *data, Dwarf_Unsigned size, uint64_t *offsetp)
{
  800421070d:	55                   	push   %rbp
  800421070e:	48 89 e5             	mov    %rsp,%rbp
  8004210711:	48 83 ec 28          	sub    $0x28,%rsp
  8004210715:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004210719:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  800421071d:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	char *ret, *src;

	ret = src = (char *) data + *offsetp;
  8004210721:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210725:	48 8b 10             	mov    (%rax),%rdx
  8004210728:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421072c:	48 01 d0             	add    %rdx,%rax
  800421072f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004210733:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210737:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	while (*src != '\0' && *offsetp < size) {
  800421073b:	eb 17                	jmp    8004210754 <_dwarf_read_string+0x47>
		src++;
  800421073d:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
		(*offsetp)++;
  8004210742:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210746:	48 8b 00             	mov    (%rax),%rax
  8004210749:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421074d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210751:	48 89 10             	mov    %rdx,(%rax)
{
	char *ret, *src;

	ret = src = (char *) data + *offsetp;

	while (*src != '\0' && *offsetp < size) {
  8004210754:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210758:	0f b6 00             	movzbl (%rax),%eax
  800421075b:	84 c0                	test   %al,%al
  800421075d:	74 0d                	je     800421076c <_dwarf_read_string+0x5f>
  800421075f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210763:	48 8b 00             	mov    (%rax),%rax
  8004210766:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  800421076a:	72 d1                	jb     800421073d <_dwarf_read_string+0x30>
		src++;
		(*offsetp)++;
	}

	if (*src == '\0' && *offsetp < size)
  800421076c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210770:	0f b6 00             	movzbl (%rax),%eax
  8004210773:	84 c0                	test   %al,%al
  8004210775:	75 1f                	jne    8004210796 <_dwarf_read_string+0x89>
  8004210777:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421077b:	48 8b 00             	mov    (%rax),%rax
  800421077e:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004210782:	73 12                	jae    8004210796 <_dwarf_read_string+0x89>
		(*offsetp)++;
  8004210784:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210788:	48 8b 00             	mov    (%rax),%rax
  800421078b:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421078f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210793:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  8004210796:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  800421079a:	c9                   	leaveq 
  800421079b:	c3                   	retq   

000000800421079c <_dwarf_read_block>:

uint8_t *
_dwarf_read_block(void *data, uint64_t *offsetp, uint64_t length)
{
  800421079c:	55                   	push   %rbp
  800421079d:	48 89 e5             	mov    %rsp,%rbp
  80042107a0:	48 83 ec 28          	sub    $0x28,%rsp
  80042107a4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042107a8:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042107ac:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	uint8_t *ret, *src;

	ret = src = (uint8_t *) data + *offsetp;
  80042107b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042107b4:	48 8b 10             	mov    (%rax),%rdx
  80042107b7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107bb:	48 01 d0             	add    %rdx,%rax
  80042107be:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042107c2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042107c6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	(*offsetp) += length;
  80042107ca:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042107ce:	48 8b 10             	mov    (%rax),%rdx
  80042107d1:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042107d5:	48 01 c2             	add    %rax,%rdx
  80042107d8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042107dc:	48 89 10             	mov    %rdx,(%rax)

	return (ret);
  80042107df:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
}
  80042107e3:	c9                   	leaveq 
  80042107e4:	c3                   	retq   

00000080042107e5 <_dwarf_elf_get_byte_order>:

Dwarf_Endianness
_dwarf_elf_get_byte_order(void *obj)
{
  80042107e5:	55                   	push   %rbp
  80042107e6:	48 89 e5             	mov    %rsp,%rbp
  80042107e9:	48 83 ec 20          	sub    $0x20,%rsp
  80042107ed:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *)obj;
  80042107f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042107f5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  80042107f9:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042107fe:	75 35                	jne    8004210835 <_dwarf_elf_get_byte_order+0x50>
  8004210800:	48 b9 e0 9f 21 04 80 	movabs $0x8004219fe0,%rcx
  8004210807:	00 00 00 
  800421080a:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004210811:	00 00 00 
  8004210814:	be 29 01 00 00       	mov    $0x129,%esi
  8004210819:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004210820:	00 00 00 
  8004210823:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210828:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800421082f:	00 00 00 
  8004210832:	41 ff d0             	callq  *%r8

//TODO: Need to check for 64bit here. Because currently Elf header for
//      64bit doesn't have any memeber e_ident. But need to see what is
//      similar in 64bit.
	switch (e->e_ident[EI_DATA]) {
  8004210835:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210839:	0f b6 40 05          	movzbl 0x5(%rax),%eax
  800421083d:	0f b6 c0             	movzbl %al,%eax
  8004210840:	83 f8 02             	cmp    $0x2,%eax
  8004210843:	75 07                	jne    800421084c <_dwarf_elf_get_byte_order+0x67>
	case ELFDATA2MSB:
		return (DW_OBJECT_MSB);
  8004210845:	b8 00 00 00 00       	mov    $0x0,%eax
  800421084a:	eb 05                	jmp    8004210851 <_dwarf_elf_get_byte_order+0x6c>

	case ELFDATA2LSB:
	case ELFDATANONE:
	default:
		return (DW_OBJECT_LSB);
  800421084c:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
  8004210851:	c9                   	leaveq 
  8004210852:	c3                   	retq   

0000008004210853 <_dwarf_elf_get_pointer_size>:

Dwarf_Small
_dwarf_elf_get_pointer_size(void *obj)
{
  8004210853:	55                   	push   %rbp
  8004210854:	48 89 e5             	mov    %rsp,%rbp
  8004210857:	48 83 ec 20          	sub    $0x20,%rsp
  800421085b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Elf *e;

	e = (Elf *) obj;
  800421085f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210863:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(e != NULL);
  8004210867:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  800421086c:	75 35                	jne    80042108a3 <_dwarf_elf_get_pointer_size+0x50>
  800421086e:	48 b9 e0 9f 21 04 80 	movabs $0x8004219fe0,%rcx
  8004210875:	00 00 00 
  8004210878:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  800421087f:	00 00 00 
  8004210882:	be 3f 01 00 00       	mov    $0x13f,%esi
  8004210887:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  800421088e:	00 00 00 
  8004210891:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210896:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800421089d:	00 00 00 
  80042108a0:	41 ff d0             	callq  *%r8

	if (e->e_ident[4] == ELFCLASS32)
  80042108a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042108a7:	0f b6 40 04          	movzbl 0x4(%rax),%eax
  80042108ab:	3c 01                	cmp    $0x1,%al
  80042108ad:	75 07                	jne    80042108b6 <_dwarf_elf_get_pointer_size+0x63>
		return (4);
  80042108af:	b8 04 00 00 00       	mov    $0x4,%eax
  80042108b4:	eb 05                	jmp    80042108bb <_dwarf_elf_get_pointer_size+0x68>
	else
		return (8);
  80042108b6:	b8 08 00 00 00       	mov    $0x8,%eax
}
  80042108bb:	c9                   	leaveq 
  80042108bc:	c3                   	retq   

00000080042108bd <_dwarf_init>:

//Return 0 on success
int _dwarf_init(Dwarf_Debug dbg, void *obj)
{
  80042108bd:	55                   	push   %rbp
  80042108be:	48 89 e5             	mov    %rsp,%rbp
  80042108c1:	53                   	push   %rbx
  80042108c2:	48 83 ec 18          	sub    $0x18,%rsp
  80042108c6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042108ca:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	memset(dbg, 0, sizeof(struct _Dwarf_Debug));
  80042108ce:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108d2:	ba 60 00 00 00       	mov    $0x60,%edx
  80042108d7:	be 00 00 00 00       	mov    $0x0,%esi
  80042108dc:	48 89 c7             	mov    %rax,%rdi
  80042108df:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  80042108e6:	00 00 00 
  80042108e9:	ff d0                	callq  *%rax
	dbg->curr_off_dbginfo = 0;
  80042108eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108ef:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
	dbg->dbg_info_size = 0;
  80042108f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042108fa:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004210901:	00 
	dbg->dbg_pointer_size = _dwarf_elf_get_pointer_size(obj); 
  8004210902:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210906:	48 89 c7             	mov    %rax,%rdi
  8004210909:	48 b8 53 08 21 04 80 	movabs $0x8004210853,%rax
  8004210910:	00 00 00 
  8004210913:	ff d0                	callq  *%rax
  8004210915:	0f b6 d0             	movzbl %al,%edx
  8004210918:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421091c:	89 50 28             	mov    %edx,0x28(%rax)

	if (_dwarf_elf_get_byte_order(obj) == DW_OBJECT_MSB) {
  800421091f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210923:	48 89 c7             	mov    %rax,%rdi
  8004210926:	48 b8 e5 07 21 04 80 	movabs $0x80042107e5,%rax
  800421092d:	00 00 00 
  8004210930:	ff d0                	callq  *%rax
  8004210932:	85 c0                	test   %eax,%eax
  8004210934:	75 26                	jne    800421095c <_dwarf_init+0x9f>
		dbg->read = _dwarf_read_msb;
  8004210936:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421093a:	48 b9 8a 01 21 04 80 	movabs $0x800421018a,%rcx
  8004210941:	00 00 00 
  8004210944:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_msb;
  8004210948:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421094c:	48 bb 3c 03 21 04 80 	movabs $0x800421033c,%rbx
  8004210953:	00 00 00 
  8004210956:	48 89 58 20          	mov    %rbx,0x20(%rax)
  800421095a:	eb 24                	jmp    8004210980 <_dwarf_init+0xc3>
	} else {
		dbg->read = _dwarf_read_lsb;
  800421095c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210960:	48 b9 3d ff 20 04 80 	movabs $0x800420ff3d,%rcx
  8004210967:	00 00 00 
  800421096a:	48 89 48 18          	mov    %rcx,0x18(%rax)
		dbg->decode = _dwarf_decode_lsb;
  800421096e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210972:	48 be 69 00 21 04 80 	movabs $0x8004210069,%rsi
  8004210979:	00 00 00 
  800421097c:	48 89 70 20          	mov    %rsi,0x20(%rax)
	}
	_dwarf_frame_params_init(dbg);
  8004210980:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210984:	48 89 c7             	mov    %rax,%rdi
  8004210987:	48 b8 8a 1e 21 04 80 	movabs $0x8004211e8a,%rax
  800421098e:	00 00 00 
  8004210991:	ff d0                	callq  *%rax
	return 0;
  8004210993:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210998:	48 83 c4 18          	add    $0x18,%rsp
  800421099c:	5b                   	pop    %rbx
  800421099d:	5d                   	pop    %rbp
  800421099e:	c3                   	retq   

000000800421099f <_get_next_cu>:

//Return 0 on success
int _get_next_cu(Dwarf_Debug dbg, Dwarf_CU *cu)
{
  800421099f:	55                   	push   %rbp
  80042109a0:	48 89 e5             	mov    %rsp,%rbp
  80042109a3:	48 83 ec 20          	sub    $0x20,%rsp
  80042109a7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042109ab:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
	uint32_t length;
	uint64_t offset;
	uint8_t dwarf_size;

	if(dbg->curr_off_dbginfo > dbg->dbg_info_size)
  80042109af:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109b3:	48 8b 10             	mov    (%rax),%rdx
  80042109b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109ba:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042109be:	48 39 c2             	cmp    %rax,%rdx
  80042109c1:	76 0a                	jbe    80042109cd <_get_next_cu+0x2e>
		return -1;
  80042109c3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042109c8:	e9 6b 01 00 00       	jmpq   8004210b38 <_get_next_cu+0x199>

	offset = dbg->curr_off_dbginfo;
  80042109cd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109d1:	48 8b 00             	mov    (%rax),%rax
  80042109d4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	cu->cu_offset = offset;
  80042109d8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042109dc:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042109e0:	48 89 50 30          	mov    %rdx,0x30(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset,4);
  80042109e4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042109e8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042109ec:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042109f0:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  80042109f4:	48 89 d1             	mov    %rdx,%rcx
  80042109f7:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  80042109fb:	ba 04 00 00 00       	mov    $0x4,%edx
  8004210a00:	48 89 cf             	mov    %rcx,%rdi
  8004210a03:	ff d0                	callq  *%rax
  8004210a05:	89 45 fc             	mov    %eax,-0x4(%rbp)
	if (length == 0xffffffff) {
  8004210a08:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
  8004210a0c:	75 2a                	jne    8004210a38 <_get_next_cu+0x99>
		length = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 8);
  8004210a0e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a12:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210a16:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210a1a:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210a1e:	48 89 d1             	mov    %rdx,%rcx
  8004210a21:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210a25:	ba 08 00 00 00       	mov    $0x8,%edx
  8004210a2a:	48 89 cf             	mov    %rcx,%rdi
  8004210a2d:	ff d0                	callq  *%rax
  8004210a2f:	89 45 fc             	mov    %eax,-0x4(%rbp)
		dwarf_size = 8;
  8004210a32:	c6 45 fb 08          	movb   $0x8,-0x5(%rbp)
  8004210a36:	eb 04                	jmp    8004210a3c <_get_next_cu+0x9d>
	} else {
		dwarf_size = 4;
  8004210a38:	c6 45 fb 04          	movb   $0x4,-0x5(%rbp)
	}

	cu->cu_dwarf_size = dwarf_size;
  8004210a3c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a40:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004210a44:	88 50 19             	mov    %dl,0x19(%rax)
	 if (length > ds->ds_size - offset) {
	 return (DW_DLE_CU_LENGTH_ERROR);
	 }*/

	/* Compute the offset to the next compilation unit: */
	dbg->curr_off_dbginfo = offset + length;
  8004210a47:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210a4a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210a4e:	48 01 c2             	add    %rax,%rdx
  8004210a51:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a55:	48 89 10             	mov    %rdx,(%rax)
	cu->cu_next_offset   = dbg->curr_off_dbginfo;
  8004210a58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a5c:	48 8b 10             	mov    (%rax),%rdx
  8004210a5f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a63:	48 89 50 20          	mov    %rdx,0x20(%rax)

	/* Initialise the compilation unit. */
	cu->cu_length = (uint64_t)length;
  8004210a67:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004210a6a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210a6e:	48 89 10             	mov    %rdx,(%rax)

	cu->cu_length_size   = (dwarf_size == 4 ? 4 : 12);
  8004210a71:	80 7d fb 04          	cmpb   $0x4,-0x5(%rbp)
  8004210a75:	75 07                	jne    8004210a7e <_get_next_cu+0xdf>
  8004210a77:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210a7c:	eb 05                	jmp    8004210a83 <_get_next_cu+0xe4>
  8004210a7e:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004210a83:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210a87:	88 42 18             	mov    %al,0x18(%rdx)
	cu->version              = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 2);
  8004210a8a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210a8e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210a92:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210a96:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210a9a:	48 89 d1             	mov    %rdx,%rcx
  8004210a9d:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210aa1:	ba 02 00 00 00       	mov    $0x2,%edx
  8004210aa6:	48 89 cf             	mov    %rcx,%rdi
  8004210aa9:	ff d0                	callq  *%rax
  8004210aab:	89 c2                	mov    %eax,%edx
  8004210aad:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210ab1:	66 89 50 08          	mov    %dx,0x8(%rax)
	cu->debug_abbrev_offset  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, dwarf_size);
  8004210ab5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ab9:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210abd:	0f b6 55 fb          	movzbl -0x5(%rbp),%edx
  8004210ac1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004210ac5:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004210ac9:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210acd:	48 89 cf             	mov    %rcx,%rdi
  8004210ad0:	ff d0                	callq  *%rax
  8004210ad2:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210ad6:	48 89 42 10          	mov    %rax,0x10(%rdx)
	//cu->cu_abbrev_offset_cur = cu->cu_abbrev_offset;
	cu->addr_size  = dbg->read((uint8_t *)dbg->dbg_info_offset_elf, &offset, 1);
  8004210ada:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210ade:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210ae2:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210ae6:	48 8b 52 08          	mov    0x8(%rdx),%rdx
  8004210aea:	48 89 d1             	mov    %rdx,%rcx
  8004210aed:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
  8004210af1:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210af6:	48 89 cf             	mov    %rcx,%rdi
  8004210af9:	ff d0                	callq  *%rax
  8004210afb:	89 c2                	mov    %eax,%edx
  8004210afd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210b01:	88 50 0a             	mov    %dl,0xa(%rax)

	if (cu->version < 2 || cu->version > 4) {
  8004210b04:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210b08:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210b0c:	66 83 f8 01          	cmp    $0x1,%ax
  8004210b10:	76 0e                	jbe    8004210b20 <_get_next_cu+0x181>
  8004210b12:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210b16:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  8004210b1a:	66 83 f8 04          	cmp    $0x4,%ax
  8004210b1e:	76 07                	jbe    8004210b27 <_get_next_cu+0x188>
		return -1;
  8004210b20:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004210b25:	eb 11                	jmp    8004210b38 <_get_next_cu+0x199>
	}

	cu->cu_die_offset = offset;
  8004210b27:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004210b2b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004210b2f:	48 89 50 28          	mov    %rdx,0x28(%rax)

	return 0;
  8004210b33:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210b38:	c9                   	leaveq 
  8004210b39:	c3                   	retq   

0000008004210b3a <print_cu>:

void print_cu(Dwarf_CU cu)
{
  8004210b3a:	55                   	push   %rbp
  8004210b3b:	48 89 e5             	mov    %rsp,%rbp
	cprintf("%ld---%du--%d\n",cu.cu_length,cu.version,cu.addr_size);
  8004210b3e:	0f b6 45 1a          	movzbl 0x1a(%rbp),%eax
  8004210b42:	0f b6 c8             	movzbl %al,%ecx
  8004210b45:	0f b7 45 18          	movzwl 0x18(%rbp),%eax
  8004210b49:	0f b7 d0             	movzwl %ax,%edx
  8004210b4c:	48 8b 45 10          	mov    0x10(%rbp),%rax
  8004210b50:	48 89 c6             	mov    %rax,%rsi
  8004210b53:	48 bf 12 a0 21 04 80 	movabs $0x800421a012,%rdi
  8004210b5a:	00 00 00 
  8004210b5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210b62:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  8004210b69:	00 00 00 
  8004210b6c:	41 ff d0             	callq  *%r8
}
  8004210b6f:	5d                   	pop    %rbp
  8004210b70:	c3                   	retq   

0000008004210b71 <_dwarf_abbrev_parse>:

//Return 0 on success
int
_dwarf_abbrev_parse(Dwarf_Debug dbg, Dwarf_CU cu, Dwarf_Unsigned *offset,
		    Dwarf_Abbrev *abp, Dwarf_Section *ds)
{
  8004210b71:	55                   	push   %rbp
  8004210b72:	48 89 e5             	mov    %rsp,%rbp
  8004210b75:	48 83 ec 60          	sub    $0x60,%rsp
  8004210b79:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
  8004210b7d:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  8004210b81:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  8004210b85:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
	uint64_t tag;
	uint8_t children;
	uint64_t abbr_addr;
	int ret;

	assert(abp != NULL);
  8004210b89:	48 83 7d a8 00       	cmpq   $0x0,-0x58(%rbp)
  8004210b8e:	75 35                	jne    8004210bc5 <_dwarf_abbrev_parse+0x54>
  8004210b90:	48 b9 21 a0 21 04 80 	movabs $0x800421a021,%rcx
  8004210b97:	00 00 00 
  8004210b9a:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004210ba1:	00 00 00 
  8004210ba4:	be a4 01 00 00       	mov    $0x1a4,%esi
  8004210ba9:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004210bb0:	00 00 00 
  8004210bb3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210bb8:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004210bbf:	00 00 00 
  8004210bc2:	41 ff d0             	callq  *%r8
	assert(ds != NULL);
  8004210bc5:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
  8004210bca:	75 35                	jne    8004210c01 <_dwarf_abbrev_parse+0x90>
  8004210bcc:	48 b9 2d a0 21 04 80 	movabs $0x800421a02d,%rcx
  8004210bd3:	00 00 00 
  8004210bd6:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004210bdd:	00 00 00 
  8004210be0:	be a5 01 00 00       	mov    $0x1a5,%esi
  8004210be5:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004210bec:	00 00 00 
  8004210bef:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210bf4:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004210bfb:	00 00 00 
  8004210bfe:	41 ff d0             	callq  *%r8

	if (*offset >= ds->ds_size)
  8004210c01:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210c05:	48 8b 10             	mov    (%rax),%rdx
  8004210c08:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210c0c:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210c10:	48 39 c2             	cmp    %rax,%rdx
  8004210c13:	72 0a                	jb     8004210c1f <_dwarf_abbrev_parse+0xae>
        	return (DW_DLE_NO_ENTRY);
  8004210c15:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210c1a:	e9 d3 01 00 00       	jmpq   8004210df2 <_dwarf_abbrev_parse+0x281>

	aboff = *offset;
  8004210c1f:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210c23:	48 8b 00             	mov    (%rax),%rax
  8004210c26:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	abbr_addr = (uint64_t)ds->ds_data; //(uint64_t)((uint8_t *)elf_base_ptr + ds->sh_offset);
  8004210c2a:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004210c2e:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210c32:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	entry = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210c36:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c3a:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210c3e:	48 89 d6             	mov    %rdx,%rsi
  8004210c41:	48 89 c7             	mov    %rax,%rdi
  8004210c44:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004210c4b:	00 00 00 
  8004210c4e:	ff d0                	callq  *%rax
  8004210c50:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	if (entry == 0) {
  8004210c54:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004210c59:	75 15                	jne    8004210c70 <_dwarf_abbrev_parse+0xff>
		/* Last entry. */
		//Need to make connection from below function
		abp->ab_entry = 0;
  8004210c5b:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210c5f:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		return DW_DLE_NONE;
  8004210c66:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210c6b:	e9 82 01 00 00       	jmpq   8004210df2 <_dwarf_abbrev_parse+0x281>
	}

	tag = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210c70:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210c74:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210c78:	48 89 d6             	mov    %rdx,%rsi
  8004210c7b:	48 89 c7             	mov    %rax,%rdi
  8004210c7e:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004210c85:	00 00 00 
  8004210c88:	ff d0                	callq  *%rax
  8004210c8a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	children = dbg->read((uint8_t *)abbr_addr, offset, 1);
  8004210c8e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004210c92:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004210c96:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
  8004210c9a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004210c9e:	ba 01 00 00 00       	mov    $0x1,%edx
  8004210ca3:	48 89 cf             	mov    %rcx,%rdi
  8004210ca6:	ff d0                	callq  *%rax
  8004210ca8:	88 45 df             	mov    %al,-0x21(%rbp)

	abp->ab_entry    = entry;
  8004210cab:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210caf:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004210cb3:	48 89 10             	mov    %rdx,(%rax)
	abp->ab_tag      = tag;
  8004210cb6:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210cba:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004210cbe:	48 89 50 08          	mov    %rdx,0x8(%rax)
	abp->ab_children = children;
  8004210cc2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210cc6:	0f b6 55 df          	movzbl -0x21(%rbp),%edx
  8004210cca:	88 50 10             	mov    %dl,0x10(%rax)
	abp->ab_offset   = aboff;
  8004210ccd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210cd1:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004210cd5:	48 89 50 18          	mov    %rdx,0x18(%rax)
	abp->ab_length   = 0;    /* fill in later. */
  8004210cd9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210cdd:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
  8004210ce4:	00 
	abp->ab_atnum    = 0;
  8004210ce5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210ce9:	48 c7 40 28 00 00 00 	movq   $0x0,0x28(%rax)
  8004210cf0:	00 

	/* Parse attribute definitions. */
	do {
		adoff = *offset;
  8004210cf1:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210cf5:	48 8b 00             	mov    (%rax),%rax
  8004210cf8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		attr = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210cfc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d00:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210d04:	48 89 d6             	mov    %rdx,%rsi
  8004210d07:	48 89 c7             	mov    %rax,%rdi
  8004210d0a:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004210d11:	00 00 00 
  8004210d14:	ff d0                	callq  *%rax
  8004210d16:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
		form = _dwarf_read_uleb128((uint8_t *)abbr_addr, offset);
  8004210d1a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210d1e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004210d22:	48 89 d6             	mov    %rdx,%rsi
  8004210d25:	48 89 c7             	mov    %rax,%rdi
  8004210d28:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004210d2f:	00 00 00 
  8004210d32:	ff d0                	callq  *%rax
  8004210d34:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
		if (attr != 0)
  8004210d38:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210d3d:	0f 84 89 00 00 00    	je     8004210dcc <_dwarf_abbrev_parse+0x25b>
		{
			/* Initialise the attribute definition structure. */
			abp->ab_attrdef[abp->ab_atnum].ad_attrib = attr;
  8004210d43:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210d47:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210d4b:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210d4f:	48 89 d0             	mov    %rdx,%rax
  8004210d52:	48 01 c0             	add    %rax,%rax
  8004210d55:	48 01 d0             	add    %rdx,%rax
  8004210d58:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d5c:	48 01 c8             	add    %rcx,%rax
  8004210d5f:	48 8d 50 30          	lea    0x30(%rax),%rdx
  8004210d63:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210d67:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_form   = form;
  8004210d6a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210d6e:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210d72:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210d76:	48 89 d0             	mov    %rdx,%rax
  8004210d79:	48 01 c0             	add    %rax,%rax
  8004210d7c:	48 01 d0             	add    %rdx,%rax
  8004210d7f:	48 c1 e0 03          	shl    $0x3,%rax
  8004210d83:	48 01 c8             	add    %rcx,%rax
  8004210d86:	48 8d 50 38          	lea    0x38(%rax),%rdx
  8004210d8a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004210d8e:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_attrdef[abp->ab_atnum].ad_offset = adoff;
  8004210d91:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210d95:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004210d99:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
  8004210d9d:	48 89 d0             	mov    %rdx,%rax
  8004210da0:	48 01 c0             	add    %rax,%rax
  8004210da3:	48 01 d0             	add    %rdx,%rax
  8004210da6:	48 c1 e0 03          	shl    $0x3,%rax
  8004210daa:	48 01 c8             	add    %rcx,%rax
  8004210dad:	48 8d 50 40          	lea    0x40(%rax),%rdx
  8004210db1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004210db5:	48 89 02             	mov    %rax,(%rdx)
			abp->ab_atnum++;
  8004210db8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210dbc:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004210dc0:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004210dc4:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210dc8:	48 89 50 28          	mov    %rdx,0x28(%rax)
		}
	} while (attr != 0);
  8004210dcc:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004210dd1:	0f 85 1a ff ff ff    	jne    8004210cf1 <_dwarf_abbrev_parse+0x180>

	//(*abp)->ab_length = *offset - aboff;
	abp->ab_length = (uint64_t)(*offset - aboff);
  8004210dd7:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004210ddb:	48 8b 00             	mov    (%rax),%rax
  8004210dde:	48 2b 45 f8          	sub    -0x8(%rbp),%rax
  8004210de2:	48 89 c2             	mov    %rax,%rdx
  8004210de5:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004210de9:	48 89 50 20          	mov    %rdx,0x20(%rax)

	return DW_DLV_OK;
  8004210ded:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004210df2:	c9                   	leaveq 
  8004210df3:	c3                   	retq   

0000008004210df4 <_dwarf_abbrev_find>:

//Return 0 on success
int
_dwarf_abbrev_find(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t entry, Dwarf_Abbrev *abp)
{
  8004210df4:	55                   	push   %rbp
  8004210df5:	48 89 e5             	mov    %rsp,%rbp
  8004210df8:	48 83 ec 70          	sub    $0x70,%rsp
  8004210dfc:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004210e00:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004210e04:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
	Dwarf_Section *ds;
	uint64_t offset;
	int ret;

	if (entry == 0)
  8004210e08:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004210e0d:	75 0a                	jne    8004210e19 <_dwarf_abbrev_find+0x25>
	{
		return (DW_DLE_NO_ENTRY);
  8004210e0f:	b8 04 00 00 00       	mov    $0x4,%eax
  8004210e14:	e9 0a 01 00 00       	jmpq   8004210f23 <_dwarf_abbrev_find+0x12f>
	}

	/* Load and search the abbrev table. */
	ds = _dwarf_find_section(".debug_abbrev");
  8004210e19:	48 bf 38 a0 21 04 80 	movabs $0x800421a038,%rdi
  8004210e20:	00 00 00 
  8004210e23:	48 b8 63 51 21 04 80 	movabs $0x8004215163,%rax
  8004210e2a:	00 00 00 
  8004210e2d:	ff d0                	callq  *%rax
  8004210e2f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	assert(ds != NULL);
  8004210e33:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004210e38:	75 35                	jne    8004210e6f <_dwarf_abbrev_find+0x7b>
  8004210e3a:	48 b9 2d a0 21 04 80 	movabs $0x800421a02d,%rcx
  8004210e41:	00 00 00 
  8004210e44:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004210e4b:	00 00 00 
  8004210e4e:	be e5 01 00 00       	mov    $0x1e5,%esi
  8004210e53:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004210e5a:	00 00 00 
  8004210e5d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210e62:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004210e69:	00 00 00 
  8004210e6c:	41 ff d0             	callq  *%r8

	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
  8004210e6f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004210e73:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	while (offset < ds->ds_size) {
  8004210e77:	e9 8d 00 00 00       	jmpq   8004210f09 <_dwarf_abbrev_find+0x115>
		ret = _dwarf_abbrev_parse(dbg, cu, &offset, abp, ds);
  8004210e7c:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
  8004210e80:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004210e84:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
  8004210e88:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004210e8c:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004210e90:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004210e94:	48 8b 7d 18          	mov    0x18(%rbp),%rdi
  8004210e98:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004210e9d:	48 8b 7d 20          	mov    0x20(%rbp),%rdi
  8004210ea1:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004210ea6:	48 8b 7d 28          	mov    0x28(%rbp),%rdi
  8004210eaa:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004210eaf:	48 8b 7d 30          	mov    0x30(%rbp),%rdi
  8004210eb3:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004210eb8:	48 8b 7d 38          	mov    0x38(%rbp),%rdi
  8004210ebc:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004210ec1:	48 8b 7d 40          	mov    0x40(%rbp),%rdi
  8004210ec5:	48 89 7c 24 30       	mov    %rdi,0x30(%rsp)
  8004210eca:	48 89 c7             	mov    %rax,%rdi
  8004210ecd:	48 b8 71 0b 21 04 80 	movabs $0x8004210b71,%rax
  8004210ed4:	00 00 00 
  8004210ed7:	ff d0                	callq  *%rax
  8004210ed9:	89 45 f4             	mov    %eax,-0xc(%rbp)
		if (ret != DW_DLE_NONE)
  8004210edc:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004210ee0:	74 05                	je     8004210ee7 <_dwarf_abbrev_find+0xf3>
			return (ret);
  8004210ee2:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004210ee5:	eb 3c                	jmp    8004210f23 <_dwarf_abbrev_find+0x12f>
		if (abp->ab_entry == entry) {
  8004210ee7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210eeb:	48 8b 00             	mov    (%rax),%rax
  8004210eee:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004210ef2:	75 07                	jne    8004210efb <_dwarf_abbrev_find+0x107>
			//cu->cu_abbrev_offset_cur = offset;
			return DW_DLE_NONE;
  8004210ef4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004210ef9:	eb 28                	jmp    8004210f23 <_dwarf_abbrev_find+0x12f>
		}
		if (abp->ab_entry == 0) {
  8004210efb:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004210eff:	48 8b 00             	mov    (%rax),%rax
  8004210f02:	48 85 c0             	test   %rax,%rax
  8004210f05:	75 02                	jne    8004210f09 <_dwarf_abbrev_find+0x115>
			//cu->cu_abbrev_offset_cur = offset;
			//cu->cu_abbrev_loaded = 1;
			break;
  8004210f07:	eb 15                	jmp    8004210f1e <_dwarf_abbrev_find+0x12a>
	//TODO: We are starting offset from 0, however libdwarf logic
	//      is keeping a counter for current offset. Ok. let use
	//      that. I relent, but this will be done in Phase 2. :)
	//offset = 0; //cu->cu_abbrev_offset_cur;
	offset = cu.debug_abbrev_offset; //cu->cu_abbrev_offset_cur;
	while (offset < ds->ds_size) {
  8004210f09:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004210f0d:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004210f11:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004210f15:	48 39 c2             	cmp    %rax,%rdx
  8004210f18:	0f 87 5e ff ff ff    	ja     8004210e7c <_dwarf_abbrev_find+0x88>
			//cu->cu_abbrev_loaded = 1;
			break;
		}
	}

	return DW_DLE_NO_ENTRY;
  8004210f1e:	b8 04 00 00 00       	mov    $0x4,%eax
}
  8004210f23:	c9                   	leaveq 
  8004210f24:	c3                   	retq   

0000008004210f25 <_dwarf_attr_init>:

//Return 0 on success
int
_dwarf_attr_init(Dwarf_Debug dbg, uint64_t *offsetp, Dwarf_CU *cu, Dwarf_Die *ret_die, Dwarf_AttrDef *ad,
		 uint64_t form, int indirect)
{
  8004210f25:	55                   	push   %rbp
  8004210f26:	48 89 e5             	mov    %rsp,%rbp
  8004210f29:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
  8004210f30:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004210f37:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004210f3e:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004210f45:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
  8004210f4c:	4c 89 85 48 ff ff ff 	mov    %r8,-0xb8(%rbp)
  8004210f53:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
	struct _Dwarf_Attribute atref;
	Dwarf_Section *str;
	int ret;
	Dwarf_Section *ds = _dwarf_find_section(".debug_info");
  8004210f5a:	48 bf 46 a0 21 04 80 	movabs $0x800421a046,%rdi
  8004210f61:	00 00 00 
  8004210f64:	48 b8 63 51 21 04 80 	movabs $0x8004215163,%rax
  8004210f6b:	00 00 00 
  8004210f6e:	ff d0                	callq  *%rax
  8004210f70:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	uint8_t *ds_data = (uint8_t *)ds->ds_data; //(uint8_t *)dbg->dbg_info_offset_elf;
  8004210f74:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004210f78:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210f7c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint8_t dwarf_size = cu->cu_dwarf_size;
  8004210f80:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  8004210f87:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004210f8b:	88 45 e7             	mov    %al,-0x19(%rbp)

	ret = DW_DLE_NONE;
  8004210f8e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	memset(&atref, 0, sizeof(atref));
  8004210f95:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004210f9c:	ba 60 00 00 00       	mov    $0x60,%edx
  8004210fa1:	be 00 00 00 00       	mov    $0x0,%esi
  8004210fa6:	48 89 c7             	mov    %rax,%rdi
  8004210fa9:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004210fb0:	00 00 00 
  8004210fb3:	ff d0                	callq  *%rax
	atref.at_die = ret_die;
  8004210fb5:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004210fbc:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
	atref.at_attrib = ad->ad_attrib;
  8004210fc3:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210fca:	48 8b 00             	mov    (%rax),%rax
  8004210fcd:	48 89 45 80          	mov    %rax,-0x80(%rbp)
	atref.at_form = ad->ad_form;
  8004210fd1:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  8004210fd8:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004210fdc:	48 89 45 88          	mov    %rax,-0x78(%rbp)
	atref.at_indirect = indirect;
  8004210fe0:	8b 45 10             	mov    0x10(%rbp),%eax
  8004210fe3:	89 45 90             	mov    %eax,-0x70(%rbp)
	atref.at_ld = NULL;
  8004210fe6:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
  8004210fed:	00 

	switch (form) {
  8004210fee:	48 83 bd 40 ff ff ff 	cmpq   $0x20,-0xc0(%rbp)
  8004210ff5:	20 
  8004210ff6:	0f 87 82 04 00 00    	ja     800421147e <_dwarf_attr_init+0x559>
  8004210ffc:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  8004211003:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421100a:	00 
  800421100b:	48 b8 70 a0 21 04 80 	movabs $0x800421a070,%rax
  8004211012:	00 00 00 
  8004211015:	48 01 d0             	add    %rdx,%rax
  8004211018:	48 8b 00             	mov    (%rax),%rax
  800421101b:	ff e0                	jmpq   *%rax
	case DW_FORM_addr:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  800421101d:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211024:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211028:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  800421102f:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004211033:	0f b6 d2             	movzbl %dl,%edx
  8004211036:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421103d:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211041:	48 89 cf             	mov    %rcx,%rdi
  8004211044:	ff d0                	callq  *%rax
  8004211046:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421104a:	e9 37 04 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_block:
	case DW_FORM_exprloc:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  800421104f:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211056:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421105a:	48 89 d6             	mov    %rdx,%rsi
  800421105d:	48 89 c7             	mov    %rax,%rdi
  8004211060:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004211067:	00 00 00 
  800421106a:	ff d0                	callq  *%rax
  800421106c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  8004211070:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211074:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  800421107b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421107f:	48 89 ce             	mov    %rcx,%rsi
  8004211082:	48 89 c7             	mov    %rax,%rdi
  8004211085:	48 b8 9c 07 21 04 80 	movabs $0x800421079c,%rax
  800421108c:	00 00 00 
  800421108f:	ff d0                	callq  *%rax
  8004211091:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211095:	e9 ec 03 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_block1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  800421109a:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042110a1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042110a5:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042110ac:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042110b0:	ba 01 00 00 00       	mov    $0x1,%edx
  80042110b5:	48 89 cf             	mov    %rcx,%rdi
  80042110b8:	ff d0                	callq  *%rax
  80042110ba:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  80042110be:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042110c2:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  80042110c9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042110cd:	48 89 ce             	mov    %rcx,%rsi
  80042110d0:	48 89 c7             	mov    %rax,%rdi
  80042110d3:	48 b8 9c 07 21 04 80 	movabs $0x800421079c,%rax
  80042110da:	00 00 00 
  80042110dd:	ff d0                	callq  *%rax
  80042110df:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  80042110e3:	e9 9e 03 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_block2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042110e8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042110ef:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042110f3:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042110fa:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042110fe:	ba 02 00 00 00       	mov    $0x2,%edx
  8004211103:	48 89 cf             	mov    %rcx,%rdi
  8004211106:	ff d0                	callq  *%rax
  8004211108:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421110c:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211110:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211117:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421111b:	48 89 ce             	mov    %rcx,%rsi
  800421111e:	48 89 c7             	mov    %rax,%rdi
  8004211121:	48 b8 9c 07 21 04 80 	movabs $0x800421079c,%rax
  8004211128:	00 00 00 
  800421112b:	ff d0                	callq  *%rax
  800421112d:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211131:	e9 50 03 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_block4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  8004211136:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421113d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211141:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211148:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421114c:	ba 04 00 00 00       	mov    $0x4,%edx
  8004211151:	48 89 cf             	mov    %rcx,%rdi
  8004211154:	ff d0                	callq  *%rax
  8004211156:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		atref.u[1].u8p = (uint8_t*)_dwarf_read_block(ds_data, offsetp, atref.u[0].u64);
  800421115a:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421115e:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211165:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211169:	48 89 ce             	mov    %rcx,%rsi
  800421116c:	48 89 c7             	mov    %rax,%rdi
  800421116f:	48 b8 9c 07 21 04 80 	movabs $0x800421079c,%rax
  8004211176:	00 00 00 
  8004211179:	ff d0                	callq  *%rax
  800421117b:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  800421117f:	e9 02 03 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_data1:
	case DW_FORM_flag:
	case DW_FORM_ref1:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 1);
  8004211184:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421118b:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421118f:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211196:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421119a:	ba 01 00 00 00       	mov    $0x1,%edx
  800421119f:	48 89 cf             	mov    %rcx,%rdi
  80042111a2:	ff d0                	callq  *%rax
  80042111a4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042111a8:	e9 d9 02 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_data2:
	case DW_FORM_ref2:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 2);
  80042111ad:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042111b4:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042111b8:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042111bf:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042111c3:	ba 02 00 00 00       	mov    $0x2,%edx
  80042111c8:	48 89 cf             	mov    %rcx,%rdi
  80042111cb:	ff d0                	callq  *%rax
  80042111cd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042111d1:	e9 b0 02 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_data4:
	case DW_FORM_ref4:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 4);
  80042111d6:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042111dd:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042111e1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042111e8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042111ec:	ba 04 00 00 00       	mov    $0x4,%edx
  80042111f1:	48 89 cf             	mov    %rcx,%rdi
  80042111f4:	ff d0                	callq  *%rax
  80042111f6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042111fa:	e9 87 02 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_data8:
	case DW_FORM_ref8:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, 8);
  80042111ff:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211206:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421120a:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211211:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211215:	ba 08 00 00 00       	mov    $0x8,%edx
  800421121a:	48 89 cf             	mov    %rcx,%rdi
  800421121d:	ff d0                	callq  *%rax
  800421121f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211223:	e9 5e 02 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_indirect:
		form = _dwarf_read_uleb128(ds_data, offsetp);
  8004211228:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421122f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211233:	48 89 d6             	mov    %rdx,%rsi
  8004211236:	48 89 c7             	mov    %rax,%rdi
  8004211239:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004211240:	00 00 00 
  8004211243:	ff d0                	callq  *%rax
  8004211245:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
		return (_dwarf_attr_init(dbg, offsetp, cu, ret_die, ad, form, 1));
  800421124c:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
  8004211253:	48 8b bd 48 ff ff ff 	mov    -0xb8(%rbp),%rdi
  800421125a:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004211261:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  8004211268:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  800421126f:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211276:	c7 04 24 01 00 00 00 	movl   $0x1,(%rsp)
  800421127d:	4d 89 c1             	mov    %r8,%r9
  8004211280:	49 89 f8             	mov    %rdi,%r8
  8004211283:	48 89 c7             	mov    %rax,%rdi
  8004211286:	48 b8 25 0f 21 04 80 	movabs $0x8004210f25,%rax
  800421128d:	00 00 00 
  8004211290:	ff d0                	callq  *%rax
  8004211292:	e9 1d 03 00 00       	jmpq   80042115b4 <_dwarf_attr_init+0x68f>
	case DW_FORM_ref_addr:
		if (cu->version == 2)
  8004211297:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  800421129e:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042112a2:	66 83 f8 02          	cmp    $0x2,%ax
  80042112a6:	75 2f                	jne    80042112d7 <_dwarf_attr_init+0x3b2>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, cu->addr_size);
  80042112a8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042112af:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042112b3:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
  80042112ba:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  80042112be:	0f b6 d2             	movzbl %dl,%edx
  80042112c1:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042112c8:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042112cc:	48 89 cf             	mov    %rcx,%rdi
  80042112cf:	ff d0                	callq  *%rax
  80042112d1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042112d5:	eb 39                	jmp    8004211310 <_dwarf_attr_init+0x3eb>
		else if (cu->version == 3)
  80042112d7:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
  80042112de:	0f b7 40 08          	movzwl 0x8(%rax),%eax
  80042112e2:	66 83 f8 03          	cmp    $0x3,%ax
  80042112e6:	75 28                	jne    8004211310 <_dwarf_attr_init+0x3eb>
			atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042112e8:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042112ef:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042112f3:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042112f7:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042112fe:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004211302:	48 89 cf             	mov    %rcx,%rdi
  8004211305:	ff d0                	callq  *%rax
  8004211307:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421130b:	e9 76 01 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
  8004211310:	e9 71 01 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_udata:
	case DW_FORM_udata:
		atref.u[0].u64 = _dwarf_read_uleb128(ds_data, offsetp);
  8004211315:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  800421131c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211320:	48 89 d6             	mov    %rdx,%rsi
  8004211323:	48 89 c7             	mov    %rax,%rdi
  8004211326:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  800421132d:	00 00 00 
  8004211330:	ff d0                	callq  *%rax
  8004211332:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211336:	e9 4b 01 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_sdata:
		atref.u[0].s64 = _dwarf_read_sleb128(ds_data, offsetp);
  800421133b:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211342:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211346:	48 89 d6             	mov    %rdx,%rsi
  8004211349:	48 89 c7             	mov    %rax,%rdi
  800421134c:	48 b8 eb 04 21 04 80 	movabs $0x80042104eb,%rax
  8004211353:	00 00 00 
  8004211356:	ff d0                	callq  *%rax
  8004211358:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  800421135c:	e9 25 01 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_sec_offset:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  8004211361:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004211368:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421136c:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  8004211370:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  8004211377:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  800421137b:	48 89 cf             	mov    %rcx,%rdi
  800421137e:	ff d0                	callq  *%rax
  8004211380:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  8004211384:	e9 fd 00 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_string:
		atref.u[0].s =(char*) _dwarf_read_string(ds_data, (uint64_t)ds->ds_size, offsetp);
  8004211389:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421138d:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211391:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  8004211398:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421139c:	48 89 ce             	mov    %rcx,%rsi
  800421139f:	48 89 c7             	mov    %rax,%rdi
  80042113a2:	48 b8 0d 07 21 04 80 	movabs $0x800421070d,%rax
  80042113a9:	00 00 00 
  80042113ac:	ff d0                	callq  *%rax
  80042113ae:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		break;
  80042113b2:	e9 cf 00 00 00       	jmpq   8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_strp:
		atref.u[0].u64 = dbg->read(ds_data, offsetp, dwarf_size);
  80042113b7:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042113be:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042113c2:	0f b6 55 e7          	movzbl -0x19(%rbp),%edx
  80042113c6:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
  80042113cd:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042113d1:	48 89 cf             	mov    %rcx,%rdi
  80042113d4:	ff d0                	callq  *%rax
  80042113d6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
		str = _dwarf_find_section(".debug_str");
  80042113da:	48 bf 52 a0 21 04 80 	movabs $0x800421a052,%rdi
  80042113e1:	00 00 00 
  80042113e4:	48 b8 63 51 21 04 80 	movabs $0x8004215163,%rax
  80042113eb:	00 00 00 
  80042113ee:	ff d0                	callq  *%rax
  80042113f0:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		assert(str != NULL);
  80042113f4:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042113f9:	75 35                	jne    8004211430 <_dwarf_attr_init+0x50b>
  80042113fb:	48 b9 5d a0 21 04 80 	movabs $0x800421a05d,%rcx
  8004211402:	00 00 00 
  8004211405:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  800421140c:	00 00 00 
  800421140f:	be 51 02 00 00       	mov    $0x251,%esi
  8004211414:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  800421141b:	00 00 00 
  800421141e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211423:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800421142a:	00 00 00 
  800421142d:	41 ff d0             	callq  *%r8
		//atref.u[1].s = (char *)(elf_base_ptr + str->sh_offset) + atref.u[0].u64;
		atref.u[1].s = (char *)str->ds_data + atref.u[0].u64;
  8004211430:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211434:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211438:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421143c:	48 01 d0             	add    %rdx,%rax
  800421143f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211443:	eb 41                	jmp    8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_ref_sig8:
		atref.u[0].u64 = 8;
  8004211445:	48 c7 45 98 08 00 00 	movq   $0x8,-0x68(%rbp)
  800421144c:	00 
		atref.u[1].u8p = (uint8_t*)(_dwarf_read_block(ds_data, offsetp, atref.u[0].u64));
  800421144d:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  8004211451:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
  8004211458:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421145c:	48 89 ce             	mov    %rcx,%rsi
  800421145f:	48 89 c7             	mov    %rax,%rdi
  8004211462:	48 b8 9c 07 21 04 80 	movabs $0x800421079c,%rax
  8004211469:	00 00 00 
  800421146c:	ff d0                	callq  *%rax
  800421146e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
		break;
  8004211472:	eb 12                	jmp    8004211486 <_dwarf_attr_init+0x561>
	case DW_FORM_flag_present:
		/* This form has no value encoded in the DIE. */
		atref.u[0].u64 = 1;
  8004211474:	48 c7 45 98 01 00 00 	movq   $0x1,-0x68(%rbp)
  800421147b:	00 
		break;
  800421147c:	eb 08                	jmp    8004211486 <_dwarf_attr_init+0x561>
	default:
		//DWARF_SET_ERROR(dbg, error, DW_DLE_ATTR_FORM_BAD);
		ret = DW_DLE_ATTR_FORM_BAD;
  800421147e:	c7 45 fc 0e 00 00 00 	movl   $0xe,-0x4(%rbp)
		break;
  8004211485:	90                   	nop
	}

	if (ret == DW_DLE_NONE) {
  8004211486:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  800421148a:	0f 85 21 01 00 00    	jne    80042115b1 <_dwarf_attr_init+0x68c>
		if (form == DW_FORM_block || form == DW_FORM_block1 ||
  8004211490:	48 83 bd 40 ff ff ff 	cmpq   $0x9,-0xc0(%rbp)
  8004211497:	09 
  8004211498:	74 1e                	je     80042114b8 <_dwarf_attr_init+0x593>
  800421149a:	48 83 bd 40 ff ff ff 	cmpq   $0xa,-0xc0(%rbp)
  80042114a1:	0a 
  80042114a2:	74 14                	je     80042114b8 <_dwarf_attr_init+0x593>
  80042114a4:	48 83 bd 40 ff ff ff 	cmpq   $0x3,-0xc0(%rbp)
  80042114ab:	03 
  80042114ac:	74 0a                	je     80042114b8 <_dwarf_attr_init+0x593>
		    form == DW_FORM_block2 || form == DW_FORM_block4) {
  80042114ae:	48 83 bd 40 ff ff ff 	cmpq   $0x4,-0xc0(%rbp)
  80042114b5:	04 
  80042114b6:	75 10                	jne    80042114c8 <_dwarf_attr_init+0x5a3>
			atref.at_block.bl_len = atref.u[0].u64;
  80042114b8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042114bc:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			atref.at_block.bl_data = atref.u[1].u8p;
  80042114c0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042114c4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
  80042114c8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042114cc:	48 83 f8 03          	cmp    $0x3,%rax
  80042114d0:	75 39                	jne    800421150b <_dwarf_attr_init+0x5e6>
			switch (atref.at_form) {
  80042114d2:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042114d6:	48 83 f8 08          	cmp    $0x8,%rax
  80042114da:	74 1c                	je     80042114f8 <_dwarf_attr_init+0x5d3>
  80042114dc:	48 83 f8 0e          	cmp    $0xe,%rax
  80042114e0:	74 02                	je     80042114e4 <_dwarf_attr_init+0x5bf>
				break;
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
				break;
			default:
				break;
  80042114e2:	eb 27                	jmp    800421150b <_dwarf_attr_init+0x5e6>
		}
		//ret = _dwarf_attr_add(die, &atref, NULL, error);
		if (atref.at_attrib == DW_AT_name) {
			switch (atref.at_form) {
			case DW_FORM_strp:
				ret_die->die_name = atref.u[1].s;
  80042114e4:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042114e8:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  80042114ef:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  80042114f6:	eb 13                	jmp    800421150b <_dwarf_attr_init+0x5e6>
			case DW_FORM_string:
				ret_die->die_name = atref.u[0].s;
  80042114f8:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  80042114fc:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211503:	48 89 90 50 03 00 00 	mov    %rdx,0x350(%rax)
				break;
  800421150a:	90                   	nop
			default:
				break;
			}
		}
		ret_die->die_attr[ret_die->die_attr_count++] = atref;
  800421150b:	48 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%rax
  8004211512:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004211519:	8d 48 01             	lea    0x1(%rax),%ecx
  800421151c:	48 8b 95 50 ff ff ff 	mov    -0xb0(%rbp),%rdx
  8004211523:	88 8a 58 03 00 00    	mov    %cl,0x358(%rdx)
  8004211529:	0f b6 c0             	movzbl %al,%eax
  800421152c:	48 8b 8d 50 ff ff ff 	mov    -0xb0(%rbp),%rcx
  8004211533:	48 63 d0             	movslq %eax,%rdx
  8004211536:	48 89 d0             	mov    %rdx,%rax
  8004211539:	48 01 c0             	add    %rax,%rax
  800421153c:	48 01 d0             	add    %rdx,%rax
  800421153f:	48 c1 e0 05          	shl    $0x5,%rax
  8004211543:	48 01 c8             	add    %rcx,%rax
  8004211546:	48 05 70 03 00 00    	add    $0x370,%rax
  800421154c:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004211553:	48 89 10             	mov    %rdx,(%rax)
  8004211556:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  800421155d:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004211561:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004211565:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004211569:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  800421156d:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004211571:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004211575:	48 89 50 20          	mov    %rdx,0x20(%rax)
  8004211579:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421157d:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004211581:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004211585:	48 89 50 30          	mov    %rdx,0x30(%rax)
  8004211589:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  800421158d:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004211591:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004211595:	48 89 50 40          	mov    %rdx,0x40(%rax)
  8004211599:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  800421159d:	48 89 50 48          	mov    %rdx,0x48(%rax)
  80042115a1:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042115a5:	48 89 50 50          	mov    %rdx,0x50(%rax)
  80042115a9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042115ad:	48 89 50 58          	mov    %rdx,0x58(%rax)
	}

	return (ret);
  80042115b1:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  80042115b4:	c9                   	leaveq 
  80042115b5:	c3                   	retq   

00000080042115b6 <dwarf_search_die_within_cu>:

int
dwarf_search_die_within_cu(Dwarf_Debug dbg, Dwarf_CU cu, uint64_t offset, Dwarf_Die *ret_die, int search_sibling)
{
  80042115b6:	55                   	push   %rbp
  80042115b7:	48 89 e5             	mov    %rsp,%rbp
  80042115ba:	48 81 ec d0 03 00 00 	sub    $0x3d0,%rsp
  80042115c1:	48 89 bd 88 fc ff ff 	mov    %rdi,-0x378(%rbp)
  80042115c8:	48 89 b5 80 fc ff ff 	mov    %rsi,-0x380(%rbp)
  80042115cf:	48 89 95 78 fc ff ff 	mov    %rdx,-0x388(%rbp)
  80042115d6:	89 8d 74 fc ff ff    	mov    %ecx,-0x38c(%rbp)
	uint64_t abnum;
	uint64_t die_offset;
	int ret, level;
	int i;

	assert(dbg);
  80042115dc:	48 83 bd 88 fc ff ff 	cmpq   $0x0,-0x378(%rbp)
  80042115e3:	00 
  80042115e4:	75 35                	jne    800421161b <dwarf_search_die_within_cu+0x65>
  80042115e6:	48 b9 78 a1 21 04 80 	movabs $0x800421a178,%rcx
  80042115ed:	00 00 00 
  80042115f0:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  80042115f7:	00 00 00 
  80042115fa:	be 86 02 00 00       	mov    $0x286,%esi
  80042115ff:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211606:	00 00 00 
  8004211609:	b8 00 00 00 00       	mov    $0x0,%eax
  800421160e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211615:	00 00 00 
  8004211618:	41 ff d0             	callq  *%r8
	//assert(cu);
	assert(ret_die);
  800421161b:	48 83 bd 78 fc ff ff 	cmpq   $0x0,-0x388(%rbp)
  8004211622:	00 
  8004211623:	75 35                	jne    800421165a <dwarf_search_die_within_cu+0xa4>
  8004211625:	48 b9 7c a1 21 04 80 	movabs $0x800421a17c,%rcx
  800421162c:	00 00 00 
  800421162f:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004211636:	00 00 00 
  8004211639:	be 88 02 00 00       	mov    $0x288,%esi
  800421163e:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211645:	00 00 00 
  8004211648:	b8 00 00 00 00       	mov    $0x0,%eax
  800421164d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211654:	00 00 00 
  8004211657:	41 ff d0             	callq  *%r8

	level = 1;
  800421165a:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%rbp)

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  8004211661:	e9 17 02 00 00       	jmpq   800421187d <dwarf_search_die_within_cu+0x2c7>

		die_offset = offset;
  8004211666:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800421166d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

		abnum = _dwarf_read_uleb128((uint8_t *)dbg->dbg_info_offset_elf, &offset);
  8004211671:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004211678:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421167c:	48 8d 95 80 fc ff ff 	lea    -0x380(%rbp),%rdx
  8004211683:	48 89 d6             	mov    %rdx,%rsi
  8004211686:	48 89 c7             	mov    %rax,%rdi
  8004211689:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004211690:	00 00 00 
  8004211693:	ff d0                	callq  *%rax
  8004211695:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

		if (abnum == 0) {
  8004211699:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  800421169e:	75 22                	jne    80042116c2 <dwarf_search_die_within_cu+0x10c>
			if (level == 0 || !search_sibling) {
  80042116a0:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  80042116a4:	74 09                	je     80042116af <dwarf_search_die_within_cu+0xf9>
  80042116a6:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  80042116ad:	75 0a                	jne    80042116b9 <dwarf_search_die_within_cu+0x103>
				//No more entry
				return (DW_DLE_NO_ENTRY);
  80042116af:	b8 04 00 00 00       	mov    $0x4,%eax
  80042116b4:	e9 f4 01 00 00       	jmpq   80042118ad <dwarf_search_die_within_cu+0x2f7>
			}
			/*
			 * Return to previous DIE level.
			 */
			level--;
  80042116b9:	83 6d fc 01          	subl   $0x1,-0x4(%rbp)
			continue;
  80042116bd:	e9 bb 01 00 00       	jmpq   800421187d <dwarf_search_die_within_cu+0x2c7>
		}

		if ((ret = _dwarf_abbrev_find(dbg, cu, abnum, &ab)) != DW_DLE_NONE)
  80042116c2:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  80042116c9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042116cd:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042116d4:	48 8b 75 10          	mov    0x10(%rbp),%rsi
  80042116d8:	48 89 34 24          	mov    %rsi,(%rsp)
  80042116dc:	48 8b 75 18          	mov    0x18(%rbp),%rsi
  80042116e0:	48 89 74 24 08       	mov    %rsi,0x8(%rsp)
  80042116e5:	48 8b 75 20          	mov    0x20(%rbp),%rsi
  80042116e9:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  80042116ee:	48 8b 75 28          	mov    0x28(%rbp),%rsi
  80042116f2:	48 89 74 24 18       	mov    %rsi,0x18(%rsp)
  80042116f7:	48 8b 75 30          	mov    0x30(%rbp),%rsi
  80042116fb:	48 89 74 24 20       	mov    %rsi,0x20(%rsp)
  8004211700:	48 8b 75 38          	mov    0x38(%rbp),%rsi
  8004211704:	48 89 74 24 28       	mov    %rsi,0x28(%rsp)
  8004211709:	48 8b 75 40          	mov    0x40(%rbp),%rsi
  800421170d:	48 89 74 24 30       	mov    %rsi,0x30(%rsp)
  8004211712:	48 89 ce             	mov    %rcx,%rsi
  8004211715:	48 89 c7             	mov    %rax,%rdi
  8004211718:	48 b8 f4 0d 21 04 80 	movabs $0x8004210df4,%rax
  800421171f:	00 00 00 
  8004211722:	ff d0                	callq  *%rax
  8004211724:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004211727:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421172b:	74 08                	je     8004211735 <dwarf_search_die_within_cu+0x17f>
			return (ret);
  800421172d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211730:	e9 78 01 00 00       	jmpq   80042118ad <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_offset = die_offset;
  8004211735:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421173c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004211740:	48 89 10             	mov    %rdx,(%rax)
		ret_die->die_abnum  = abnum;
  8004211743:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421174a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421174e:	48 89 50 10          	mov    %rdx,0x10(%rax)
		ret_die->die_ab  = ab;
  8004211752:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211759:	48 8d 78 20          	lea    0x20(%rax),%rdi
  800421175d:	48 8d 95 b0 fc ff ff 	lea    -0x350(%rbp),%rdx
  8004211764:	b8 66 00 00 00       	mov    $0x66,%eax
  8004211769:	48 89 d6             	mov    %rdx,%rsi
  800421176c:	48 89 c1             	mov    %rax,%rcx
  800421176f:	f3 48 a5             	rep movsq %ds:(%rsi),%es:(%rdi)
		ret_die->die_attr_count = 0;
  8004211772:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211779:	c6 80 58 03 00 00 00 	movb   $0x0,0x358(%rax)
		ret_die->die_tag = ab.ab_tag;
  8004211780:	48 8b 95 b8 fc ff ff 	mov    -0x348(%rbp),%rdx
  8004211787:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  800421178e:	48 89 50 18          	mov    %rdx,0x18(%rax)
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004211792:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
  8004211799:	e9 8e 00 00 00       	jmpq   800421182c <dwarf_search_die_within_cu+0x276>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
  800421179e:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042117a1:	48 63 d0             	movslq %eax,%rdx
  80042117a4:	48 89 d0             	mov    %rdx,%rax
  80042117a7:	48 01 c0             	add    %rax,%rax
  80042117aa:	48 01 d0             	add    %rdx,%rax
  80042117ad:	48 c1 e0 03          	shl    $0x3,%rax
  80042117b1:	48 01 e8             	add    %rbp,%rax
  80042117b4:	48 2d 18 03 00 00    	sub    $0x318,%rax
  80042117ba:	48 8b 08             	mov    (%rax),%rcx
  80042117bd:	48 8d b5 b0 fc ff ff 	lea    -0x350(%rbp),%rsi
  80042117c4:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042117c7:	48 63 d0             	movslq %eax,%rdx
  80042117ca:	48 89 d0             	mov    %rdx,%rax
  80042117cd:	48 01 c0             	add    %rax,%rax
  80042117d0:	48 01 d0             	add    %rdx,%rax
  80042117d3:	48 c1 e0 03          	shl    $0x3,%rax
  80042117d7:	48 83 c0 30          	add    $0x30,%rax
  80042117db:	48 8d 3c 06          	lea    (%rsi,%rax,1),%rdi
  80042117df:	48 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%rdx
  80042117e6:	48 8d b5 80 fc ff ff 	lea    -0x380(%rbp),%rsi
  80042117ed:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  80042117f4:	c7 04 24 00 00 00 00 	movl   $0x0,(%rsp)
  80042117fb:	49 89 c9             	mov    %rcx,%r9
  80042117fe:	49 89 f8             	mov    %rdi,%r8
  8004211801:	48 89 d1             	mov    %rdx,%rcx
  8004211804:	48 8d 55 10          	lea    0x10(%rbp),%rdx
  8004211808:	48 89 c7             	mov    %rax,%rdi
  800421180b:	48 b8 25 0f 21 04 80 	movabs $0x8004210f25,%rax
  8004211812:	00 00 00 
  8004211815:	ff d0                	callq  *%rax
  8004211817:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  800421181a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  800421181e:	74 08                	je     8004211828 <dwarf_search_die_within_cu+0x272>
				return (ret);
  8004211820:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004211823:	e9 85 00 00 00       	jmpq   80042118ad <dwarf_search_die_within_cu+0x2f7>
		ret_die->die_attr_count = 0;
		ret_die->die_tag = ab.ab_tag;
		//ret_die->die_cu  = cu;
		//ret_die->die_dbg = cu->cu_dbg;

		for(i=0; i < ab.ab_atnum; i++)
  8004211828:	83 45 f8 01          	addl   $0x1,-0x8(%rbp)
  800421182c:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421182f:	48 63 d0             	movslq %eax,%rdx
  8004211832:	48 8b 85 d8 fc ff ff 	mov    -0x328(%rbp),%rax
  8004211839:	48 39 c2             	cmp    %rax,%rdx
  800421183c:	0f 82 5c ff ff ff    	jb     800421179e <dwarf_search_die_within_cu+0x1e8>
		{
			if ((ret = _dwarf_attr_init(dbg, &offset, &cu, ret_die, &ab.ab_attrdef[i], ab.ab_attrdef[i].ad_form, 0)) != DW_DLE_NONE)
				return (ret);
		}

		ret_die->die_next_off = offset;
  8004211842:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
  8004211849:	48 8b 85 78 fc ff ff 	mov    -0x388(%rbp),%rax
  8004211850:	48 89 50 08          	mov    %rdx,0x8(%rax)
		if (search_sibling && level > 0) {
  8004211854:	83 bd 74 fc ff ff 00 	cmpl   $0x0,-0x38c(%rbp)
  800421185b:	74 19                	je     8004211876 <dwarf_search_die_within_cu+0x2c0>
  800421185d:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211861:	7e 13                	jle    8004211876 <dwarf_search_die_within_cu+0x2c0>
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004211863:	0f b6 85 c0 fc ff ff 	movzbl -0x340(%rbp),%eax
  800421186a:	3c 01                	cmp    $0x1,%al
  800421186c:	75 06                	jne    8004211874 <dwarf_search_die_within_cu+0x2be>
				/* Advance to next DIE level. */
				level++;
  800421186e:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
		}

		ret_die->die_next_off = offset;
		if (search_sibling && level > 0) {
			//dwarf_dealloc(dbg, die, DW_DLA_DIE);
			if (ab.ab_children == DW_CHILDREN_yes) {
  8004211872:	eb 09                	jmp    800421187d <dwarf_search_die_within_cu+0x2c7>
  8004211874:	eb 07                	jmp    800421187d <dwarf_search_die_within_cu+0x2c7>
				/* Advance to next DIE level. */
				level++;
			}
		} else {
			//*ret_die = die;
			return (DW_DLE_NONE);
  8004211876:	b8 00 00 00 00       	mov    $0x0,%eax
  800421187b:	eb 30                	jmp    80042118ad <dwarf_search_die_within_cu+0x2f7>
	//assert(cu);
	assert(ret_die);

	level = 1;

	while (offset < cu.cu_next_offset && offset < dbg->dbg_info_size) {
  800421187d:	48 8b 55 30          	mov    0x30(%rbp),%rdx
  8004211881:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  8004211888:	48 39 c2             	cmp    %rax,%rdx
  800421188b:	76 1b                	jbe    80042118a8 <dwarf_search_die_within_cu+0x2f2>
  800421188d:	48 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%rax
  8004211894:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211898:	48 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%rax
  800421189f:	48 39 c2             	cmp    %rax,%rdx
  80042118a2:	0f 87 be fd ff ff    	ja     8004211666 <dwarf_search_die_within_cu+0xb0>
			//*ret_die = die;
			return (DW_DLE_NONE);
		}
	}

	return (DW_DLE_NO_ENTRY);
  80042118a8:	b8 04 00 00 00       	mov    $0x4,%eax
}
  80042118ad:	c9                   	leaveq 
  80042118ae:	c3                   	retq   

00000080042118af <dwarf_offdie>:

//Return 0 on success
int
dwarf_offdie(Dwarf_Debug dbg, uint64_t offset, Dwarf_Die *ret_die, Dwarf_CU cu)
{
  80042118af:	55                   	push   %rbp
  80042118b0:	48 89 e5             	mov    %rsp,%rbp
  80042118b3:	48 83 ec 60          	sub    $0x60,%rsp
  80042118b7:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042118bb:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  80042118bf:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
	int ret;

	assert(dbg);
  80042118c3:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042118c8:	75 35                	jne    80042118ff <dwarf_offdie+0x50>
  80042118ca:	48 b9 78 a1 21 04 80 	movabs $0x800421a178,%rcx
  80042118d1:	00 00 00 
  80042118d4:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  80042118db:	00 00 00 
  80042118de:	be c4 02 00 00       	mov    $0x2c4,%esi
  80042118e3:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  80042118ea:	00 00 00 
  80042118ed:	b8 00 00 00 00       	mov    $0x0,%eax
  80042118f2:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042118f9:	00 00 00 
  80042118fc:	41 ff d0             	callq  *%r8
	assert(ret_die);
  80042118ff:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211904:	75 35                	jne    800421193b <dwarf_offdie+0x8c>
  8004211906:	48 b9 7c a1 21 04 80 	movabs $0x800421a17c,%rcx
  800421190d:	00 00 00 
  8004211910:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004211917:	00 00 00 
  800421191a:	be c5 02 00 00       	mov    $0x2c5,%esi
  800421191f:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211926:	00 00 00 
  8004211929:	b8 00 00 00 00       	mov    $0x0,%eax
  800421192e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211935:	00 00 00 
  8004211938:	41 ff d0             	callq  *%r8

	/* First search the current CU. */
	if (offset < cu.cu_next_offset) {
  800421193b:	48 8b 45 30          	mov    0x30(%rbp),%rax
  800421193f:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211943:	76 66                	jbe    80042119ab <dwarf_offdie+0xfc>
		ret = dwarf_search_die_within_cu(dbg, cu, offset, ret_die, 0);
  8004211945:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004211949:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
  800421194d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211951:	48 8b 4d 10          	mov    0x10(%rbp),%rcx
  8004211955:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211959:	48 8b 4d 18          	mov    0x18(%rbp),%rcx
  800421195d:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004211962:	48 8b 4d 20          	mov    0x20(%rbp),%rcx
  8004211966:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  800421196b:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421196f:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004211974:	48 8b 4d 30          	mov    0x30(%rbp),%rcx
  8004211978:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  800421197d:	48 8b 4d 38          	mov    0x38(%rbp),%rcx
  8004211981:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004211986:	48 8b 4d 40          	mov    0x40(%rbp),%rcx
  800421198a:	48 89 4c 24 30       	mov    %rcx,0x30(%rsp)
  800421198f:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004211994:	48 89 c7             	mov    %rax,%rdi
  8004211997:	48 b8 b6 15 21 04 80 	movabs $0x80042115b6,%rax
  800421199e:	00 00 00 
  80042119a1:	ff d0                	callq  *%rax
  80042119a3:	89 45 fc             	mov    %eax,-0x4(%rbp)
		return ret;
  80042119a6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042119a9:	eb 05                	jmp    80042119b0 <dwarf_offdie+0x101>
	}

	/*TODO: Search other CU*/
	return DW_DLV_OK;
  80042119ab:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042119b0:	c9                   	leaveq 
  80042119b1:	c3                   	retq   

00000080042119b2 <_dwarf_attr_find>:

Dwarf_Attribute*
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
  80042119b2:	55                   	push   %rbp
  80042119b3:	48 89 e5             	mov    %rsp,%rbp
  80042119b6:	48 83 ec 1c          	sub    $0x1c,%rsp
  80042119ba:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042119be:	89 f0                	mov    %esi,%eax
  80042119c0:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
	Dwarf_Attribute *myat = NULL;
  80042119c4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  80042119cb:	00 
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  80042119cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042119d3:	eb 57                	jmp    8004211a2c <_dwarf_attr_find+0x7a>
	{
		if (die->die_attr[i].at_attrib == attr)
  80042119d5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  80042119d9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042119dc:	48 63 d0             	movslq %eax,%rdx
  80042119df:	48 89 d0             	mov    %rdx,%rax
  80042119e2:	48 01 c0             	add    %rax,%rax
  80042119e5:	48 01 d0             	add    %rdx,%rax
  80042119e8:	48 c1 e0 05          	shl    $0x5,%rax
  80042119ec:	48 01 c8             	add    %rcx,%rax
  80042119ef:	48 05 80 03 00 00    	add    $0x380,%rax
  80042119f5:	48 8b 10             	mov    (%rax),%rdx
  80042119f8:	0f b7 45 e4          	movzwl -0x1c(%rbp),%eax
  80042119fc:	48 39 c2             	cmp    %rax,%rdx
  80042119ff:	75 27                	jne    8004211a28 <_dwarf_attr_find+0x76>
		{
			myat = &(die->die_attr[i]);
  8004211a01:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004211a04:	48 63 d0             	movslq %eax,%rdx
  8004211a07:	48 89 d0             	mov    %rdx,%rax
  8004211a0a:	48 01 c0             	add    %rax,%rax
  8004211a0d:	48 01 d0             	add    %rdx,%rax
  8004211a10:	48 c1 e0 05          	shl    $0x5,%rax
  8004211a14:	48 8d 90 70 03 00 00 	lea    0x370(%rax),%rdx
  8004211a1b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a1f:	48 01 d0             	add    %rdx,%rax
  8004211a22:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  8004211a26:	eb 17                	jmp    8004211a3f <_dwarf_attr_find+0x8d>
_dwarf_attr_find(Dwarf_Die *die, uint16_t attr)
{
	Dwarf_Attribute *myat = NULL;
	int i;
    
	for(i=0; i < die->die_attr_count; i++)
  8004211a28:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004211a2c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211a30:	0f b6 80 58 03 00 00 	movzbl 0x358(%rax),%eax
  8004211a37:	0f b6 c0             	movzbl %al,%eax
  8004211a3a:	3b 45 f4             	cmp    -0xc(%rbp),%eax
  8004211a3d:	7f 96                	jg     80042119d5 <_dwarf_attr_find+0x23>
			myat = &(die->die_attr[i]);
			break;
		}
	}

	return myat;
  8004211a3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  8004211a43:	c9                   	leaveq 
  8004211a44:	c3                   	retq   

0000008004211a45 <dwarf_siblingof>:

//Return 0 on success
int
dwarf_siblingof(Dwarf_Debug dbg, Dwarf_Die *die, Dwarf_Die *ret_die,
		Dwarf_CU *cu)
{
  8004211a45:	55                   	push   %rbp
  8004211a46:	48 89 e5             	mov    %rsp,%rbp
  8004211a49:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004211a4d:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211a51:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211a55:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211a59:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
	Dwarf_Attribute *at;
	uint64_t offset;
	int ret, search_sibling;

	assert(dbg);
  8004211a5d:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211a62:	75 35                	jne    8004211a99 <dwarf_siblingof+0x54>
  8004211a64:	48 b9 78 a1 21 04 80 	movabs $0x800421a178,%rcx
  8004211a6b:	00 00 00 
  8004211a6e:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004211a75:	00 00 00 
  8004211a78:	be ec 02 00 00       	mov    $0x2ec,%esi
  8004211a7d:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211a84:	00 00 00 
  8004211a87:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211a8c:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211a93:	00 00 00 
  8004211a96:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004211a99:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211a9e:	75 35                	jne    8004211ad5 <dwarf_siblingof+0x90>
  8004211aa0:	48 b9 7c a1 21 04 80 	movabs $0x800421a17c,%rcx
  8004211aa7:	00 00 00 
  8004211aaa:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004211ab1:	00 00 00 
  8004211ab4:	be ed 02 00 00       	mov    $0x2ed,%esi
  8004211ab9:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211ac0:	00 00 00 
  8004211ac3:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211ac8:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211acf:	00 00 00 
  8004211ad2:	41 ff d0             	callq  *%r8
	assert(cu);
  8004211ad5:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004211ada:	75 35                	jne    8004211b11 <dwarf_siblingof+0xcc>
  8004211adc:	48 b9 84 a1 21 04 80 	movabs $0x800421a184,%rcx
  8004211ae3:	00 00 00 
  8004211ae6:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004211aed:	00 00 00 
  8004211af0:	be ee 02 00 00       	mov    $0x2ee,%esi
  8004211af5:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211afc:	00 00 00 
  8004211aff:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211b04:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211b0b:	00 00 00 
  8004211b0e:	41 ff d0             	callq  *%r8

	/* Application requests the first DIE in this CU. */
	if (die == NULL)
  8004211b11:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211b16:	75 65                	jne    8004211b7d <dwarf_siblingof+0x138>
		return (dwarf_offdie(dbg, cu->cu_die_offset, ret_die, *cu));
  8004211b18:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211b1c:	48 8b 70 28          	mov    0x28(%rax),%rsi
  8004211b20:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211b24:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004211b28:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211b2c:	48 8b 38             	mov    (%rax),%rdi
  8004211b2f:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004211b33:	48 8b 78 08          	mov    0x8(%rax),%rdi
  8004211b37:	48 89 7c 24 08       	mov    %rdi,0x8(%rsp)
  8004211b3c:	48 8b 78 10          	mov    0x10(%rax),%rdi
  8004211b40:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004211b45:	48 8b 78 18          	mov    0x18(%rax),%rdi
  8004211b49:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004211b4e:	48 8b 78 20          	mov    0x20(%rax),%rdi
  8004211b52:	48 89 7c 24 20       	mov    %rdi,0x20(%rsp)
  8004211b57:	48 8b 78 28          	mov    0x28(%rax),%rdi
  8004211b5b:	48 89 7c 24 28       	mov    %rdi,0x28(%rsp)
  8004211b60:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211b64:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211b69:	48 89 cf             	mov    %rcx,%rdi
  8004211b6c:	48 b8 af 18 21 04 80 	movabs $0x80042118af,%rax
  8004211b73:	00 00 00 
  8004211b76:	ff d0                	callq  *%rax
  8004211b78:	e9 0a 01 00 00       	jmpq   8004211c87 <dwarf_siblingof+0x242>

	/*
	 * If the DIE doesn't have any children, its sibling sits next
	 * right to it.
	 */
	search_sibling = 0;
  8004211b7d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211b84:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211b88:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004211b8c:	84 c0                	test   %al,%al
  8004211b8e:	75 0e                	jne    8004211b9e <dwarf_siblingof+0x159>
		offset = die->die_next_off;
  8004211b90:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211b94:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211b98:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211b9c:	eb 6b                	jmp    8004211c09 <dwarf_siblingof+0x1c4>
	else {
		/*
		 * Look for DW_AT_sibling attribute for the offset of
		 * its sibling.
		 */
		if ((at = _dwarf_attr_find(die, DW_AT_sibling)) != NULL) {
  8004211b9e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211ba2:	be 01 00 00 00       	mov    $0x1,%esi
  8004211ba7:	48 89 c7             	mov    %rax,%rdi
  8004211baa:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  8004211bb1:	00 00 00 
  8004211bb4:	ff d0                	callq  *%rax
  8004211bb6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004211bba:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211bbf:	74 35                	je     8004211bf6 <dwarf_siblingof+0x1b1>
			if (at->at_form != DW_FORM_ref_addr)
  8004211bc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211bc5:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004211bc9:	48 83 f8 10          	cmp    $0x10,%rax
  8004211bcd:	74 19                	je     8004211be8 <dwarf_siblingof+0x1a3>
				offset = at->u[0].u64 + cu->cu_offset;
  8004211bcf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211bd3:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004211bd7:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211bdb:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211bdf:	48 01 d0             	add    %rdx,%rax
  8004211be2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211be6:	eb 21                	jmp    8004211c09 <dwarf_siblingof+0x1c4>
			else
				offset = at->u[0].u64;
  8004211be8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211bec:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004211bf0:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004211bf4:	eb 13                	jmp    8004211c09 <dwarf_siblingof+0x1c4>
		} else {
			offset = die->die_next_off;
  8004211bf6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004211bfa:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004211bfe:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			search_sibling = 1;
  8004211c02:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%rbp)
		}
	}

	ret = dwarf_search_die_within_cu(dbg, *cu, offset, ret_die, search_sibling);
  8004211c09:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004211c0c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004211c10:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
  8004211c14:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
  8004211c18:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004211c1c:	4c 8b 00             	mov    (%rax),%r8
  8004211c1f:	4c 89 04 24          	mov    %r8,(%rsp)
  8004211c23:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004211c27:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  8004211c2c:	4c 8b 40 10          	mov    0x10(%rax),%r8
  8004211c30:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  8004211c35:	4c 8b 40 18          	mov    0x18(%rax),%r8
  8004211c39:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004211c3e:	4c 8b 40 20          	mov    0x20(%rax),%r8
  8004211c42:	4c 89 44 24 20       	mov    %r8,0x20(%rsp)
  8004211c47:	4c 8b 40 28          	mov    0x28(%rax),%r8
  8004211c4b:	4c 89 44 24 28       	mov    %r8,0x28(%rsp)
  8004211c50:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211c54:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211c59:	48 b8 b6 15 21 04 80 	movabs $0x80042115b6,%rax
  8004211c60:	00 00 00 
  8004211c63:	ff d0                	callq  *%rax
  8004211c65:	89 45 e4             	mov    %eax,-0x1c(%rbp)


	if (ret == DW_DLE_NO_ENTRY) {
  8004211c68:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
  8004211c6c:	75 07                	jne    8004211c75 <dwarf_siblingof+0x230>
		return (DW_DLV_NO_ENTRY);
  8004211c6e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211c73:	eb 12                	jmp    8004211c87 <dwarf_siblingof+0x242>
	} else if (ret != DW_DLE_NONE)
  8004211c75:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004211c79:	74 07                	je     8004211c82 <dwarf_siblingof+0x23d>
		return (DW_DLV_ERROR);
  8004211c7b:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211c80:	eb 05                	jmp    8004211c87 <dwarf_siblingof+0x242>


	return (DW_DLV_OK);
  8004211c82:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211c87:	c9                   	leaveq 
  8004211c88:	c3                   	retq   

0000008004211c89 <dwarf_child>:

int
dwarf_child(Dwarf_Debug dbg, Dwarf_CU *cu, Dwarf_Die *die, Dwarf_Die *ret_die)
{
  8004211c89:	55                   	push   %rbp
  8004211c8a:	48 89 e5             	mov    %rsp,%rbp
  8004211c8d:	48 83 ec 70          	sub    $0x70,%rsp
  8004211c91:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211c95:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211c99:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211c9d:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	int ret;

	assert(die);
  8004211ca1:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211ca6:	75 35                	jne    8004211cdd <dwarf_child+0x54>
  8004211ca8:	48 b9 87 a1 21 04 80 	movabs $0x800421a187,%rcx
  8004211caf:	00 00 00 
  8004211cb2:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004211cb9:	00 00 00 
  8004211cbc:	be 1c 03 00 00       	mov    $0x31c,%esi
  8004211cc1:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211cc8:	00 00 00 
  8004211ccb:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211cd0:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211cd7:	00 00 00 
  8004211cda:	41 ff d0             	callq  *%r8
	assert(ret_die);
  8004211cdd:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211ce2:	75 35                	jne    8004211d19 <dwarf_child+0x90>
  8004211ce4:	48 b9 7c a1 21 04 80 	movabs $0x800421a17c,%rcx
  8004211ceb:	00 00 00 
  8004211cee:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004211cf5:	00 00 00 
  8004211cf8:	be 1d 03 00 00       	mov    $0x31d,%esi
  8004211cfd:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211d04:	00 00 00 
  8004211d07:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d0c:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211d13:	00 00 00 
  8004211d16:	41 ff d0             	callq  *%r8
	assert(dbg);
  8004211d19:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  8004211d1e:	75 35                	jne    8004211d55 <dwarf_child+0xcc>
  8004211d20:	48 b9 78 a1 21 04 80 	movabs $0x800421a178,%rcx
  8004211d27:	00 00 00 
  8004211d2a:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004211d31:	00 00 00 
  8004211d34:	be 1e 03 00 00       	mov    $0x31e,%esi
  8004211d39:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211d40:	00 00 00 
  8004211d43:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d48:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211d4f:	00 00 00 
  8004211d52:	41 ff d0             	callq  *%r8
	assert(cu);
  8004211d55:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  8004211d5a:	75 35                	jne    8004211d91 <dwarf_child+0x108>
  8004211d5c:	48 b9 84 a1 21 04 80 	movabs $0x800421a184,%rcx
  8004211d63:	00 00 00 
  8004211d66:	48 ba ea 9f 21 04 80 	movabs $0x8004219fea,%rdx
  8004211d6d:	00 00 00 
  8004211d70:	be 1f 03 00 00       	mov    $0x31f,%esi
  8004211d75:	48 bf ff 9f 21 04 80 	movabs $0x8004219fff,%rdi
  8004211d7c:	00 00 00 
  8004211d7f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211d84:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004211d8b:	00 00 00 
  8004211d8e:	41 ff d0             	callq  *%r8

	if (die->die_ab.ab_children == DW_CHILDREN_no)
  8004211d91:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211d95:	0f b6 40 30          	movzbl 0x30(%rax),%eax
  8004211d99:	84 c0                	test   %al,%al
  8004211d9b:	75 0a                	jne    8004211da7 <dwarf_child+0x11e>
		return (DW_DLE_NO_ENTRY);
  8004211d9d:	b8 04 00 00 00       	mov    $0x4,%eax
  8004211da2:	e9 84 00 00 00       	jmpq   8004211e2b <dwarf_child+0x1a2>

	ret = dwarf_search_die_within_cu(dbg, *cu, die->die_next_off, ret_die, 0);
  8004211da7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004211dab:	48 8b 70 08          	mov    0x8(%rax),%rsi
  8004211daf:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004211db3:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
  8004211db7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004211dbb:	48 8b 08             	mov    (%rax),%rcx
  8004211dbe:	48 89 0c 24          	mov    %rcx,(%rsp)
  8004211dc2:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004211dc6:	48 89 4c 24 08       	mov    %rcx,0x8(%rsp)
  8004211dcb:	48 8b 48 10          	mov    0x10(%rax),%rcx
  8004211dcf:	48 89 4c 24 10       	mov    %rcx,0x10(%rsp)
  8004211dd4:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004211dd8:	48 89 4c 24 18       	mov    %rcx,0x18(%rsp)
  8004211ddd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004211de1:	48 89 4c 24 20       	mov    %rcx,0x20(%rsp)
  8004211de6:	48 8b 48 28          	mov    0x28(%rax),%rcx
  8004211dea:	48 89 4c 24 28       	mov    %rcx,0x28(%rsp)
  8004211def:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211df3:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  8004211df8:	b9 00 00 00 00       	mov    $0x0,%ecx
  8004211dfd:	48 b8 b6 15 21 04 80 	movabs $0x80042115b6,%rax
  8004211e04:	00 00 00 
  8004211e07:	ff d0                	callq  *%rax
  8004211e09:	89 45 fc             	mov    %eax,-0x4(%rbp)

	if (ret == DW_DLE_NO_ENTRY) {
  8004211e0c:	83 7d fc 04          	cmpl   $0x4,-0x4(%rbp)
  8004211e10:	75 07                	jne    8004211e19 <dwarf_child+0x190>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  8004211e12:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211e17:	eb 12                	jmp    8004211e2b <dwarf_child+0x1a2>
	} else if (ret != DW_DLE_NONE)
  8004211e19:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
  8004211e1d:	74 07                	je     8004211e26 <dwarf_child+0x19d>
		return (DW_DLV_ERROR);
  8004211e1f:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211e24:	eb 05                	jmp    8004211e2b <dwarf_child+0x1a2>

	return (DW_DLV_OK);
  8004211e26:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211e2b:	c9                   	leaveq 
  8004211e2c:	c3                   	retq   

0000008004211e2d <_dwarf_find_section_enhanced>:


int  _dwarf_find_section_enhanced(Dwarf_Section *ds)
{
  8004211e2d:	55                   	push   %rbp
  8004211e2e:	48 89 e5             	mov    %rsp,%rbp
  8004211e31:	48 83 ec 20          	sub    $0x20,%rsp
  8004211e35:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *secthdr = _dwarf_find_section(ds->ds_name);
  8004211e39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e3d:	48 8b 00             	mov    (%rax),%rax
  8004211e40:	48 89 c7             	mov    %rax,%rdi
  8004211e43:	48 b8 63 51 21 04 80 	movabs $0x8004215163,%rax
  8004211e4a:	00 00 00 
  8004211e4d:	ff d0                	callq  *%rax
  8004211e4f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	ds->ds_data = secthdr->ds_data;//(Dwarf_Small*)((uint8_t *)elf_base_ptr + secthdr->sh_offset);
  8004211e53:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e57:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004211e5b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e5f:	48 89 50 08          	mov    %rdx,0x8(%rax)
	ds->ds_addr = secthdr->ds_addr;
  8004211e63:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e67:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004211e6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e6f:	48 89 50 10          	mov    %rdx,0x10(%rax)
	ds->ds_size = secthdr->ds_size;
  8004211e73:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e77:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004211e7b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211e7f:	48 89 50 18          	mov    %rdx,0x18(%rax)
	return 0;
  8004211e83:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004211e88:	c9                   	leaveq 
  8004211e89:	c3                   	retq   

0000008004211e8a <_dwarf_frame_params_init>:

extern int  _dwarf_find_section_enhanced(Dwarf_Section *ds);

void
_dwarf_frame_params_init(Dwarf_Debug dbg)
{
  8004211e8a:	55                   	push   %rbp
  8004211e8b:	48 89 e5             	mov    %rsp,%rbp
  8004211e8e:	48 83 ec 08          	sub    $0x8,%rsp
  8004211e92:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
        /* Initialise call frame related parameters. */
        dbg->dbg_frame_rule_table_size = DW_FRAME_LAST_REG_NUM;
  8004211e96:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211e9a:	66 c7 40 48 42 00    	movw   $0x42,0x48(%rax)
        dbg->dbg_frame_rule_initial_value = DW_FRAME_REG_INITIAL_VALUE;
  8004211ea0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ea4:	66 c7 40 4a 0b 04    	movw   $0x40b,0x4a(%rax)
        dbg->dbg_frame_cfa_value = DW_FRAME_CFA_COL3;
  8004211eaa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211eae:	66 c7 40 4c 9c 05    	movw   $0x59c,0x4c(%rax)
        dbg->dbg_frame_same_value = DW_FRAME_SAME_VAL;
  8004211eb4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211eb8:	66 c7 40 4e 0b 04    	movw   $0x40b,0x4e(%rax)
        dbg->dbg_frame_undefined_value = DW_FRAME_UNDEFINED_VAL;
  8004211ebe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ec2:	66 c7 40 50 0a 04    	movw   $0x40a,0x50(%rax)
}
  8004211ec8:	c9                   	leaveq 
  8004211ec9:	c3                   	retq   

0000008004211eca <dwarf_get_fde_at_pc>:


int
dwarf_get_fde_at_pc(Dwarf_Debug dbg, Dwarf_Addr pc,
		    Dwarf_Addr *lopc, Dwarf_Addr *hipc, struct _Dwarf_Fde *ret_fde, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004211eca:	55                   	push   %rbp
  8004211ecb:	48 89 e5             	mov    %rsp,%rbp
  8004211ece:	48 83 ec 40          	sub    $0x40,%rsp
  8004211ed2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004211ed6:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004211eda:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004211ede:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004211ee2:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
  8004211ee6:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
	Dwarf_Fde fde = ret_fde;
  8004211eea:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004211eee:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	memset(fde, 0, sizeof(struct _Dwarf_Fde));
  8004211ef2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211ef6:	ba 80 00 00 00       	mov    $0x80,%edx
  8004211efb:	be 00 00 00 00       	mov    $0x0,%esi
  8004211f00:	48 89 c7             	mov    %rax,%rdi
  8004211f03:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004211f0a:	00 00 00 
  8004211f0d:	ff d0                	callq  *%rax
	fde->fde_cie = cie;
  8004211f0f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f13:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004211f17:	48 89 50 08          	mov    %rdx,0x8(%rax)
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) 
  8004211f1b:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004211f20:	74 0e                	je     8004211f30 <dwarf_get_fde_at_pc+0x66>
  8004211f22:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004211f27:	74 07                	je     8004211f30 <dwarf_get_fde_at_pc+0x66>
  8004211f29:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211f2e:	75 07                	jne    8004211f37 <dwarf_get_fde_at_pc+0x6d>
                return (DW_DLV_ERROR);
  8004211f30:	b8 01 00 00 00       	mov    $0x1,%eax
  8004211f35:	eb 78                	jmp    8004211faf <dwarf_get_fde_at_pc+0xe5>

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  8004211f37:	eb 5c                	jmp    8004211f95 <dwarf_get_fde_at_pc+0xcb>
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
  8004211f39:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004211f3d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f41:	48 89 d1             	mov    %rdx,%rcx
  8004211f44:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004211f48:	be 01 00 00 00       	mov    $0x1,%esi
  8004211f4d:	48 89 c7             	mov    %rax,%rdi
  8004211f50:	48 b8 ee 40 21 04 80 	movabs $0x80042140ee,%rax
  8004211f57:	00 00 00 
  8004211f5a:	ff d0                	callq  *%rax
  8004211f5c:	85 c0                	test   %eax,%eax
  8004211f5e:	79 07                	jns    8004211f67 <dwarf_get_fde_at_pc+0x9d>
		{
			return DW_DLV_NO_ENTRY;
  8004211f60:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004211f65:	eb 48                	jmp    8004211faf <dwarf_get_fde_at_pc+0xe5>
		}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211f67:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f6b:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004211f6f:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211f73:	77 20                	ja     8004211f95 <dwarf_get_fde_at_pc+0xcb>
  8004211f75:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f79:	48 8b 50 30          	mov    0x30(%rax),%rdx
                    fde->fde_adrange)
  8004211f7d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004211f81:	48 8b 40 38          	mov    0x38(%rax),%rax
        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
                if (_dwarf_get_next_fde(dbg, true, error, fde) < 0)
		{
			return DW_DLV_NO_ENTRY;
		}
                if (pc >= fde->fde_initloc && pc < fde->fde_initloc +
  8004211f85:	48 01 d0             	add    %rdx,%rax
  8004211f88:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004211f8c:	76 07                	jbe    8004211f95 <dwarf_get_fde_at_pc+0xcb>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
  8004211f8e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211f93:	eb 1a                	jmp    8004211faf <dwarf_get_fde_at_pc+0xe5>
	fde->fde_cie = cie;
	
        if (ret_fde == NULL || lopc == NULL || hipc == NULL) 
                return (DW_DLV_ERROR);

        while(dbg->dbg_eh_offset < dbg->dbg_eh_size) {
  8004211f95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211f99:	48 8b 50 38          	mov    0x38(%rax),%rdx
  8004211f9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004211fa1:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004211fa5:	48 39 c2             	cmp    %rax,%rdx
  8004211fa8:	72 8f                	jb     8004211f39 <dwarf_get_fde_at_pc+0x6f>
                    fde->fde_adrange)
                        return (DW_DLV_OK);
        }

        DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
        return (DW_DLV_NO_ENTRY);
  8004211faa:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  8004211faf:	c9                   	leaveq 
  8004211fb0:	c3                   	retq   

0000008004211fb1 <_dwarf_frame_regtable_copy>:

int
_dwarf_frame_regtable_copy(Dwarf_Debug dbg, Dwarf_Regtable3 **dest,
			   Dwarf_Regtable3 *src, Dwarf_Error *error)
{
  8004211fb1:	55                   	push   %rbp
  8004211fb2:	48 89 e5             	mov    %rsp,%rbp
  8004211fb5:	53                   	push   %rbx
  8004211fb6:	48 83 ec 38          	sub    $0x38,%rsp
  8004211fba:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  8004211fbe:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  8004211fc2:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  8004211fc6:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
        int i;

        assert(dest != NULL);
  8004211fca:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004211fcf:	75 35                	jne    8004212006 <_dwarf_frame_regtable_copy+0x55>
  8004211fd1:	48 b9 9a a1 21 04 80 	movabs $0x800421a19a,%rcx
  8004211fd8:	00 00 00 
  8004211fdb:	48 ba a7 a1 21 04 80 	movabs $0x800421a1a7,%rdx
  8004211fe2:	00 00 00 
  8004211fe5:	be 57 00 00 00       	mov    $0x57,%esi
  8004211fea:	48 bf bc a1 21 04 80 	movabs $0x800421a1bc,%rdi
  8004211ff1:	00 00 00 
  8004211ff4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004211ff9:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004212000:	00 00 00 
  8004212003:	41 ff d0             	callq  *%r8
        assert(src != NULL);
  8004212006:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  800421200b:	75 35                	jne    8004212042 <_dwarf_frame_regtable_copy+0x91>
  800421200d:	48 b9 d2 a1 21 04 80 	movabs $0x800421a1d2,%rcx
  8004212014:	00 00 00 
  8004212017:	48 ba a7 a1 21 04 80 	movabs $0x800421a1a7,%rdx
  800421201e:	00 00 00 
  8004212021:	be 58 00 00 00       	mov    $0x58,%esi
  8004212026:	48 bf bc a1 21 04 80 	movabs $0x800421a1bc,%rdi
  800421202d:	00 00 00 
  8004212030:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212035:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  800421203c:	00 00 00 
  800421203f:	41 ff d0             	callq  *%r8

        if (*dest == NULL) {
  8004212042:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212046:	48 8b 00             	mov    (%rax),%rax
  8004212049:	48 85 c0             	test   %rax,%rax
  800421204c:	75 39                	jne    8004212087 <_dwarf_frame_regtable_copy+0xd6>
		*dest = &global_rt_table_shadow;
  800421204e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212052:	48 bb 00 97 37 04 80 	movabs $0x8004379700,%rbx
  8004212059:	00 00 00 
  800421205c:	48 89 18             	mov    %rbx,(%rax)
                (*dest)->rt3_reg_table_size = src->rt3_reg_table_size;
  800421205f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212063:	48 8b 00             	mov    (%rax),%rax
  8004212066:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421206a:	0f b7 52 18          	movzwl 0x18(%rdx),%edx
  800421206e:	66 89 50 18          	mov    %dx,0x18(%rax)
		(*dest)->rt3_rules = global_rules_shadow;
  8004212072:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212076:	48 8b 00             	mov    (%rax),%rax
  8004212079:	48 bb 80 99 37 04 80 	movabs $0x8004379980,%rbx
  8004212080:	00 00 00 
  8004212083:	48 89 58 20          	mov    %rbx,0x20(%rax)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
  8004212087:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
  800421208b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421208f:	48 8b 00             	mov    (%rax),%rax
  8004212092:	ba 18 00 00 00       	mov    $0x18,%edx
  8004212097:	48 89 ce             	mov    %rcx,%rsi
  800421209a:	48 89 c7             	mov    %rax,%rdi
  800421209d:	48 b8 1f fc 20 04 80 	movabs $0x800420fc1f,%rax
  80042120a4:	00 00 00 
  80042120a7:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  80042120a9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  80042120b0:	eb 5a                	jmp    800421210c <_dwarf_frame_regtable_copy+0x15b>
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
  80042120b2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042120b6:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042120ba:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042120bd:	48 63 d0             	movslq %eax,%rdx
  80042120c0:	48 89 d0             	mov    %rdx,%rax
  80042120c3:	48 01 c0             	add    %rax,%rax
  80042120c6:	48 01 d0             	add    %rdx,%rax
  80042120c9:	48 c1 e0 03          	shl    $0x3,%rax
  80042120cd:	48 01 c1             	add    %rax,%rcx
  80042120d0:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042120d4:	48 8b 00             	mov    (%rax),%rax
  80042120d7:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042120db:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042120de:	48 63 d0             	movslq %eax,%rdx
  80042120e1:	48 89 d0             	mov    %rdx,%rax
  80042120e4:	48 01 c0             	add    %rax,%rax
  80042120e7:	48 01 d0             	add    %rdx,%rax
  80042120ea:	48 c1 e0 03          	shl    $0x3,%rax
  80042120ee:	48 01 f0             	add    %rsi,%rax
  80042120f1:	ba 18 00 00 00       	mov    $0x18,%edx
  80042120f6:	48 89 ce             	mov    %rcx,%rsi
  80042120f9:	48 89 c7             	mov    %rax,%rdi
  80042120fc:	48 b8 1f fc 20 04 80 	movabs $0x800420fc1f,%rax
  8004212103:	00 00 00 
  8004212106:	ff d0                	callq  *%rax

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
  8004212108:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800421210c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212110:	48 8b 00             	mov    (%rax),%rax
  8004212113:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212117:	0f b7 c0             	movzwl %ax,%eax
  800421211a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421211d:	7e 10                	jle    800421212f <_dwarf_frame_regtable_copy+0x17e>
		     i < src->rt3_reg_table_size; i++)
  800421211f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212123:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212127:	0f b7 c0             	movzwl %ax,%eax
        }

        memcpy(&(*dest)->rt3_cfa_rule, &src->rt3_cfa_rule,
	       sizeof(Dwarf_Regtable_Entry3));

        for (i = 0; i < (*dest)->rt3_reg_table_size &&
  800421212a:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  800421212d:	7f 83                	jg     80042120b2 <_dwarf_frame_regtable_copy+0x101>
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  800421212f:	eb 32                	jmp    8004212163 <_dwarf_frame_regtable_copy+0x1b2>
                (*dest)->rt3_rules[i].dw_regnum =
  8004212131:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212135:	48 8b 00             	mov    (%rax),%rax
  8004212138:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421213c:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421213f:	48 63 d0             	movslq %eax,%rdx
  8004212142:	48 89 d0             	mov    %rdx,%rax
  8004212145:	48 01 c0             	add    %rax,%rax
  8004212148:	48 01 d0             	add    %rdx,%rax
  800421214b:	48 c1 e0 03          	shl    $0x3,%rax
  800421214f:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
			dbg->dbg_frame_undefined_value;
  8004212153:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004212157:	0f b7 40 50          	movzwl 0x50(%rax),%eax
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
                (*dest)->rt3_rules[i].dw_regnum =
  800421215b:	66 89 42 02          	mov    %ax,0x2(%rdx)
        for (i = 0; i < (*dest)->rt3_reg_table_size &&
		     i < src->rt3_reg_table_size; i++)
                memcpy(&(*dest)->rt3_rules[i], &src->rt3_rules[i],
		       sizeof(Dwarf_Regtable_Entry3));

        for (; i < (*dest)->rt3_reg_table_size; i++)
  800421215f:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  8004212163:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004212167:	48 8b 00             	mov    (%rax),%rax
  800421216a:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421216e:	0f b7 c0             	movzwl %ax,%eax
  8004212171:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  8004212174:	7f bb                	jg     8004212131 <_dwarf_frame_regtable_copy+0x180>
                (*dest)->rt3_rules[i].dw_regnum =
			dbg->dbg_frame_undefined_value;

        return (DW_DLE_NONE);
  8004212176:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421217b:	48 83 c4 38          	add    $0x38,%rsp
  800421217f:	5b                   	pop    %rbx
  8004212180:	5d                   	pop    %rbp
  8004212181:	c3                   	retq   

0000008004212182 <_dwarf_frame_run_inst>:

static int
_dwarf_frame_run_inst(Dwarf_Debug dbg, Dwarf_Regtable3 *rt, uint8_t *insts,
		      Dwarf_Unsigned len, Dwarf_Unsigned caf, Dwarf_Signed daf, Dwarf_Addr pc,
		      Dwarf_Addr pc_req, Dwarf_Addr *row_pc, Dwarf_Error *error)
{
  8004212182:	55                   	push   %rbp
  8004212183:	48 89 e5             	mov    %rsp,%rbp
  8004212186:	53                   	push   %rbx
  8004212187:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
  800421218e:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
  8004212192:	48 89 75 90          	mov    %rsi,-0x70(%rbp)
  8004212196:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
  800421219a:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
  800421219e:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
  80042121a5:	4c 89 8d 70 ff ff ff 	mov    %r9,-0x90(%rbp)
                        ret = DW_DLE_DF_REG_NUM_TOO_HIGH;               \
                        goto program_done;                              \
                }                                                       \
        } while(0)

        ret = DW_DLE_NONE;
  80042121ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
        init_rt = saved_rt = NULL;
  80042121b3:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  80042121ba:	00 
  80042121bb:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042121bf:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        *row_pc = pc;
  80042121c3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042121c7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042121cb:	48 89 10             	mov    %rdx,(%rax)

        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
  80042121ce:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  80042121d2:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  80042121d6:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
  80042121da:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042121de:	48 89 c7             	mov    %rax,%rdi
  80042121e1:	48 b8 b1 1f 21 04 80 	movabs $0x8004211fb1,%rax
  80042121e8:	00 00 00 
  80042121eb:	ff d0                	callq  *%rax
        p = insts;
  80042121ed:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  80042121f1:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
        pe = p + len;
  80042121f5:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  80042121f9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042121fd:	48 01 d0             	add    %rdx,%rax
  8004212200:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

        while (p < pe) {
  8004212204:	e9 3a 0d 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                if (*p == DW_CFA_nop) {
  8004212209:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  800421220d:	0f b6 00             	movzbl (%rax),%eax
  8004212210:	84 c0                	test   %al,%al
  8004212212:	75 11                	jne    8004212225 <_dwarf_frame_run_inst+0xa3>
                        p++;
  8004212214:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212218:	48 83 c0 01          	add    $0x1,%rax
  800421221c:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        continue;
  8004212220:	e9 1e 0d 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                }

                high2 = *p & 0xc0;
  8004212225:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212229:	0f b6 00             	movzbl (%rax),%eax
  800421222c:	83 e0 c0             	and    $0xffffffc0,%eax
  800421222f:	88 45 df             	mov    %al,-0x21(%rbp)
                low6 = *p & 0x3f;
  8004212232:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212236:	0f b6 00             	movzbl (%rax),%eax
  8004212239:	83 e0 3f             	and    $0x3f,%eax
  800421223c:	88 45 de             	mov    %al,-0x22(%rbp)
                p++;
  800421223f:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212243:	48 83 c0 01          	add    $0x1,%rax
  8004212247:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

                if (high2 > 0) {
  800421224b:	80 7d df 00          	cmpb   $0x0,-0x21(%rbp)
  800421224f:	0f 84 a1 01 00 00    	je     80042123f6 <_dwarf_frame_run_inst+0x274>
                        switch (high2) {
  8004212255:	0f b6 45 df          	movzbl -0x21(%rbp),%eax
  8004212259:	3d 80 00 00 00       	cmp    $0x80,%eax
  800421225e:	74 38                	je     8004212298 <_dwarf_frame_run_inst+0x116>
  8004212260:	3d c0 00 00 00       	cmp    $0xc0,%eax
  8004212265:	0f 84 01 01 00 00    	je     800421236c <_dwarf_frame_run_inst+0x1ea>
  800421226b:	83 f8 40             	cmp    $0x40,%eax
  800421226e:	0f 85 71 01 00 00    	jne    80042123e5 <_dwarf_frame_run_inst+0x263>
                        case DW_CFA_advance_loc:
                                pc += low6 * caf;
  8004212274:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  8004212278:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421227f:	ff 
  8004212280:	48 01 45 10          	add    %rax,0x10(%rbp)
                                if (pc_req < pc)
  8004212284:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212288:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421228c:	73 05                	jae    8004212293 <_dwarf_frame_run_inst+0x111>
                                        goto program_done;
  800421228e:	e9 be 0c 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                                break;
  8004212293:	e9 59 01 00 00       	jmpq   80042123f1 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_offset:
                                *row_pc = pc;
  8004212298:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421229c:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042122a0:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  80042122a3:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042122a7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042122ab:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042122af:	66 39 c2             	cmp    %ax,%dx
  80042122b2:	72 0c                	jb     80042122c0 <_dwarf_frame_run_inst+0x13e>
  80042122b4:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042122bb:	e9 91 0c 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                                RL[low6].dw_offset_relevant = 1;
  80042122c0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042122c4:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042122c8:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042122cc:	48 89 d0             	mov    %rdx,%rax
  80042122cf:	48 01 c0             	add    %rax,%rax
  80042122d2:	48 01 d0             	add    %rdx,%rax
  80042122d5:	48 c1 e0 03          	shl    $0x3,%rax
  80042122d9:	48 01 c8             	add    %rcx,%rax
  80042122dc:	c6 00 01             	movb   $0x1,(%rax)
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
  80042122df:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042122e3:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042122e7:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042122eb:	48 89 d0             	mov    %rdx,%rax
  80042122ee:	48 01 c0             	add    %rax,%rax
  80042122f1:	48 01 d0             	add    %rdx,%rax
  80042122f4:	48 c1 e0 03          	shl    $0x3,%rax
  80042122f8:	48 01 c8             	add    %rcx,%rax
  80042122fb:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
  80042122ff:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212303:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212307:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421230b:	48 89 d0             	mov    %rdx,%rax
  800421230e:	48 01 c0             	add    %rax,%rax
  8004212311:	48 01 d0             	add    %rdx,%rax
  8004212314:	48 c1 e0 03          	shl    $0x3,%rax
  8004212318:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421231c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212320:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212324:	66 89 42 02          	mov    %ax,0x2(%rdx)
                                RL[low6].dw_offset_or_block_len =
  8004212328:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421232c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212330:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  8004212334:	48 89 d0             	mov    %rdx,%rax
  8004212337:	48 01 c0             	add    %rax,%rax
  800421233a:	48 01 d0             	add    %rdx,%rax
  800421233d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212341:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
					_dwarf_decode_uleb128(&p) * daf;
  8004212345:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212349:	48 89 c7             	mov    %rax,%rdi
  800421234c:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212353:	00 00 00 
  8004212356:	ff d0                	callq  *%rax
  8004212358:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  800421235f:	48 0f af c2          	imul   %rdx,%rax
                                *row_pc = pc;
                                CHECK_TABLE_SIZE(low6);
                                RL[low6].dw_offset_relevant = 1;
                                RL[low6].dw_value_type = DW_EXPR_OFFSET;
                                RL[low6].dw_regnum = dbg->dbg_frame_cfa_value;
                                RL[low6].dw_offset_or_block_len =
  8004212363:	48 89 43 08          	mov    %rax,0x8(%rbx)
					_dwarf_decode_uleb128(&p) * daf;
                                break;
  8004212367:	e9 85 00 00 00       	jmpq   80042123f1 <_dwarf_frame_run_inst+0x26f>
                        case DW_CFA_restore:
                                *row_pc = pc;
  800421236c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212370:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212374:	48 89 10             	mov    %rdx,(%rax)
                                CHECK_TABLE_SIZE(low6);
  8004212377:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  800421237b:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421237f:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212383:	66 39 c2             	cmp    %ax,%dx
  8004212386:	72 0c                	jb     8004212394 <_dwarf_frame_run_inst+0x212>
  8004212388:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421238f:	e9 bd 0b 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                                memcpy(&RL[low6], &INITRL[low6],
  8004212394:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212398:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421239c:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042123a0:	48 89 d0             	mov    %rdx,%rax
  80042123a3:	48 01 c0             	add    %rax,%rax
  80042123a6:	48 01 d0             	add    %rdx,%rax
  80042123a9:	48 c1 e0 03          	shl    $0x3,%rax
  80042123ad:	48 01 c1             	add    %rax,%rcx
  80042123b0:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042123b4:	48 8b 70 20          	mov    0x20(%rax),%rsi
  80042123b8:	0f b6 55 de          	movzbl -0x22(%rbp),%edx
  80042123bc:	48 89 d0             	mov    %rdx,%rax
  80042123bf:	48 01 c0             	add    %rax,%rax
  80042123c2:	48 01 d0             	add    %rdx,%rax
  80042123c5:	48 c1 e0 03          	shl    $0x3,%rax
  80042123c9:	48 01 f0             	add    %rsi,%rax
  80042123cc:	ba 18 00 00 00       	mov    $0x18,%edx
  80042123d1:	48 89 ce             	mov    %rcx,%rsi
  80042123d4:	48 89 c7             	mov    %rax,%rdi
  80042123d7:	48 b8 1f fc 20 04 80 	movabs $0x800420fc1f,%rax
  80042123de:	00 00 00 
  80042123e1:	ff d0                	callq  *%rax
				       sizeof(Dwarf_Regtable_Entry3));
                                break;
  80042123e3:	eb 0c                	jmp    80042123f1 <_dwarf_frame_run_inst+0x26f>
                        default:
                                DWARF_SET_ERROR(dbg, error,
						DW_DLE_FRAME_INSTR_EXEC_ERROR);
                                ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  80042123e5:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                                goto program_done;
  80042123ec:	e9 60 0b 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        }

                        continue;
  80042123f1:	e9 4d 0b 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                }

                switch (low6) {
  80042123f6:	0f b6 45 de          	movzbl -0x22(%rbp),%eax
  80042123fa:	83 f8 16             	cmp    $0x16,%eax
  80042123fd:	0f 87 37 0b 00 00    	ja     8004212f3a <_dwarf_frame_run_inst+0xdb8>
  8004212403:	89 c0                	mov    %eax,%eax
  8004212405:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  800421240c:	00 
  800421240d:	48 b8 e0 a1 21 04 80 	movabs $0x800421a1e0,%rax
  8004212414:	00 00 00 
  8004212417:	48 01 d0             	add    %rdx,%rax
  800421241a:	48 8b 00             	mov    (%rax),%rax
  800421241d:	ff e0                	jmpq   *%rax
                case DW_CFA_set_loc:
                        pc = dbg->decode(&p, dbg->dbg_pointer_size);
  800421241f:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212423:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212427:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
  800421242b:	8b 4a 28             	mov    0x28(%rdx),%ecx
  800421242e:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212432:	89 ce                	mov    %ecx,%esi
  8004212434:	48 89 d7             	mov    %rdx,%rdi
  8004212437:	ff d0                	callq  *%rax
  8004212439:	48 89 45 10          	mov    %rax,0x10(%rbp)
                        if (pc_req < pc)
  800421243d:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212441:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  8004212445:	73 05                	jae    800421244c <_dwarf_frame_run_inst+0x2ca>
                                goto program_done;
  8004212447:	e9 05 0b 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        break;
  800421244c:	e9 f2 0a 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc1:
                        pc += dbg->decode(&p, 1) * caf;
  8004212451:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212455:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004212459:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  800421245d:	be 01 00 00 00       	mov    $0x1,%esi
  8004212462:	48 89 d7             	mov    %rdx,%rdi
  8004212465:	ff d0                	callq  *%rax
  8004212467:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  800421246e:	ff 
  800421246f:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  8004212473:	48 8b 45 18          	mov    0x18(%rbp),%rax
  8004212477:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  800421247b:	73 05                	jae    8004212482 <_dwarf_frame_run_inst+0x300>
                                goto program_done;
  800421247d:	e9 cf 0a 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        break;
  8004212482:	e9 bc 0a 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc2:
                        pc += dbg->decode(&p, 2) * caf;
  8004212487:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  800421248b:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421248f:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  8004212493:	be 02 00 00 00       	mov    $0x2,%esi
  8004212498:	48 89 d7             	mov    %rdx,%rdi
  800421249b:	ff d0                	callq  *%rax
  800421249d:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042124a4:	ff 
  80042124a5:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  80042124a9:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042124ad:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042124b1:	73 05                	jae    80042124b8 <_dwarf_frame_run_inst+0x336>
                                goto program_done;
  80042124b3:	e9 99 0a 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        break;
  80042124b8:	e9 86 0a 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_advance_loc4:
                        pc += dbg->decode(&p, 4) * caf;
  80042124bd:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042124c1:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042124c5:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
  80042124c9:	be 04 00 00 00       	mov    $0x4,%esi
  80042124ce:	48 89 d7             	mov    %rdx,%rdi
  80042124d1:	ff d0                	callq  *%rax
  80042124d3:	48 0f af 85 78 ff ff 	imul   -0x88(%rbp),%rax
  80042124da:	ff 
  80042124db:	48 01 45 10          	add    %rax,0x10(%rbp)
                        if (pc_req < pc)
  80042124df:	48 8b 45 18          	mov    0x18(%rbp),%rax
  80042124e3:	48 3b 45 10          	cmp    0x10(%rbp),%rax
  80042124e7:	73 05                	jae    80042124ee <_dwarf_frame_run_inst+0x36c>
                                goto program_done;
  80042124e9:	e9 63 0a 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        break;
  80042124ee:	e9 50 0a 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended:
                        *row_pc = pc;
  80042124f3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042124f7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042124fb:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042124fe:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212502:	48 89 c7             	mov    %rax,%rdi
  8004212505:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  800421250c:	00 00 00 
  800421250f:	ff d0                	callq  *%rax
  8004212511:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212515:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212519:	48 89 c7             	mov    %rax,%rdi
  800421251c:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212523:	00 00 00 
  8004212526:	ff d0                	callq  *%rax
  8004212528:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  800421252c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212530:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212534:	0f b7 c0             	movzwl %ax,%eax
  8004212537:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  800421253b:	77 0c                	ja     8004212549 <_dwarf_frame_run_inst+0x3c7>
  800421253d:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212544:	e9 08 0a 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004212549:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421254d:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212551:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212555:	48 89 d0             	mov    %rdx,%rax
  8004212558:	48 01 c0             	add    %rax,%rax
  800421255b:	48 01 d0             	add    %rdx,%rax
  800421255e:	48 c1 e0 03          	shl    $0x3,%rax
  8004212562:	48 01 c8             	add    %rcx,%rax
  8004212565:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004212568:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421256c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212570:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212574:	48 89 d0             	mov    %rdx,%rax
  8004212577:	48 01 c0             	add    %rax,%rax
  800421257a:	48 01 d0             	add    %rdx,%rax
  800421257d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212581:	48 01 c8             	add    %rcx,%rax
  8004212584:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212588:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421258c:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212590:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212594:	48 89 d0             	mov    %rdx,%rax
  8004212597:	48 01 c0             	add    %rax,%rax
  800421259a:	48 01 d0             	add    %rdx,%rax
  800421259d:	48 c1 e0 03          	shl    $0x3,%rax
  80042125a1:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042125a5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042125a9:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042125ad:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  80042125b1:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042125b5:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042125b9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042125bd:	48 89 d0             	mov    %rdx,%rax
  80042125c0:	48 01 c0             	add    %rax,%rax
  80042125c3:	48 01 d0             	add    %rdx,%rax
  80042125c6:	48 c1 e0 03          	shl    $0x3,%rax
  80042125ca:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042125ce:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042125d5:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  80042125da:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  80042125de:	e9 60 09 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_extended:
                        *row_pc = pc;
  80042125e3:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042125e7:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042125eb:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042125ee:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042125f2:	48 89 c7             	mov    %rax,%rdi
  80042125f5:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  80042125fc:	00 00 00 
  80042125ff:	ff d0                	callq  *%rax
  8004212601:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212605:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212609:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  800421260d:	0f b7 c0             	movzwl %ax,%eax
  8004212610:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212614:	77 0c                	ja     8004212622 <_dwarf_frame_run_inst+0x4a0>
  8004212616:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  800421261d:	e9 2f 09 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        memcpy(&RL[reg], &INITRL[reg],
  8004212622:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004212626:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421262a:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421262e:	48 89 d0             	mov    %rdx,%rax
  8004212631:	48 01 c0             	add    %rax,%rax
  8004212634:	48 01 d0             	add    %rdx,%rax
  8004212637:	48 c1 e0 03          	shl    $0x3,%rax
  800421263b:	48 01 c1             	add    %rax,%rcx
  800421263e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212642:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212646:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421264a:	48 89 d0             	mov    %rdx,%rax
  800421264d:	48 01 c0             	add    %rax,%rax
  8004212650:	48 01 d0             	add    %rdx,%rax
  8004212653:	48 c1 e0 03          	shl    $0x3,%rax
  8004212657:	48 01 f0             	add    %rsi,%rax
  800421265a:	ba 18 00 00 00       	mov    $0x18,%edx
  800421265f:	48 89 ce             	mov    %rcx,%rsi
  8004212662:	48 89 c7             	mov    %rax,%rdi
  8004212665:	48 b8 1f fc 20 04 80 	movabs $0x800420fc1f,%rax
  800421266c:	00 00 00 
  800421266f:	ff d0                	callq  *%rax
			       sizeof(Dwarf_Regtable_Entry3));
                        break;
  8004212671:	e9 cd 08 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_undefined:
                        *row_pc = pc;
  8004212676:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421267a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421267e:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212681:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212685:	48 89 c7             	mov    %rax,%rdi
  8004212688:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  800421268f:	00 00 00 
  8004212692:	ff d0                	callq  *%rax
  8004212694:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212698:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421269c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042126a0:	0f b7 c0             	movzwl %ax,%eax
  80042126a3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042126a7:	77 0c                	ja     80042126b5 <_dwarf_frame_run_inst+0x533>
  80042126a9:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042126b0:	e9 9c 08 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  80042126b5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126b9:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042126bd:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042126c1:	48 89 d0             	mov    %rdx,%rax
  80042126c4:	48 01 c0             	add    %rax,%rax
  80042126c7:	48 01 d0             	add    %rdx,%rax
  80042126ca:	48 c1 e0 03          	shl    $0x3,%rax
  80042126ce:	48 01 c8             	add    %rcx,%rax
  80042126d1:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_undefined_value;
  80042126d4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042126d8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042126dc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042126e0:	48 89 d0             	mov    %rdx,%rax
  80042126e3:	48 01 c0             	add    %rax,%rax
  80042126e6:	48 01 d0             	add    %rdx,%rax
  80042126e9:	48 c1 e0 03          	shl    $0x3,%rax
  80042126ed:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  80042126f1:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042126f5:	0f b7 40 50          	movzwl 0x50(%rax),%eax
  80042126f9:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  80042126fd:	e9 41 08 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_same_value:
                        reg = _dwarf_decode_uleb128(&p);
  8004212702:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212706:	48 89 c7             	mov    %rax,%rdi
  8004212709:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212710:	00 00 00 
  8004212713:	ff d0                	callq  *%rax
  8004212715:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212719:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421271d:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212721:	0f b7 c0             	movzwl %ax,%eax
  8004212724:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212728:	77 0c                	ja     8004212736 <_dwarf_frame_run_inst+0x5b4>
  800421272a:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212731:	e9 1b 08 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004212736:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421273a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421273e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212742:	48 89 d0             	mov    %rdx,%rax
  8004212745:	48 01 c0             	add    %rax,%rax
  8004212748:	48 01 d0             	add    %rdx,%rax
  800421274b:	48 c1 e0 03          	shl    $0x3,%rax
  800421274f:	48 01 c8             	add    %rcx,%rax
  8004212752:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_same_value;
  8004212755:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212759:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421275d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212761:	48 89 d0             	mov    %rdx,%rax
  8004212764:	48 01 c0             	add    %rax,%rax
  8004212767:	48 01 d0             	add    %rdx,%rax
  800421276a:	48 c1 e0 03          	shl    $0x3,%rax
  800421276e:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212772:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212776:	0f b7 40 4e          	movzwl 0x4e(%rax),%eax
  800421277a:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  800421277e:	e9 c0 07 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_register:
                        *row_pc = pc;
  8004212783:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212787:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421278b:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  800421278e:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212792:	48 89 c7             	mov    %rax,%rdi
  8004212795:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  800421279c:	00 00 00 
  800421279f:	ff d0                	callq  *%rax
  80042127a1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        reg2 = _dwarf_decode_uleb128(&p);
  80042127a5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042127a9:	48 89 c7             	mov    %rax,%rdi
  80042127ac:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  80042127b3:	00 00 00 
  80042127b6:	ff d0                	callq  *%rax
  80042127b8:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042127bc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127c0:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042127c4:	0f b7 c0             	movzwl %ax,%eax
  80042127c7:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042127cb:	77 0c                	ja     80042127d9 <_dwarf_frame_run_inst+0x657>
  80042127cd:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042127d4:	e9 78 07 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  80042127d9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127dd:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042127e1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042127e5:	48 89 d0             	mov    %rdx,%rax
  80042127e8:	48 01 c0             	add    %rax,%rax
  80042127eb:	48 01 d0             	add    %rdx,%rax
  80042127ee:	48 c1 e0 03          	shl    $0x3,%rax
  80042127f2:	48 01 c8             	add    %rcx,%rax
  80042127f5:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_regnum = reg2;
  80042127f8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042127fc:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212800:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212804:	48 89 d0             	mov    %rdx,%rax
  8004212807:	48 01 c0             	add    %rax,%rax
  800421280a:	48 01 d0             	add    %rdx,%rax
  800421280d:	48 c1 e0 03          	shl    $0x3,%rax
  8004212811:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212815:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004212819:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        break;
  800421281d:	e9 21 07 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_remember_state:
                        _dwarf_frame_regtable_copy(dbg, &saved_rt, rt, error);
  8004212822:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
  8004212826:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  800421282a:	48 8d 75 a8          	lea    -0x58(%rbp),%rsi
  800421282e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212832:	48 89 c7             	mov    %rax,%rdi
  8004212835:	48 b8 b1 1f 21 04 80 	movabs $0x8004211fb1,%rax
  800421283c:	00 00 00 
  800421283f:	ff d0                	callq  *%rax
                        break;
  8004212841:	e9 fd 06 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_restore_state:
                        *row_pc = pc;
  8004212846:	48 8b 45 20          	mov    0x20(%rbp),%rax
  800421284a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421284e:	48 89 10             	mov    %rdx,(%rax)
                        _dwarf_frame_regtable_copy(dbg, &rt, saved_rt, error);
  8004212851:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004212855:	48 8b 4d 28          	mov    0x28(%rbp),%rcx
  8004212859:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
  800421285d:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212861:	48 89 c7             	mov    %rax,%rdi
  8004212864:	48 b8 b1 1f 21 04 80 	movabs $0x8004211fb1,%rax
  800421286b:	00 00 00 
  800421286e:	ff d0                	callq  *%rax
                        break;
  8004212870:	e9 ce 06 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa:
                        *row_pc = pc;
  8004212875:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212879:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  800421287d:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212880:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212884:	48 89 c7             	mov    %rax,%rdi
  8004212887:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  800421288e:	00 00 00 
  8004212891:	ff d0                	callq  *%rax
  8004212893:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212897:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421289b:	48 89 c7             	mov    %rax,%rdi
  800421289e:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  80042128a5:	00 00 00 
  80042128a8:	ff d0                	callq  *%rax
  80042128aa:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  80042128ae:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128b2:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  80042128b5:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128b9:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  80042128bd:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128c1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042128c5:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  80042128c9:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042128cd:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042128d1:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  80042128d5:	e9 69 06 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_register:
                        *row_pc = pc;
  80042128da:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042128de:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042128e2:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042128e5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042128e9:	48 89 c7             	mov    %rax,%rdi
  80042128ec:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  80042128f3:	00 00 00 
  80042128f6:	ff d0                	callq  *%rax
  80042128f8:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CFA.dw_regnum = reg;
  80042128fc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212900:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212904:	66 89 50 02          	mov    %dx,0x2(%rax)
                         * Note that DW_CFA_def_cfa_register change the CFA
                         * rule register while keep the old offset. So we
                         * should not touch the CFA.dw_offset_relevant flag
                         * here.
                         */
                        break;
  8004212908:	e9 36 06 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset:
                        *row_pc = pc;
  800421290d:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212911:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212915:	48 89 10             	mov    %rdx,(%rax)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212918:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  800421291c:	48 89 c7             	mov    %rax,%rdi
  800421291f:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212926:	00 00 00 
  8004212929:	ff d0                	callq  *%rax
  800421292b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CFA.dw_offset_relevant = 1;
  800421292f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212933:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212936:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421293a:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = uoff;
  800421293e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212942:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004212946:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  800421294a:	e9 f4 05 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_expression:
                        *row_pc = pc;
  800421294f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212953:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212957:	48 89 10             	mov    %rdx,(%rax)
                        CFA.dw_offset_relevant = 0;
  800421295a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  800421295e:	c6 00 00             	movb   $0x0,(%rax)
                        CFA.dw_value_type = DW_EXPR_EXPRESSION;
  8004212961:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212965:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        CFA.dw_offset_or_block_len = _dwarf_decode_uleb128(&p);
  8004212969:	48 8b 5d 90          	mov    -0x70(%rbp),%rbx
  800421296d:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212971:	48 89 c7             	mov    %rax,%rdi
  8004212974:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  800421297b:	00 00 00 
  800421297e:	ff d0                	callq  *%rax
  8004212980:	48 89 43 08          	mov    %rax,0x8(%rbx)
                        CFA.dw_block_ptr = p;
  8004212984:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212988:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  800421298c:	48 89 50 10          	mov    %rdx,0x10(%rax)
                        p += CFA.dw_offset_or_block_len;
  8004212990:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
  8004212994:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212998:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421299c:	48 01 d0             	add    %rdx,%rax
  800421299f:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  80042129a3:	e9 9b 05 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_expression:
                        *row_pc = pc;
  80042129a8:	48 8b 45 20          	mov    0x20(%rbp),%rax
  80042129ac:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  80042129b0:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  80042129b3:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042129b7:	48 89 c7             	mov    %rax,%rdi
  80042129ba:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  80042129c1:	00 00 00 
  80042129c4:	ff d0                	callq  *%rax
  80042129c6:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  80042129ca:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129ce:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  80042129d2:	0f b7 c0             	movzwl %ax,%eax
  80042129d5:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042129d9:	77 0c                	ja     80042129e7 <_dwarf_frame_run_inst+0x865>
  80042129db:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  80042129e2:	e9 6a 05 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  80042129e7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042129eb:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042129ef:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042129f3:	48 89 d0             	mov    %rdx,%rax
  80042129f6:	48 01 c0             	add    %rax,%rax
  80042129f9:	48 01 d0             	add    %rdx,%rax
  80042129fc:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a00:	48 01 c8             	add    %rcx,%rax
  8004212a03:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
  8004212a06:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a0a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a0e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a12:	48 89 d0             	mov    %rdx,%rax
  8004212a15:	48 01 c0             	add    %rax,%rax
  8004212a18:	48 01 d0             	add    %rdx,%rax
  8004212a1b:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a1f:	48 01 c8             	add    %rcx,%rax
  8004212a22:	c6 40 01 02          	movb   $0x2,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004212a26:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a2a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a2e:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a32:	48 89 d0             	mov    %rdx,%rax
  8004212a35:	48 01 c0             	add    %rax,%rax
  8004212a38:	48 01 d0             	add    %rdx,%rax
  8004212a3b:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a3f:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004212a43:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212a47:	48 89 c7             	mov    %rax,%rdi
  8004212a4a:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212a51:	00 00 00 
  8004212a54:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004212a56:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  8004212a5a:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a5e:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212a62:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a66:	48 89 d0             	mov    %rdx,%rax
  8004212a69:	48 01 c0             	add    %rax,%rax
  8004212a6c:	48 01 d0             	add    %rdx,%rax
  8004212a6f:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a73:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212a77:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212a7b:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004212a7f:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212a83:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212a87:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212a8b:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212a8f:	48 89 d0             	mov    %rdx,%rax
  8004212a92:	48 01 c0             	add    %rax,%rax
  8004212a95:	48 01 d0             	add    %rdx,%rax
  8004212a98:	48 c1 e0 03          	shl    $0x3,%rax
  8004212a9c:	48 01 f0             	add    %rsi,%rax
  8004212a9f:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212aa3:	48 01 c8             	add    %rcx,%rax
  8004212aa6:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  8004212aaa:	e9 94 04 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_offset_extended_sf:
                        *row_pc = pc;
  8004212aaf:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212ab3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212ab7:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212aba:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212abe:	48 89 c7             	mov    %rax,%rdi
  8004212ac1:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212ac8:	00 00 00 
  8004212acb:	ff d0                	callq  *%rax
  8004212acd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004212ad1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212ad5:	48 89 c7             	mov    %rax,%rdi
  8004212ad8:	48 b8 0e 06 21 04 80 	movabs $0x800421060e,%rax
  8004212adf:	00 00 00 
  8004212ae2:	ff d0                	callq  *%rax
  8004212ae4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212ae8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212aec:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212af0:	0f b7 c0             	movzwl %ax,%eax
  8004212af3:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212af7:	77 0c                	ja     8004212b05 <_dwarf_frame_run_inst+0x983>
  8004212af9:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212b00:	e9 4c 04 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004212b05:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b09:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212b0d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b11:	48 89 d0             	mov    %rdx,%rax
  8004212b14:	48 01 c0             	add    %rax,%rax
  8004212b17:	48 01 d0             	add    %rdx,%rax
  8004212b1a:	48 c1 e0 03          	shl    $0x3,%rax
  8004212b1e:	48 01 c8             	add    %rcx,%rax
  8004212b21:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_OFFSET;
  8004212b24:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b28:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212b2c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b30:	48 89 d0             	mov    %rdx,%rax
  8004212b33:	48 01 c0             	add    %rax,%rax
  8004212b36:	48 01 d0             	add    %rdx,%rax
  8004212b39:	48 c1 e0 03          	shl    $0x3,%rax
  8004212b3d:	48 01 c8             	add    %rcx,%rax
  8004212b40:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212b44:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b48:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212b4c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b50:	48 89 d0             	mov    %rdx,%rax
  8004212b53:	48 01 c0             	add    %rax,%rax
  8004212b56:	48 01 d0             	add    %rdx,%rax
  8004212b59:	48 c1 e0 03          	shl    $0x3,%rax
  8004212b5d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212b61:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212b65:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212b69:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004212b6d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212b71:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212b75:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212b79:	48 89 d0             	mov    %rdx,%rax
  8004212b7c:	48 01 c0             	add    %rax,%rax
  8004212b7f:	48 01 d0             	add    %rdx,%rax
  8004212b82:	48 c1 e0 03          	shl    $0x3,%rax
  8004212b86:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212b8a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212b91:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212b96:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004212b9a:	e9 a4 03 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_sf:
                        *row_pc = pc;
  8004212b9f:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212ba3:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212ba7:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212baa:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212bae:	48 89 c7             	mov    %rax,%rdi
  8004212bb1:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212bb8:	00 00 00 
  8004212bbb:	ff d0                	callq  *%rax
  8004212bbd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004212bc1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212bc5:	48 89 c7             	mov    %rax,%rdi
  8004212bc8:	48 b8 0e 06 21 04 80 	movabs $0x800421060e,%rax
  8004212bcf:	00 00 00 
  8004212bd2:	ff d0                	callq  *%rax
  8004212bd4:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004212bd8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bdc:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212bdf:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212be3:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_regnum = reg;
  8004212be7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212beb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212bef:	66 89 50 02          	mov    %dx,0x2(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004212bf3:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212bf7:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212bfe:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212c03:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004212c07:	e9 37 03 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_def_cfa_offset_sf:
                        *row_pc = pc;
  8004212c0c:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212c10:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212c14:	48 89 10             	mov    %rdx,(%rax)
                        soff = _dwarf_decode_sleb128(&p);
  8004212c17:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c1b:	48 89 c7             	mov    %rax,%rdi
  8004212c1e:	48 b8 0e 06 21 04 80 	movabs $0x800421060e,%rax
  8004212c25:	00 00 00 
  8004212c28:	ff d0                	callq  *%rax
  8004212c2a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CFA.dw_offset_relevant = 1;
  8004212c2e:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c32:	c6 00 01             	movb   $0x1,(%rax)
                        CFA.dw_value_type = DW_EXPR_OFFSET;
  8004212c35:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c39:	c6 40 01 00          	movb   $0x0,0x1(%rax)
                        CFA.dw_offset_or_block_len = soff * daf;
  8004212c3d:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c41:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
  8004212c48:	48 0f af 55 b8       	imul   -0x48(%rbp),%rdx
  8004212c4d:	48 89 50 08          	mov    %rdx,0x8(%rax)
                        break;
  8004212c51:	e9 ed 02 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset:
                        *row_pc = pc;
  8004212c56:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212c5a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212c5e:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212c61:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c65:	48 89 c7             	mov    %rax,%rdi
  8004212c68:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212c6f:	00 00 00 
  8004212c72:	ff d0                	callq  *%rax
  8004212c74:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        uoff = _dwarf_decode_uleb128(&p);
  8004212c78:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212c7c:	48 89 c7             	mov    %rax,%rdi
  8004212c7f:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212c86:	00 00 00 
  8004212c89:	ff d0                	callq  *%rax
  8004212c8b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212c8f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212c93:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212c97:	0f b7 c0             	movzwl %ax,%eax
  8004212c9a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212c9e:	77 0c                	ja     8004212cac <_dwarf_frame_run_inst+0xb2a>
  8004212ca0:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212ca7:	e9 a5 02 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004212cac:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cb0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cb4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cb8:	48 89 d0             	mov    %rdx,%rax
  8004212cbb:	48 01 c0             	add    %rax,%rax
  8004212cbe:	48 01 d0             	add    %rdx,%rax
  8004212cc1:	48 c1 e0 03          	shl    $0x3,%rax
  8004212cc5:	48 01 c8             	add    %rcx,%rax
  8004212cc8:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212ccb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ccf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cd3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cd7:	48 89 d0             	mov    %rdx,%rax
  8004212cda:	48 01 c0             	add    %rax,%rax
  8004212cdd:	48 01 d0             	add    %rdx,%rax
  8004212ce0:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ce4:	48 01 c8             	add    %rcx,%rax
  8004212ce7:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212ceb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212cef:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212cf3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212cf7:	48 89 d0             	mov    %rdx,%rax
  8004212cfa:	48 01 c0             	add    %rax,%rax
  8004212cfd:	48 01 d0             	add    %rdx,%rax
  8004212d00:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d04:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212d08:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212d0c:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212d10:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = uoff * daf;
  8004212d14:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d18:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212d1c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212d20:	48 89 d0             	mov    %rdx,%rax
  8004212d23:	48 01 c0             	add    %rax,%rax
  8004212d26:	48 01 d0             	add    %rdx,%rax
  8004212d29:	48 c1 e0 03          	shl    $0x3,%rax
  8004212d2d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212d31:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212d38:	48 0f af 45 c8       	imul   -0x38(%rbp),%rax
  8004212d3d:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004212d41:	e9 fd 01 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_offset_sf:
                        *row_pc = pc;
  8004212d46:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212d4a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212d4e:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212d51:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212d55:	48 89 c7             	mov    %rax,%rdi
  8004212d58:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212d5f:	00 00 00 
  8004212d62:	ff d0                	callq  *%rax
  8004212d64:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        soff = _dwarf_decode_sleb128(&p);
  8004212d68:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212d6c:	48 89 c7             	mov    %rax,%rdi
  8004212d6f:	48 b8 0e 06 21 04 80 	movabs $0x800421060e,%rax
  8004212d76:	00 00 00 
  8004212d79:	ff d0                	callq  *%rax
  8004212d7b:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212d7f:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212d83:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212d87:	0f b7 c0             	movzwl %ax,%eax
  8004212d8a:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212d8e:	77 0c                	ja     8004212d9c <_dwarf_frame_run_inst+0xc1a>
  8004212d90:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212d97:	e9 b5 01 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 1;
  8004212d9c:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212da0:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212da4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212da8:	48 89 d0             	mov    %rdx,%rax
  8004212dab:	48 01 c0             	add    %rax,%rax
  8004212dae:	48 01 d0             	add    %rdx,%rax
  8004212db1:	48 c1 e0 03          	shl    $0x3,%rax
  8004212db5:	48 01 c8             	add    %rcx,%rax
  8004212db8:	c6 00 01             	movb   $0x1,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_OFFSET;
  8004212dbb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212dbf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212dc3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212dc7:	48 89 d0             	mov    %rdx,%rax
  8004212dca:	48 01 c0             	add    %rax,%rax
  8004212dcd:	48 01 d0             	add    %rdx,%rax
  8004212dd0:	48 c1 e0 03          	shl    $0x3,%rax
  8004212dd4:	48 01 c8             	add    %rcx,%rax
  8004212dd7:	c6 40 01 01          	movb   $0x1,0x1(%rax)
                        RL[reg].dw_regnum = dbg->dbg_frame_cfa_value;
  8004212ddb:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212ddf:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212de3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212de7:	48 89 d0             	mov    %rdx,%rax
  8004212dea:	48 01 c0             	add    %rax,%rax
  8004212ded:	48 01 d0             	add    %rdx,%rax
  8004212df0:	48 c1 e0 03          	shl    $0x3,%rax
  8004212df4:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212df8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  8004212dfc:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  8004212e00:	66 89 42 02          	mov    %ax,0x2(%rdx)
                        RL[reg].dw_offset_or_block_len = soff * daf;
  8004212e04:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e08:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212e0c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e10:	48 89 d0             	mov    %rdx,%rax
  8004212e13:	48 01 c0             	add    %rax,%rax
  8004212e16:	48 01 d0             	add    %rdx,%rax
  8004212e19:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e1d:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212e21:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  8004212e28:	48 0f af 45 b8       	imul   -0x48(%rbp),%rax
  8004212e2d:	48 89 42 08          	mov    %rax,0x8(%rdx)
                        break;
  8004212e31:	e9 0d 01 00 00       	jmpq   8004212f43 <_dwarf_frame_run_inst+0xdc1>
                case DW_CFA_val_expression:
                        *row_pc = pc;
  8004212e36:	48 8b 45 20          	mov    0x20(%rbp),%rax
  8004212e3a:	48 8b 55 10          	mov    0x10(%rbp),%rdx
  8004212e3e:	48 89 10             	mov    %rdx,(%rax)
                        reg = _dwarf_decode_uleb128(&p);
  8004212e41:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212e45:	48 89 c7             	mov    %rax,%rdi
  8004212e48:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212e4f:	00 00 00 
  8004212e52:	ff d0                	callq  *%rax
  8004212e54:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
                        CHECK_TABLE_SIZE(reg);
  8004212e58:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e5c:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004212e60:	0f b7 c0             	movzwl %ax,%eax
  8004212e63:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  8004212e67:	77 0c                	ja     8004212e75 <_dwarf_frame_run_inst+0xcf3>
  8004212e69:	c7 45 ec 18 00 00 00 	movl   $0x18,-0x14(%rbp)
  8004212e70:	e9 dc 00 00 00       	jmpq   8004212f51 <_dwarf_frame_run_inst+0xdcf>
                        RL[reg].dw_offset_relevant = 0;
  8004212e75:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e79:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212e7d:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212e81:	48 89 d0             	mov    %rdx,%rax
  8004212e84:	48 01 c0             	add    %rax,%rax
  8004212e87:	48 01 d0             	add    %rdx,%rax
  8004212e8a:	48 c1 e0 03          	shl    $0x3,%rax
  8004212e8e:	48 01 c8             	add    %rcx,%rax
  8004212e91:	c6 00 00             	movb   $0x0,(%rax)
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
  8004212e94:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212e98:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212e9c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ea0:	48 89 d0             	mov    %rdx,%rax
  8004212ea3:	48 01 c0             	add    %rax,%rax
  8004212ea6:	48 01 d0             	add    %rdx,%rax
  8004212ea9:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ead:	48 01 c8             	add    %rcx,%rax
  8004212eb0:	c6 40 01 03          	movb   $0x3,0x1(%rax)
                        RL[reg].dw_offset_or_block_len =
  8004212eb4:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212eb8:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ebc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ec0:	48 89 d0             	mov    %rdx,%rax
  8004212ec3:	48 01 c0             	add    %rax,%rax
  8004212ec6:	48 01 d0             	add    %rdx,%rax
  8004212ec9:	48 c1 e0 03          	shl    $0x3,%rax
  8004212ecd:	48 8d 1c 01          	lea    (%rcx,%rax,1),%rbx
				_dwarf_decode_uleb128(&p);
  8004212ed1:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004212ed5:	48 89 c7             	mov    %rax,%rdi
  8004212ed8:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004212edf:	00 00 00 
  8004212ee2:	ff d0                	callq  *%rax
                        *row_pc = pc;
                        reg = _dwarf_decode_uleb128(&p);
                        CHECK_TABLE_SIZE(reg);
                        RL[reg].dw_offset_relevant = 0;
                        RL[reg].dw_value_type = DW_EXPR_VAL_EXPRESSION;
                        RL[reg].dw_offset_or_block_len =
  8004212ee4:	48 89 43 08          	mov    %rax,0x8(%rbx)
				_dwarf_decode_uleb128(&p);
                        RL[reg].dw_block_ptr = p;
  8004212ee8:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212eec:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004212ef0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212ef4:	48 89 d0             	mov    %rdx,%rax
  8004212ef7:	48 01 c0             	add    %rax,%rax
  8004212efa:	48 01 d0             	add    %rdx,%rax
  8004212efd:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f01:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  8004212f05:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212f09:	48 89 42 10          	mov    %rax,0x10(%rdx)
                        p += RL[reg].dw_offset_or_block_len;
  8004212f0d:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
  8004212f11:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  8004212f15:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004212f19:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004212f1d:	48 89 d0             	mov    %rdx,%rax
  8004212f20:	48 01 c0             	add    %rax,%rax
  8004212f23:	48 01 d0             	add    %rdx,%rax
  8004212f26:	48 c1 e0 03          	shl    $0x3,%rax
  8004212f2a:	48 01 f0             	add    %rsi,%rax
  8004212f2d:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004212f31:	48 01 c8             	add    %rcx,%rax
  8004212f34:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
                        break;
  8004212f38:	eb 09                	jmp    8004212f43 <_dwarf_frame_run_inst+0xdc1>
                default:
                        DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_INSTR_EXEC_ERROR);
                        ret = DW_DLE_FRAME_INSTR_EXEC_ERROR;
  8004212f3a:	c7 45 ec 15 00 00 00 	movl   $0x15,-0x14(%rbp)
                        goto program_done;
  8004212f41:	eb 0e                	jmp    8004212f51 <_dwarf_frame_run_inst+0xdcf>
        /* Save a copy of the table as initial state. */
        _dwarf_frame_regtable_copy(dbg, &init_rt, rt, error);
        p = insts;
        pe = p + len;

        while (p < pe) {
  8004212f43:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004212f47:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004212f4b:	0f 82 b8 f2 ff ff    	jb     8004212209 <_dwarf_frame_run_inst+0x87>
                        goto program_done;
                }
        }

program_done:
        return (ret);
  8004212f51:	8b 45 ec             	mov    -0x14(%rbp),%eax
#undef  CFA
#undef  INITCFA
#undef  RL
#undef  INITRL
#undef  CHECK_TABLE_SIZE
}
  8004212f54:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
  8004212f5b:	5b                   	pop    %rbx
  8004212f5c:	5d                   	pop    %rbp
  8004212f5d:	c3                   	retq   

0000008004212f5e <_dwarf_frame_get_internal_table>:

int
_dwarf_frame_get_internal_table(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_req, Dwarf_Regtable3 **ret_rt, Dwarf_Addr *ret_row_pc,
				Dwarf_Error *error)
{
  8004212f5e:	55                   	push   %rbp
  8004212f5f:	48 89 e5             	mov    %rsp,%rbp
  8004212f62:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
  8004212f66:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004212f6a:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004212f6e:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004212f72:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004212f76:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
  8004212f7a:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
        Dwarf_Cie cie;
        Dwarf_Regtable3 *rt;
        Dwarf_Addr row_pc;
        int i, ret;

        assert(ret_rt != NULL);
  8004212f7e:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004212f83:	75 35                	jne    8004212fba <_dwarf_frame_get_internal_table+0x5c>
  8004212f85:	48 b9 98 a2 21 04 80 	movabs $0x800421a298,%rcx
  8004212f8c:	00 00 00 
  8004212f8f:	48 ba a7 a1 21 04 80 	movabs $0x800421a1a7,%rdx
  8004212f96:	00 00 00 
  8004212f99:	be 82 01 00 00       	mov    $0x182,%esi
  8004212f9e:	48 bf bc a1 21 04 80 	movabs $0x800421a1bc,%rdi
  8004212fa5:	00 00 00 
  8004212fa8:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212fad:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004212fb4:	00 00 00 
  8004212fb7:	41 ff d0             	callq  *%r8

        //dbg = fde->fde_dbg;
        assert(dbg != NULL);
  8004212fba:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004212fbf:	75 35                	jne    8004212ff6 <_dwarf_frame_get_internal_table+0x98>
  8004212fc1:	48 b9 a7 a2 21 04 80 	movabs $0x800421a2a7,%rcx
  8004212fc8:	00 00 00 
  8004212fcb:	48 ba a7 a1 21 04 80 	movabs $0x800421a1a7,%rdx
  8004212fd2:	00 00 00 
  8004212fd5:	be 85 01 00 00       	mov    $0x185,%esi
  8004212fda:	48 bf bc a1 21 04 80 	movabs $0x800421a1bc,%rdi
  8004212fe1:	00 00 00 
  8004212fe4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004212fe9:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004212ff0:	00 00 00 
  8004212ff3:	41 ff d0             	callq  *%r8

        rt = dbg->dbg_internal_reg_table;
  8004212ff6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004212ffa:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004212ffe:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

        /* Clear the content of regtable from previous run. */
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
  8004213002:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213006:	ba 18 00 00 00       	mov    $0x18,%edx
  800421300b:	be 00 00 00 00       	mov    $0x0,%esi
  8004213010:	48 89 c7             	mov    %rax,%rdi
  8004213013:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  800421301a:	00 00 00 
  800421301d:	ff d0                	callq  *%rax
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
  800421301f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213023:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213027:	0f b7 d0             	movzwl %ax,%edx
  800421302a:	48 89 d0             	mov    %rdx,%rax
  800421302d:	48 01 c0             	add    %rax,%rax
  8004213030:	48 01 d0             	add    %rdx,%rax
  8004213033:	48 c1 e0 03          	shl    $0x3,%rax
  8004213037:	48 89 c2             	mov    %rax,%rdx
  800421303a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421303e:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004213042:	be 00 00 00 00       	mov    $0x0,%esi
  8004213047:	48 89 c7             	mov    %rax,%rdi
  800421304a:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004213051:	00 00 00 
  8004213054:	ff d0                	callq  *%rax
	       sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  8004213056:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  800421305d:	eb 2f                	jmp    800421308e <_dwarf_frame_get_internal_table+0x130>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;
  800421305f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213063:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213067:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421306a:	48 63 d0             	movslq %eax,%rdx
  800421306d:	48 89 d0             	mov    %rdx,%rax
  8004213070:	48 01 c0             	add    %rax,%rax
  8004213073:	48 01 d0             	add    %rdx,%rax
  8004213076:	48 c1 e0 03          	shl    $0x3,%rax
  800421307a:	48 8d 14 01          	lea    (%rcx,%rax,1),%rdx
  800421307e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213082:	0f b7 40 4a          	movzwl 0x4a(%rax),%eax
  8004213086:	66 89 42 02          	mov    %ax,0x2(%rdx)
        memset(&rt->rt3_cfa_rule, 0, sizeof(Dwarf_Regtable_Entry3));
        memset(rt->rt3_rules, 0, rt->rt3_reg_table_size *
	       sizeof(Dwarf_Regtable_Entry3));

        /* Set rules to initial values. */
        for (i = 0; i < rt->rt3_reg_table_size; i++)
  800421308a:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  800421308e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004213092:	0f b7 40 18          	movzwl 0x18(%rax),%eax
  8004213096:	0f b7 c0             	movzwl %ax,%eax
  8004213099:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  800421309c:	7f c1                	jg     800421305f <_dwarf_frame_get_internal_table+0x101>
                rt->rt3_rules[i].dw_regnum = dbg->dbg_frame_rule_initial_value;

        /* Run initial instructions in CIE. */
        cie = fde->fde_cie;
  800421309e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042130a2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042130a6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
        assert(cie != NULL);
  80042130aa:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
  80042130af:	75 35                	jne    80042130e6 <_dwarf_frame_get_internal_table+0x188>
  80042130b1:	48 b9 b3 a2 21 04 80 	movabs $0x800421a2b3,%rcx
  80042130b8:	00 00 00 
  80042130bb:	48 ba a7 a1 21 04 80 	movabs $0x800421a1a7,%rdx
  80042130c2:	00 00 00 
  80042130c5:	be 94 01 00 00       	mov    $0x194,%esi
  80042130ca:	48 bf bc a1 21 04 80 	movabs $0x800421a1bc,%rdi
  80042130d1:	00 00 00 
  80042130d4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042130d9:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042130e0:	00 00 00 
  80042130e3:	41 ff d0             	callq  *%r8
        ret = _dwarf_frame_run_inst(dbg, rt, cie->cie_initinst,
  80042130e6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130ea:	4c 8b 48 40          	mov    0x40(%rax),%r9
  80042130ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130f2:	4c 8b 40 38          	mov    0x38(%rax),%r8
  80042130f6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042130fa:	48 8b 48 70          	mov    0x70(%rax),%rcx
  80042130fe:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213102:	48 8b 50 68          	mov    0x68(%rax),%rdx
  8004213106:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800421310a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421310e:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
  8004213112:	48 89 7c 24 18       	mov    %rdi,0x18(%rsp)
  8004213117:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
  800421311b:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004213120:	48 c7 44 24 08 ff ff 	movq   $0xffffffffffffffff,0x8(%rsp)
  8004213127:	ff ff 
  8004213129:	48 c7 04 24 00 00 00 	movq   $0x0,(%rsp)
  8004213130:	00 
  8004213131:	48 89 c7             	mov    %rax,%rdi
  8004213134:	48 b8 82 21 21 04 80 	movabs $0x8004212182,%rax
  800421313b:	00 00 00 
  800421313e:	ff d0                	callq  *%rax
  8004213140:	89 45 e4             	mov    %eax,-0x1c(%rbp)
				    cie->cie_instlen, cie->cie_caf, cie->cie_daf, 0, ~0ULL,
				    &row_pc, error);
        if (ret != DW_DLE_NONE)
  8004213143:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004213147:	74 08                	je     8004213151 <_dwarf_frame_get_internal_table+0x1f3>
                return (ret);
  8004213149:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421314c:	e9 98 00 00 00       	jmpq   80042131e9 <_dwarf_frame_get_internal_table+0x28b>
        /* Run instructions in FDE. */
        if (pc_req >= fde->fde_initloc) {
  8004213151:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213155:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213159:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
  800421315d:	77 6f                	ja     80042131ce <_dwarf_frame_get_internal_table+0x270>
                ret = _dwarf_frame_run_inst(dbg, rt, fde->fde_inst,
  800421315f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213163:	48 8b 78 30          	mov    0x30(%rax),%rdi
  8004213167:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421316b:	4c 8b 48 40          	mov    0x40(%rax),%r9
  800421316f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213173:	4c 8b 50 38          	mov    0x38(%rax),%r10
  8004213177:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421317b:	48 8b 48 58          	mov    0x58(%rax),%rcx
  800421317f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213183:	48 8b 50 50          	mov    0x50(%rax),%rdx
  8004213187:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
  800421318b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421318f:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
  8004213193:	4c 89 44 24 18       	mov    %r8,0x18(%rsp)
  8004213198:	4c 8d 45 d8          	lea    -0x28(%rbp),%r8
  800421319c:	4c 89 44 24 10       	mov    %r8,0x10(%rsp)
  80042131a1:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
  80042131a5:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  80042131aa:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042131ae:	4d 89 d0             	mov    %r10,%r8
  80042131b1:	48 89 c7             	mov    %rax,%rdi
  80042131b4:	48 b8 82 21 21 04 80 	movabs $0x8004212182,%rax
  80042131bb:	00 00 00 
  80042131be:	ff d0                	callq  *%rax
  80042131c0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
					    fde->fde_instlen, cie->cie_caf, cie->cie_daf,
					    fde->fde_initloc, pc_req, &row_pc, error);
                if (ret != DW_DLE_NONE)
  80042131c3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  80042131c7:	74 05                	je     80042131ce <_dwarf_frame_get_internal_table+0x270>
                        return (ret);
  80042131c9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042131cc:	eb 1b                	jmp    80042131e9 <_dwarf_frame_get_internal_table+0x28b>
        }

        *ret_rt = rt;
  80042131ce:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042131d2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042131d6:	48 89 10             	mov    %rdx,(%rax)
        *ret_row_pc = row_pc;
  80042131d9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042131dd:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  80042131e1:	48 89 10             	mov    %rdx,(%rax)

        return (DW_DLE_NONE);
  80042131e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042131e9:	c9                   	leaveq 
  80042131ea:	c3                   	retq   

00000080042131eb <dwarf_get_fde_info_for_all_regs>:

int
dwarf_get_fde_info_for_all_regs(Dwarf_Debug dbg, Dwarf_Fde fde,
				Dwarf_Addr pc_requested, Dwarf_Regtable *reg_table, Dwarf_Addr *row_pc,
				Dwarf_Error *error)
{
  80042131eb:	55                   	push   %rbp
  80042131ec:	48 89 e5             	mov    %rsp,%rbp
  80042131ef:	48 83 ec 50          	sub    $0x50,%rsp
  80042131f3:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042131f7:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042131fb:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042131ff:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  8004213203:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
  8004213207:	4c 89 4d b0          	mov    %r9,-0x50(%rbp)
        Dwarf_Regtable3 *rt;
        Dwarf_Addr pc;
        Dwarf_Half cfa;
        int i, ret;

        if (fde == NULL || reg_table == NULL) {
  800421320b:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
  8004213210:	74 07                	je     8004213219 <dwarf_get_fde_info_for_all_regs+0x2e>
  8004213212:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
  8004213217:	75 0a                	jne    8004213223 <dwarf_get_fde_info_for_all_regs+0x38>
                DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
                return (DW_DLV_ERROR);
  8004213219:	b8 01 00 00 00       	mov    $0x1,%eax
  800421321e:	e9 eb 02 00 00       	jmpq   800421350e <dwarf_get_fde_info_for_all_regs+0x323>
        }

        assert(dbg != NULL);
  8004213223:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004213228:	75 35                	jne    800421325f <dwarf_get_fde_info_for_all_regs+0x74>
  800421322a:	48 b9 a7 a2 21 04 80 	movabs $0x800421a2a7,%rcx
  8004213231:	00 00 00 
  8004213234:	48 ba a7 a1 21 04 80 	movabs $0x800421a1a7,%rdx
  800421323b:	00 00 00 
  800421323e:	be ba 01 00 00       	mov    $0x1ba,%esi
  8004213243:	48 bf bc a1 21 04 80 	movabs $0x800421a1bc,%rdi
  800421324a:	00 00 00 
  800421324d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213252:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004213259:	00 00 00 
  800421325c:	41 ff d0             	callq  *%r8

        if (pc_requested < fde->fde_initloc ||
  800421325f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213263:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004213267:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  800421326b:	77 19                	ja     8004213286 <dwarf_get_fde_info_for_all_regs+0x9b>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
  800421326d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213271:	48 8b 50 30          	mov    0x30(%rax),%rdx
  8004213275:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004213279:	48 8b 40 38          	mov    0x38(%rax),%rax
  800421327d:	48 01 d0             	add    %rdx,%rax
                return (DW_DLV_ERROR);
        }

        assert(dbg != NULL);

        if (pc_requested < fde->fde_initloc ||
  8004213280:	48 3b 45 c8          	cmp    -0x38(%rbp),%rax
  8004213284:	77 0a                	ja     8004213290 <dwarf_get_fde_info_for_all_regs+0xa5>
            pc_requested >= fde->fde_initloc + fde->fde_adrange) {
                DWARF_SET_ERROR(dbg, error, DW_DLE_PC_NOT_IN_FDE_RANGE);
                return (DW_DLV_ERROR);
  8004213286:	b8 01 00 00 00       	mov    $0x1,%eax
  800421328b:	e9 7e 02 00 00       	jmpq   800421350e <dwarf_get_fde_info_for_all_regs+0x323>
        }

        ret = _dwarf_frame_get_internal_table(dbg, fde, pc_requested, &rt, &pc,
  8004213290:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
  8004213294:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
  8004213298:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
  800421329c:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042132a0:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042132a4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042132a8:	4d 89 c1             	mov    %r8,%r9
  80042132ab:	49 89 f8             	mov    %rdi,%r8
  80042132ae:	48 89 c7             	mov    %rax,%rdi
  80042132b1:	48 b8 5e 2f 21 04 80 	movabs $0x8004212f5e,%rax
  80042132b8:	00 00 00 
  80042132bb:	ff d0                	callq  *%rax
  80042132bd:	89 45 f8             	mov    %eax,-0x8(%rbp)
                                              error);
        if (ret != DW_DLE_NONE)
  80042132c0:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042132c4:	74 0a                	je     80042132d0 <dwarf_get_fde_info_for_all_regs+0xe5>
                return (DW_DLV_ERROR);
  80042132c6:	b8 01 00 00 00       	mov    $0x1,%eax
  80042132cb:	e9 3e 02 00 00       	jmpq   800421350e <dwarf_get_fde_info_for_all_regs+0x323>
        /*
         * Copy the CFA rule to the column intended for holding the CFA,
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
  80042132d0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042132d4:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  80042132d8:	66 89 45 f6          	mov    %ax,-0xa(%rbp)
        if (cfa < DW_REG_TABLE_SIZE) {
  80042132dc:	66 83 7d f6 41       	cmpw   $0x41,-0xa(%rbp)
  80042132e1:	0f 87 b1 00 00 00    	ja     8004213398 <dwarf_get_fde_info_for_all_regs+0x1ad>
                reg_table->rules[cfa].dw_offset_relevant =
  80042132e7:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
			CFA.dw_offset_relevant;
  80042132eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042132ef:	0f b6 00             	movzbl (%rax),%eax
         * if it's within the range of regtable.
         */
#define CFA rt->rt3_cfa_rule
        cfa = dbg->dbg_frame_cfa_value;
        if (cfa < DW_REG_TABLE_SIZE) {
                reg_table->rules[cfa].dw_offset_relevant =
  80042132f2:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042132f6:	48 63 c9             	movslq %ecx,%rcx
  80042132f9:	48 83 c1 01          	add    $0x1,%rcx
  80042132fd:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213301:	48 01 ca             	add    %rcx,%rdx
  8004213304:	88 02                	mov    %al,(%rdx)
			CFA.dw_offset_relevant;
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
  8004213306:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421330a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421330e:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  8004213312:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213316:	48 63 c9             	movslq %ecx,%rcx
  8004213319:	48 83 c1 01          	add    $0x1,%rcx
  800421331d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213321:	48 01 ca             	add    %rcx,%rdx
  8004213324:	88 42 01             	mov    %al,0x1(%rdx)
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
  8004213327:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421332b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421332f:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213333:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213337:	48 63 c9             	movslq %ecx,%rcx
  800421333a:	48 83 c1 01          	add    $0x1,%rcx
  800421333e:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213342:	48 01 ca             	add    %rcx,%rdx
  8004213345:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
  8004213349:	0f b7 4d f6          	movzwl -0xa(%rbp),%ecx
  800421334d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213351:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004213355:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213359:	48 63 c9             	movslq %ecx,%rcx
  800421335c:	48 83 c1 01          	add    $0x1,%rcx
  8004213360:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213364:	48 01 ca             	add    %rcx,%rdx
  8004213367:	48 83 c2 08          	add    $0x8,%rdx
  800421336b:	48 89 02             	mov    %rax,(%rdx)
                reg_table->cfa_rule = reg_table->rules[cfa];
  800421336e:	0f b7 55 f6          	movzwl -0xa(%rbp),%edx
  8004213372:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004213376:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421337a:	48 63 d2             	movslq %edx,%rdx
  800421337d:	48 83 c2 01          	add    $0x1,%rdx
  8004213381:	48 c1 e2 04          	shl    $0x4,%rdx
  8004213385:	48 01 d0             	add    %rdx,%rax
  8004213388:	48 8b 50 08          	mov    0x8(%rax),%rdx
  800421338c:	48 8b 00             	mov    (%rax),%rax
  800421338f:	48 89 01             	mov    %rax,(%rcx)
  8004213392:	48 89 51 08          	mov    %rdx,0x8(%rcx)
  8004213396:	eb 3c                	jmp    80042133d4 <dwarf_get_fde_info_for_all_regs+0x1e9>
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
                    CFA.dw_offset_relevant;
  8004213398:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421339c:	0f b6 10             	movzbl (%rax),%edx
                reg_table->rules[cfa].dw_value_type = CFA.dw_value_type;
                reg_table->rules[cfa].dw_regnum = CFA.dw_regnum;
                reg_table->rules[cfa].dw_offset = CFA.dw_offset_or_block_len;
                reg_table->cfa_rule = reg_table->rules[cfa];
        } else {
                reg_table->cfa_rule.dw_offset_relevant =
  800421339f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042133a3:	88 10                	mov    %dl,(%rax)
                    CFA.dw_offset_relevant;
                reg_table->cfa_rule.dw_value_type = CFA.dw_value_type;
  80042133a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133a9:	0f b6 50 01          	movzbl 0x1(%rax),%edx
  80042133ad:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042133b1:	88 50 01             	mov    %dl,0x1(%rax)
                reg_table->cfa_rule.dw_regnum = CFA.dw_regnum;
  80042133b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133b8:	0f b7 50 02          	movzwl 0x2(%rax),%edx
  80042133bc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042133c0:	66 89 50 02          	mov    %dx,0x2(%rax)
                reg_table->cfa_rule.dw_offset = CFA.dw_offset_or_block_len;
  80042133c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133c8:	48 8b 50 08          	mov    0x8(%rax),%rdx
  80042133cc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042133d0:	48 89 50 08          	mov    %rdx,0x8(%rax)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042133d4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  80042133db:	e9 fd 00 00 00       	jmpq   80042134dd <dwarf_get_fde_info_for_all_regs+0x2f2>
             i++) {

                /* Do not overwrite CFA column */
                if (i == cfa)
  80042133e0:	0f b7 45 f6          	movzwl -0xa(%rbp),%eax
  80042133e4:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042133e7:	75 05                	jne    80042133ee <dwarf_get_fde_info_for_all_regs+0x203>
                        continue;
  80042133e9:	e9 eb 00 00 00       	jmpq   80042134d9 <dwarf_get_fde_info_for_all_regs+0x2ee>

                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
  80042133ee:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042133f2:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042133f6:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042133f9:	48 63 d0             	movslq %eax,%rdx
  80042133fc:	48 89 d0             	mov    %rdx,%rax
  80042133ff:	48 01 c0             	add    %rax,%rax
  8004213402:	48 01 d0             	add    %rdx,%rax
  8004213405:	48 c1 e0 03          	shl    $0x3,%rax
  8004213409:	48 01 c8             	add    %rcx,%rax
  800421340c:	0f b6 00             	movzbl (%rax),%eax

                /* Do not overwrite CFA column */
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
  800421340f:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213413:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213416:	48 63 c9             	movslq %ecx,%rcx
  8004213419:	48 83 c1 01          	add    $0x1,%rcx
  800421341d:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213421:	48 01 ca             	add    %rcx,%rdx
  8004213424:	88 02                	mov    %al,(%rdx)
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
  8004213426:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421342a:	48 8b 48 20          	mov    0x20(%rax),%rcx
  800421342e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004213431:	48 63 d0             	movslq %eax,%rdx
  8004213434:	48 89 d0             	mov    %rdx,%rax
  8004213437:	48 01 c0             	add    %rax,%rax
  800421343a:	48 01 d0             	add    %rdx,%rax
  800421343d:	48 c1 e0 03          	shl    $0x3,%rax
  8004213441:	48 01 c8             	add    %rcx,%rax
  8004213444:	0f b6 40 01          	movzbl 0x1(%rax),%eax
                if (i == cfa)
                        continue;

                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
  8004213448:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  800421344c:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  800421344f:	48 63 c9             	movslq %ecx,%rcx
  8004213452:	48 83 c1 01          	add    $0x1,%rcx
  8004213456:	48 c1 e1 04          	shl    $0x4,%rcx
  800421345a:	48 01 ca             	add    %rcx,%rdx
  800421345d:	88 42 01             	mov    %al,0x1(%rdx)
			rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
  8004213460:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213464:	48 8b 48 20          	mov    0x20(%rax),%rcx
  8004213468:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421346b:	48 63 d0             	movslq %eax,%rdx
  800421346e:	48 89 d0             	mov    %rdx,%rax
  8004213471:	48 01 c0             	add    %rax,%rax
  8004213474:	48 01 d0             	add    %rdx,%rax
  8004213477:	48 c1 e0 03          	shl    $0x3,%rax
  800421347b:	48 01 c8             	add    %rcx,%rax
  800421347e:	0f b7 40 02          	movzwl 0x2(%rax),%eax
  8004213482:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004213486:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  8004213489:	48 63 c9             	movslq %ecx,%rcx
  800421348c:	48 83 c1 01          	add    $0x1,%rcx
  8004213490:	48 c1 e1 04          	shl    $0x4,%rcx
  8004213494:	48 01 ca             	add    %rcx,%rdx
  8004213497:	66 89 42 02          	mov    %ax,0x2(%rdx)
                reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
  800421349b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421349f:	48 8b 48 20          	mov    0x20(%rax),%rcx
  80042134a3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042134a6:	48 63 d0             	movslq %eax,%rdx
  80042134a9:	48 89 d0             	mov    %rdx,%rax
  80042134ac:	48 01 c0             	add    %rax,%rax
  80042134af:	48 01 d0             	add    %rdx,%rax
  80042134b2:	48 c1 e0 03          	shl    $0x3,%rax
  80042134b6:	48 01 c8             	add    %rcx,%rax
  80042134b9:	48 8b 40 08          	mov    0x8(%rax),%rax
                reg_table->rules[i].dw_offset_relevant =
			rt->rt3_rules[i].dw_offset_relevant;
                reg_table->rules[i].dw_value_type =
			rt->rt3_rules[i].dw_value_type;
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
  80042134bd:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  80042134c1:	8b 4d fc             	mov    -0x4(%rbp),%ecx
  80042134c4:	48 63 c9             	movslq %ecx,%rcx
  80042134c7:	48 83 c1 01          	add    $0x1,%rcx
  80042134cb:	48 c1 e1 04          	shl    $0x4,%rcx
  80042134cf:	48 01 ca             	add    %rcx,%rdx
  80042134d2:	48 83 c2 08          	add    $0x8,%rdx
  80042134d6:	48 89 02             	mov    %rax,(%rdx)

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
             i++) {
  80042134d9:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
        }

        /*
         * Copy other columns.
         */
        for (i = 0; i < DW_REG_TABLE_SIZE && i < dbg->dbg_frame_rule_table_size;
  80042134dd:	83 7d fc 41          	cmpl   $0x41,-0x4(%rbp)
  80042134e1:	7f 14                	jg     80042134f7 <dwarf_get_fde_info_for_all_regs+0x30c>
  80042134e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042134e7:	0f b7 40 48          	movzwl 0x48(%rax),%eax
  80042134eb:	0f b7 c0             	movzwl %ax,%eax
  80042134ee:	3b 45 fc             	cmp    -0x4(%rbp),%eax
  80042134f1:	0f 8f e9 fe ff ff    	jg     80042133e0 <dwarf_get_fde_info_for_all_regs+0x1f5>
                reg_table->rules[i].dw_regnum = rt->rt3_rules[i].dw_regnum;
                reg_table->rules[i].dw_offset =
			rt->rt3_rules[i].dw_offset_or_block_len;
        }

        if (row_pc) *row_pc = pc;
  80042134f7:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
  80042134fc:	74 0b                	je     8004213509 <dwarf_get_fde_info_for_all_regs+0x31e>
  80042134fe:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213502:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213506:	48 89 10             	mov    %rdx,(%rax)
        return (DW_DLV_OK);
  8004213509:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421350e:	c9                   	leaveq 
  800421350f:	c3                   	retq   

0000008004213510 <_dwarf_frame_read_lsb_encoded>:

static int
_dwarf_frame_read_lsb_encoded(Dwarf_Debug dbg, uint64_t *val, uint8_t *data,
			      uint64_t *offsetp, uint8_t encode, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004213510:	55                   	push   %rbp
  8004213511:	48 89 e5             	mov    %rsp,%rbp
  8004213514:	48 83 ec 40          	sub    $0x40,%rsp
  8004213518:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421351c:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004213520:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004213524:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  8004213528:	44 89 c0             	mov    %r8d,%eax
  800421352b:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
  800421352f:	88 45 cc             	mov    %al,-0x34(%rbp)
	uint8_t application;

	if (encode == DW_EH_PE_omit)
  8004213532:	80 7d cc ff          	cmpb   $0xff,-0x34(%rbp)
  8004213536:	75 0a                	jne    8004213542 <_dwarf_frame_read_lsb_encoded+0x32>
		return (DW_DLE_NONE);
  8004213538:	b8 00 00 00 00       	mov    $0x0,%eax
  800421353d:	e9 e6 01 00 00       	jmpq   8004213728 <_dwarf_frame_read_lsb_encoded+0x218>

	application = encode & 0xf0;
  8004213542:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213546:	83 e0 f0             	and    $0xfffffff0,%eax
  8004213549:	88 45 ff             	mov    %al,-0x1(%rbp)
	encode &= 0x0f;
  800421354c:	80 65 cc 0f          	andb   $0xf,-0x34(%rbp)

	switch (encode) {
  8004213550:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004213554:	83 f8 0c             	cmp    $0xc,%eax
  8004213557:	0f 87 72 01 00 00    	ja     80042136cf <_dwarf_frame_read_lsb_encoded+0x1bf>
  800421355d:	89 c0                	mov    %eax,%eax
  800421355f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004213566:	00 
  8004213567:	48 b8 c0 a2 21 04 80 	movabs $0x800421a2c0,%rax
  800421356e:	00 00 00 
  8004213571:	48 01 d0             	add    %rdx,%rax
  8004213574:	48 8b 00             	mov    (%rax),%rax
  8004213577:	ff e0                	jmpq   *%rax
	case DW_EH_PE_absptr:
		*val = dbg->read(data, offsetp, dbg->dbg_pointer_size);
  8004213579:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421357d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213581:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213585:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213588:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421358c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213590:	48 89 cf             	mov    %rcx,%rdi
  8004213593:	ff d0                	callq  *%rax
  8004213595:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213599:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421359c:	e9 35 01 00 00       	jmpq   80042136d6 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_uleb128:
		*val = _dwarf_read_uleb128(data, offsetp);
  80042135a1:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042135a5:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042135a9:	48 89 d6             	mov    %rdx,%rsi
  80042135ac:	48 89 c7             	mov    %rax,%rdi
  80042135af:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  80042135b6:	00 00 00 
  80042135b9:	ff d0                	callq  *%rax
  80042135bb:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042135bf:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042135c2:	e9 0f 01 00 00       	jmpq   80042136d6 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata2:
		*val = dbg->read(data, offsetp, 2);
  80042135c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042135cb:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042135cf:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042135d3:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042135d7:	ba 02 00 00 00       	mov    $0x2,%edx
  80042135dc:	48 89 cf             	mov    %rcx,%rdi
  80042135df:	ff d0                	callq  *%rax
  80042135e1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042135e5:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042135e8:	e9 e9 00 00 00       	jmpq   80042136d6 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata4:
		*val = dbg->read(data, offsetp, 4);
  80042135ed:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042135f1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042135f5:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042135f9:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042135fd:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213602:	48 89 cf             	mov    %rcx,%rdi
  8004213605:	ff d0                	callq  *%rax
  8004213607:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  800421360b:	48 89 02             	mov    %rax,(%rdx)
		break;
  800421360e:	e9 c3 00 00 00       	jmpq   80042136d6 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_udata8:
		*val = dbg->read(data, offsetp, 8);
  8004213613:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213617:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421361b:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421361f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213623:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213628:	48 89 cf             	mov    %rcx,%rdi
  800421362b:	ff d0                	callq  *%rax
  800421362d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213631:	48 89 02             	mov    %rax,(%rdx)
		break;
  8004213634:	e9 9d 00 00 00       	jmpq   80042136d6 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sleb128:
		*val = _dwarf_read_sleb128(data, offsetp);
  8004213639:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  800421363d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213641:	48 89 d6             	mov    %rdx,%rsi
  8004213644:	48 89 c7             	mov    %rax,%rdi
  8004213647:	48 b8 eb 04 21 04 80 	movabs $0x80042104eb,%rax
  800421364e:	00 00 00 
  8004213651:	ff d0                	callq  *%rax
  8004213653:	48 89 c2             	mov    %rax,%rdx
  8004213656:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421365a:	48 89 10             	mov    %rdx,(%rax)
		break;
  800421365d:	eb 77                	jmp    80042136d6 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata2:
		*val = (int16_t) dbg->read(data, offsetp, 2);
  800421365f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213663:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213667:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  800421366b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  800421366f:	ba 02 00 00 00       	mov    $0x2,%edx
  8004213674:	48 89 cf             	mov    %rcx,%rdi
  8004213677:	ff d0                	callq  *%rax
  8004213679:	48 0f bf d0          	movswq %ax,%rdx
  800421367d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213681:	48 89 10             	mov    %rdx,(%rax)
		break;
  8004213684:	eb 50                	jmp    80042136d6 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata4:
		*val = (int32_t) dbg->read(data, offsetp, 4);
  8004213686:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421368a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421368e:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  8004213692:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  8004213696:	ba 04 00 00 00       	mov    $0x4,%edx
  800421369b:	48 89 cf             	mov    %rcx,%rdi
  800421369e:	ff d0                	callq  *%rax
  80042136a0:	48 63 d0             	movslq %eax,%rdx
  80042136a3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136a7:	48 89 10             	mov    %rdx,(%rax)
		break;
  80042136aa:	eb 2a                	jmp    80042136d6 <_dwarf_frame_read_lsb_encoded+0x1c6>
	case DW_EH_PE_sdata8:
		*val = dbg->read(data, offsetp, 8);
  80042136ac:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042136b0:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042136b4:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
  80042136b8:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
  80042136bc:	ba 08 00 00 00       	mov    $0x8,%edx
  80042136c1:	48 89 cf             	mov    %rcx,%rdi
  80042136c4:	ff d0                	callq  *%rax
  80042136c6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042136ca:	48 89 02             	mov    %rax,(%rdx)
		break;
  80042136cd:	eb 07                	jmp    80042136d6 <_dwarf_frame_read_lsb_encoded+0x1c6>
	default:
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  80042136cf:	b8 14 00 00 00       	mov    $0x14,%eax
  80042136d4:	eb 52                	jmp    8004213728 <_dwarf_frame_read_lsb_encoded+0x218>
	}

	if (application == DW_EH_PE_pcrel) {
  80042136d6:	80 7d ff 10          	cmpb   $0x10,-0x1(%rbp)
  80042136da:	75 47                	jne    8004213723 <_dwarf_frame_read_lsb_encoded+0x213>
		/*
		 * Value is relative to .eh_frame section virtual addr.
		 */
		switch (encode) {
  80042136dc:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  80042136e0:	83 f8 01             	cmp    $0x1,%eax
  80042136e3:	7c 3d                	jl     8004213722 <_dwarf_frame_read_lsb_encoded+0x212>
  80042136e5:	83 f8 04             	cmp    $0x4,%eax
  80042136e8:	7e 0a                	jle    80042136f4 <_dwarf_frame_read_lsb_encoded+0x1e4>
  80042136ea:	83 e8 09             	sub    $0x9,%eax
  80042136ed:	83 f8 03             	cmp    $0x3,%eax
  80042136f0:	77 30                	ja     8004213722 <_dwarf_frame_read_lsb_encoded+0x212>
  80042136f2:	eb 17                	jmp    800421370b <_dwarf_frame_read_lsb_encoded+0x1fb>
		case DW_EH_PE_uleb128:
		case DW_EH_PE_udata2:
		case DW_EH_PE_udata4:
		case DW_EH_PE_udata8:
			*val += pc;
  80042136f4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042136f8:	48 8b 10             	mov    (%rax),%rdx
  80042136fb:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042136ff:	48 01 c2             	add    %rax,%rdx
  8004213702:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004213706:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004213709:	eb 18                	jmp    8004213723 <_dwarf_frame_read_lsb_encoded+0x213>
		case DW_EH_PE_sleb128:
		case DW_EH_PE_sdata2:
		case DW_EH_PE_sdata4:
		case DW_EH_PE_sdata8:
			*val = pc + (int64_t) *val;
  800421370b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421370f:	48 8b 10             	mov    (%rax),%rdx
  8004213712:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213716:	48 01 c2             	add    %rax,%rdx
  8004213719:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421371d:	48 89 10             	mov    %rdx,(%rax)
			break;
  8004213720:	eb 01                	jmp    8004213723 <_dwarf_frame_read_lsb_encoded+0x213>
		default:
			/* DW_EH_PE_absptr is absolute value. */
			break;
  8004213722:	90                   	nop
		}
	}

	/* XXX Applications other than DW_EH_PE_pcrel are not handled. */

	return (DW_DLE_NONE);
  8004213723:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213728:	c9                   	leaveq 
  8004213729:	c3                   	retq   

000000800421372a <_dwarf_frame_parse_lsb_cie_augment>:

static int
_dwarf_frame_parse_lsb_cie_augment(Dwarf_Debug dbg, Dwarf_Cie cie,
				   Dwarf_Error *error)
{
  800421372a:	55                   	push   %rbp
  800421372b:	48 89 e5             	mov    %rsp,%rbp
  800421372e:	48 83 ec 50          	sub    $0x50,%rsp
  8004213732:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213736:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  800421373a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
	uint8_t *aug_p, *augdata_p;
	uint64_t val, offset;
	uint8_t encode;
	int ret;

	assert(cie->cie_augment != NULL && *cie->cie_augment == 'z');
  800421373e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213742:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213746:	48 85 c0             	test   %rax,%rax
  8004213749:	74 0f                	je     800421375a <_dwarf_frame_parse_lsb_cie_augment+0x30>
  800421374b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421374f:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213753:	0f b6 00             	movzbl (%rax),%eax
  8004213756:	3c 7a                	cmp    $0x7a,%al
  8004213758:	74 35                	je     800421378f <_dwarf_frame_parse_lsb_cie_augment+0x65>
  800421375a:	48 b9 28 a3 21 04 80 	movabs $0x800421a328,%rcx
  8004213761:	00 00 00 
  8004213764:	48 ba a7 a1 21 04 80 	movabs $0x800421a1a7,%rdx
  800421376b:	00 00 00 
  800421376e:	be 45 02 00 00       	mov    $0x245,%esi
  8004213773:	48 bf bc a1 21 04 80 	movabs $0x800421a1bc,%rdi
  800421377a:	00 00 00 
  800421377d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213782:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004213789:	00 00 00 
  800421378c:	41 ff d0             	callq  *%r8
	/*
	 * Here we're only interested in the presence of augment 'R'
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
  800421378f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213793:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213797:	48 83 c0 01          	add    $0x1,%rax
  800421379b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	augdata_p = cie->cie_augdata;
  800421379f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  80042137a3:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042137a7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	while (*aug_p != '\0') {
  80042137ab:	e9 af 00 00 00       	jmpq   800421385f <_dwarf_frame_parse_lsb_cie_augment+0x135>
		switch (*aug_p) {
  80042137b0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042137b4:	0f b6 00             	movzbl (%rax),%eax
  80042137b7:	0f b6 c0             	movzbl %al,%eax
  80042137ba:	83 f8 50             	cmp    $0x50,%eax
  80042137bd:	74 18                	je     80042137d7 <_dwarf_frame_parse_lsb_cie_augment+0xad>
  80042137bf:	83 f8 52             	cmp    $0x52,%eax
  80042137c2:	74 77                	je     800421383b <_dwarf_frame_parse_lsb_cie_augment+0x111>
  80042137c4:	83 f8 4c             	cmp    $0x4c,%eax
  80042137c7:	0f 85 86 00 00 00    	jne    8004213853 <_dwarf_frame_parse_lsb_cie_augment+0x129>
		case 'L':
			/* Skip one augment in augment data. */
			augdata_p++;
  80042137cd:	48 83 45 f0 01       	addq   $0x1,-0x10(%rbp)
			break;
  80042137d2:	e9 83 00 00 00       	jmpq   800421385a <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'P':
			/* Skip two augments in augment data. */
			encode = *augdata_p++;
  80042137d7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042137db:	48 8d 50 01          	lea    0x1(%rax),%rdx
  80042137df:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  80042137e3:	0f b6 00             	movzbl (%rax),%eax
  80042137e6:	88 45 ef             	mov    %al,-0x11(%rbp)
			offset = 0;
  80042137e9:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
  80042137f0:	00 
			ret = _dwarf_frame_read_lsb_encoded(dbg, &val,
  80042137f1:	44 0f b6 45 ef       	movzbl -0x11(%rbp),%r8d
  80042137f6:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
  80042137fa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042137fe:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
  8004213802:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213806:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421380a:	48 89 3c 24          	mov    %rdi,(%rsp)
  800421380e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004213814:	48 89 c7             	mov    %rax,%rdi
  8004213817:	48 b8 10 35 21 04 80 	movabs $0x8004213510,%rax
  800421381e:	00 00 00 
  8004213821:	ff d0                	callq  *%rax
  8004213823:	89 45 e8             	mov    %eax,-0x18(%rbp)
							    augdata_p, &offset, encode, 0, error);
			if (ret != DW_DLE_NONE)
  8004213826:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  800421382a:	74 05                	je     8004213831 <_dwarf_frame_parse_lsb_cie_augment+0x107>
				return (ret);
  800421382c:	8b 45 e8             	mov    -0x18(%rbp),%eax
  800421382f:	eb 42                	jmp    8004213873 <_dwarf_frame_parse_lsb_cie_augment+0x149>
			augdata_p += offset;
  8004213831:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004213835:	48 01 45 f0          	add    %rax,-0x10(%rbp)
			break;
  8004213839:	eb 1f                	jmp    800421385a <_dwarf_frame_parse_lsb_cie_augment+0x130>
		case 'R':
			cie->cie_fde_encode = *augdata_p++;
  800421383b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421383f:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004213843:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
  8004213847:	0f b6 10             	movzbl (%rax),%edx
  800421384a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  800421384e:	88 50 60             	mov    %dl,0x60(%rax)
			break;
  8004213851:	eb 07                	jmp    800421385a <_dwarf_frame_parse_lsb_cie_augment+0x130>
		default:
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
  8004213853:	b8 14 00 00 00       	mov    $0x14,%eax
  8004213858:	eb 19                	jmp    8004213873 <_dwarf_frame_parse_lsb_cie_augment+0x149>
		}
		aug_p++;
  800421385a:	48 83 45 f8 01       	addq   $0x1,-0x8(%rbp)
	 * and associated CIE augment data, which describes the
	 * encoding scheme of FDE PC begin and range.
	 */
	aug_p = &cie->cie_augment[1];
	augdata_p = cie->cie_augdata;
	while (*aug_p != '\0') {
  800421385f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213863:	0f b6 00             	movzbl (%rax),%eax
  8004213866:	84 c0                	test   %al,%al
  8004213868:	0f 85 42 ff ff ff    	jne    80042137b0 <_dwarf_frame_parse_lsb_cie_augment+0x86>
			return (DW_DLE_FRAME_AUGMENTATION_UNKNOWN);
		}
		aug_p++;
	}

	return (DW_DLE_NONE);
  800421386e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213873:	c9                   	leaveq 
  8004213874:	c3                   	retq   

0000008004213875 <_dwarf_frame_set_cie>:


static int
_dwarf_frame_set_cie(Dwarf_Debug dbg, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, Dwarf_Cie ret_cie, Dwarf_Error *error)
{
  8004213875:	55                   	push   %rbp
  8004213876:	48 89 e5             	mov    %rsp,%rbp
  8004213879:	48 83 ec 60          	sub    $0x60,%rsp
  800421387d:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213881:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213885:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213889:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  800421388d:	4c 89 45 a8          	mov    %r8,-0x58(%rbp)
	Dwarf_Cie cie;
	uint64_t length;
	int dwarf_size, ret;
	char *p;

	assert(ret_cie);
  8004213891:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
  8004213896:	75 35                	jne    80042138cd <_dwarf_frame_set_cie+0x58>
  8004213898:	48 b9 5d a3 21 04 80 	movabs $0x800421a35d,%rcx
  800421389f:	00 00 00 
  80042138a2:	48 ba a7 a1 21 04 80 	movabs $0x800421a1a7,%rdx
  80042138a9:	00 00 00 
  80042138ac:	be 76 02 00 00       	mov    $0x276,%esi
  80042138b1:	48 bf bc a1 21 04 80 	movabs $0x800421a1bc,%rdi
  80042138b8:	00 00 00 
  80042138bb:	b8 00 00 00 00       	mov    $0x0,%eax
  80042138c0:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042138c7:	00 00 00 
  80042138ca:	41 ff d0             	callq  *%r8
	cie = ret_cie;
  80042138cd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042138d1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	cie->cie_dbg = dbg;
  80042138d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042138d9:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042138dd:	48 89 10             	mov    %rdx,(%rax)
	cie->cie_offset = *off;
  80042138e0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042138e4:	48 8b 10             	mov    (%rax),%rdx
  80042138e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042138eb:	48 89 50 10          	mov    %rdx,0x10(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  80042138ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042138f3:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042138f7:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042138fb:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042138ff:	48 89 d1             	mov    %rdx,%rcx
  8004213902:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213906:	ba 04 00 00 00       	mov    $0x4,%edx
  800421390b:	48 89 cf             	mov    %rcx,%rdi
  800421390e:	ff d0                	callq  *%rax
  8004213910:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004213914:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213919:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  800421391d:	75 2e                	jne    800421394d <_dwarf_frame_set_cie+0xd8>
		dwarf_size = 8;
  800421391f:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004213926:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421392a:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421392e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213932:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213936:	48 89 d1             	mov    %rdx,%rcx
  8004213939:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  800421393d:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213942:	48 89 cf             	mov    %rcx,%rdi
  8004213945:	ff d0                	callq  *%rax
  8004213947:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421394b:	eb 07                	jmp    8004213954 <_dwarf_frame_set_cie+0xdf>
	} else
		dwarf_size = 4;
  800421394d:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004213954:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213958:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421395c:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213960:	48 8b 00             	mov    (%rax),%rax
  8004213963:	48 29 c2             	sub    %rax,%rdx
  8004213966:	48 89 d0             	mov    %rdx,%rax
  8004213969:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  800421396d:	73 0a                	jae    8004213979 <_dwarf_frame_set_cie+0x104>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  800421396f:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213974:	e9 5d 03 00 00       	jmpq   8004213cd6 <_dwarf_frame_set_cie+0x461>
	}

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
  8004213979:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421397d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213981:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213985:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213989:	48 89 d1             	mov    %rdx,%rcx
  800421398c:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421398f:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213993:	48 89 cf             	mov    %rcx,%rdi
  8004213996:	ff d0                	callq  *%rax
	cie->cie_length = length;
  8004213998:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421399c:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042139a0:	48 89 50 18          	mov    %rdx,0x18(%rax)

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  80042139a4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042139a8:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042139ac:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042139b0:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042139b4:	48 89 d1             	mov    %rdx,%rcx
  80042139b7:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  80042139bb:	ba 01 00 00 00       	mov    $0x1,%edx
  80042139c0:	48 89 cf             	mov    %rcx,%rdi
  80042139c3:	ff d0                	callq  *%rax
  80042139c5:	89 c2                	mov    %eax,%edx
  80042139c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042139cb:	66 89 50 20          	mov    %dx,0x20(%rax)
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  80042139cf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042139d3:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  80042139d7:	66 83 f8 01          	cmp    $0x1,%ax
  80042139db:	74 26                	je     8004213a03 <_dwarf_frame_set_cie+0x18e>
  80042139dd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042139e1:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  80042139e5:	66 83 f8 03          	cmp    $0x3,%ax
  80042139e9:	74 18                	je     8004213a03 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
  80042139eb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042139ef:	0f b7 40 20          	movzwl 0x20(%rax),%eax

	(void) dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size); /* Skip CIE id. */
	cie->cie_length = length;

	cie->cie_version = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
	if (cie->cie_version != 1 && cie->cie_version != 3 &&
  80042139f3:	66 83 f8 04          	cmp    $0x4,%ax
  80042139f7:	74 0a                	je     8004213a03 <_dwarf_frame_set_cie+0x18e>
	    cie->cie_version != 4) {
		DWARF_SET_ERROR(dbg, error, DW_DLE_FRAME_VERSION_BAD);
		return (DW_DLE_FRAME_VERSION_BAD);
  80042139f9:	b8 16 00 00 00       	mov    $0x16,%eax
  80042139fe:	e9 d3 02 00 00       	jmpq   8004213cd6 <_dwarf_frame_set_cie+0x461>
	}

	cie->cie_augment = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213a03:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a07:	48 8b 10             	mov    (%rax),%rdx
  8004213a0a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a0e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213a12:	48 01 d0             	add    %rdx,%rax
  8004213a15:	48 89 c2             	mov    %rax,%rdx
  8004213a18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a1c:	48 89 50 28          	mov    %rdx,0x28(%rax)
	p = (char *)dbg->dbg_eh_offset;
  8004213a20:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213a24:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213a28:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	while (p[(*off)++] != '\0')
  8004213a2c:	90                   	nop
  8004213a2d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a31:	48 8b 00             	mov    (%rax),%rax
  8004213a34:	48 8d 48 01          	lea    0x1(%rax),%rcx
  8004213a38:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213a3c:	48 89 0a             	mov    %rcx,(%rdx)
  8004213a3f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004213a43:	48 01 d0             	add    %rdx,%rax
  8004213a46:	0f b6 00             	movzbl (%rax),%eax
  8004213a49:	84 c0                	test   %al,%al
  8004213a4b:	75 e0                	jne    8004213a2d <_dwarf_frame_set_cie+0x1b8>
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
  8004213a4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a51:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213a55:	0f b6 00             	movzbl (%rax),%eax
  8004213a58:	84 c0                	test   %al,%al
  8004213a5a:	74 48                	je     8004213aa4 <_dwarf_frame_set_cie+0x22f>
  8004213a5c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a60:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213a64:	0f b6 00             	movzbl (%rax),%eax
  8004213a67:	3c 7a                	cmp    $0x7a,%al
  8004213a69:	74 39                	je     8004213aa4 <_dwarf_frame_set_cie+0x22f>
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004213a6b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a6f:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213a73:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213a77:	75 07                	jne    8004213a80 <_dwarf_frame_set_cie+0x20b>
  8004213a79:	b8 04 00 00 00       	mov    $0x4,%eax
  8004213a7e:	eb 05                	jmp    8004213a85 <_dwarf_frame_set_cie+0x210>
  8004213a80:	b8 0c 00 00 00       	mov    $0xc,%eax
  8004213a85:	48 01 c2             	add    %rax,%rdx
			cie->cie_length;
  8004213a88:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213a8c:	48 8b 40 18          	mov    0x18(%rax),%rax
	while (p[(*off)++] != '\0')
		;

	/* We only recognize normal .dwarf_frame and GNU .eh_frame sections. */
	if (*cie->cie_augment != 0 && *cie->cie_augment != 'z') {
		*off = cie->cie_offset + ((dwarf_size == 4) ? 4 : 12) +
  8004213a90:	48 01 c2             	add    %rax,%rdx
  8004213a93:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213a97:	48 89 10             	mov    %rdx,(%rax)
			cie->cie_length;
		return (DW_DLE_NONE);
  8004213a9a:	b8 00 00 00 00       	mov    $0x0,%eax
  8004213a9f:	e9 32 02 00 00       	jmpq   8004213cd6 <_dwarf_frame_set_cie+0x461>
	}

	/* Optional EH Data field for .eh_frame section. */
	if (strstr((char *)cie->cie_augment, "eh") != NULL)
  8004213aa4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213aa8:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213aac:	48 be 65 a3 21 04 80 	movabs $0x800421a365,%rsi
  8004213ab3:	00 00 00 
  8004213ab6:	48 89 c7             	mov    %rax,%rdi
  8004213ab9:	48 b8 a2 fe 20 04 80 	movabs $0x800420fea2,%rax
  8004213ac0:	00 00 00 
  8004213ac3:	ff d0                	callq  *%rax
  8004213ac5:	48 85 c0             	test   %rax,%rax
  8004213ac8:	74 28                	je     8004213af2 <_dwarf_frame_set_cie+0x27d>
		cie->cie_ehdata = dbg->read(ds->ds_data, off,
  8004213aca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ace:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ad2:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213ad6:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213ad9:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004213add:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004213ae1:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213ae5:	48 89 cf             	mov    %rcx,%rdi
  8004213ae8:	ff d0                	callq  *%rax
  8004213aea:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213aee:	48 89 42 30          	mov    %rax,0x30(%rdx)
					    dbg->dbg_pointer_size);

	cie->cie_caf = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213af2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213af6:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213afa:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213afe:	48 89 d6             	mov    %rdx,%rsi
  8004213b01:	48 89 c7             	mov    %rax,%rdi
  8004213b04:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004213b0b:	00 00 00 
  8004213b0e:	ff d0                	callq  *%rax
  8004213b10:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213b14:	48 89 42 38          	mov    %rax,0x38(%rdx)
	cie->cie_daf = _dwarf_read_sleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213b18:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b1c:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213b20:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213b24:	48 89 d6             	mov    %rdx,%rsi
  8004213b27:	48 89 c7             	mov    %rax,%rdi
  8004213b2a:	48 b8 eb 04 21 04 80 	movabs $0x80042104eb,%rax
  8004213b31:	00 00 00 
  8004213b34:	ff d0                	callq  *%rax
  8004213b36:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213b3a:	48 89 42 40          	mov    %rax,0x40(%rdx)

	/* Return address register. */
	if (cie->cie_version == 1)
  8004213b3e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213b42:	0f b7 40 20          	movzwl 0x20(%rax),%eax
  8004213b46:	66 83 f8 01          	cmp    $0x1,%ax
  8004213b4a:	75 2b                	jne    8004213b77 <_dwarf_frame_set_cie+0x302>
		cie->cie_ra = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 1);
  8004213b4c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b50:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213b54:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213b58:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213b5c:	48 89 d1             	mov    %rdx,%rcx
  8004213b5f:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
  8004213b63:	ba 01 00 00 00       	mov    $0x1,%edx
  8004213b68:	48 89 cf             	mov    %rcx,%rdi
  8004213b6b:	ff d0                	callq  *%rax
  8004213b6d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213b71:	48 89 42 48          	mov    %rax,0x48(%rdx)
  8004213b75:	eb 26                	jmp    8004213b9d <_dwarf_frame_set_cie+0x328>
	else
		cie->cie_ra = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213b77:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213b7b:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213b7f:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213b83:	48 89 d6             	mov    %rdx,%rsi
  8004213b86:	48 89 c7             	mov    %rax,%rdi
  8004213b89:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004213b90:	00 00 00 
  8004213b93:	ff d0                	callq  *%rax
  8004213b95:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213b99:	48 89 42 48          	mov    %rax,0x48(%rdx)

	/* Optional CIE augmentation data for .eh_frame section. */
	if (*cie->cie_augment == 'z') {
  8004213b9d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ba1:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213ba5:	0f b6 00             	movzbl (%rax),%eax
  8004213ba8:	3c 7a                	cmp    $0x7a,%al
  8004213baa:	0f 85 93 00 00 00    	jne    8004213c43 <_dwarf_frame_set_cie+0x3ce>
		cie->cie_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213bb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213bb4:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213bb8:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004213bbc:	48 89 d6             	mov    %rdx,%rsi
  8004213bbf:	48 89 c7             	mov    %rax,%rdi
  8004213bc2:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004213bc9:	00 00 00 
  8004213bcc:	ff d0                	callq  *%rax
  8004213bce:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213bd2:	48 89 42 50          	mov    %rax,0x50(%rdx)
		cie->cie_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213bd6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213bda:	48 8b 10             	mov    (%rax),%rdx
  8004213bdd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213be1:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213be5:	48 01 d0             	add    %rdx,%rax
  8004213be8:	48 89 c2             	mov    %rax,%rdx
  8004213beb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bef:	48 89 50 58          	mov    %rdx,0x58(%rax)
		*off += cie->cie_auglen;
  8004213bf3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213bf7:	48 8b 10             	mov    (%rax),%rdx
  8004213bfa:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213bfe:	48 8b 40 50          	mov    0x50(%rax),%rax
  8004213c02:	48 01 c2             	add    %rax,%rdx
  8004213c05:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c09:	48 89 10             	mov    %rdx,(%rax)
		/*
		 * XXX Use DW_EH_PE_absptr for default FDE PC start/range,
		 * in case _dwarf_frame_parse_lsb_cie_augment fails to
		 * find out the real encode.
		 */
		cie->cie_fde_encode = DW_EH_PE_absptr;
  8004213c0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c10:	c6 40 60 00          	movb   $0x0,0x60(%rax)
		ret = _dwarf_frame_parse_lsb_cie_augment(dbg, cie, error);
  8004213c14:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
  8004213c18:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004213c1c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c20:	48 89 ce             	mov    %rcx,%rsi
  8004213c23:	48 89 c7             	mov    %rax,%rdi
  8004213c26:	48 b8 2a 37 21 04 80 	movabs $0x800421372a,%rax
  8004213c2d:	00 00 00 
  8004213c30:	ff d0                	callq  *%rax
  8004213c32:	89 45 dc             	mov    %eax,-0x24(%rbp)
		if (ret != DW_DLE_NONE)
  8004213c35:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213c39:	74 08                	je     8004213c43 <_dwarf_frame_set_cie+0x3ce>
			return (ret);
  8004213c3b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213c3e:	e9 93 00 00 00       	jmpq   8004213cd6 <_dwarf_frame_set_cie+0x461>
	}

	/* CIE Initial instructions. */
	cie->cie_initinst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213c43:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c47:	48 8b 10             	mov    (%rax),%rdx
  8004213c4a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213c4e:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213c52:	48 01 d0             	add    %rdx,%rax
  8004213c55:	48 89 c2             	mov    %rax,%rdx
  8004213c58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c5c:	48 89 50 68          	mov    %rdx,0x68(%rax)
	if (dwarf_size == 4)
  8004213c60:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004213c64:	75 2a                	jne    8004213c90 <_dwarf_frame_set_cie+0x41b>
		cie->cie_instlen = cie->cie_offset + 4 + length - *off;
  8004213c66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c6a:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213c6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213c72:	48 01 c2             	add    %rax,%rdx
  8004213c75:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213c79:	48 8b 00             	mov    (%rax),%rax
  8004213c7c:	48 29 c2             	sub    %rax,%rdx
  8004213c7f:	48 89 d0             	mov    %rdx,%rax
  8004213c82:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004213c86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c8a:	48 89 50 70          	mov    %rdx,0x70(%rax)
  8004213c8e:	eb 28                	jmp    8004213cb8 <_dwarf_frame_set_cie+0x443>
	else
		cie->cie_instlen = cie->cie_offset + 12 + length - *off;
  8004213c90:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213c94:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213c98:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004213c9c:	48 01 c2             	add    %rax,%rdx
  8004213c9f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ca3:	48 8b 00             	mov    (%rax),%rax
  8004213ca6:	48 29 c2             	sub    %rax,%rdx
  8004213ca9:	48 89 d0             	mov    %rdx,%rax
  8004213cac:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  8004213cb0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213cb4:	48 89 50 70          	mov    %rdx,0x70(%rax)

	*off += cie->cie_instlen;
  8004213cb8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213cbc:	48 8b 10             	mov    (%rax),%rdx
  8004213cbf:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213cc3:	48 8b 40 70          	mov    0x70(%rax),%rax
  8004213cc7:	48 01 c2             	add    %rax,%rdx
  8004213cca:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213cce:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004213cd1:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004213cd6:	c9                   	leaveq 
  8004213cd7:	c3                   	retq   

0000008004213cd8 <_dwarf_frame_set_fde>:

static int
_dwarf_frame_set_fde(Dwarf_Debug dbg, Dwarf_Fde ret_fde, Dwarf_Section *ds,
		     Dwarf_Unsigned *off, int eh_frame, Dwarf_Cie cie, Dwarf_Error *error)
{
  8004213cd8:	55                   	push   %rbp
  8004213cd9:	48 89 e5             	mov    %rsp,%rbp
  8004213cdc:	48 83 ec 70          	sub    $0x70,%rsp
  8004213ce0:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004213ce4:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004213ce8:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004213cec:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
  8004213cf0:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
  8004213cf4:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
	Dwarf_Fde fde;
	Dwarf_Unsigned cieoff;
	uint64_t length, val;
	int dwarf_size, ret;

	fde = ret_fde;
  8004213cf8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004213cfc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	fde->fde_dbg = dbg;
  8004213d00:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d04:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d08:	48 89 10             	mov    %rdx,(%rax)
	fde->fde_addr = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213d0b:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213d0f:	48 8b 10             	mov    (%rax),%rdx
  8004213d12:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d16:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213d1a:	48 01 d0             	add    %rdx,%rax
  8004213d1d:	48 89 c2             	mov    %rax,%rdx
  8004213d20:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d24:	48 89 50 10          	mov    %rdx,0x10(%rax)
	fde->fde_offset = *off;
  8004213d28:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213d2c:	48 8b 10             	mov    (%rax),%rdx
  8004213d2f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213d33:	48 89 50 18          	mov    %rdx,0x18(%rax)

	length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004213d37:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d3b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d3f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d43:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213d47:	48 89 d1             	mov    %rdx,%rcx
  8004213d4a:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213d4e:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213d53:	48 89 cf             	mov    %rcx,%rdi
  8004213d56:	ff d0                	callq  *%rax
  8004213d58:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (length == 0xffffffff) {
  8004213d5c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004213d61:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004213d65:	75 2e                	jne    8004213d95 <_dwarf_frame_set_fde+0xbd>
		dwarf_size = 8;
  8004213d67:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 8);
  8004213d6e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213d72:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213d76:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213d7a:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213d7e:	48 89 d1             	mov    %rdx,%rcx
  8004213d81:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213d85:	ba 08 00 00 00       	mov    $0x8,%edx
  8004213d8a:	48 89 cf             	mov    %rcx,%rdi
  8004213d8d:	ff d0                	callq  *%rax
  8004213d8f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004213d93:	eb 07                	jmp    8004213d9c <_dwarf_frame_set_fde+0xc4>
	} else
		dwarf_size = 4;
  8004213d95:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

	if (length > dbg->dbg_eh_size - *off) {
  8004213d9c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213da0:	48 8b 50 40          	mov    0x40(%rax),%rdx
  8004213da4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213da8:	48 8b 00             	mov    (%rax),%rax
  8004213dab:	48 29 c2             	sub    %rax,%rdx
  8004213dae:	48 89 d0             	mov    %rdx,%rax
  8004213db1:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  8004213db5:	73 0a                	jae    8004213dc1 <_dwarf_frame_set_fde+0xe9>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_FRAME_LENGTH_BAD);
		return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  8004213db7:	b8 12 00 00 00       	mov    $0x12,%eax
  8004213dbc:	e9 c4 02 00 00       	jmpq   8004214085 <_dwarf_frame_set_fde+0x3ad>
	}

	fde->fde_length = length;
  8004213dc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213dc5:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004213dc9:	48 89 50 20          	mov    %rdx,0x20(%rax)

	if (eh_frame) {
  8004213dcd:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213dd1:	74 5e                	je     8004213e31 <_dwarf_frame_set_fde+0x159>
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, 4);
  8004213dd3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213dd7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213ddb:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213ddf:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213de3:	48 89 d1             	mov    %rdx,%rcx
  8004213de6:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213dea:	ba 04 00 00 00       	mov    $0x4,%edx
  8004213def:	48 89 cf             	mov    %rcx,%rdi
  8004213df2:	ff d0                	callq  *%rax
  8004213df4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213df8:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = *off - (4 + fde->fde_cieoff);
  8004213dfc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213e00:	48 8b 10             	mov    (%rax),%rdx
  8004213e03:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e07:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213e0b:	48 29 c2             	sub    %rax,%rdx
  8004213e0e:	48 89 d0             	mov    %rdx,%rax
  8004213e11:	48 83 e8 04          	sub    $0x4,%rax
  8004213e15:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
		/* This delta should never be 0. */
		if (cieoff == fde->fde_offset) {
  8004213e19:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e1d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e21:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
  8004213e25:	75 3d                	jne    8004213e64 <_dwarf_frame_set_fde+0x18c>
			DWARF_SET_ERROR(dbg, error, DW_DLE_NO_CIE_FOR_FDE);
			return (DW_DLE_NO_CIE_FOR_FDE);
  8004213e27:	b8 13 00 00 00       	mov    $0x13,%eax
  8004213e2c:	e9 54 02 00 00       	jmpq   8004214085 <_dwarf_frame_set_fde+0x3ad>
		}
	} else {
		fde->fde_cieoff = dbg->read((uint8_t *)dbg->dbg_eh_offset, off, dwarf_size);
  8004213e31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213e35:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213e39:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213e3d:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004213e41:	48 89 d1             	mov    %rdx,%rcx
  8004213e44:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004213e47:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213e4b:	48 89 cf             	mov    %rcx,%rdi
  8004213e4e:	ff d0                	callq  *%rax
  8004213e50:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213e54:	48 89 42 28          	mov    %rax,0x28(%rdx)
		cieoff = fde->fde_cieoff;
  8004213e58:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213e5c:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213e60:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	}

	if (eh_frame) {
  8004213e64:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213e68:	0f 84 c3 00 00 00    	je     8004213f31 <_dwarf_frame_set_fde+0x259>
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213e6e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e72:	48 8b 50 10          	mov    0x10(%rax),%rdx
  8004213e76:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213e7a:	48 8b 00             	mov    (%rax),%rax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004213e7d:	4c 8d 0c 02          	lea    (%rdx,%rax,1),%r9
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
  8004213e81:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213e85:	0f b6 40 60          	movzbl 0x60(%rax),%eax
	if (eh_frame) {
		/*
		 * The FDE PC start/range for .eh_frame is encoded according
		 * to the LSB spec's extension to DWARF2.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004213e89:	44 0f b6 c0          	movzbl %al,%r8d
  8004213e8d:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213e91:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213e95:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004213e99:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213e9d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ea1:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004213ea5:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213ea9:	48 89 c7             	mov    %rax,%rdi
  8004213eac:	48 b8 10 35 21 04 80 	movabs $0x8004213510,%rax
  8004213eb3:	00 00 00 
  8004213eb6:	ff d0                	callq  *%rax
  8004213eb8:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    off, cie->cie_fde_encode, ds->ds_addr + *off, error);
		if (ret != DW_DLE_NONE)
  8004213ebb:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213ebf:	74 08                	je     8004213ec9 <_dwarf_frame_set_fde+0x1f1>
			return (ret);
  8004213ec1:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213ec4:	e9 bc 01 00 00       	jmpq   8004214085 <_dwarf_frame_set_fde+0x3ad>
		fde->fde_initloc = val;
  8004213ec9:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213ecd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213ed1:	48 89 50 30          	mov    %rdx,0x30(%rax)
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
						    off, cie->cie_fde_encode, 0, error);
  8004213ed5:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213ed9:	0f b6 40 60          	movzbl 0x60(%rax),%eax
		fde->fde_initloc = val;
		/*
		 * FDE PC range should not be relative value to anything.
		 * So pass 0 for pc value.
		 */
		ret = _dwarf_frame_read_lsb_encoded(dbg, &val, ds->ds_data,
  8004213edd:	44 0f b6 c0          	movzbl %al,%r8d
  8004213ee1:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004213ee5:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004213ee9:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
  8004213eed:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi
  8004213ef1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ef5:	48 8b 7d 10          	mov    0x10(%rbp),%rdi
  8004213ef9:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004213efd:	41 b9 00 00 00 00    	mov    $0x0,%r9d
  8004213f03:	48 89 c7             	mov    %rax,%rdi
  8004213f06:	48 b8 10 35 21 04 80 	movabs $0x8004213510,%rax
  8004213f0d:	00 00 00 
  8004213f10:	ff d0                	callq  *%rax
  8004213f12:	89 45 dc             	mov    %eax,-0x24(%rbp)
						    off, cie->cie_fde_encode, 0, error);
		if (ret != DW_DLE_NONE)
  8004213f15:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004213f19:	74 08                	je     8004213f23 <_dwarf_frame_set_fde+0x24b>
			return (ret);
  8004213f1b:	8b 45 dc             	mov    -0x24(%rbp),%eax
  8004213f1e:	e9 62 01 00 00       	jmpq   8004214085 <_dwarf_frame_set_fde+0x3ad>
		fde->fde_adrange = val;
  8004213f23:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004213f27:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213f2b:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004213f2f:	eb 50                	jmp    8004213f81 <_dwarf_frame_set_fde+0x2a9>
	} else {
		fde->fde_initloc = dbg->read(ds->ds_data, off,
  8004213f31:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f35:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f39:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213f3d:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213f40:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004213f44:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004213f48:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213f4c:	48 89 cf             	mov    %rcx,%rdi
  8004213f4f:	ff d0                	callq  *%rax
  8004213f51:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213f55:	48 89 42 30          	mov    %rax,0x30(%rdx)
					     dbg->dbg_pointer_size);
		fde->fde_adrange = dbg->read(ds->ds_data, off,
  8004213f59:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f5d:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004213f61:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004213f65:	8b 52 28             	mov    0x28(%rdx),%edx
  8004213f68:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
  8004213f6c:	48 8b 49 08          	mov    0x8(%rcx),%rcx
  8004213f70:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004213f74:	48 89 cf             	mov    %rcx,%rdi
  8004213f77:	ff d0                	callq  *%rax
  8004213f79:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213f7d:	48 89 42 38          	mov    %rax,0x38(%rdx)
					     dbg->dbg_pointer_size);
	}

	/* Optional FDE augmentation data for .eh_frame section. (ignored) */
	if (eh_frame && *cie->cie_augment == 'z') {
  8004213f81:	83 7d ac 00          	cmpl   $0x0,-0x54(%rbp)
  8004213f85:	74 6b                	je     8004213ff2 <_dwarf_frame_set_fde+0x31a>
  8004213f87:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004213f8b:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004213f8f:	0f b6 00             	movzbl (%rax),%eax
  8004213f92:	3c 7a                	cmp    $0x7a,%al
  8004213f94:	75 5c                	jne    8004213ff2 <_dwarf_frame_set_fde+0x31a>
		fde->fde_auglen = _dwarf_read_uleb128((uint8_t *)dbg->dbg_eh_offset, off);
  8004213f96:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213f9a:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213f9e:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
  8004213fa2:	48 89 d6             	mov    %rdx,%rsi
  8004213fa5:	48 89 c7             	mov    %rax,%rdi
  8004213fa8:	48 b8 8f 05 21 04 80 	movabs $0x800421058f,%rax
  8004213faf:	00 00 00 
  8004213fb2:	ff d0                	callq  *%rax
  8004213fb4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004213fb8:	48 89 42 40          	mov    %rax,0x40(%rdx)
		fde->fde_augdata = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213fbc:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213fc0:	48 8b 10             	mov    (%rax),%rdx
  8004213fc3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213fc7:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004213fcb:	48 01 d0             	add    %rdx,%rax
  8004213fce:	48 89 c2             	mov    %rax,%rdx
  8004213fd1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fd5:	48 89 50 48          	mov    %rdx,0x48(%rax)
		*off += fde->fde_auglen;
  8004213fd9:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213fdd:	48 8b 10             	mov    (%rax),%rdx
  8004213fe0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004213fe4:	48 8b 40 40          	mov    0x40(%rax),%rax
  8004213fe8:	48 01 c2             	add    %rax,%rdx
  8004213feb:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213fef:	48 89 10             	mov    %rdx,(%rax)
	}

	fde->fde_inst = (uint8_t *)dbg->dbg_eh_offset + *off;
  8004213ff2:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004213ff6:	48 8b 10             	mov    (%rax),%rdx
  8004213ff9:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004213ffd:	48 8b 40 38          	mov    0x38(%rax),%rax
  8004214001:	48 01 d0             	add    %rdx,%rax
  8004214004:	48 89 c2             	mov    %rax,%rdx
  8004214007:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421400b:	48 89 50 50          	mov    %rdx,0x50(%rax)
	if (dwarf_size == 4)
  800421400f:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214013:	75 2a                	jne    800421403f <_dwarf_frame_set_fde+0x367>
		fde->fde_instlen = fde->fde_offset + 4 + length - *off;
  8004214015:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214019:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421401d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214021:	48 01 c2             	add    %rax,%rdx
  8004214024:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214028:	48 8b 00             	mov    (%rax),%rax
  800421402b:	48 29 c2             	sub    %rax,%rdx
  800421402e:	48 89 d0             	mov    %rdx,%rax
  8004214031:	48 8d 50 04          	lea    0x4(%rax),%rdx
  8004214035:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214039:	48 89 50 58          	mov    %rdx,0x58(%rax)
  800421403d:	eb 28                	jmp    8004214067 <_dwarf_frame_set_fde+0x38f>
	else
		fde->fde_instlen = fde->fde_offset + 12 + length - *off;
  800421403f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214043:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214047:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421404b:	48 01 c2             	add    %rax,%rdx
  800421404e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214052:	48 8b 00             	mov    (%rax),%rax
  8004214055:	48 29 c2             	sub    %rax,%rdx
  8004214058:	48 89 d0             	mov    %rdx,%rax
  800421405b:	48 8d 50 0c          	lea    0xc(%rax),%rdx
  800421405f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214063:	48 89 50 58          	mov    %rdx,0x58(%rax)

	*off += fde->fde_instlen;
  8004214067:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421406b:	48 8b 10             	mov    (%rax),%rdx
  800421406e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214072:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214076:	48 01 c2             	add    %rax,%rdx
  8004214079:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421407d:	48 89 10             	mov    %rdx,(%rax)
	return (DW_DLE_NONE);
  8004214080:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214085:	c9                   	leaveq 
  8004214086:	c3                   	retq   

0000008004214087 <_dwarf_frame_interal_table_init>:


int
_dwarf_frame_interal_table_init(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004214087:	55                   	push   %rbp
  8004214088:	48 89 e5             	mov    %rsp,%rbp
  800421408b:	48 83 ec 20          	sub    $0x20,%rsp
  800421408f:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004214093:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
        Dwarf_Regtable3 *rt = &global_rt_table;
  8004214097:	48 b8 c0 96 37 04 80 	movabs $0x80043796c0,%rax
  800421409e:	00 00 00 
  80042140a1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

        if (dbg->dbg_internal_reg_table != NULL)
  80042140a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042140a9:	48 8b 40 58          	mov    0x58(%rax),%rax
  80042140ad:	48 85 c0             	test   %rax,%rax
  80042140b0:	74 07                	je     80042140b9 <_dwarf_frame_interal_table_init+0x32>
                return (DW_DLE_NONE);
  80042140b2:	b8 00 00 00 00       	mov    $0x0,%eax
  80042140b7:	eb 33                	jmp    80042140ec <_dwarf_frame_interal_table_init+0x65>

        rt->rt3_reg_table_size = dbg->dbg_frame_rule_table_size;
  80042140b9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042140bd:	0f b7 50 48          	movzwl 0x48(%rax),%edx
  80042140c1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042140c5:	66 89 50 18          	mov    %dx,0x18(%rax)
        rt->rt3_rules = global_rules;
  80042140c9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042140cd:	48 b9 c0 9f 37 04 80 	movabs $0x8004379fc0,%rcx
  80042140d4:	00 00 00 
  80042140d7:	48 89 48 20          	mov    %rcx,0x20(%rax)

        dbg->dbg_internal_reg_table = rt;
  80042140db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042140df:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042140e3:	48 89 50 58          	mov    %rdx,0x58(%rax)

        return (DW_DLE_NONE);
  80042140e7:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042140ec:	c9                   	leaveq 
  80042140ed:	c3                   	retq   

00000080042140ee <_dwarf_get_next_fde>:

static int
_dwarf_get_next_fde(Dwarf_Debug dbg,
                    int eh_frame, Dwarf_Error *error, Dwarf_Fde ret_fde)
{
  80042140ee:	55                   	push   %rbp
  80042140ef:	48 89 e5             	mov    %rsp,%rbp
  80042140f2:	48 83 ec 60          	sub    $0x60,%rsp
  80042140f6:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  80042140fa:	89 75 c4             	mov    %esi,-0x3c(%rbp)
  80042140fd:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
  8004214101:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
	Dwarf_Section *ds = &debug_frame_sec; 
  8004214105:	48 b8 80 b6 22 04 80 	movabs $0x800422b680,%rax
  800421410c:	00 00 00 
  800421410f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uint64_t length, offset, cie_id, entry_off;
	int dwarf_size, i, ret=-1;
  8004214113:	c7 45 f0 ff ff ff ff 	movl   $0xffffffff,-0x10(%rbp)

	offset = dbg->curr_off_eh;
  800421411a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421411e:	48 8b 40 30          	mov    0x30(%rax),%rax
  8004214122:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	if (offset < dbg->dbg_eh_size) {
  8004214126:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421412a:	48 8b 50 40          	mov    0x40(%rax),%rdx
  800421412e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004214132:	48 39 c2             	cmp    %rax,%rdx
  8004214135:	0f 86 fe 01 00 00    	jbe    8004214339 <_dwarf_get_next_fde+0x24b>
		entry_off = offset;
  800421413b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421413f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 4);
  8004214143:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214147:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421414b:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  800421414f:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  8004214153:	48 89 d1             	mov    %rdx,%rcx
  8004214156:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  800421415a:	ba 04 00 00 00       	mov    $0x4,%edx
  800421415f:	48 89 cf             	mov    %rcx,%rdi
  8004214162:	ff d0                	callq  *%rax
  8004214164:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
		if (length == 0xffffffff) {
  8004214168:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421416d:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004214171:	75 2e                	jne    80042141a1 <_dwarf_get_next_fde+0xb3>
			dwarf_size = 8;
  8004214173:	c7 45 f4 08 00 00 00 	movl   $0x8,-0xc(%rbp)
			length = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, 8);
  800421417a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421417e:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214182:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004214186:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  800421418a:	48 89 d1             	mov    %rdx,%rcx
  800421418d:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214191:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214196:	48 89 cf             	mov    %rcx,%rdi
  8004214199:	ff d0                	callq  *%rax
  800421419b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421419f:	eb 07                	jmp    80042141a8 <_dwarf_get_next_fde+0xba>
		} else
			dwarf_size = 4;
  80042141a1:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%rbp)

		if (length > dbg->dbg_eh_size - offset || (length == 0 && !eh_frame)) {
  80042141a8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042141ac:	48 8b 50 40          	mov    0x40(%rax),%rdx
  80042141b0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042141b4:	48 29 c2             	sub    %rax,%rdx
  80042141b7:	48 89 d0             	mov    %rdx,%rax
  80042141ba:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
  80042141be:	72 0d                	jb     80042141cd <_dwarf_get_next_fde+0xdf>
  80042141c0:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042141c5:	75 10                	jne    80042141d7 <_dwarf_get_next_fde+0xe9>
  80042141c7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042141cb:	75 0a                	jne    80042141d7 <_dwarf_get_next_fde+0xe9>
			DWARF_SET_ERROR(dbg, error,
					DW_DLE_DEBUG_FRAME_LENGTH_BAD);
			return (DW_DLE_DEBUG_FRAME_LENGTH_BAD);
  80042141cd:	b8 12 00 00 00       	mov    $0x12,%eax
  80042141d2:	e9 67 01 00 00       	jmpq   800421433e <_dwarf_get_next_fde+0x250>
		}

		/* Check terminator for .eh_frame */
		if (eh_frame && length == 0)
  80042141d7:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  80042141db:	74 11                	je     80042141ee <_dwarf_get_next_fde+0x100>
  80042141dd:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042141e2:	75 0a                	jne    80042141ee <_dwarf_get_next_fde+0x100>
			return(-1);
  80042141e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042141e9:	e9 50 01 00 00       	jmpq   800421433e <_dwarf_get_next_fde+0x250>

		cie_id = dbg->read((uint8_t *)dbg->dbg_eh_offset, &offset, dwarf_size);
  80042141ee:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042141f2:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042141f6:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  80042141fa:	48 8b 52 38          	mov    0x38(%rdx),%rdx
  80042141fe:	48 89 d1             	mov    %rdx,%rcx
  8004214201:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004214204:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
  8004214208:	48 89 cf             	mov    %rcx,%rdi
  800421420b:	ff d0                	callq  *%rax
  800421420d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

		if (eh_frame) {
  8004214211:	83 7d c4 00          	cmpl   $0x0,-0x3c(%rbp)
  8004214215:	74 79                	je     8004214290 <_dwarf_get_next_fde+0x1a2>
			/* GNU .eh_frame use CIE id 0. */
			if (cie_id == 0)
  8004214217:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
  800421421c:	75 32                	jne    8004214250 <_dwarf_get_next_fde+0x162>
				ret = _dwarf_frame_set_cie(dbg, ds,
  800421421e:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214222:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004214226:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421422a:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  800421422e:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  8004214232:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214236:	49 89 f8             	mov    %rdi,%r8
  8004214239:	48 89 c7             	mov    %rax,%rdi
  800421423c:	48 b8 75 38 21 04 80 	movabs $0x8004213875,%rax
  8004214243:	00 00 00 
  8004214246:	ff d0                	callq  *%rax
  8004214248:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421424b:	e9 c8 00 00 00       	jmpq   8004214318 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg,ret_fde, ds,
  8004214250:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  8004214254:	4c 8b 40 08          	mov    0x8(%rax),%r8
  8004214258:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  800421425c:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214260:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  8004214264:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214268:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  800421426c:	48 89 3c 24          	mov    %rdi,(%rsp)
  8004214270:	4d 89 c1             	mov    %r8,%r9
  8004214273:	41 b8 01 00 00 00    	mov    $0x1,%r8d
  8004214279:	48 89 c7             	mov    %rax,%rdi
  800421427c:	48 b8 d8 3c 21 04 80 	movabs $0x8004213cd8,%rax
  8004214283:	00 00 00 
  8004214286:	ff d0                	callq  *%rax
  8004214288:	89 45 f0             	mov    %eax,-0x10(%rbp)
  800421428b:	e9 88 00 00 00       	jmpq   8004214318 <_dwarf_get_next_fde+0x22a>
							   &entry_off, 1, ret_fde->fde_cie, error);
		} else {
			/* .dwarf_frame use CIE id ~0 */
			if ((dwarf_size == 4 && cie_id == ~0U) ||
  8004214290:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  8004214294:	75 0b                	jne    80042142a1 <_dwarf_get_next_fde+0x1b3>
  8004214296:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  800421429b:	48 39 45 e0          	cmp    %rax,-0x20(%rbp)
  800421429f:	74 0d                	je     80042142ae <_dwarf_get_next_fde+0x1c0>
  80042142a1:	83 7d f4 08          	cmpl   $0x8,-0xc(%rbp)
  80042142a5:	75 36                	jne    80042142dd <_dwarf_get_next_fde+0x1ef>
			    (dwarf_size == 8 && cie_id == ~0ULL))
  80042142a7:	48 83 7d e0 ff       	cmpq   $0xffffffffffffffff,-0x20(%rbp)
  80042142ac:	75 2f                	jne    80042142dd <_dwarf_get_next_fde+0x1ef>
				ret = _dwarf_frame_set_cie(dbg, ds,
  80042142ae:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042142b2:	48 8b 48 08          	mov    0x8(%rax),%rcx
  80042142b6:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042142ba:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
  80042142be:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
  80042142c2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042142c6:	49 89 f8             	mov    %rdi,%r8
  80042142c9:	48 89 c7             	mov    %rax,%rdi
  80042142cc:	48 b8 75 38 21 04 80 	movabs $0x8004213875,%rax
  80042142d3:	00 00 00 
  80042142d6:	ff d0                	callq  *%rax
  80042142d8:	89 45 f0             	mov    %eax,-0x10(%rbp)
  80042142db:	eb 3b                	jmp    8004214318 <_dwarf_get_next_fde+0x22a>
							   &entry_off, ret_fde->fde_cie, error);
			else
				ret = _dwarf_frame_set_fde(dbg, ret_fde, ds,
  80042142dd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042142e1:	4c 8b 40 08          	mov    0x8(%rax),%r8
  80042142e5:	48 8d 4d d0          	lea    -0x30(%rbp),%rcx
  80042142e9:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042142ed:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
  80042142f1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042142f5:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
  80042142f9:	48 89 3c 24          	mov    %rdi,(%rsp)
  80042142fd:	4d 89 c1             	mov    %r8,%r9
  8004214300:	41 b8 00 00 00 00    	mov    $0x0,%r8d
  8004214306:	48 89 c7             	mov    %rax,%rdi
  8004214309:	48 b8 d8 3c 21 04 80 	movabs $0x8004213cd8,%rax
  8004214310:	00 00 00 
  8004214313:	ff d0                	callq  *%rax
  8004214315:	89 45 f0             	mov    %eax,-0x10(%rbp)
							   &entry_off, 0, ret_fde->fde_cie, error);
		}

		if (ret != DW_DLE_NONE)
  8004214318:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  800421431c:	74 07                	je     8004214325 <_dwarf_get_next_fde+0x237>
			return(-1);
  800421431e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214323:	eb 19                	jmp    800421433e <_dwarf_get_next_fde+0x250>

		offset = entry_off;
  8004214325:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214329:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
		dbg->curr_off_eh = offset;
  800421432d:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004214331:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214335:	48 89 50 30          	mov    %rdx,0x30(%rax)
	}

	return (0);
  8004214339:	b8 00 00 00 00       	mov    $0x0,%eax
}
  800421433e:	c9                   	leaveq 
  800421433f:	c3                   	retq   

0000008004214340 <dwarf_set_frame_cfa_value>:

Dwarf_Half
dwarf_set_frame_cfa_value(Dwarf_Debug dbg, Dwarf_Half value)
{
  8004214340:	55                   	push   %rbp
  8004214341:	48 89 e5             	mov    %rsp,%rbp
  8004214344:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004214348:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421434c:	89 f0                	mov    %esi,%eax
  800421434e:	66 89 45 e4          	mov    %ax,-0x1c(%rbp)
        Dwarf_Half old_value;

        old_value = dbg->dbg_frame_cfa_value;
  8004214352:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214356:	0f b7 40 4c          	movzwl 0x4c(%rax),%eax
  800421435a:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
        dbg->dbg_frame_cfa_value = value;
  800421435e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214362:	0f b7 55 e4          	movzwl -0x1c(%rbp),%edx
  8004214366:	66 89 50 4c          	mov    %dx,0x4c(%rax)

        return (old_value);
  800421436a:	0f b7 45 fe          	movzwl -0x2(%rbp),%eax
}
  800421436e:	c9                   	leaveq 
  800421436f:	c3                   	retq   

0000008004214370 <dwarf_init_eh_section>:

int dwarf_init_eh_section(Dwarf_Debug dbg, Dwarf_Error *error)
{
  8004214370:	55                   	push   %rbp
  8004214371:	48 89 e5             	mov    %rsp,%rbp
  8004214374:	48 83 ec 10          	sub    $0x10,%rsp
  8004214378:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  800421437c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	Dwarf_Section *section;

	if (dbg == NULL) {
  8004214380:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004214385:	75 0a                	jne    8004214391 <dwarf_init_eh_section+0x21>
		DWARF_SET_ERROR(dbg, error, DW_DLE_ARGUMENT);
		return (DW_DLV_ERROR);
  8004214387:	b8 01 00 00 00       	mov    $0x1,%eax
  800421438c:	e9 85 00 00 00       	jmpq   8004214416 <dwarf_init_eh_section+0xa6>
	}

	if (dbg->dbg_internal_reg_table == NULL) {
  8004214391:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004214395:	48 8b 40 58          	mov    0x58(%rax),%rax
  8004214399:	48 85 c0             	test   %rax,%rax
  800421439c:	75 25                	jne    80042143c3 <dwarf_init_eh_section+0x53>
		if (_dwarf_frame_interal_table_init(dbg, error) != DW_DLE_NONE)
  800421439e:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  80042143a2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042143a6:	48 89 d6             	mov    %rdx,%rsi
  80042143a9:	48 89 c7             	mov    %rax,%rdi
  80042143ac:	48 b8 87 40 21 04 80 	movabs $0x8004214087,%rax
  80042143b3:	00 00 00 
  80042143b6:	ff d0                	callq  *%rax
  80042143b8:	85 c0                	test   %eax,%eax
  80042143ba:	74 07                	je     80042143c3 <dwarf_init_eh_section+0x53>
			return (DW_DLV_ERROR);
  80042143bc:	b8 01 00 00 00       	mov    $0x1,%eax
  80042143c1:	eb 53                	jmp    8004214416 <dwarf_init_eh_section+0xa6>
	}

	_dwarf_find_section_enhanced(&debug_frame_sec);
  80042143c3:	48 bf 80 b6 22 04 80 	movabs $0x800422b680,%rdi
  80042143ca:	00 00 00 
  80042143cd:	48 b8 2d 1e 21 04 80 	movabs $0x8004211e2d,%rax
  80042143d4:	00 00 00 
  80042143d7:	ff d0                	callq  *%rax

	dbg->curr_off_eh = 0;
  80042143d9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042143dd:	48 c7 40 30 00 00 00 	movq   $0x0,0x30(%rax)
  80042143e4:	00 
	dbg->dbg_eh_offset = debug_frame_sec.ds_addr;
  80042143e5:	48 b8 80 b6 22 04 80 	movabs $0x800422b680,%rax
  80042143ec:	00 00 00 
  80042143ef:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042143f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042143f7:	48 89 50 38          	mov    %rdx,0x38(%rax)
	dbg->dbg_eh_size = debug_frame_sec.ds_size;
  80042143fb:	48 b8 80 b6 22 04 80 	movabs $0x800422b680,%rax
  8004214402:	00 00 00 
  8004214405:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214409:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421440d:	48 89 50 40          	mov    %rdx,0x40(%rax)

	return (DW_DLV_OK);
  8004214411:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214416:	c9                   	leaveq 
  8004214417:	c3                   	retq   

0000008004214418 <_dwarf_lineno_run_program>:


static int
_dwarf_lineno_run_program(Dwarf_CU *cu, Dwarf_LineInfo li, uint8_t *p,
			  uint8_t *pe, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214418:	55                   	push   %rbp
  8004214419:	48 89 e5             	mov    %rsp,%rbp
  800421441c:	53                   	push   %rbx
  800421441d:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
  8004214424:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
  8004214428:	48 89 75 80          	mov    %rsi,-0x80(%rbp)
  800421442c:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  8004214433:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
  800421443a:	4c 89 85 68 ff ff ff 	mov    %r8,-0x98(%rbp)
  8004214441:	4c 89 8d 60 ff ff ff 	mov    %r9,-0xa0(%rbp)
	uint64_t address, file, line, column, isa, opsize;
	int is_stmt, basic_block, end_sequence;
	int prologue_end, epilogue_begin;
	int ret;

	ln = &li->li_line;
  8004214448:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421444c:	48 83 c0 48          	add    $0x48,%rax
  8004214450:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

	/*
	 *   ln->ln_li     = li;             \
	 * Set registers to their default values.
	 */
	RESET_REGISTERS;
  8004214454:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  800421445b:	00 
  800421445c:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  8004214463:	00 
  8004214464:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  800421446b:	00 
  800421446c:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  8004214473:	00 
  8004214474:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214478:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  800421447c:	0f b6 c0             	movzbl %al,%eax
  800421447f:	89 45 cc             	mov    %eax,-0x34(%rbp)
  8004214482:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004214489:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  8004214490:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004214497:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  800421449e:	e9 0a 05 00 00       	jmpq   80042149ad <_dwarf_lineno_run_program+0x595>
		if (*p == 0) {
  80042144a3:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042144aa:	0f b6 00             	movzbl (%rax),%eax
  80042144ad:	84 c0                	test   %al,%al
  80042144af:	0f 85 78 01 00 00    	jne    800421462d <_dwarf_lineno_run_program+0x215>

			/*
			 * Extended Opcodes.
			 */

			p++;
  80042144b5:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042144bc:	48 83 c0 01          	add    $0x1,%rax
  80042144c0:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
			opsize = _dwarf_decode_uleb128(&p);
  80042144c7:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042144ce:	48 89 c7             	mov    %rax,%rdi
  80042144d1:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  80042144d8:	00 00 00 
  80042144db:	ff d0                	callq  *%rax
  80042144dd:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
			switch (*p) {
  80042144e1:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042144e8:	0f b6 00             	movzbl (%rax),%eax
  80042144eb:	0f b6 c0             	movzbl %al,%eax
  80042144ee:	83 f8 02             	cmp    $0x2,%eax
  80042144f1:	74 7a                	je     800421456d <_dwarf_lineno_run_program+0x155>
  80042144f3:	83 f8 03             	cmp    $0x3,%eax
  80042144f6:	0f 84 b3 00 00 00    	je     80042145af <_dwarf_lineno_run_program+0x197>
  80042144fc:	83 f8 01             	cmp    $0x1,%eax
  80042144ff:	0f 85 09 01 00 00    	jne    800421460e <_dwarf_lineno_run_program+0x1f6>
			case DW_LNE_end_sequence:
				p++;
  8004214505:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421450c:	48 83 c0 01          	add    $0x1,%rax
  8004214510:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				end_sequence = 1;
  8004214517:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
				RESET_REGISTERS;
  800421451e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214525:	00 
  8004214526:	48 c7 45 e0 01 00 00 	movq   $0x1,-0x20(%rbp)
  800421452d:	00 
  800421452e:	48 c7 45 d8 01 00 00 	movq   $0x1,-0x28(%rbp)
  8004214535:	00 
  8004214536:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
  800421453d:	00 
  800421453e:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214542:	0f b6 40 19          	movzbl 0x19(%rax),%eax
  8004214546:	0f b6 c0             	movzbl %al,%eax
  8004214549:	89 45 cc             	mov    %eax,-0x34(%rbp)
  800421454c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
  8004214553:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
  800421455a:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
  8004214561:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004214568:	e9 bb 00 00 00       	jmpq   8004214628 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_set_address:
				p++;
  800421456d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214574:	48 83 c0 01          	add    $0x1,%rax
  8004214578:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				address = dbg->decode(&p, cu->addr_size);
  800421457f:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214586:	00 00 00 
  8004214589:	48 8b 00             	mov    (%rax),%rax
  800421458c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214590:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
  8004214594:	0f b6 52 0a          	movzbl 0xa(%rdx),%edx
  8004214598:	0f b6 ca             	movzbl %dl,%ecx
  800421459b:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  80042145a2:	89 ce                	mov    %ecx,%esi
  80042145a4:	48 89 d7             	mov    %rdx,%rdi
  80042145a7:	ff d0                	callq  *%rax
  80042145a9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
				break;
  80042145ad:	eb 79                	jmp    8004214628 <_dwarf_lineno_run_program+0x210>
			case DW_LNE_define_file:
				p++;
  80042145af:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042145b6:	48 83 c0 01          	add    $0x1,%rax
  80042145ba:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
				ret = _dwarf_lineno_add_file(li, &p, NULL,
  80042145c1:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  80042145c8:	00 00 00 
  80042145cb:	48 8b 08             	mov    (%rax),%rcx
  80042145ce:	48 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%rdx
  80042145d5:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
  80042145dc:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042145e0:	49 89 c8             	mov    %rcx,%r8
  80042145e3:	48 89 d1             	mov    %rdx,%rcx
  80042145e6:	ba 00 00 00 00       	mov    $0x0,%edx
  80042145eb:	48 89 c7             	mov    %rax,%rdi
  80042145ee:	48 b8 d0 49 21 04 80 	movabs $0x80042149d0,%rax
  80042145f5:	00 00 00 
  80042145f8:	ff d0                	callq  *%rax
  80042145fa:	89 45 a4             	mov    %eax,-0x5c(%rbp)
							     error, dbg);
				if (ret != DW_DLE_NONE)
  80042145fd:	83 7d a4 00          	cmpl   $0x0,-0x5c(%rbp)
  8004214601:	74 09                	je     800421460c <_dwarf_lineno_run_program+0x1f4>
					goto prog_fail;
  8004214603:	90                   	nop

	return (DW_DLE_NONE);

prog_fail:

	return (ret);
  8004214604:	8b 45 a4             	mov    -0x5c(%rbp),%eax
  8004214607:	e9 ba 03 00 00       	jmpq   80042149c6 <_dwarf_lineno_run_program+0x5ae>
				p++;
				ret = _dwarf_lineno_add_file(li, &p, NULL,
							     error, dbg);
				if (ret != DW_DLE_NONE)
					goto prog_fail;
				break;
  800421460c:	eb 1a                	jmp    8004214628 <_dwarf_lineno_run_program+0x210>
			default:
				/* Unrecognized extened opcodes. */
				p += opsize;
  800421460e:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
  8004214615:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004214619:	48 01 d0             	add    %rdx,%rax
  800421461c:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004214623:	e9 85 03 00 00       	jmpq   80042149ad <_dwarf_lineno_run_program+0x595>
  8004214628:	e9 80 03 00 00       	jmpq   80042149ad <_dwarf_lineno_run_program+0x595>
			}

		} else if (*p > 0 && *p < li->li_opbase) {
  800421462d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214634:	0f b6 00             	movzbl (%rax),%eax
  8004214637:	84 c0                	test   %al,%al
  8004214639:	0f 84 3c 02 00 00    	je     800421487b <_dwarf_lineno_run_program+0x463>
  800421463f:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214646:	0f b6 10             	movzbl (%rax),%edx
  8004214649:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421464d:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214651:	38 c2                	cmp    %al,%dl
  8004214653:	0f 83 22 02 00 00    	jae    800421487b <_dwarf_lineno_run_program+0x463>

			/*
			 * Standard Opcodes.
			 */

			switch (*p++) {
  8004214659:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  8004214660:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214664:	48 89 95 78 ff ff ff 	mov    %rdx,-0x88(%rbp)
  800421466b:	0f b6 00             	movzbl (%rax),%eax
  800421466e:	0f b6 c0             	movzbl %al,%eax
  8004214671:	83 f8 0c             	cmp    $0xc,%eax
  8004214674:	0f 87 fb 01 00 00    	ja     8004214875 <_dwarf_lineno_run_program+0x45d>
  800421467a:	89 c0                	mov    %eax,%eax
  800421467c:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004214683:	00 
  8004214684:	48 b8 68 a3 21 04 80 	movabs $0x800421a368,%rax
  800421468b:	00 00 00 
  800421468e:	48 01 d0             	add    %rdx,%rax
  8004214691:	48 8b 00             	mov    (%rax),%rax
  8004214694:	ff e0                	jmpq   *%rax
			case DW_LNS_copy:
				APPEND_ROW;
  8004214696:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  800421469d:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  80042146a1:	73 0a                	jae    80042146ad <_dwarf_lineno_run_program+0x295>
  80042146a3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042146a8:	e9 19 03 00 00       	jmpq   80042149c6 <_dwarf_lineno_run_program+0x5ae>
  80042146ad:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146b1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  80042146b5:	48 89 10             	mov    %rdx,(%rax)
  80042146b8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146bc:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  80042146c3:	00 
  80042146c4:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146c8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042146cc:	48 89 50 10          	mov    %rdx,0x10(%rax)
  80042146d0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146d4:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042146d8:	48 89 50 18          	mov    %rdx,0x18(%rax)
  80042146dc:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  80042146e0:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146e4:	48 89 50 20          	mov    %rdx,0x20(%rax)
  80042146e8:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146ec:	8b 55 c8             	mov    -0x38(%rbp),%edx
  80042146ef:	89 50 28             	mov    %edx,0x28(%rax)
  80042146f2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  80042146f6:	8b 55 cc             	mov    -0x34(%rbp),%edx
  80042146f9:	89 50 2c             	mov    %edx,0x2c(%rax)
  80042146fc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214700:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004214703:	89 50 30             	mov    %edx,0x30(%rax)
  8004214706:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421470a:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004214711:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214715:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214719:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
				basic_block = 0;
  8004214720:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
				prologue_end = 0;
  8004214727:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
				epilogue_begin = 0;
  800421472e:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
				break;
  8004214735:	e9 3c 01 00 00       	jmpq   8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  800421473a:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214741:	48 89 c7             	mov    %rax,%rdi
  8004214744:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  800421474b:	00 00 00 
  800421474e:	ff d0                	callq  *%rax
					li->li_minlen;
  8004214750:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
  8004214754:	0f b6 52 18          	movzbl 0x18(%rdx),%edx
				basic_block = 0;
				prologue_end = 0;
				epilogue_begin = 0;
				break;
			case DW_LNS_advance_pc:
				address += _dwarf_decode_uleb128(&p) *
  8004214758:	0f b6 d2             	movzbl %dl,%edx
  800421475b:	48 0f af c2          	imul   %rdx,%rax
  800421475f:	48 01 45 e8          	add    %rax,-0x18(%rbp)
					li->li_minlen;
				break;
  8004214763:	e9 0e 01 00 00       	jmpq   8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_advance_line:
				line += _dwarf_decode_sleb128(&p);
  8004214768:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421476f:	48 89 c7             	mov    %rax,%rdi
  8004214772:	48 b8 0e 06 21 04 80 	movabs $0x800421060e,%rax
  8004214779:	00 00 00 
  800421477c:	ff d0                	callq  *%rax
  800421477e:	48 01 45 d8          	add    %rax,-0x28(%rbp)
				break;
  8004214782:	e9 ef 00 00 00       	jmpq   8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_file:
				file = _dwarf_decode_uleb128(&p);
  8004214787:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  800421478e:	48 89 c7             	mov    %rax,%rdi
  8004214791:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004214798:	00 00 00 
  800421479b:	ff d0                	callq  *%rax
  800421479d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
				break;
  80042147a1:	e9 d0 00 00 00       	jmpq   8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_column:
				column = _dwarf_decode_uleb128(&p);
  80042147a6:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  80042147ad:	48 89 c7             	mov    %rax,%rdi
  80042147b0:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  80042147b7:	00 00 00 
  80042147ba:	ff d0                	callq  *%rax
  80042147bc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
				break;
  80042147c0:	e9 b1 00 00 00       	jmpq   8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_negate_stmt:
				is_stmt = !is_stmt;
  80042147c5:	83 7d cc 00          	cmpl   $0x0,-0x34(%rbp)
  80042147c9:	0f 94 c0             	sete   %al
  80042147cc:	0f b6 c0             	movzbl %al,%eax
  80042147cf:	89 45 cc             	mov    %eax,-0x34(%rbp)
				break;
  80042147d2:	e9 9f 00 00 00       	jmpq   8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_basic_block:
				basic_block = 1;
  80042147d7:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
				break;
  80042147de:	e9 93 00 00 00       	jmpq   8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_const_add_pc:
				address += ADDRESS(255);
  80042147e3:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042147e7:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042147eb:	0f b6 c0             	movzbl %al,%eax
  80042147ee:	ba ff 00 00 00       	mov    $0xff,%edx
  80042147f3:	89 d1                	mov    %edx,%ecx
  80042147f5:	29 c1                	sub    %eax,%ecx
  80042147f7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042147fb:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042147ff:	0f b6 d8             	movzbl %al,%ebx
  8004214802:	89 c8                	mov    %ecx,%eax
  8004214804:	99                   	cltd   
  8004214805:	f7 fb                	idiv   %ebx
  8004214807:	89 c2                	mov    %eax,%edx
  8004214809:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421480d:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  8004214811:	0f b6 c0             	movzbl %al,%eax
  8004214814:	0f af c2             	imul   %edx,%eax
  8004214817:	48 98                	cltq   
  8004214819:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  800421481d:	eb 57                	jmp    8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_fixed_advance_pc:
				address += dbg->decode(&p, 2);
  800421481f:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214826:	00 00 00 
  8004214829:	48 8b 00             	mov    (%rax),%rax
  800421482c:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004214830:	48 8d 95 78 ff ff ff 	lea    -0x88(%rbp),%rdx
  8004214837:	be 02 00 00 00       	mov    $0x2,%esi
  800421483c:	48 89 d7             	mov    %rdx,%rdi
  800421483f:	ff d0                	callq  *%rax
  8004214841:	48 01 45 e8          	add    %rax,-0x18(%rbp)
				break;
  8004214845:	eb 2f                	jmp    8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_prologue_end:
				prologue_end = 1;
  8004214847:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				break;
  800421484e:	eb 26                	jmp    8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_epilogue_begin:
				epilogue_begin = 1;
  8004214850:	c7 45 b0 01 00 00 00 	movl   $0x1,-0x50(%rbp)
				break;
  8004214857:	eb 1d                	jmp    8004214876 <_dwarf_lineno_run_program+0x45e>
			case DW_LNS_set_isa:
				isa = _dwarf_decode_uleb128(&p);
  8004214859:	48 8d 85 78 ff ff ff 	lea    -0x88(%rbp),%rax
  8004214860:	48 89 c7             	mov    %rax,%rdi
  8004214863:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  800421486a:	00 00 00 
  800421486d:	ff d0                	callq  *%rax
  800421486f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
				break;
  8004214873:	eb 01                	jmp    8004214876 <_dwarf_lineno_run_program+0x45e>
			default:
				/* Unrecognized extened opcodes. What to do? */
				break;
  8004214875:	90                   	nop
			}

		} else {
  8004214876:	e9 32 01 00 00       	jmpq   80042149ad <_dwarf_lineno_run_program+0x595>

			/*
			 * Special Opcodes.
			 */

			line += LINE(*p);
  800421487b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421487f:	0f b6 40 1a          	movzbl 0x1a(%rax),%eax
  8004214883:	0f be c8             	movsbl %al,%ecx
  8004214886:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  800421488d:	0f b6 00             	movzbl (%rax),%eax
  8004214890:	0f b6 d0             	movzbl %al,%edx
  8004214893:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214897:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  800421489b:	0f b6 c0             	movzbl %al,%eax
  800421489e:	29 c2                	sub    %eax,%edx
  80042148a0:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042148a4:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042148a8:	0f b6 f0             	movzbl %al,%esi
  80042148ab:	89 d0                	mov    %edx,%eax
  80042148ad:	99                   	cltd   
  80042148ae:	f7 fe                	idiv   %esi
  80042148b0:	89 d0                	mov    %edx,%eax
  80042148b2:	01 c8                	add    %ecx,%eax
  80042148b4:	48 98                	cltq   
  80042148b6:	48 01 45 d8          	add    %rax,-0x28(%rbp)
			address += ADDRESS(*p);
  80042148ba:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042148c1:	0f b6 00             	movzbl (%rax),%eax
  80042148c4:	0f b6 d0             	movzbl %al,%edx
  80042148c7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042148cb:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  80042148cf:	0f b6 c0             	movzbl %al,%eax
  80042148d2:	89 d1                	mov    %edx,%ecx
  80042148d4:	29 c1                	sub    %eax,%ecx
  80042148d6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042148da:	0f b6 40 1b          	movzbl 0x1b(%rax),%eax
  80042148de:	0f b6 d8             	movzbl %al,%ebx
  80042148e1:	89 c8                	mov    %ecx,%eax
  80042148e3:	99                   	cltd   
  80042148e4:	f7 fb                	idiv   %ebx
  80042148e6:	89 c2                	mov    %eax,%edx
  80042148e8:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042148ec:	0f b6 40 18          	movzbl 0x18(%rax),%eax
  80042148f0:	0f b6 c0             	movzbl %al,%eax
  80042148f3:	0f af c2             	imul   %edx,%eax
  80042148f6:	48 98                	cltq   
  80042148f8:	48 01 45 e8          	add    %rax,-0x18(%rbp)
			APPEND_ROW;
  80042148fc:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004214903:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004214907:	73 0a                	jae    8004214913 <_dwarf_lineno_run_program+0x4fb>
  8004214909:	b8 00 00 00 00       	mov    $0x0,%eax
  800421490e:	e9 b3 00 00 00       	jmpq   80042149c6 <_dwarf_lineno_run_program+0x5ae>
  8004214913:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214917:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421491b:	48 89 10             	mov    %rdx,(%rax)
  800421491e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214922:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
  8004214929:	00 
  800421492a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421492e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214932:	48 89 50 10          	mov    %rdx,0x10(%rax)
  8004214936:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421493a:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  800421493e:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004214942:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214946:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421494a:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421494e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214952:	8b 55 c8             	mov    -0x38(%rbp),%edx
  8004214955:	89 50 28             	mov    %edx,0x28(%rax)
  8004214958:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  800421495c:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800421495f:	89 50 2c             	mov    %edx,0x2c(%rax)
  8004214962:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214966:	8b 55 c4             	mov    -0x3c(%rbp),%edx
  8004214969:	89 50 30             	mov    %edx,0x30(%rax)
  800421496c:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  8004214970:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
  8004214977:	48 8d 50 01          	lea    0x1(%rax),%rdx
  800421497b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  800421497f:	48 89 90 80 00 00 00 	mov    %rdx,0x80(%rax)
			basic_block = 0;
  8004214986:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
			prologue_end = 0;
  800421498d:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
			epilogue_begin = 0;
  8004214994:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%rbp)
			p++;
  800421499b:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042149a2:	48 83 c0 01          	add    $0x1,%rax
  80042149a6:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
	RESET_REGISTERS;

	/*
	 * Start line number program.
	 */
	while (p < pe) {
  80042149ad:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042149b4:	48 3b 85 70 ff ff ff 	cmp    -0x90(%rbp),%rax
  80042149bb:	0f 82 e2 fa ff ff    	jb     80042144a3 <_dwarf_lineno_run_program+0x8b>
			epilogue_begin = 0;
			p++;
		}
	}

	return (DW_DLE_NONE);
  80042149c1:	b8 00 00 00 00       	mov    $0x0,%eax

#undef  RESET_REGISTERS
#undef  APPEND_ROW
#undef  LINE
#undef  ADDRESS
}
  80042149c6:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  80042149cd:	5b                   	pop    %rbx
  80042149ce:	5d                   	pop    %rbp
  80042149cf:	c3                   	retq   

00000080042149d0 <_dwarf_lineno_add_file>:

static int
_dwarf_lineno_add_file(Dwarf_LineInfo li, uint8_t **p, const char *compdir,
		       Dwarf_Error *error, Dwarf_Debug dbg)
{
  80042149d0:	55                   	push   %rbp
  80042149d1:	48 89 e5             	mov    %rsp,%rbp
  80042149d4:	53                   	push   %rbx
  80042149d5:	48 83 ec 48          	sub    $0x48,%rsp
  80042149d9:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  80042149dd:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  80042149e1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
  80042149e5:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  80042149e9:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
	char *fname;
	//const char *dirname;
	uint8_t *src;
	int slen;

	src = *p;
  80042149ed:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042149f1:	48 8b 00             	mov    (%rax),%rax
  80042149f4:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  DWARF_SET_ERROR(dbg, error, DW_DLE_MEMORY);
  return (DW_DLE_MEMORY);
  }
*/  
	//lf->lf_fullpath = NULL;
	fname = (char *) src;
  80042149f8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042149fc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	src += strlen(fname) + 1;
  8004214a00:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
  8004214a04:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214a08:	48 89 c7             	mov    %rax,%rdi
  8004214a0b:	48 b8 78 f7 20 04 80 	movabs $0x800420f778,%rax
  8004214a12:	00 00 00 
  8004214a15:	ff d0                	callq  *%rax
  8004214a17:	48 98                	cltq   
  8004214a19:	48 83 c0 01          	add    $0x1,%rax
  8004214a1d:	48 01 d8             	add    %rbx,%rax
  8004214a20:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	_dwarf_decode_uleb128(&src);
  8004214a24:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214a28:	48 89 c7             	mov    %rax,%rdi
  8004214a2b:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004214a32:	00 00 00 
  8004214a35:	ff d0                	callq  *%rax
	   snprintf(lf->lf_fullpath, slen, "%s/%s", dirname,
	   lf->lf_fname);
	   }
	   }
	*/
	_dwarf_decode_uleb128(&src);
  8004214a37:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214a3b:	48 89 c7             	mov    %rax,%rdi
  8004214a3e:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004214a45:	00 00 00 
  8004214a48:	ff d0                	callq  *%rax
	_dwarf_decode_uleb128(&src);
  8004214a4a:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  8004214a4e:	48 89 c7             	mov    %rax,%rdi
  8004214a51:	48 b8 a0 06 21 04 80 	movabs $0x80042106a0,%rax
  8004214a58:	00 00 00 
  8004214a5b:	ff d0                	callq  *%rax
	//STAILQ_INSERT_TAIL(&li->li_lflist, lf, lf_next);
	//li->li_lflen++;

	*p = src;
  8004214a5d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004214a61:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214a65:	48 89 10             	mov    %rdx,(%rax)

	return (DW_DLE_NONE);
  8004214a68:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004214a6d:	48 83 c4 48          	add    $0x48,%rsp
  8004214a71:	5b                   	pop    %rbx
  8004214a72:	5d                   	pop    %rbp
  8004214a73:	c3                   	retq   

0000008004214a74 <_dwarf_lineno_init>:

int     
_dwarf_lineno_init(Dwarf_Die *die, uint64_t offset, Dwarf_LineInfo linfo, Dwarf_Addr pc, Dwarf_Error *error)
{   
  8004214a74:	55                   	push   %rbp
  8004214a75:	48 89 e5             	mov    %rsp,%rbp
  8004214a78:	53                   	push   %rbx
  8004214a79:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
  8004214a80:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
  8004214a87:	48 89 b5 10 ff ff ff 	mov    %rsi,-0xf0(%rbp)
  8004214a8e:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
  8004214a95:	48 89 8d 00 ff ff ff 	mov    %rcx,-0x100(%rbp)
  8004214a9c:	4c 89 85 f8 fe ff ff 	mov    %r8,-0x108(%rbp)
	Dwarf_Section myds = {.ds_name = ".debug_line"};
  8004214aa3:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
  8004214aaa:	00 
  8004214aab:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
  8004214ab2:	00 
  8004214ab3:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
  8004214aba:	00 
  8004214abb:	48 c7 45 a8 00 00 00 	movq   $0x0,-0x58(%rbp)
  8004214ac2:	00 
  8004214ac3:	48 b8 d0 a3 21 04 80 	movabs $0x800421a3d0,%rax
  8004214aca:	00 00 00 
  8004214acd:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	Dwarf_Section *ds = &myds;
  8004214ad1:	48 8d 45 90          	lea    -0x70(%rbp),%rax
  8004214ad5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	//Dwarf_LineFile lf, tlf;
	uint64_t length, hdroff, endoff;
	uint8_t *p;
	int dwarf_size, i, ret;
            
	cu = die->cu_header;
  8004214ad9:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  8004214ae0:	48 8b 80 60 03 00 00 	mov    0x360(%rax),%rax
  8004214ae7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	assert(cu != NULL); 
  8004214aeb:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
  8004214af0:	75 35                	jne    8004214b27 <_dwarf_lineno_init+0xb3>
  8004214af2:	48 b9 dc a3 21 04 80 	movabs $0x800421a3dc,%rcx
  8004214af9:	00 00 00 
  8004214afc:	48 ba e7 a3 21 04 80 	movabs $0x800421a3e7,%rdx
  8004214b03:	00 00 00 
  8004214b06:	be 17 01 00 00       	mov    $0x117,%esi
  8004214b0b:	48 bf fc a3 21 04 80 	movabs $0x800421a3fc,%rdi
  8004214b12:	00 00 00 
  8004214b15:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214b1a:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004214b21:	00 00 00 
  8004214b24:	41 ff d0             	callq  *%r8
	assert(dbg != NULL);
  8004214b27:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214b2e:	00 00 00 
  8004214b31:	48 8b 00             	mov    (%rax),%rax
  8004214b34:	48 85 c0             	test   %rax,%rax
  8004214b37:	75 35                	jne    8004214b6e <_dwarf_lineno_init+0xfa>
  8004214b39:	48 b9 13 a4 21 04 80 	movabs $0x800421a413,%rcx
  8004214b40:	00 00 00 
  8004214b43:	48 ba e7 a3 21 04 80 	movabs $0x800421a3e7,%rdx
  8004214b4a:	00 00 00 
  8004214b4d:	be 18 01 00 00       	mov    $0x118,%esi
  8004214b52:	48 bf fc a3 21 04 80 	movabs $0x800421a3fc,%rdi
  8004214b59:	00 00 00 
  8004214b5c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214b61:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004214b68:	00 00 00 
  8004214b6b:	41 ff d0             	callq  *%r8

	if ((_dwarf_find_section_enhanced(ds)) != 0)
  8004214b6e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214b72:	48 89 c7             	mov    %rax,%rdi
  8004214b75:	48 b8 2d 1e 21 04 80 	movabs $0x8004211e2d,%rax
  8004214b7c:	00 00 00 
  8004214b7f:	ff d0                	callq  *%rax
  8004214b81:	85 c0                	test   %eax,%eax
  8004214b83:	74 0a                	je     8004214b8f <_dwarf_lineno_init+0x11b>
		return (DW_DLE_NONE);
  8004214b85:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214b8a:	e9 4f 04 00 00       	jmpq   8004214fde <_dwarf_lineno_init+0x56a>

	li = linfo;
  8004214b8f:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  8004214b96:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
	 break;
	 }
	 }
	*/

	length = dbg->read(ds->ds_data, &offset, 4);
  8004214b9a:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214ba1:	00 00 00 
  8004214ba4:	48 8b 00             	mov    (%rax),%rax
  8004214ba7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214bab:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214baf:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214bb3:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214bba:	ba 04 00 00 00       	mov    $0x4,%edx
  8004214bbf:	48 89 cf             	mov    %rcx,%rdi
  8004214bc2:	ff d0                	callq  *%rax
  8004214bc4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	if (length == 0xffffffff) {
  8004214bc8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8004214bcd:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
  8004214bd1:	75 37                	jne    8004214c0a <_dwarf_lineno_init+0x196>
		dwarf_size = 8;
  8004214bd3:	c7 45 e4 08 00 00 00 	movl   $0x8,-0x1c(%rbp)
		length = dbg->read(ds->ds_data, &offset, 8);
  8004214bda:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214be1:	00 00 00 
  8004214be4:	48 8b 00             	mov    (%rax),%rax
  8004214be7:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214beb:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214bef:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214bf3:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214bfa:	ba 08 00 00 00       	mov    $0x8,%edx
  8004214bff:	48 89 cf             	mov    %rcx,%rdi
  8004214c02:	ff d0                	callq  *%rax
  8004214c04:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  8004214c08:	eb 07                	jmp    8004214c11 <_dwarf_lineno_init+0x19d>
	} else
		dwarf_size = 4;
  8004214c0a:	c7 45 e4 04 00 00 00 	movl   $0x4,-0x1c(%rbp)

	if (length > ds->ds_size - offset) {
  8004214c11:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214c15:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004214c19:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214c20:	48 29 c2             	sub    %rax,%rdx
  8004214c23:	48 89 d0             	mov    %rdx,%rax
  8004214c26:	48 3b 45 e8          	cmp    -0x18(%rbp),%rax
  8004214c2a:	73 0a                	jae    8004214c36 <_dwarf_lineno_init+0x1c2>
		DWARF_SET_ERROR(dbg, error, DW_DLE_DEBUG_LINE_LENGTH_BAD);
		return (DW_DLE_DEBUG_LINE_LENGTH_BAD);
  8004214c2c:	b8 0f 00 00 00       	mov    $0xf,%eax
  8004214c31:	e9 a8 03 00 00       	jmpq   8004214fde <_dwarf_lineno_init+0x56a>
	}
	/*
	 * Read in line number program header.
	 */
	li->li_length = length;
  8004214c36:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c3a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214c3e:	48 89 10             	mov    %rdx,(%rax)
	endoff = offset + length;
  8004214c41:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
  8004214c48:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004214c4c:	48 01 d0             	add    %rdx,%rax
  8004214c4f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	li->li_version = dbg->read(ds->ds_data, &offset, 2); /* FIXME: verify version */
  8004214c53:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214c5a:	00 00 00 
  8004214c5d:	48 8b 00             	mov    (%rax),%rax
  8004214c60:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c64:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c68:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214c6c:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214c73:	ba 02 00 00 00       	mov    $0x2,%edx
  8004214c78:	48 89 cf             	mov    %rcx,%rdi
  8004214c7b:	ff d0                	callq  *%rax
  8004214c7d:	89 c2                	mov    %eax,%edx
  8004214c7f:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214c83:	66 89 50 08          	mov    %dx,0x8(%rax)
	li->li_hdrlen = dbg->read(ds->ds_data, &offset, dwarf_size);
  8004214c87:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214c8e:	00 00 00 
  8004214c91:	48 8b 00             	mov    (%rax),%rax
  8004214c94:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214c98:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214c9c:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214ca0:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004214ca3:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214caa:	48 89 cf             	mov    %rcx,%rdi
  8004214cad:	ff d0                	callq  *%rax
  8004214caf:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004214cb3:	48 89 42 10          	mov    %rax,0x10(%rdx)
	hdroff = offset;
  8004214cb7:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214cbe:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
	li->li_minlen = dbg->read(ds->ds_data, &offset, 1);
  8004214cc2:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214cc9:	00 00 00 
  8004214ccc:	48 8b 00             	mov    (%rax),%rax
  8004214ccf:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214cd3:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214cd7:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214cdb:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214ce2:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214ce7:	48 89 cf             	mov    %rcx,%rdi
  8004214cea:	ff d0                	callq  *%rax
  8004214cec:	89 c2                	mov    %eax,%edx
  8004214cee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214cf2:	88 50 18             	mov    %dl,0x18(%rax)
	li->li_defstmt = dbg->read(ds->ds_data, &offset, 1);
  8004214cf5:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214cfc:	00 00 00 
  8004214cff:	48 8b 00             	mov    (%rax),%rax
  8004214d02:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d06:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214d0a:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214d0e:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214d15:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214d1a:	48 89 cf             	mov    %rcx,%rdi
  8004214d1d:	ff d0                	callq  *%rax
  8004214d1f:	89 c2                	mov    %eax,%edx
  8004214d21:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d25:	88 50 19             	mov    %dl,0x19(%rax)
	li->li_lbase = dbg->read(ds->ds_data, &offset, 1);
  8004214d28:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214d2f:	00 00 00 
  8004214d32:	48 8b 00             	mov    (%rax),%rax
  8004214d35:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d39:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214d3d:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214d41:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214d48:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214d4d:	48 89 cf             	mov    %rcx,%rdi
  8004214d50:	ff d0                	callq  *%rax
  8004214d52:	89 c2                	mov    %eax,%edx
  8004214d54:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d58:	88 50 1a             	mov    %dl,0x1a(%rax)
	li->li_lrange = dbg->read(ds->ds_data, &offset, 1);
  8004214d5b:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214d62:	00 00 00 
  8004214d65:	48 8b 00             	mov    (%rax),%rax
  8004214d68:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d6c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214d70:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214d74:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214d7b:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214d80:	48 89 cf             	mov    %rcx,%rdi
  8004214d83:	ff d0                	callq  *%rax
  8004214d85:	89 c2                	mov    %eax,%edx
  8004214d87:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214d8b:	88 50 1b             	mov    %dl,0x1b(%rax)
	li->li_opbase = dbg->read(ds->ds_data, &offset, 1);
  8004214d8e:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214d95:	00 00 00 
  8004214d98:	48 8b 00             	mov    (%rax),%rax
  8004214d9b:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214d9f:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214da3:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214da7:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214dae:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214db3:	48 89 cf             	mov    %rcx,%rdi
  8004214db6:	ff d0                	callq  *%rax
  8004214db8:	89 c2                	mov    %eax,%edx
  8004214dba:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214dbe:	88 50 1c             	mov    %dl,0x1c(%rax)
	//STAILQ_INIT(&li->li_lflist);
	//STAILQ_INIT(&li->li_lnlist);

	if ((int)li->li_hdrlen - 5 < li->li_opbase - 1) {
  8004214dc1:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214dc5:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214dc9:	8d 50 fb             	lea    -0x5(%rax),%edx
  8004214dcc:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214dd0:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214dd4:	0f b6 c0             	movzbl %al,%eax
  8004214dd7:	83 e8 01             	sub    $0x1,%eax
  8004214dda:	39 c2                	cmp    %eax,%edx
  8004214ddc:	7d 0c                	jge    8004214dea <_dwarf_lineno_init+0x376>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214dde:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214de5:	e9 f1 01 00 00       	jmpq   8004214fdb <_dwarf_lineno_init+0x567>
	}

	li->li_oplen = global_std_op;
  8004214dea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214dee:	48 bb 00 a6 37 04 80 	movabs $0x800437a600,%rbx
  8004214df5:	00 00 00 
  8004214df8:	48 89 58 20          	mov    %rbx,0x20(%rax)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004214dfc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%rbp)
  8004214e03:	eb 41                	jmp    8004214e46 <_dwarf_lineno_init+0x3d2>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);
  8004214e05:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e09:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004214e0d:	8b 45 e0             	mov    -0x20(%rbp),%eax
  8004214e10:	48 98                	cltq   
  8004214e12:	48 8d 1c 02          	lea    (%rdx,%rax,1),%rbx
  8004214e16:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214e1d:	00 00 00 
  8004214e20:	48 8b 00             	mov    (%rax),%rax
  8004214e23:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214e27:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004214e2b:	48 8b 4a 08          	mov    0x8(%rdx),%rcx
  8004214e2f:	48 8d b5 10 ff ff ff 	lea    -0xf0(%rbp),%rsi
  8004214e36:	ba 01 00 00 00       	mov    $0x1,%edx
  8004214e3b:	48 89 cf             	mov    %rcx,%rdi
  8004214e3e:	ff d0                	callq  *%rax
  8004214e40:	88 03                	mov    %al,(%rbx)

	/*
	 * Read in std opcode arg length list. Note that the first
	 * element is not used.
	 */
	for (i = 1; i < li->li_opbase; i++)
  8004214e42:	83 45 e0 01          	addl   $0x1,-0x20(%rbp)
  8004214e46:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214e4a:	0f b6 40 1c          	movzbl 0x1c(%rax),%eax
  8004214e4e:	0f b6 c0             	movzbl %al,%eax
  8004214e51:	3b 45 e0             	cmp    -0x20(%rbp),%eax
  8004214e54:	7f af                	jg     8004214e05 <_dwarf_lineno_init+0x391>
		li->li_oplen[i] = dbg->read(ds->ds_data, &offset, 1);

	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
  8004214e56:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
  8004214e5d:	00 
	p = ds->ds_data + offset;
  8004214e5e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214e62:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214e66:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  8004214e6d:	48 01 d0             	add    %rdx,%rax
  8004214e70:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	while (*p != '\0') {
  8004214e77:	eb 1f                	jmp    8004214e98 <_dwarf_lineno_init+0x424>
		while (*p++ != '\0')
  8004214e79:	90                   	nop
  8004214e7a:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214e81:	48 8d 50 01          	lea    0x1(%rax),%rdx
  8004214e85:	48 89 95 28 ff ff ff 	mov    %rdx,-0xd8(%rbp)
  8004214e8c:	0f b6 00             	movzbl (%rax),%eax
  8004214e8f:	84 c0                	test   %al,%al
  8004214e91:	75 e7                	jne    8004214e7a <_dwarf_lineno_init+0x406>
			;
		length++;
  8004214e93:	48 83 45 e8 01       	addq   $0x1,-0x18(%rbp)
	/*
	 * Check how many strings in the include dir string array.
	 */
	length = 0;
	p = ds->ds_data + offset;
	while (*p != '\0') {
  8004214e98:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214e9f:	0f b6 00             	movzbl (%rax),%eax
  8004214ea2:	84 c0                	test   %al,%al
  8004214ea4:	75 d3                	jne    8004214e79 <_dwarf_lineno_init+0x405>
		while (*p++ != '\0')
			;
		length++;
	}
	li->li_inclen = length;
  8004214ea6:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214eaa:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004214eae:	48 89 50 30          	mov    %rdx,0x30(%rax)

	/* Sanity check. */
	if (p - ds->ds_data > (int) ds->ds_size) {
  8004214eb2:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214eb9:	48 89 c2             	mov    %rax,%rdx
  8004214ebc:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214ec0:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214ec4:	48 29 c2             	sub    %rax,%rdx
  8004214ec7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214ecb:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004214ecf:	48 98                	cltq   
  8004214ed1:	48 39 c2             	cmp    %rax,%rdx
  8004214ed4:	7e 0c                	jle    8004214ee2 <_dwarf_lineno_init+0x46e>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214ed6:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214edd:	e9 f9 00 00 00       	jmpq   8004214fdb <_dwarf_lineno_init+0x567>
  li->li_incdirs[i++] = (char *) p;
  while (*p++ != '\0')
  ;
  }
*/
	p++;
  8004214ee2:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214ee9:	48 83 c0 01          	add    $0x1,%rax
  8004214eed:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214ef4:	eb 3c                	jmp    8004214f32 <_dwarf_lineno_init+0x4be>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
  8004214ef6:	48 b8 68 b6 22 04 80 	movabs $0x800422b668,%rax
  8004214efd:	00 00 00 
  8004214f00:	48 8b 08             	mov    (%rax),%rcx
  8004214f03:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
  8004214f0a:	48 8d b5 28 ff ff ff 	lea    -0xd8(%rbp),%rsi
  8004214f11:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214f15:	49 89 c8             	mov    %rcx,%r8
  8004214f18:	48 89 d1             	mov    %rdx,%rcx
  8004214f1b:	ba 00 00 00 00       	mov    $0x0,%edx
  8004214f20:	48 89 c7             	mov    %rax,%rdi
  8004214f23:	48 b8 d0 49 21 04 80 	movabs $0x80042149d0,%rax
  8004214f2a:	00 00 00 
  8004214f2d:	ff d0                	callq  *%rax
  8004214f2f:	89 45 dc             	mov    %eax,-0x24(%rbp)
	p++;

	/*
	 * Process file list.
	 */
	while (*p != '\0') {
  8004214f32:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214f39:	0f b6 00             	movzbl (%rax),%eax
  8004214f3c:	84 c0                	test   %al,%al
  8004214f3e:	75 b6                	jne    8004214ef6 <_dwarf_lineno_init+0x482>
		ret = _dwarf_lineno_add_file(li, &p, NULL, error, dbg);
		//p++;
	}

	p++;
  8004214f40:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214f47:	48 83 c0 01          	add    $0x1,%rax
  8004214f4b:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
	/* Sanity check. */
	if (p - ds->ds_data - hdroff != li->li_hdrlen) {
  8004214f52:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  8004214f59:	48 89 c2             	mov    %rax,%rdx
  8004214f5c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214f60:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004214f64:	48 29 c2             	sub    %rax,%rdx
  8004214f67:	48 89 d0             	mov    %rdx,%rax
  8004214f6a:	48 2b 45 b0          	sub    -0x50(%rbp),%rax
  8004214f6e:	48 89 c2             	mov    %rax,%rdx
  8004214f71:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004214f75:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004214f79:	48 39 c2             	cmp    %rax,%rdx
  8004214f7c:	74 09                	je     8004214f87 <_dwarf_lineno_init+0x513>
		ret = DW_DLE_DEBUG_LINE_LENGTH_BAD;
  8004214f7e:	c7 45 dc 0f 00 00 00 	movl   $0xf,-0x24(%rbp)
		DWARF_SET_ERROR(dbg, error, ret);
		goto fail_cleanup;
  8004214f85:	eb 54                	jmp    8004214fdb <_dwarf_lineno_init+0x567>
	}

	/*
	 * Process line number program.
	 */
	ret = _dwarf_lineno_run_program(cu, li, p, ds->ds_data + endoff, pc,
  8004214f87:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004214f8b:	48 8b 50 08          	mov    0x8(%rax),%rdx
  8004214f8f:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004214f93:	48 8d 0c 02          	lea    (%rdx,%rax,1),%rcx
  8004214f97:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
  8004214f9e:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
  8004214fa5:	48 8b bd 00 ff ff ff 	mov    -0x100(%rbp),%rdi
  8004214fac:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
  8004214fb0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004214fb4:	4d 89 c1             	mov    %r8,%r9
  8004214fb7:	49 89 f8             	mov    %rdi,%r8
  8004214fba:	48 89 c7             	mov    %rax,%rdi
  8004214fbd:	48 b8 18 44 21 04 80 	movabs $0x8004214418,%rax
  8004214fc4:	00 00 00 
  8004214fc7:	ff d0                	callq  *%rax
  8004214fc9:	89 45 dc             	mov    %eax,-0x24(%rbp)
					error);
	if (ret != DW_DLE_NONE)
  8004214fcc:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  8004214fd0:	74 02                	je     8004214fd4 <_dwarf_lineno_init+0x560>
		goto fail_cleanup;
  8004214fd2:	eb 07                	jmp    8004214fdb <_dwarf_lineno_init+0x567>

	//cu->cu_lineinfo = li;

	return (DW_DLE_NONE);
  8004214fd4:	b8 00 00 00 00       	mov    $0x0,%eax
  8004214fd9:	eb 03                	jmp    8004214fde <_dwarf_lineno_init+0x56a>
fail_cleanup:

	/*if (li->li_oplen)
	  free(li->li_oplen);*/

	return (ret);
  8004214fdb:	8b 45 dc             	mov    -0x24(%rbp),%eax
}
  8004214fde:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
  8004214fe5:	5b                   	pop    %rbx
  8004214fe6:	5d                   	pop    %rbp
  8004214fe7:	c3                   	retq   

0000008004214fe8 <dwarf_srclines>:

int
dwarf_srclines(Dwarf_Die *die, Dwarf_Line linebuf, Dwarf_Addr pc, Dwarf_Error *error)
{
  8004214fe8:	55                   	push   %rbp
  8004214fe9:	48 89 e5             	mov    %rsp,%rbp
  8004214fec:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
  8004214ff3:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
  8004214ffa:	48 89 b5 60 ff ff ff 	mov    %rsi,-0xa0(%rbp)
  8004215001:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
  8004215008:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
	_Dwarf_LineInfo li;
	Dwarf_Attribute *at;

	assert(die);
  800421500f:	48 83 bd 68 ff ff ff 	cmpq   $0x0,-0x98(%rbp)
  8004215016:	00 
  8004215017:	75 35                	jne    800421504e <dwarf_srclines+0x66>
  8004215019:	48 b9 1f a4 21 04 80 	movabs $0x800421a41f,%rcx
  8004215020:	00 00 00 
  8004215023:	48 ba e7 a3 21 04 80 	movabs $0x800421a3e7,%rdx
  800421502a:	00 00 00 
  800421502d:	be ae 01 00 00       	mov    $0x1ae,%esi
  8004215032:	48 bf fc a3 21 04 80 	movabs $0x800421a3fc,%rdi
  8004215039:	00 00 00 
  800421503c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215041:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004215048:	00 00 00 
  800421504b:	41 ff d0             	callq  *%r8
	assert(linebuf);
  800421504e:	48 83 bd 60 ff ff ff 	cmpq   $0x0,-0xa0(%rbp)
  8004215055:	00 
  8004215056:	75 35                	jne    800421508d <dwarf_srclines+0xa5>
  8004215058:	48 b9 23 a4 21 04 80 	movabs $0x800421a423,%rcx
  800421505f:	00 00 00 
  8004215062:	48 ba e7 a3 21 04 80 	movabs $0x800421a3e7,%rdx
  8004215069:	00 00 00 
  800421506c:	be af 01 00 00       	mov    $0x1af,%esi
  8004215071:	48 bf fc a3 21 04 80 	movabs $0x800421a3fc,%rdi
  8004215078:	00 00 00 
  800421507b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215080:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004215087:	00 00 00 
  800421508a:	41 ff d0             	callq  *%r8

	memset(&li, 0, sizeof(_Dwarf_LineInfo));
  800421508d:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
  8004215094:	ba 88 00 00 00       	mov    $0x88,%edx
  8004215099:	be 00 00 00 00       	mov    $0x0,%esi
  800421509e:	48 89 c7             	mov    %rax,%rdi
  80042150a1:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  80042150a8:	00 00 00 
  80042150ab:	ff d0                	callq  *%rax

	if ((at = _dwarf_attr_find(die, DW_AT_stmt_list)) == NULL) {
  80042150ad:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  80042150b4:	be 10 00 00 00       	mov    $0x10,%esi
  80042150b9:	48 89 c7             	mov    %rax,%rdi
  80042150bc:	48 b8 b2 19 21 04 80 	movabs $0x80042119b2,%rax
  80042150c3:	00 00 00 
  80042150c6:	ff d0                	callq  *%rax
  80042150c8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  80042150cc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  80042150d1:	75 0a                	jne    80042150dd <dwarf_srclines+0xf5>
		DWARF_SET_ERROR(dbg, error, DW_DLE_NO_ENTRY);
		return (DW_DLV_NO_ENTRY);
  80042150d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80042150d8:	e9 84 00 00 00       	jmpq   8004215161 <dwarf_srclines+0x179>
	}

	if (_dwarf_lineno_init(die, at->u[0].u64, &li, pc, error) !=
  80042150dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042150e1:	48 8b 70 28          	mov    0x28(%rax),%rsi
  80042150e5:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
  80042150ec:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
  80042150f3:	48 8d 95 70 ff ff ff 	lea    -0x90(%rbp),%rdx
  80042150fa:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215101:	49 89 f8             	mov    %rdi,%r8
  8004215104:	48 89 c7             	mov    %rax,%rdi
  8004215107:	48 b8 74 4a 21 04 80 	movabs $0x8004214a74,%rax
  800421510e:	00 00 00 
  8004215111:	ff d0                	callq  *%rax
  8004215113:	85 c0                	test   %eax,%eax
  8004215115:	74 07                	je     800421511e <dwarf_srclines+0x136>
	    DW_DLE_NONE)
	{
		return (DW_DLV_ERROR);
  8004215117:	b8 01 00 00 00       	mov    $0x1,%eax
  800421511c:	eb 43                	jmp    8004215161 <dwarf_srclines+0x179>
	}
	*linebuf = li.li_line;
  800421511e:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
  8004215125:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
  8004215129:	48 89 10             	mov    %rdx,(%rax)
  800421512c:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
  8004215130:	48 89 50 08          	mov    %rdx,0x8(%rax)
  8004215134:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
  8004215138:	48 89 50 10          	mov    %rdx,0x10(%rax)
  800421513c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
  8004215140:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215144:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215148:	48 89 50 20          	mov    %rdx,0x20(%rax)
  800421514c:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215150:	48 89 50 28          	mov    %rdx,0x28(%rax)
  8004215154:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215158:	48 89 50 30          	mov    %rdx,0x30(%rax)

	return (DW_DLV_OK);
  800421515c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004215161:	c9                   	leaveq 
  8004215162:	c3                   	retq   

0000008004215163 <_dwarf_find_section>:
uintptr_t
read_section_headers(uintptr_t, uintptr_t);

Dwarf_Section *
_dwarf_find_section(const char *name)
{
  8004215163:	55                   	push   %rbp
  8004215164:	48 89 e5             	mov    %rsp,%rbp
  8004215167:	48 83 ec 20          	sub    $0x20,%rsp
  800421516b:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	Dwarf_Section *ret=NULL;
  800421516f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
  8004215176:	00 
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  8004215177:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  800421517e:	eb 57                	jmp    80042151d7 <_dwarf_find_section+0x74>
		if(!strcmp(section_info[i].ds_name, name)) {
  8004215180:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215187:	00 00 00 
  800421518a:	8b 55 f4             	mov    -0xc(%rbp),%edx
  800421518d:	48 63 d2             	movslq %edx,%rdx
  8004215190:	48 c1 e2 05          	shl    $0x5,%rdx
  8004215194:	48 01 d0             	add    %rdx,%rax
  8004215197:	48 8b 00             	mov    (%rax),%rax
  800421519a:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  800421519e:	48 89 d6             	mov    %rdx,%rsi
  80042151a1:	48 89 c7             	mov    %rax,%rdi
  80042151a4:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  80042151ab:	00 00 00 
  80042151ae:	ff d0                	callq  *%rax
  80042151b0:	85 c0                	test   %eax,%eax
  80042151b2:	75 1f                	jne    80042151d3 <_dwarf_find_section+0x70>
			ret = (section_info + i);
  80042151b4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042151b7:	48 98                	cltq   
  80042151b9:	48 c1 e0 05          	shl    $0x5,%rax
  80042151bd:	48 89 c2             	mov    %rax,%rdx
  80042151c0:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042151c7:	00 00 00 
  80042151ca:	48 01 d0             	add    %rdx,%rax
  80042151cd:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
			break;
  80042151d1:	eb 0a                	jmp    80042151dd <_dwarf_find_section+0x7a>
_dwarf_find_section(const char *name)
{
	Dwarf_Section *ret=NULL;
	int i;

	for(i=0; i < NDEBUG_SECT; i++) {
  80042151d3:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  80042151d7:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
  80042151db:	7e a3                	jle    8004215180 <_dwarf_find_section+0x1d>
			ret = (section_info + i);
			break;
		}
	}

	return ret;
  80042151dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
  80042151e1:	c9                   	leaveq 
  80042151e2:	c3                   	retq   

00000080042151e3 <find_debug_sections>:

void find_debug_sections(uintptr_t elf) 
{
  80042151e3:	55                   	push   %rbp
  80042151e4:	48 89 e5             	mov    %rsp,%rbp
  80042151e7:	48 83 ec 40          	sub    $0x40,%rsp
  80042151eb:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
	Elf *ehdr = (Elf *)elf;
  80042151ef:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  80042151f3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	uintptr_t debug_address = USTABDATA;
  80042151f7:	48 c7 45 f8 00 00 20 	movq   $0x200000,-0x8(%rbp)
  80042151fe:	00 
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
  80042151ff:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215203:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004215207:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421520b:	48 01 d0             	add    %rdx,%rax
  800421520e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
  8004215212:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215216:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  800421521a:	0f b7 c0             	movzwl %ax,%eax
  800421521d:	48 c1 e0 06          	shl    $0x6,%rax
  8004215221:	48 89 c2             	mov    %rax,%rdx
  8004215224:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215228:	48 01 d0             	add    %rdx,%rax
  800421522b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	Secthdr* esh = sh + ehdr->e_shnum;
  800421522f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215233:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  8004215237:	0f b7 c0             	movzwl %ax,%eax
  800421523a:	48 c1 e0 06          	shl    $0x6,%rax
  800421523e:	48 89 c2             	mov    %rax,%rdx
  8004215241:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215245:	48 01 d0             	add    %rdx,%rax
  8004215248:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	for(;sh < esh; sh++) {
  800421524c:	e9 4b 02 00 00       	jmpq   800421549c <find_debug_sections+0x2b9>
		char* name = (char*)((uint8_t*)elf + shstr_tab->sh_offset) + sh->sh_name;
  8004215251:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215255:	8b 00                	mov    (%rax),%eax
  8004215257:	89 c2                	mov    %eax,%edx
  8004215259:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421525d:	48 8b 48 18          	mov    0x18(%rax),%rcx
  8004215261:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215265:	48 01 c8             	add    %rcx,%rax
  8004215268:	48 01 d0             	add    %rdx,%rax
  800421526b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
		if(!strcmp(name, ".debug_info")) {
  800421526f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215273:	48 be 2b a4 21 04 80 	movabs $0x800421a42b,%rsi
  800421527a:	00 00 00 
  800421527d:	48 89 c7             	mov    %rax,%rdi
  8004215280:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  8004215287:	00 00 00 
  800421528a:	ff d0                	callq  *%rax
  800421528c:	85 c0                	test   %eax,%eax
  800421528e:	75 4b                	jne    80042152db <find_debug_sections+0xf8>
			section_info[DEBUG_INFO].ds_data = (uint8_t*)debug_address;
  8004215290:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215294:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800421529b:	00 00 00 
  800421529e:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = debug_address;
  80042152a2:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042152a9:	00 00 00 
  80042152ac:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042152b0:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = sh->sh_size;
  80042152b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042152b8:	48 8b 50 20          	mov    0x20(%rax),%rdx
  80042152bc:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042152c3:	00 00 00 
  80042152c6:	48 89 50 18          	mov    %rdx,0x18(%rax)
			debug_address += sh->sh_size;
  80042152ca:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042152ce:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042152d2:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042152d6:	e9 bc 01 00 00       	jmpq   8004215497 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_abbrev")) {
  80042152db:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042152df:	48 be 37 a4 21 04 80 	movabs $0x800421a437,%rsi
  80042152e6:	00 00 00 
  80042152e9:	48 89 c7             	mov    %rax,%rdi
  80042152ec:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  80042152f3:	00 00 00 
  80042152f6:	ff d0                	callq  *%rax
  80042152f8:	85 c0                	test   %eax,%eax
  80042152fa:	75 4b                	jne    8004215347 <find_debug_sections+0x164>
			section_info[DEBUG_ABBREV].ds_data = (uint8_t*)debug_address;
  80042152fc:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215300:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215307:	00 00 00 
  800421530a:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = debug_address;
  800421530e:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215315:	00 00 00 
  8004215318:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421531c:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = sh->sh_size;
  8004215320:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215324:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215328:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800421532f:	00 00 00 
  8004215332:	48 89 50 38          	mov    %rdx,0x38(%rax)
			debug_address += sh->sh_size;
  8004215336:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421533a:	48 8b 40 20          	mov    0x20(%rax),%rax
  800421533e:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215342:	e9 50 01 00 00       	jmpq   8004215497 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_line")){
  8004215347:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421534b:	48 be 4f a4 21 04 80 	movabs $0x800421a44f,%rsi
  8004215352:	00 00 00 
  8004215355:	48 89 c7             	mov    %rax,%rdi
  8004215358:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  800421535f:	00 00 00 
  8004215362:	ff d0                	callq  *%rax
  8004215364:	85 c0                	test   %eax,%eax
  8004215366:	75 4b                	jne    80042153b3 <find_debug_sections+0x1d0>
			section_info[DEBUG_LINE].ds_data = (uint8_t*)debug_address;
  8004215368:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421536c:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215373:	00 00 00 
  8004215376:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = debug_address;
  800421537a:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215381:	00 00 00 
  8004215384:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004215388:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = sh->sh_size;
  800421538c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215390:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215394:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800421539b:	00 00 00 
  800421539e:	48 89 50 78          	mov    %rdx,0x78(%rax)
			debug_address += sh->sh_size;
  80042153a2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153a6:	48 8b 40 20          	mov    0x20(%rax),%rax
  80042153aa:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  80042153ae:	e9 e4 00 00 00       	jmpq   8004215497 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".eh_frame")){
  80042153b3:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042153b7:	48 be 45 a4 21 04 80 	movabs $0x800421a445,%rsi
  80042153be:	00 00 00 
  80042153c1:	48 89 c7             	mov    %rax,%rdi
  80042153c4:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  80042153cb:	00 00 00 
  80042153ce:	ff d0                	callq  *%rax
  80042153d0:	85 c0                	test   %eax,%eax
  80042153d2:	75 53                	jne    8004215427 <find_debug_sections+0x244>
			section_info[DEBUG_FRAME].ds_data = (uint8_t*)sh->sh_addr;
  80042153d4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153d8:	48 8b 40 10          	mov    0x10(%rax),%rax
  80042153dc:	48 89 c2             	mov    %rax,%rdx
  80042153df:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042153e6:	00 00 00 
  80042153e9:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = sh->sh_addr;
  80042153ed:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042153f1:	48 8b 50 10          	mov    0x10(%rax),%rdx
  80042153f5:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042153fc:	00 00 00 
  80042153ff:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = sh->sh_size;
  8004215403:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215407:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421540b:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215412:	00 00 00 
  8004215415:	48 89 50 58          	mov    %rdx,0x58(%rax)
			debug_address += sh->sh_size;
  8004215419:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421541d:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215421:	48 01 45 f8          	add    %rax,-0x8(%rbp)
  8004215425:	eb 70                	jmp    8004215497 <find_debug_sections+0x2b4>
		} else if(!strcmp(name, ".debug_str")) {
  8004215427:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421542b:	48 be 5b a4 21 04 80 	movabs $0x800421a45b,%rsi
  8004215432:	00 00 00 
  8004215435:	48 89 c7             	mov    %rax,%rdi
  8004215438:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  800421543f:	00 00 00 
  8004215442:	ff d0                	callq  *%rax
  8004215444:	85 c0                	test   %eax,%eax
  8004215446:	75 4f                	jne    8004215497 <find_debug_sections+0x2b4>
			section_info[DEBUG_STR].ds_data = (uint8_t*)debug_address;
  8004215448:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421544c:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215453:	00 00 00 
  8004215456:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = debug_address;
  800421545d:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215464:	00 00 00 
  8004215467:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421546b:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = sh->sh_size;
  8004215472:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215476:	48 8b 50 20          	mov    0x20(%rax),%rdx
  800421547a:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215481:	00 00 00 
  8004215484:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
			debug_address += sh->sh_size;
  800421548b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421548f:	48 8b 40 20          	mov    0x20(%rax),%rax
  8004215493:	48 01 45 f8          	add    %rax,-0x8(%rbp)
	Elf *ehdr = (Elf *)elf;
	uintptr_t debug_address = USTABDATA;
	Secthdr *sh = (Secthdr *)(((uint8_t *)ehdr + ehdr->e_shoff));
	Secthdr *shstr_tab = sh + ehdr->e_shstrndx;
	Secthdr* esh = sh + ehdr->e_shnum;
	for(;sh < esh; sh++) {
  8004215497:	48 83 45 f0 40       	addq   $0x40,-0x10(%rbp)
  800421549c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042154a0:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
  80042154a4:	0f 82 a7 fd ff ff    	jb     8004215251 <find_debug_sections+0x6e>
			section_info[DEBUG_STR].ds_size = sh->sh_size;
			debug_address += sh->sh_size;
		}
	}

}
  80042154aa:	c9                   	leaveq 
  80042154ab:	c3                   	retq   

00000080042154ac <read_section_headers>:

uint64_t
read_section_headers(uintptr_t elfhdr, uintptr_t to_va)
{
  80042154ac:	55                   	push   %rbp
  80042154ad:	48 89 e5             	mov    %rsp,%rbp
  80042154b0:	48 81 ec 60 01 00 00 	sub    $0x160,%rsp
  80042154b7:	48 89 bd a8 fe ff ff 	mov    %rdi,-0x158(%rbp)
  80042154be:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
	Secthdr* secthdr_ptr[20] = {0};
  80042154c5:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
  80042154cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80042154d1:	ba 14 00 00 00       	mov    $0x14,%edx
  80042154d6:	48 89 f7             	mov    %rsi,%rdi
  80042154d9:	48 89 d1             	mov    %rdx,%rcx
  80042154dc:	f3 48 ab             	rep stos %rax,%es:(%rdi)
	char* kvbase = ROUNDUP((char*)to_va, SECTSIZE);
  80042154df:	48 c7 45 e8 00 02 00 	movq   $0x200,-0x18(%rbp)
  80042154e6:	00 
  80042154e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042154eb:	48 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%rdx
  80042154f2:	48 01 d0             	add    %rdx,%rax
  80042154f5:	48 83 e8 01          	sub    $0x1,%rax
  80042154f9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  80042154fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215501:	ba 00 00 00 00       	mov    $0x0,%edx
  8004215506:	48 f7 75 e8          	divq   -0x18(%rbp)
  800421550a:	48 89 d0             	mov    %rdx,%rax
  800421550d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  8004215511:	48 29 c2             	sub    %rax,%rdx
  8004215514:	48 89 d0             	mov    %rdx,%rax
  8004215517:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
	uint64_t kvoffset = 0;
  800421551b:	48 c7 85 b8 fe ff ff 	movq   $0x0,-0x148(%rbp)
  8004215522:	00 00 00 00 
	char *orig_secthdr = (char*)kvbase;
  8004215526:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421552a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
	char * secthdr = NULL;
  800421552e:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
  8004215535:	00 
	uint64_t offset;
	if(elfhdr == KELFHDR)
  8004215536:	48 b8 00 00 01 04 80 	movabs $0x8004010000,%rax
  800421553d:	00 00 00 
  8004215540:	48 39 85 a8 fe ff ff 	cmp    %rax,-0x158(%rbp)
  8004215547:	75 11                	jne    800421555a <read_section_headers+0xae>
		offset = ((Elf*)elfhdr)->e_shoff;
  8004215549:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215550:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215554:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004215558:	eb 26                	jmp    8004215580 <read_section_headers+0xd4>
	else
		offset = ((Elf*)elfhdr)->e_shoff + (elfhdr - KERNBASE);
  800421555a:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215561:	48 8b 50 28          	mov    0x28(%rax),%rdx
  8004215565:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  800421556c:	48 01 c2             	add    %rax,%rdx
  800421556f:	48 b8 00 00 00 fc 7f 	movabs $0xffffff7ffc000000,%rax
  8004215576:	ff ff ff 
  8004215579:	48 01 d0             	add    %rdx,%rax
  800421557c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	int numSectionHeaders = ((Elf*)elfhdr)->e_shnum;
  8004215580:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215587:	0f b7 40 3c          	movzwl 0x3c(%rax),%eax
  800421558b:	0f b7 c0             	movzwl %ax,%eax
  800421558e:	89 45 c4             	mov    %eax,-0x3c(%rbp)
	int sizeSections = ((Elf*)elfhdr)->e_shentsize;
  8004215591:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  8004215598:	0f b7 40 3a          	movzwl 0x3a(%rax),%eax
  800421559c:	0f b7 c0             	movzwl %ax,%eax
  800421559f:	89 45 c0             	mov    %eax,-0x40(%rbp)
	char *nametab;
	int i;
	uint64_t temp;
	char *name;

	Elf *ehdr = (Elf *)elfhdr;
  80042155a2:	48 8b 85 a8 fe ff ff 	mov    -0x158(%rbp),%rax
  80042155a9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
  80042155ad:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  80042155b0:	0f af 45 c0          	imul   -0x40(%rbp),%eax
  80042155b4:	48 63 f0             	movslq %eax,%rsi
  80042155b7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042155bb:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  80042155c2:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042155c6:	48 89 c7             	mov    %rax,%rdi
  80042155c9:	48 b8 eb 5b 21 04 80 	movabs $0x8004215beb,%rax
  80042155d0:	00 00 00 
  80042155d3:	ff d0                	callq  *%rax
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
  80042155d5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042155d9:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  80042155dd:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042155e1:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042155e7:	48 89 c2             	mov    %rax,%rdx
  80042155ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042155ee:	48 29 d0             	sub    %rdx,%rax
  80042155f1:	48 89 c2             	mov    %rax,%rdx
  80042155f4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042155f8:	48 01 d0             	add    %rdx,%rax
  80042155fb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
	for (i = 0; i < numSectionHeaders; i++)
  80042155ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004215606:	eb 24                	jmp    800421562c <read_section_headers+0x180>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
  8004215608:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421560b:	48 98                	cltq   
  800421560d:	48 c1 e0 06          	shl    $0x6,%rax
  8004215611:	48 89 c2             	mov    %rax,%rdx
  8004215614:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215618:	48 01 c2             	add    %rax,%rdx
  800421561b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421561e:	48 98                	cltq   
  8004215620:	48 89 94 c5 c0 fe ff 	mov    %rdx,-0x140(%rbp,%rax,8)
  8004215627:	ff 
	Secthdr *sec_name;  

	readseg((uint64_t)orig_secthdr , numSectionHeaders * sizeSections,
		offset, &kvoffset);
	secthdr = (char*)orig_secthdr + (offset - ROUNDDOWN(offset, SECTSIZE));
	for (i = 0; i < numSectionHeaders; i++)
  8004215628:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  800421562c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421562f:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004215632:	7c d4                	jl     8004215608 <read_section_headers+0x15c>
	{
		secthdr_ptr[i] = (Secthdr*)(secthdr) + i;
	}
	
	sec_name = secthdr_ptr[ehdr->e_shstrndx]; 
  8004215634:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004215638:	0f b7 40 3e          	movzwl 0x3e(%rax),%eax
  800421563c:	0f b7 c0             	movzwl %ax,%eax
  800421563f:	48 98                	cltq   
  8004215641:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215648:	ff 
  8004215649:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
	temp = kvoffset;
  800421564d:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215654:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
  8004215658:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  800421565c:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215660:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215664:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215668:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  800421566f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215673:	48 01 c8             	add    %rcx,%rax
  8004215676:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  800421567d:	48 89 c7             	mov    %rax,%rdi
  8004215680:	48 b8 eb 5b 21 04 80 	movabs $0x8004215beb,%rax
  8004215687:	00 00 00 
  800421568a:	ff d0                	callq  *%rax
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	
  800421568c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215690:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215694:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215698:	48 8b 40 18          	mov    0x18(%rax),%rax
  800421569c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
  80042156a0:	48 8b 45 98          	mov    -0x68(%rbp),%rax
  80042156a4:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042156aa:	48 29 c2             	sub    %rax,%rdx
  80042156ad:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042156b1:	48 01 c2             	add    %rax,%rdx
  80042156b4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042156b8:	48 01 d0             	add    %rdx,%rax
  80042156bb:	48 89 45 90          	mov    %rax,-0x70(%rbp)

    
	for (i = 0; i < numSectionHeaders; i++)
  80042156bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  80042156c6:	e9 04 05 00 00       	jmpq   8004215bcf <read_section_headers+0x723>
	{
		name = (char *)(nametab + secthdr_ptr[i]->sh_name);
  80042156cb:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042156ce:	48 98                	cltq   
  80042156d0:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042156d7:	ff 
  80042156d8:	8b 00                	mov    (%rax),%eax
  80042156da:	89 c2                	mov    %eax,%edx
  80042156dc:	48 8b 45 90          	mov    -0x70(%rbp),%rax
  80042156e0:	48 01 d0             	add    %rdx,%rax
  80042156e3:	48 89 45 88          	mov    %rax,-0x78(%rbp)
		assert(kvoffset % SECTSIZE == 0);
  80042156e7:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  80042156ee:	25 ff 01 00 00       	and    $0x1ff,%eax
  80042156f3:	48 85 c0             	test   %rax,%rax
  80042156f6:	74 35                	je     800421572d <read_section_headers+0x281>
  80042156f8:	48 b9 66 a4 21 04 80 	movabs $0x800421a466,%rcx
  80042156ff:	00 00 00 
  8004215702:	48 ba 7f a4 21 04 80 	movabs $0x800421a47f,%rdx
  8004215709:	00 00 00 
  800421570c:	be 87 00 00 00       	mov    $0x87,%esi
  8004215711:	48 bf 94 a4 21 04 80 	movabs $0x800421a494,%rdi
  8004215718:	00 00 00 
  800421571b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215720:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004215727:	00 00 00 
  800421572a:	41 ff d0             	callq  *%r8
		temp = kvoffset;
  800421572d:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215734:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
  8004215738:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421573c:	48 be 2b a4 21 04 80 	movabs $0x800421a42b,%rsi
  8004215743:	00 00 00 
  8004215746:	48 89 c7             	mov    %rax,%rdi
  8004215749:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  8004215750:	00 00 00 
  8004215753:	ff d0                	callq  *%rax
  8004215755:	85 c0                	test   %eax,%eax
  8004215757:	0f 85 d8 00 00 00    	jne    8004215835 <read_section_headers+0x389>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421575d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215760:	48 98                	cltq   
  8004215762:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215769:	ff 
#ifdef DWARF_DEBUG
		cprintf("SectName: %s\n", name);
#endif
		if(!strcmp(name, ".debug_info"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  800421576a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421576e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215771:	48 98                	cltq   
  8004215773:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421577a:	ff 
  800421577b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421577f:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215786:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421578a:	48 01 c8             	add    %rcx,%rax
  800421578d:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215794:	48 89 c7             	mov    %rax,%rdi
  8004215797:	48 b8 eb 5b 21 04 80 	movabs $0x8004215beb,%rax
  800421579e:	00 00 00 
  80042157a1:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_INFO].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042157a3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042157a6:	48 98                	cltq   
  80042157a8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042157af:	ff 
  80042157b0:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042157b4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042157b7:	48 98                	cltq   
  80042157b9:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042157c0:	ff 
  80042157c1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042157c5:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  80042157c9:	48 8b 45 80          	mov    -0x80(%rbp),%rax
  80042157cd:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042157d3:	48 29 c2             	sub    %rax,%rdx
  80042157d6:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042157da:	48 01 c2             	add    %rax,%rdx
  80042157dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042157e1:	48 01 c2             	add    %rax,%rdx
  80042157e4:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042157eb:	00 00 00 
  80042157ee:	48 89 50 08          	mov    %rdx,0x8(%rax)
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
  80042157f2:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042157f9:	00 00 00 
  80042157fc:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004215800:	48 89 c2             	mov    %rax,%rdx
  8004215803:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800421580a:	00 00 00 
  800421580d:	48 89 50 10          	mov    %rdx,0x10(%rax)
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
  8004215811:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215814:	48 98                	cltq   
  8004215816:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421581d:	ff 
  800421581e:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215822:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215829:	00 00 00 
  800421582c:	48 89 50 18          	mov    %rdx,0x18(%rax)
  8004215830:	e9 96 03 00 00       	jmpq   8004215bcb <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_abbrev"))
  8004215835:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215839:	48 be 37 a4 21 04 80 	movabs $0x800421a437,%rsi
  8004215840:	00 00 00 
  8004215843:	48 89 c7             	mov    %rax,%rdi
  8004215846:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  800421584d:	00 00 00 
  8004215850:	ff d0                	callq  *%rax
  8004215852:	85 c0                	test   %eax,%eax
  8004215854:	0f 85 de 00 00 00    	jne    8004215938 <read_section_headers+0x48c>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421585a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421585d:	48 98                	cltq   
  800421585f:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215866:	ff 
			section_info[DEBUG_INFO].ds_addr = (uintptr_t)section_info[DEBUG_INFO].ds_data;
			section_info[DEBUG_INFO].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_abbrev"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215867:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421586b:	8b 45 f4             	mov    -0xc(%rbp),%eax
  800421586e:	48 98                	cltq   
  8004215870:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215877:	ff 
  8004215878:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421587c:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215883:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215887:	48 01 c8             	add    %rcx,%rax
  800421588a:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215891:	48 89 c7             	mov    %rax,%rdi
  8004215894:	48 b8 eb 5b 21 04 80 	movabs $0x8004215beb,%rax
  800421589b:	00 00 00 
  800421589e:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_ABBREV].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042158a0:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158a3:	48 98                	cltq   
  80042158a5:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158ac:	ff 
  80042158ad:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042158b1:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042158b4:	48 98                	cltq   
  80042158b6:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042158bd:	ff 
  80042158be:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042158c2:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  80042158c9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
  80042158d0:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042158d6:	48 29 c2             	sub    %rax,%rdx
  80042158d9:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042158dd:	48 01 c2             	add    %rax,%rdx
  80042158e0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042158e4:	48 01 c2             	add    %rax,%rdx
  80042158e7:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042158ee:	00 00 00 
  80042158f1:	48 89 50 28          	mov    %rdx,0x28(%rax)
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
  80042158f5:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042158fc:	00 00 00 
  80042158ff:	48 8b 40 28          	mov    0x28(%rax),%rax
  8004215903:	48 89 c2             	mov    %rax,%rdx
  8004215906:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800421590d:	00 00 00 
  8004215910:	48 89 50 30          	mov    %rdx,0x30(%rax)
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
  8004215914:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215917:	48 98                	cltq   
  8004215919:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215920:	ff 
  8004215921:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215925:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  800421592c:	00 00 00 
  800421592f:	48 89 50 38          	mov    %rdx,0x38(%rax)
  8004215933:	e9 93 02 00 00       	jmpq   8004215bcb <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_line"))
  8004215938:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  800421593c:	48 be 4f a4 21 04 80 	movabs $0x800421a44f,%rsi
  8004215943:	00 00 00 
  8004215946:	48 89 c7             	mov    %rax,%rdi
  8004215949:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  8004215950:	00 00 00 
  8004215953:	ff d0                	callq  *%rax
  8004215955:	85 c0                	test   %eax,%eax
  8004215957:	0f 85 de 00 00 00    	jne    8004215a3b <read_section_headers+0x58f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  800421595d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215960:	48 98                	cltq   
  8004215962:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215969:	ff 
			section_info[DEBUG_ABBREV].ds_addr = (uintptr_t)section_info[DEBUG_ABBREV].ds_data;
			section_info[DEBUG_ABBREV].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_line"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  800421596a:	48 8b 50 18          	mov    0x18(%rax),%rdx
  800421596e:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215971:	48 98                	cltq   
  8004215973:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  800421597a:	ff 
  800421597b:	48 8b 70 20          	mov    0x20(%rax),%rsi
  800421597f:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215986:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421598a:	48 01 c8             	add    %rcx,%rax
  800421598d:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215994:	48 89 c7             	mov    %rax,%rdi
  8004215997:	48 b8 eb 5b 21 04 80 	movabs $0x8004215beb,%rax
  800421599e:	00 00 00 
  80042159a1:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_LINE].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  80042159a3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042159a6:	48 98                	cltq   
  80042159a8:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042159af:	ff 
  80042159b0:	48 8b 50 18          	mov    0x18(%rax),%rdx
  80042159b4:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042159b7:	48 98                	cltq   
  80042159b9:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  80042159c0:	ff 
  80042159c1:	48 8b 40 18          	mov    0x18(%rax),%rax
  80042159c5:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  80042159cc:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
  80042159d3:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  80042159d9:	48 29 c2             	sub    %rax,%rdx
  80042159dc:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  80042159e0:	48 01 c2             	add    %rax,%rdx
  80042159e3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042159e7:	48 01 c2             	add    %rax,%rdx
  80042159ea:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042159f1:	00 00 00 
  80042159f4:	48 89 50 68          	mov    %rdx,0x68(%rax)
			section_info[DEBUG_LINE].ds_addr = (uintptr_t)section_info[DEBUG_LINE].ds_data;
  80042159f8:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  80042159ff:	00 00 00 
  8004215a02:	48 8b 40 68          	mov    0x68(%rax),%rax
  8004215a06:	48 89 c2             	mov    %rax,%rdx
  8004215a09:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215a10:	00 00 00 
  8004215a13:	48 89 50 70          	mov    %rdx,0x70(%rax)
			section_info[DEBUG_LINE].ds_size = secthdr_ptr[i]->sh_size;
  8004215a17:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a1a:	48 98                	cltq   
  8004215a1c:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215a23:	ff 
  8004215a24:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215a28:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215a2f:	00 00 00 
  8004215a32:	48 89 50 78          	mov    %rdx,0x78(%rax)
  8004215a36:	e9 90 01 00 00       	jmpq   8004215bcb <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".eh_frame"))
  8004215a3b:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215a3f:	48 be 45 a4 21 04 80 	movabs $0x800421a445,%rsi
  8004215a46:	00 00 00 
  8004215a49:	48 89 c7             	mov    %rax,%rdi
  8004215a4c:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  8004215a53:	00 00 00 
  8004215a56:	ff d0                	callq  *%rax
  8004215a58:	85 c0                	test   %eax,%eax
  8004215a5a:	75 65                	jne    8004215ac1 <read_section_headers+0x615>
		{
			section_info[DEBUG_FRAME].ds_data = (uint8_t *)secthdr_ptr[i]->sh_addr;
  8004215a5c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215a5f:	48 98                	cltq   
  8004215a61:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215a68:	ff 
  8004215a69:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004215a6d:	48 89 c2             	mov    %rax,%rdx
  8004215a70:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215a77:	00 00 00 
  8004215a7a:	48 89 50 48          	mov    %rdx,0x48(%rax)
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
  8004215a7e:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215a85:	00 00 00 
  8004215a88:	48 8b 40 48          	mov    0x48(%rax),%rax
  8004215a8c:	48 89 c2             	mov    %rax,%rdx
  8004215a8f:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215a96:	00 00 00 
  8004215a99:	48 89 50 50          	mov    %rdx,0x50(%rax)
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
  8004215a9d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215aa0:	48 98                	cltq   
  8004215aa2:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215aa9:	ff 
  8004215aaa:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215aae:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215ab5:	00 00 00 
  8004215ab8:	48 89 50 58          	mov    %rdx,0x58(%rax)
  8004215abc:	e9 0a 01 00 00       	jmpq   8004215bcb <read_section_headers+0x71f>
		}
		else if(!strcmp(name, ".debug_str"))
  8004215ac1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
  8004215ac5:	48 be 5b a4 21 04 80 	movabs $0x800421a45b,%rsi
  8004215acc:	00 00 00 
  8004215acf:	48 89 c7             	mov    %rax,%rdi
  8004215ad2:	48 b8 46 f9 20 04 80 	movabs $0x800420f946,%rax
  8004215ad9:	00 00 00 
  8004215adc:	ff d0                	callq  *%rax
  8004215ade:	85 c0                	test   %eax,%eax
  8004215ae0:	0f 85 e5 00 00 00    	jne    8004215bcb <read_section_headers+0x71f>
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
				secthdr_ptr[i]->sh_offset, &kvoffset);	
  8004215ae6:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215ae9:	48 98                	cltq   
  8004215aeb:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215af2:	ff 
			section_info[DEBUG_FRAME].ds_addr = (uintptr_t)section_info[DEBUG_FRAME].ds_data;
			section_info[DEBUG_FRAME].ds_size = secthdr_ptr[i]->sh_size;
		}
		else if(!strcmp(name, ".debug_str"))
		{
			readseg((uint64_t)((char *)kvbase + kvoffset), secthdr_ptr[i]->sh_size, 
  8004215af3:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215af7:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215afa:	48 98                	cltq   
  8004215afc:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215b03:	ff 
  8004215b04:	48 8b 70 20          	mov    0x20(%rax),%rsi
  8004215b08:	48 8b 8d b8 fe ff ff 	mov    -0x148(%rbp),%rcx
  8004215b0f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215b13:	48 01 c8             	add    %rcx,%rax
  8004215b16:	48 8d 8d b8 fe ff ff 	lea    -0x148(%rbp),%rcx
  8004215b1d:	48 89 c7             	mov    %rax,%rdi
  8004215b20:	48 b8 eb 5b 21 04 80 	movabs $0x8004215beb,%rax
  8004215b27:	00 00 00 
  8004215b2a:	ff d0                	callq  *%rax
				secthdr_ptr[i]->sh_offset, &kvoffset);	
			section_info[DEBUG_STR].ds_data = (uint8_t *)((char *)kvbase + temp) + OFFSET_CORRECT(secthdr_ptr[i]->sh_offset);
  8004215b2c:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215b2f:	48 98                	cltq   
  8004215b31:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215b38:	ff 
  8004215b39:	48 8b 50 18          	mov    0x18(%rax),%rdx
  8004215b3d:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215b40:	48 98                	cltq   
  8004215b42:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215b49:	ff 
  8004215b4a:	48 8b 40 18          	mov    0x18(%rax),%rax
  8004215b4e:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  8004215b55:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
  8004215b5c:	48 25 00 fe ff ff    	and    $0xfffffffffffffe00,%rax
  8004215b62:	48 29 c2             	sub    %rax,%rdx
  8004215b65:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215b69:	48 01 c2             	add    %rax,%rdx
  8004215b6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215b70:	48 01 c2             	add    %rax,%rdx
  8004215b73:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215b7a:	00 00 00 
  8004215b7d:	48 89 90 88 00 00 00 	mov    %rdx,0x88(%rax)
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
  8004215b84:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215b8b:	00 00 00 
  8004215b8e:	48 8b 80 88 00 00 00 	mov    0x88(%rax),%rax
  8004215b95:	48 89 c2             	mov    %rax,%rdx
  8004215b98:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215b9f:	00 00 00 
  8004215ba2:	48 89 90 90 00 00 00 	mov    %rdx,0x90(%rax)
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
  8004215ba9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215bac:	48 98                	cltq   
  8004215bae:	48 8b 84 c5 c0 fe ff 	mov    -0x140(%rbp,%rax,8),%rax
  8004215bb5:	ff 
  8004215bb6:	48 8b 50 20          	mov    0x20(%rax),%rdx
  8004215bba:	48 b8 a0 b6 22 04 80 	movabs $0x800422b6a0,%rax
  8004215bc1:	00 00 00 
  8004215bc4:	48 89 90 98 00 00 00 	mov    %rdx,0x98(%rax)
	readseg((uint64_t)((char *)kvbase + kvoffset), sec_name->sh_size,
		sec_name->sh_offset, &kvoffset);
	nametab = (char *)((char *)kvbase + temp) + OFFSET_CORRECT(sec_name->sh_offset);	

    
	for (i = 0; i < numSectionHeaders; i++)
  8004215bcb:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004215bcf:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004215bd2:	3b 45 c4             	cmp    -0x3c(%rbp),%eax
  8004215bd5:	0f 8c f0 fa ff ff    	jl     80042156cb <read_section_headers+0x21f>
			section_info[DEBUG_STR].ds_addr = (uintptr_t)section_info[DEBUG_STR].ds_data;
			section_info[DEBUG_STR].ds_size = secthdr_ptr[i]->sh_size;
		}
	}
	
	return ((uintptr_t)kvbase + kvoffset);
  8004215bdb:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215bdf:	48 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%rax
  8004215be6:	48 01 d0             	add    %rdx,%rax
}
  8004215be9:	c9                   	leaveq 
  8004215bea:	c3                   	retq   

0000008004215beb <readseg>:

// Read 'count' bytes at 'offset' from kernel into physical address 'pa'.
// Might copy more than asked
void
readseg(uint64_t pa, uint64_t count, uint64_t offset, uint64_t* kvoffset)
{
  8004215beb:	55                   	push   %rbp
  8004215bec:	48 89 e5             	mov    %rsp,%rbp
  8004215bef:	48 83 ec 30          	sub    $0x30,%rsp
  8004215bf3:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215bf7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  8004215bfb:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
  8004215bff:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
	uint64_t end_pa;
	uint64_t orgoff = offset;
  8004215c03:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215c07:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	end_pa = pa + count;
  8004215c0b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215c0f:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004215c13:	48 01 d0             	add    %rdx,%rax
  8004215c16:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

	assert(pa % SECTSIZE == 0);	
  8004215c1a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215c1e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215c23:	48 85 c0             	test   %rax,%rax
  8004215c26:	74 35                	je     8004215c5d <readseg+0x72>
  8004215c28:	48 b9 a2 a4 21 04 80 	movabs $0x800421a4a2,%rcx
  8004215c2f:	00 00 00 
  8004215c32:	48 ba 7f a4 21 04 80 	movabs $0x800421a47f,%rdx
  8004215c39:	00 00 00 
  8004215c3c:	be c1 00 00 00       	mov    $0xc1,%esi
  8004215c41:	48 bf 94 a4 21 04 80 	movabs $0x800421a494,%rdi
  8004215c48:	00 00 00 
  8004215c4b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215c50:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004215c57:	00 00 00 
  8004215c5a:	41 ff d0             	callq  *%r8
	// round down to sector boundary
	pa &= ~(SECTSIZE - 1);
  8004215c5d:	48 81 65 e8 00 fe ff 	andq   $0xfffffffffffffe00,-0x18(%rbp)
  8004215c64:	ff 

	// translate from bytes to sectors, and kernel starts at sector 1
	offset = (offset / SECTSIZE) + 1;
  8004215c65:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004215c69:	48 c1 e8 09          	shr    $0x9,%rax
  8004215c6d:	48 83 c0 01          	add    $0x1,%rax
  8004215c71:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215c75:	eb 3c                	jmp    8004215cb3 <readseg+0xc8>
		readsect((uint8_t*) pa, offset);
  8004215c77:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215c7b:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215c7f:	48 89 d6             	mov    %rdx,%rsi
  8004215c82:	48 89 c7             	mov    %rax,%rdi
  8004215c85:	48 b8 7b 5d 21 04 80 	movabs $0x8004215d7b,%rax
  8004215c8c:	00 00 00 
  8004215c8f:	ff d0                	callq  *%rax
		pa += SECTSIZE;
  8004215c91:	48 81 45 e8 00 02 00 	addq   $0x200,-0x18(%rbp)
  8004215c98:	00 
		*kvoffset += SECTSIZE;
  8004215c99:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215c9d:	48 8b 00             	mov    (%rax),%rax
  8004215ca0:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215ca7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215cab:	48 89 10             	mov    %rdx,(%rax)
		offset++;
  8004215cae:	48 83 45 d8 01       	addq   $0x1,-0x28(%rbp)
	offset = (offset / SECTSIZE) + 1;

	// If this is too slow, we could read lots of sectors at a time.
	// We'd write more to memory than asked, but it doesn't matter --
	// we load in increasing order.
	while (pa < end_pa) {
  8004215cb3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215cb7:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
  8004215cbb:	72 ba                	jb     8004215c77 <readseg+0x8c>
		pa += SECTSIZE;
		*kvoffset += SECTSIZE;
		offset++;
	}

	if(((orgoff % SECTSIZE) + count) > SECTSIZE)
  8004215cbd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004215cc1:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215cc6:	48 89 c2             	mov    %rax,%rdx
  8004215cc9:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004215ccd:	48 01 d0             	add    %rdx,%rax
  8004215cd0:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  8004215cd6:	76 2f                	jbe    8004215d07 <readseg+0x11c>
	{
		readsect((uint8_t*) pa, offset);
  8004215cd8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215cdc:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  8004215ce0:	48 89 d6             	mov    %rdx,%rsi
  8004215ce3:	48 89 c7             	mov    %rax,%rdi
  8004215ce6:	48 b8 7b 5d 21 04 80 	movabs $0x8004215d7b,%rax
  8004215ced:	00 00 00 
  8004215cf0:	ff d0                	callq  *%rax
		*kvoffset += SECTSIZE;
  8004215cf2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215cf6:	48 8b 00             	mov    (%rax),%rax
  8004215cf9:	48 8d 90 00 02 00 00 	lea    0x200(%rax),%rdx
  8004215d00:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215d04:	48 89 10             	mov    %rdx,(%rax)
	}
	assert(*kvoffset % SECTSIZE == 0);
  8004215d07:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004215d0b:	48 8b 00             	mov    (%rax),%rax
  8004215d0e:	25 ff 01 00 00       	and    $0x1ff,%eax
  8004215d13:	48 85 c0             	test   %rax,%rax
  8004215d16:	74 35                	je     8004215d4d <readseg+0x162>
  8004215d18:	48 b9 b5 a4 21 04 80 	movabs $0x800421a4b5,%rcx
  8004215d1f:	00 00 00 
  8004215d22:	48 ba 7f a4 21 04 80 	movabs $0x800421a47f,%rdx
  8004215d29:	00 00 00 
  8004215d2c:	be d7 00 00 00       	mov    $0xd7,%esi
  8004215d31:	48 bf 94 a4 21 04 80 	movabs $0x800421a494,%rdi
  8004215d38:	00 00 00 
  8004215d3b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004215d40:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004215d47:	00 00 00 
  8004215d4a:	41 ff d0             	callq  *%r8
}
  8004215d4d:	c9                   	leaveq 
  8004215d4e:	c3                   	retq   

0000008004215d4f <waitdisk>:

void
waitdisk(void)
{
  8004215d4f:	55                   	push   %rbp
  8004215d50:	48 89 e5             	mov    %rsp,%rbp
  8004215d53:	48 83 ec 10          	sub    $0x10,%rsp
	// wait for disk reaady
	while ((inb(0x1F7) & 0xC0) != 0x40)
  8004215d57:	90                   	nop
  8004215d58:	c7 45 fc f7 01 00 00 	movl   $0x1f7,-0x4(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004215d5f:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215d62:	89 c2                	mov    %eax,%edx
  8004215d64:	ec                   	in     (%dx),%al
  8004215d65:	88 45 fb             	mov    %al,-0x5(%rbp)
    return data;
  8004215d68:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215d6c:	0f b6 c0             	movzbl %al,%eax
  8004215d6f:	25 c0 00 00 00       	and    $0xc0,%eax
  8004215d74:	83 f8 40             	cmp    $0x40,%eax
  8004215d77:	75 df                	jne    8004215d58 <waitdisk+0x9>
		/* do nothing */;
}
  8004215d79:	c9                   	leaveq 
  8004215d7a:	c3                   	retq   

0000008004215d7b <readsect>:

void
readsect(void *dst, uint64_t offset)
{
  8004215d7b:	55                   	push   %rbp
  8004215d7c:	48 89 e5             	mov    %rsp,%rbp
  8004215d7f:	48 83 ec 60          	sub    $0x60,%rsp
  8004215d83:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
  8004215d87:	48 89 75 a0          	mov    %rsi,-0x60(%rbp)
	// wait for disk to be ready
	waitdisk();
  8004215d8b:	48 b8 4f 5d 21 04 80 	movabs $0x8004215d4f,%rax
  8004215d92:	00 00 00 
  8004215d95:	ff d0                	callq  *%rax
  8004215d97:	c7 45 fc f2 01 00 00 	movl   $0x1f2,-0x4(%rbp)
  8004215d9e:	c6 45 fb 01          	movb   $0x1,-0x5(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004215da2:	0f b6 45 fb          	movzbl -0x5(%rbp),%eax
  8004215da6:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004215da9:	ee                   	out    %al,(%dx)

	outb(0x1F2, 1);		// count = 1
	outb(0x1F3, offset);
  8004215daa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215dae:	0f b6 c0             	movzbl %al,%eax
  8004215db1:	c7 45 f4 f3 01 00 00 	movl   $0x1f3,-0xc(%rbp)
  8004215db8:	88 45 f3             	mov    %al,-0xd(%rbp)
  8004215dbb:	0f b6 45 f3          	movzbl -0xd(%rbp),%eax
  8004215dbf:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004215dc2:	ee                   	out    %al,(%dx)
	outb(0x1F4, offset >> 8);
  8004215dc3:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215dc7:	48 c1 e8 08          	shr    $0x8,%rax
  8004215dcb:	0f b6 c0             	movzbl %al,%eax
  8004215dce:	c7 45 ec f4 01 00 00 	movl   $0x1f4,-0x14(%rbp)
  8004215dd5:	88 45 eb             	mov    %al,-0x15(%rbp)
  8004215dd8:	0f b6 45 eb          	movzbl -0x15(%rbp),%eax
  8004215ddc:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215ddf:	ee                   	out    %al,(%dx)
	outb(0x1F5, offset >> 16);
  8004215de0:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215de4:	48 c1 e8 10          	shr    $0x10,%rax
  8004215de8:	0f b6 c0             	movzbl %al,%eax
  8004215deb:	c7 45 e4 f5 01 00 00 	movl   $0x1f5,-0x1c(%rbp)
  8004215df2:	88 45 e3             	mov    %al,-0x1d(%rbp)
  8004215df5:	0f b6 45 e3          	movzbl -0x1d(%rbp),%eax
  8004215df9:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004215dfc:	ee                   	out    %al,(%dx)
	outb(0x1F6, (offset >> 24) | 0xE0);
  8004215dfd:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004215e01:	48 c1 e8 18          	shr    $0x18,%rax
  8004215e05:	83 c8 e0             	or     $0xffffffe0,%eax
  8004215e08:	0f b6 c0             	movzbl %al,%eax
  8004215e0b:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%rbp)
  8004215e12:	88 45 db             	mov    %al,-0x25(%rbp)
  8004215e15:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004215e19:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004215e1c:	ee                   	out    %al,(%dx)
  8004215e1d:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%rbp)
  8004215e24:	c6 45 d3 20          	movb   $0x20,-0x2d(%rbp)
  8004215e28:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004215e2c:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004215e2f:	ee                   	out    %al,(%dx)
	outb(0x1F7, 0x20);	// cmd 0x20 - read sectors

	// wait for disk to be ready
	waitdisk();
  8004215e30:	48 b8 4f 5d 21 04 80 	movabs $0x8004215d4f,%rax
  8004215e37:	00 00 00 
  8004215e3a:	ff d0                	callq  *%rax
  8004215e3c:	c7 45 cc f0 01 00 00 	movl   $0x1f0,-0x34(%rbp)
  8004215e43:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004215e47:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  8004215e4b:	c7 45 bc 80 00 00 00 	movl   $0x80,-0x44(%rbp)
}

    static __inline void
insl(int port, void *addr, int cnt)
{
    __asm __volatile("cld\n\trepne\n\tinsl"			:
  8004215e52:	8b 55 cc             	mov    -0x34(%rbp),%edx
  8004215e55:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
  8004215e59:	8b 45 bc             	mov    -0x44(%rbp),%eax
  8004215e5c:	48 89 ce             	mov    %rcx,%rsi
  8004215e5f:	48 89 f7             	mov    %rsi,%rdi
  8004215e62:	89 c1                	mov    %eax,%ecx
  8004215e64:	fc                   	cld    
  8004215e65:	f2 6d                	repnz insl (%dx),%es:(%rdi)
  8004215e67:	89 c8                	mov    %ecx,%eax
  8004215e69:	48 89 fe             	mov    %rdi,%rsi
  8004215e6c:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  8004215e70:	89 45 bc             	mov    %eax,-0x44(%rbp)

	// read a sector
	insl(0x1F0, dst, SECTSIZE/4);
}
  8004215e73:	c9                   	leaveq 
  8004215e74:	c3                   	retq   
  8004215e75:	0f 1f 00             	nopl   (%rax)

0000008004215e78 <mpentry_start>:
.set pml4, pml4phys

.code16           
.globl mpentry_start
mpentry_start:
	cli
  8004215e78:	fa                   	cli    
	xorw    %ax, %ax
  8004215e79:	31 c0                	xor    %eax,%eax
	movw    %ax, %ds
  8004215e7b:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215e7d:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215e7f:	8e d0                	mov    %eax,%ss
	
	
	lgdt    MPBOOTPHYS(gdt32desc)   // load 32 bit global descritor table
  8004215e81:	0f 01 16             	lgdt   (%rsi)
  8004215e84:	e0 70                	loopne 8004215ef6 <start64+0x10>
	movl    %cr0, %eax
  8004215e86:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215e89:	66 83 c8 01          	or     $0x1,%ax
	movl    %eax, %cr0
  8004215e8d:	0f 22 c0             	mov    %rax,%cr0
	ljmp	$(PROT_MODE_CSEG),$(MPBOOTPHYS(start32))
  8004215e90:	ea                   	(bad)  
  8004215e91:	1d 70 08 00 66       	sbb    $0x66000870,%eax

0000008004215e95 <start32>:

.code32
start32:
	
	movw    $(PROT_MODE_DSEG), %ax
  8004215e95:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215e99:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215e9b:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215e9d:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215e9f:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215ea3:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215ea5:	8e e8                	mov    %eax,%gs

#ifndef VMM_GUEST
    movl $CR4_PAE,%eax
#else
    movl $(CR4_PAE|CR4_VMXE),%eax
  8004215ea7:	b8 20 20 00 00       	mov    $0x2020,%eax
#endif

	movl %eax,%cr4
  8004215eac:	0f 22 e0             	mov    %rax,%cr4
	
	lgdt    MPBOOTPHYS(gdtdesc)
  8004215eaf:	0f 01 15 c0 70 00 00 	lgdt   0x70c0(%rip)        # 800421cf76 <bootstack+0x1f76>
	movl    %cr0, %eax
  8004215eb6:	0f 20 c0             	mov    %cr0,%rax
	orl     $CR0_PE, %eax
  8004215eb9:	83 c8 01             	or     $0x1,%eax
	movl    %eax, %cr0
  8004215ebc:	0f 22 c0             	mov    %rax,%cr0
	
	# Set up initial page table. We cannot use kern_pgdir yet because
	# we are still running at a low EIP.
	movl    $pml4, %eax
  8004215ebf:	b8 00 20 10 00       	mov    $0x102000,%eax
	movl    %eax, %cr3
  8004215ec4:	0f 22 d8             	mov    %rax,%cr3
	
	# enable the long mode in MSR
	movl $EFER_MSR,%ecx
  8004215ec7:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	rdmsr
  8004215ecc:	0f 32                	rdmsr  
	btsl $EFER_LME,%eax
  8004215ece:	0f ba e8 08          	bts    $0x8,%eax
	wrmsr
  8004215ed2:	0f 30                	wrmsr  
	
	# Turn on paging.
	movl    %cr0, %eax
  8004215ed4:	0f 20 c0             	mov    %cr0,%rax
	orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
  8004215ed7:	0d 01 00 01 80       	or     $0x80010001,%eax
	movl    %eax, %cr0
  8004215edc:	0f 22 c0             	mov    %rax,%cr0
	

	ljmpl   $(LONG_MODE_CSEG), $(MPBOOTPHYS(start64))
  8004215edf:	ea                   	(bad)  
  8004215ee0:	6e                   	outsb  %ds:(%rsi),(%dx)
  8004215ee1:	70 00                	jo     8004215ee3 <start32+0x4e>
  8004215ee3:	00 08                	add    %cl,(%rax)
	...

0000008004215ee6 <start64>:

.code64
start64:
	movw    $(LONG_MODE_DSEG), %ax
  8004215ee6:	66 b8 10 00          	mov    $0x10,%ax
	movw    %ax, %ds
  8004215eea:	8e d8                	mov    %eax,%ds
	movw    %ax, %es
  8004215eec:	8e c0                	mov    %eax,%es
	movw    %ax, %ss
  8004215eee:	8e d0                	mov    %eax,%ss
	movw    $0, %ax
  8004215ef0:	66 b8 00 00          	mov    $0x0,%ax
	movw    %ax, %fs
  8004215ef4:	8e e0                	mov    %eax,%fs
	movw    %ax, %gs
  8004215ef6:	8e e8                	mov    %eax,%gs

	# Switch to the per-cpu stack allocated in boot_aps()
	movabs    mpentry_kstack, %rax
  8004215ef8:	48 a1 78 97 37 04 80 	movabs 0x8004379778,%rax
  8004215eff:	00 00 00 
	movq    %rax,%rsp
  8004215f02:	48 89 c4             	mov    %rax,%rsp
	movq    $0x0, %rbp       # nuke frame pointer
  8004215f05:	48 c7 c5 00 00 00 00 	mov    $0x0,%rbp

	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movabs    $mp_main, %rax
  8004215f0c:	48 b8 93 05 20 04 80 	movabs $0x8004200593,%rax
  8004215f13:	00 00 00 
	call    *%rax
  8004215f16:	ff d0                	callq  *%rax

0000008004215f18 <spin>:

	# If mp_main returns (it shouldn't), loop.
spin:
	jmp     spin
  8004215f18:	eb fe                	jmp    8004215f18 <spin>
  8004215f1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000008004215f20 <gdt>:
	...
  8004215f28:	ff                   	(bad)  
  8004215f29:	ff 00                	incl   (%rax)
  8004215f2b:	00 00                	add    %al,(%rax)
  8004215f2d:	9a                   	(bad)  
  8004215f2e:	af                   	scas   %es:(%rdi),%eax
  8004215f2f:	00 ff                	add    %bh,%bh
  8004215f31:	ff 00                	incl   (%rax)
  8004215f33:	00 00                	add    %al,(%rax)
  8004215f35:	92                   	xchg   %eax,%edx
  8004215f36:	af                   	scas   %es:(%rdi),%eax
	...

0000008004215f38 <gdtdesc>:
  8004215f38:	17                   	(bad)  
  8004215f39:	00 a8 70 00 00 66    	add    %ch,0x66000070(%rax)
  8004215f3f:	90                   	nop

0000008004215f40 <gdt32>:
	...
  8004215f48:	ff                   	(bad)  
  8004215f49:	ff 00                	incl   (%rax)
  8004215f4b:	00 00                	add    %al,(%rax)
  8004215f4d:	9a                   	(bad)  
  8004215f4e:	cf                   	iret   
  8004215f4f:	00 ff                	add    %bh,%bh
  8004215f51:	ff 00                	incl   (%rax)
  8004215f53:	00 00                	add    %al,(%rax)
  8004215f55:	92                   	xchg   %eax,%edx
  8004215f56:	cf                   	iret   
	...

0000008004215f58 <gdt32desc>:
  8004215f58:	17                   	(bad)  
  8004215f59:	00 c8                	add    %cl,%al
  8004215f5b:	70 00                	jo     8004215f5d <gdt32desc+0x5>
	...

0000008004215f5e <mpentry_end>:
	.long   MPBOOTPHYS(gdt32)			# address gdt


.globl mpentry_end
mpentry_end:
	nop
  8004215f5e:	90                   	nop

0000008004215f5f <sum>:
#define MPIOINTR  0x03  // One per bus interrupt source
#define MPLINTR   0x04  // One per system interrupt source

static uint8_t
sum(void *addr, int len)
{
  8004215f5f:	55                   	push   %rbp
  8004215f60:	48 89 e5             	mov    %rsp,%rbp
  8004215f63:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004215f67:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004215f6b:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	int i, sum;

	sum = 0;
  8004215f6e:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
	for (i = 0; i < len; i++)
  8004215f75:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004215f7c:	eb 1a                	jmp    8004215f98 <sum+0x39>
		sum += ((uint8_t *)addr)[i];
  8004215f7e:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215f81:	48 63 d0             	movslq %eax,%rdx
  8004215f84:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004215f88:	48 01 d0             	add    %rdx,%rax
  8004215f8b:	0f b6 00             	movzbl (%rax),%eax
  8004215f8e:	0f b6 c0             	movzbl %al,%eax
  8004215f91:	01 45 f8             	add    %eax,-0x8(%rbp)
sum(void *addr, int len)
{
	int i, sum;

	sum = 0;
	for (i = 0; i < len; i++)
  8004215f94:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004215f98:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004215f9b:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  8004215f9e:	7c de                	jl     8004215f7e <sum+0x1f>
		sum += ((uint8_t *)addr)[i];
	return sum;
  8004215fa0:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  8004215fa3:	c9                   	leaveq 
  8004215fa4:	c3                   	retq   

0000008004215fa5 <mpsearch1>:

// Look for an MP structure in the len bytes at physical address addr.
static struct mp *
mpsearch1(physaddr_t a, int len)
{
  8004215fa5:	55                   	push   %rbp
  8004215fa6:	48 89 e5             	mov    %rsp,%rbp
  8004215fa9:	48 83 ec 40          	sub    $0x40,%rsp
  8004215fad:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
  8004215fb1:	89 75 c4             	mov    %esi,-0x3c(%rbp)
	struct mp *mp = KADDR(a), *end = KADDR(a + len);
  8004215fb4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  8004215fb8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004215fbc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215fc0:	48 c1 e8 0c          	shr    $0xc,%rax
  8004215fc4:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004215fc7:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004215fca:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004215fd1:	00 00 00 
  8004215fd4:	48 8b 00             	mov    (%rax),%rax
  8004215fd7:	48 39 c2             	cmp    %rax,%rdx
  8004215fda:	72 32                	jb     800421600e <mpsearch1+0x69>
  8004215fdc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004215fe0:	48 89 c1             	mov    %rax,%rcx
  8004215fe3:	48 ba d0 a4 21 04 80 	movabs $0x800421a4d0,%rdx
  8004215fea:	00 00 00 
  8004215fed:	be 58 00 00 00       	mov    $0x58,%esi
  8004215ff2:	48 bf f3 a4 21 04 80 	movabs $0x800421a4f3,%rdi
  8004215ff9:	00 00 00 
  8004215ffc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216001:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004216008:	00 00 00 
  800421600b:	41 ff d0             	callq  *%r8
  800421600e:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216015:	00 00 00 
  8004216018:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421601c:	48 01 d0             	add    %rdx,%rax
  800421601f:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  8004216023:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004216026:	48 63 d0             	movslq %eax,%rdx
  8004216029:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421602d:	48 01 d0             	add    %rdx,%rax
  8004216030:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  8004216034:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216038:	48 c1 e8 0c          	shr    $0xc,%rax
  800421603c:	89 45 dc             	mov    %eax,-0x24(%rbp)
  800421603f:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004216042:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004216049:	00 00 00 
  800421604c:	48 8b 00             	mov    (%rax),%rax
  800421604f:	48 39 c2             	cmp    %rax,%rdx
  8004216052:	72 32                	jb     8004216086 <mpsearch1+0xe1>
  8004216054:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216058:	48 89 c1             	mov    %rax,%rcx
  800421605b:	48 ba d0 a4 21 04 80 	movabs $0x800421a4d0,%rdx
  8004216062:	00 00 00 
  8004216065:	be 58 00 00 00       	mov    $0x58,%esi
  800421606a:	48 bf f3 a4 21 04 80 	movabs $0x800421a4f3,%rdi
  8004216071:	00 00 00 
  8004216074:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216079:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004216080:	00 00 00 
  8004216083:	41 ff d0             	callq  *%r8
  8004216086:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  800421608d:	00 00 00 
  8004216090:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216094:	48 01 d0             	add    %rdx,%rax
  8004216097:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

	for (; mp < end; mp++)
  800421609b:	eb 4d                	jmp    80042160ea <mpsearch1+0x145>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  800421609d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160a1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042160a6:	48 be 03 a5 21 04 80 	movabs $0x800421a503,%rsi
  80042160ad:	00 00 00 
  80042160b0:	48 89 c7             	mov    %rax,%rdi
  80042160b3:	48 b8 53 fc 20 04 80 	movabs $0x800420fc53,%rax
  80042160ba:	00 00 00 
  80042160bd:	ff d0                	callq  *%rax
  80042160bf:	85 c0                	test   %eax,%eax
  80042160c1:	75 22                	jne    80042160e5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
  80042160c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160c7:	be 10 00 00 00       	mov    $0x10,%esi
  80042160cc:	48 89 c7             	mov    %rax,%rdi
  80042160cf:	48 b8 5f 5f 21 04 80 	movabs $0x8004215f5f,%rax
  80042160d6:	00 00 00 
  80042160d9:	ff d0                	callq  *%rax
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
  80042160db:	84 c0                	test   %al,%al
  80042160dd:	75 06                	jne    80042160e5 <mpsearch1+0x140>
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
  80042160df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160e3:	eb 14                	jmp    80042160f9 <mpsearch1+0x154>
static struct mp *
mpsearch1(physaddr_t a, int len)
{
	struct mp *mp = KADDR(a), *end = KADDR(a + len);

	for (; mp < end; mp++)
  80042160e5:	48 83 45 f8 10       	addq   $0x10,-0x8(%rbp)
  80042160ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042160ee:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
  80042160f2:	72 a9                	jb     800421609d <mpsearch1+0xf8>
		if (memcmp(mp->signature, "_MP_", 4) == 0 &&
		    sum(mp, sizeof(*mp)) == 0)
			return mp;
	return NULL;
  80042160f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80042160f9:	c9                   	leaveq 
  80042160fa:	c3                   	retq   

00000080042160fb <mpsearch>:
// 1) in the first KB of the EBDA;
// 2) if there is no EBDA, in the last KB of system base memory;
// 3) in the BIOS ROM between 0xE0000 and 0xFFFFF.
static struct mp *
mpsearch(void)
{
  80042160fb:	55                   	push   %rbp
  80042160fc:	48 89 e5             	mov    %rsp,%rbp
  80042160ff:	48 83 ec 30          	sub    $0x30,%rsp
	struct mp *mp;

	//static_assert(sizeof(*mp) == 32);

	// The BIOS data area lives in 16-bit segment 0x40.
	bda = (uint8_t *) KADDR(0x40 << 4);
  8004216103:	48 c7 45 f8 00 04 00 	movq   $0x400,-0x8(%rbp)
  800421610a:	00 
  800421610b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421610f:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216113:	89 45 f4             	mov    %eax,-0xc(%rbp)
  8004216116:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004216119:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004216120:	00 00 00 
  8004216123:	48 8b 00             	mov    (%rax),%rax
  8004216126:	48 39 c2             	cmp    %rax,%rdx
  8004216129:	72 32                	jb     800421615d <mpsearch+0x62>
  800421612b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421612f:	48 89 c1             	mov    %rax,%rcx
  8004216132:	48 ba d0 a4 21 04 80 	movabs $0x800421a4d0,%rdx
  8004216139:	00 00 00 
  800421613c:	be 70 00 00 00       	mov    $0x70,%esi
  8004216141:	48 bf f3 a4 21 04 80 	movabs $0x800421a4f3,%rdi
  8004216148:	00 00 00 
  800421614b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216150:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004216157:	00 00 00 
  800421615a:	41 ff d0             	callq  *%r8
  800421615d:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216164:	00 00 00 
  8004216167:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421616b:	48 01 d0             	add    %rdx,%rax
  800421616e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

	// [MP 4] The 16-bit segment of the EBDA is in the two bytes
	// starting at byte 0x0E of the BDA.  0 if not present.
	if ((p = *(uint16_t *) (bda + 0x0E))) {
  8004216172:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216176:	48 83 c0 0e          	add    $0xe,%rax
  800421617a:	0f b7 00             	movzwl (%rax),%eax
  800421617d:	0f b7 c0             	movzwl %ax,%eax
  8004216180:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  8004216183:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
  8004216187:	74 2c                	je     80042161b5 <mpsearch+0xba>
		p <<= 4;	// Translate from segment to PA
  8004216189:	c1 65 e4 04          	shll   $0x4,-0x1c(%rbp)
		if ((mp = mpsearch1(p, 1024)))
  800421618d:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216190:	be 00 04 00 00       	mov    $0x400,%esi
  8004216195:	48 89 c7             	mov    %rax,%rdi
  8004216198:	48 b8 a5 5f 21 04 80 	movabs $0x8004215fa5,%rax
  800421619f:	00 00 00 
  80042161a2:	ff d0                	callq  *%rax
  80042161a4:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042161a8:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042161ad:	74 49                	je     80042161f8 <mpsearch+0xfd>
			return mp;
  80042161af:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042161b3:	eb 59                	jmp    800421620e <mpsearch+0x113>
	} else {
		// The size of base memory, in KB is in the two bytes
		// starting at 0x13 of the BDA.
		p = *(uint16_t *) (bda + 0x13) * 1024;
  80042161b5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042161b9:	48 83 c0 13          	add    $0x13,%rax
  80042161bd:	0f b7 00             	movzwl (%rax),%eax
  80042161c0:	0f b7 c0             	movzwl %ax,%eax
  80042161c3:	c1 e0 0a             	shl    $0xa,%eax
  80042161c6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		if ((mp = mpsearch1(p - 1024, 1024)))
  80042161c9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042161cc:	2d 00 04 00 00       	sub    $0x400,%eax
  80042161d1:	89 c0                	mov    %eax,%eax
  80042161d3:	be 00 04 00 00       	mov    $0x400,%esi
  80042161d8:	48 89 c7             	mov    %rax,%rdi
  80042161db:	48 b8 a5 5f 21 04 80 	movabs $0x8004215fa5,%rax
  80042161e2:	00 00 00 
  80042161e5:	ff d0                	callq  *%rax
  80042161e7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  80042161eb:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  80042161f0:	74 06                	je     80042161f8 <mpsearch+0xfd>
			return mp;
  80042161f2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042161f6:	eb 16                	jmp    800421620e <mpsearch+0x113>
	}
	return mpsearch1(0xF0000, 0x10000);
  80042161f8:	be 00 00 01 00       	mov    $0x10000,%esi
  80042161fd:	bf 00 00 0f 00       	mov    $0xf0000,%edi
  8004216202:	48 b8 a5 5f 21 04 80 	movabs $0x8004215fa5,%rax
  8004216209:	00 00 00 
  800421620c:	ff d0                	callq  *%rax
}
  800421620e:	c9                   	leaveq 
  800421620f:	c3                   	retq   

0000008004216210 <mpconfig>:
// Search for an MP configuration table.  For now, don't accept the
// default configurations (physaddr == 0).
// Check for the correct signature, checksum, and version.
static struct mpconf *
mpconfig(struct mp **pmp)
{
  8004216210:	55                   	push   %rbp
  8004216211:	48 89 e5             	mov    %rsp,%rbp
  8004216214:	48 83 ec 30          	sub    $0x30,%rsp
  8004216218:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	struct mpconf *conf;
	struct mp *mp;

	if ((mp = mpsearch()) == 0)
  800421621c:	48 b8 fb 60 21 04 80 	movabs $0x80042160fb,%rax
  8004216223:	00 00 00 
  8004216226:	ff d0                	callq  *%rax
  8004216228:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  800421622c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216231:	75 0a                	jne    800421623d <mpconfig+0x2d>
		return NULL;
  8004216233:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216238:	e9 f6 01 00 00       	jmpq   8004216433 <mpconfig+0x223>
	if (mp->physaddr == 0 || mp->type != 0) {
  800421623d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216241:	8b 40 04             	mov    0x4(%rax),%eax
  8004216244:	85 c0                	test   %eax,%eax
  8004216246:	74 0c                	je     8004216254 <mpconfig+0x44>
  8004216248:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421624c:	0f b6 40 0b          	movzbl 0xb(%rax),%eax
  8004216250:	84 c0                	test   %al,%al
  8004216252:	74 25                	je     8004216279 <mpconfig+0x69>
		cprintf("SMP: Default configurations not implemented\n");
  8004216254:	48 bf 08 a5 21 04 80 	movabs $0x800421a508,%rdi
  800421625b:	00 00 00 
  800421625e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216263:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800421626a:	00 00 00 
  800421626d:	ff d2                	callq  *%rdx
		return NULL;
  800421626f:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216274:	e9 ba 01 00 00       	jmpq   8004216433 <mpconfig+0x223>
	}
	conf = (struct mpconf *) KADDR(mp->physaddr);
  8004216279:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421627d:	8b 40 04             	mov    0x4(%rax),%eax
  8004216280:	89 c0                	mov    %eax,%eax
  8004216282:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  8004216286:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  800421628a:	48 c1 e8 0c          	shr    $0xc,%rax
  800421628e:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216291:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216294:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  800421629b:	00 00 00 
  800421629e:	48 8b 00             	mov    (%rax),%rax
  80042162a1:	48 39 c2             	cmp    %rax,%rdx
  80042162a4:	72 32                	jb     80042162d8 <mpconfig+0xc8>
  80042162a6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042162aa:	48 89 c1             	mov    %rax,%rcx
  80042162ad:	48 ba d0 a4 21 04 80 	movabs $0x800421a4d0,%rdx
  80042162b4:	00 00 00 
  80042162b7:	be 91 00 00 00       	mov    $0x91,%esi
  80042162bc:	48 bf f3 a4 21 04 80 	movabs $0x800421a4f3,%rdi
  80042162c3:	00 00 00 
  80042162c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042162cb:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042162d2:	00 00 00 
  80042162d5:	41 ff d0             	callq  *%r8
  80042162d8:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  80042162df:	00 00 00 
  80042162e2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  80042162e6:	48 01 d0             	add    %rdx,%rax
  80042162e9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	if (memcmp(conf, "PCMP", 4) != 0) {
  80042162ed:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042162f1:	ba 04 00 00 00       	mov    $0x4,%edx
  80042162f6:	48 be 35 a5 21 04 80 	movabs $0x800421a535,%rsi
  80042162fd:	00 00 00 
  8004216300:	48 89 c7             	mov    %rax,%rdi
  8004216303:	48 b8 53 fc 20 04 80 	movabs $0x800420fc53,%rax
  800421630a:	00 00 00 
  800421630d:	ff d0                	callq  *%rax
  800421630f:	85 c0                	test   %eax,%eax
  8004216311:	74 25                	je     8004216338 <mpconfig+0x128>
		cprintf("SMP: Incorrect MP configuration table signature\n");
  8004216313:	48 bf 40 a5 21 04 80 	movabs $0x800421a540,%rdi
  800421631a:	00 00 00 
  800421631d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216322:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004216329:	00 00 00 
  800421632c:	ff d2                	callq  *%rdx
		return NULL;
  800421632e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216333:	e9 fb 00 00 00       	jmpq   8004216433 <mpconfig+0x223>
	}
	if (sum(conf, conf->length) != 0) {
  8004216338:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421633c:	0f b7 40 04          	movzwl 0x4(%rax),%eax
  8004216340:	0f b7 d0             	movzwl %ax,%edx
  8004216343:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216347:	89 d6                	mov    %edx,%esi
  8004216349:	48 89 c7             	mov    %rax,%rdi
  800421634c:	48 b8 5f 5f 21 04 80 	movabs $0x8004215f5f,%rax
  8004216353:	00 00 00 
  8004216356:	ff d0                	callq  *%rax
  8004216358:	84 c0                	test   %al,%al
  800421635a:	74 25                	je     8004216381 <mpconfig+0x171>
		cprintf("SMP: Bad MP configuration checksum\n");
  800421635c:	48 bf 78 a5 21 04 80 	movabs $0x800421a578,%rdi
  8004216363:	00 00 00 
  8004216366:	b8 00 00 00 00       	mov    $0x0,%eax
  800421636b:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004216372:	00 00 00 
  8004216375:	ff d2                	callq  *%rdx
		return NULL;
  8004216377:	b8 00 00 00 00       	mov    $0x0,%eax
  800421637c:	e9 b2 00 00 00       	jmpq   8004216433 <mpconfig+0x223>
	}
	if (conf->version != 1 && conf->version != 4) {
  8004216381:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216385:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216389:	3c 01                	cmp    $0x1,%al
  800421638b:	74 3b                	je     80042163c8 <mpconfig+0x1b8>
  800421638d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216391:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  8004216395:	3c 04                	cmp    $0x4,%al
  8004216397:	74 2f                	je     80042163c8 <mpconfig+0x1b8>
		cprintf("SMP: Unsupported MP version %d\n", conf->version);
  8004216399:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421639d:	0f b6 40 06          	movzbl 0x6(%rax),%eax
  80042163a1:	0f b6 c0             	movzbl %al,%eax
  80042163a4:	89 c6                	mov    %eax,%esi
  80042163a6:	48 bf a0 a5 21 04 80 	movabs $0x800421a5a0,%rdi
  80042163ad:	00 00 00 
  80042163b0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042163b5:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042163bc:	00 00 00 
  80042163bf:	ff d2                	callq  *%rdx
		return NULL;
  80042163c1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042163c6:	eb 6b                	jmp    8004216433 <mpconfig+0x223>
	}
	if (sum((uint8_t *)conf + conf->length, conf->xlength) != conf->xchecksum) {
  80042163c8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042163cc:	0f b7 40 28          	movzwl 0x28(%rax),%eax
  80042163d0:	0f b7 c0             	movzwl %ax,%eax
  80042163d3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042163d7:	0f b7 52 04          	movzwl 0x4(%rdx),%edx
  80042163db:	0f b7 ca             	movzwl %dx,%ecx
  80042163de:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042163e2:	48 01 ca             	add    %rcx,%rdx
  80042163e5:	89 c6                	mov    %eax,%esi
  80042163e7:	48 89 d7             	mov    %rdx,%rdi
  80042163ea:	48 b8 5f 5f 21 04 80 	movabs $0x8004215f5f,%rax
  80042163f1:	00 00 00 
  80042163f4:	ff d0                	callq  *%rax
  80042163f6:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
  80042163fa:	0f b6 52 2a          	movzbl 0x2a(%rdx),%edx
  80042163fe:	38 d0                	cmp    %dl,%al
  8004216400:	74 22                	je     8004216424 <mpconfig+0x214>
		cprintf("SMP: Bad MP configuration extended checksum\n");
  8004216402:	48 bf c0 a5 21 04 80 	movabs $0x800421a5c0,%rdi
  8004216409:	00 00 00 
  800421640c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216411:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004216418:	00 00 00 
  800421641b:	ff d2                	callq  *%rdx
		return NULL;
  800421641d:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216422:	eb 0f                	jmp    8004216433 <mpconfig+0x223>
	}
	*pmp = mp;
  8004216424:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216428:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  800421642c:	48 89 10             	mov    %rdx,(%rax)
	return conf;
  800421642f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
}
  8004216433:	c9                   	leaveq 
  8004216434:	c3                   	retq   

0000008004216435 <mp_init>:

void
mp_init(void)
{
  8004216435:	55                   	push   %rbp
  8004216436:	48 89 e5             	mov    %rsp,%rbp
  8004216439:	53                   	push   %rbx
  800421643a:	48 83 ec 58          	sub    $0x58,%rsp
	struct mpconf *conf;
	struct mpproc *proc;
	uint8_t *p;
	unsigned int i;

	bootcpu = &cpus[0];
  800421643e:	48 b8 40 b2 37 04 80 	movabs $0x800437b240,%rax
  8004216445:	00 00 00 
  8004216448:	48 bb 20 b0 37 04 80 	movabs $0x800437b020,%rbx
  800421644f:	00 00 00 
  8004216452:	48 89 18             	mov    %rbx,(%rax)
	if ((conf = mpconfig(&mp)) == 0)
  8004216455:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
  8004216459:	48 89 c7             	mov    %rax,%rdi
  800421645c:	48 b8 10 62 21 04 80 	movabs $0x8004216210,%rax
  8004216463:	00 00 00 
  8004216466:	ff d0                	callq  *%rax
  8004216468:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  800421646c:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
  8004216471:	75 05                	jne    8004216478 <mp_init+0x43>
		return;
  8004216473:	e9 d2 03 00 00       	jmpq   800421684a <mp_init+0x415>
	ismp = 1;
  8004216478:	48 b8 00 b0 37 04 80 	movabs $0x800437b000,%rax
  800421647f:	00 00 00 
  8004216482:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
	lapicaddr = conf->lapicaddr;
  8004216488:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421648c:	8b 40 24             	mov    0x24(%rax),%eax
  800421648f:	89 c2                	mov    %eax,%edx
  8004216491:	48 b8 00 c0 3b 04 80 	movabs $0x80043bc000,%rax
  8004216498:	00 00 00 
  800421649b:	48 89 10             	mov    %rdx,(%rax)

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  800421649e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042164a2:	48 83 c0 2c          	add    $0x2c,%rax
  80042164a6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  80042164aa:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  80042164b1:	e9 17 02 00 00       	jmpq   80042166cd <mp_init+0x298>
		switch (*p) {
  80042164b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042164ba:	0f b6 00             	movzbl (%rax),%eax
  80042164bd:	0f b6 c0             	movzbl %al,%eax
  80042164c0:	85 c0                	test   %eax,%eax
  80042164c2:	74 16                	je     80042164da <mp_init+0xa5>
  80042164c4:	85 c0                	test   %eax,%eax
  80042164c6:	0f 88 b8 01 00 00    	js     8004216684 <mp_init+0x24f>
  80042164cc:	83 f8 04             	cmp    $0x4,%eax
  80042164cf:	0f 8f af 01 00 00    	jg     8004216684 <mp_init+0x24f>
  80042164d5:	e9 a3 01 00 00       	jmpq   800421667d <mp_init+0x248>
		case MPPROC:
			proc = (struct mpproc *)p;
  80042164da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042164de:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
			if (proc->flags & MPPROC_BOOT) {
  80042164e2:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042164e6:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042164ea:	0f b6 c0             	movzbl %al,%eax
  80042164ed:	83 e0 02             	and    $0x2,%eax
  80042164f0:	85 c0                	test   %eax,%eax
  80042164f2:	74 51                	je     8004216545 <mp_init+0x110>
				bootcpu = &cpus[ncpu];
  80042164f4:	48 b8 48 b2 37 04 80 	movabs $0x800437b248,%rax
  80042164fb:	00 00 00 
  80042164fe:	8b 00                	mov    (%rax),%eax
  8004216500:	48 98                	cltq   
  8004216502:	48 c1 e0 03          	shl    $0x3,%rax
  8004216506:	48 89 c2             	mov    %rax,%rdx
  8004216509:	48 c1 e2 04          	shl    $0x4,%rdx
  800421650d:	48 01 d0             	add    %rdx,%rax
  8004216510:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004216517:	00 00 00 
  800421651a:	48 01 c2             	add    %rax,%rdx
  800421651d:	48 b8 40 b2 37 04 80 	movabs $0x800437b240,%rax
  8004216524:	00 00 00 
  8004216527:	48 89 10             	mov    %rdx,(%rax)
				cprintf("Found boot cpu..\n");
  800421652a:	48 bf ed a5 21 04 80 	movabs $0x800421a5ed,%rdi
  8004216531:	00 00 00 
  8004216534:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216539:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004216540:	00 00 00 
  8004216543:	ff d2                	callq  *%rdx
			}
			if (ncpu < NCPU) {
  8004216545:	48 b8 48 b2 37 04 80 	movabs $0x800437b248,%rax
  800421654c:	00 00 00 
  800421654f:	8b 00                	mov    (%rax),%eax
  8004216551:	83 f8 03             	cmp    $0x3,%eax
  8004216554:	0f 8f f4 00 00 00    	jg     800421664e <mp_init+0x219>
				cprintf("type: %d apicid:%d version:%d signature:%x feature:%x flags:%x reserved:%x\n", proc->type, proc->apicid, proc->version, proc->signature, proc->feature, proc->flags, proc->reserved);
  800421655a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421655e:	4c 8d 40 0c          	lea    0xc(%rax),%r8
  8004216562:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216566:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  800421656a:	0f b6 f0             	movzbl %al,%esi
  800421656d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216571:	8b 78 08             	mov    0x8(%rax),%edi
  8004216574:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216578:	4c 8d 50 04          	lea    0x4(%rax),%r10
  800421657c:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216580:	0f b6 40 02          	movzbl 0x2(%rax),%eax
  8004216584:	0f b6 c8             	movzbl %al,%ecx
  8004216587:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  800421658b:	0f b6 40 01          	movzbl 0x1(%rax),%eax
  800421658f:	0f b6 d0             	movzbl %al,%edx
  8004216592:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216596:	0f b6 00             	movzbl (%rax),%eax
  8004216599:	0f b6 c0             	movzbl %al,%eax
  800421659c:	4c 89 44 24 08       	mov    %r8,0x8(%rsp)
  80042165a1:	89 34 24             	mov    %esi,(%rsp)
  80042165a4:	41 89 f9             	mov    %edi,%r9d
  80042165a7:	4d 89 d0             	mov    %r10,%r8
  80042165aa:	89 c6                	mov    %eax,%esi
  80042165ac:	48 bf 00 a6 21 04 80 	movabs $0x800421a600,%rdi
  80042165b3:	00 00 00 
  80042165b6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042165bb:	49 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%r10
  80042165c2:	00 00 00 
  80042165c5:	41 ff d2             	callq  *%r10
				if (proc->flags & MPROC_EN) {
  80042165c8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  80042165cc:	0f b6 40 03          	movzbl 0x3(%rax),%eax
  80042165d0:	0f b6 c0             	movzbl %al,%eax
  80042165d3:	83 e0 01             	and    $0x1,%eax
  80042165d6:	85 c0                	test   %eax,%eax
  80042165d8:	74 57                	je     8004216631 <mp_init+0x1fc>
					cpus[ncpu].cpu_id = ncpu;
  80042165da:	48 b8 48 b2 37 04 80 	movabs $0x800437b248,%rax
  80042165e1:	00 00 00 
  80042165e4:	8b 30                	mov    (%rax),%esi
  80042165e6:	48 b8 48 b2 37 04 80 	movabs $0x800437b248,%rax
  80042165ed:	00 00 00 
  80042165f0:	8b 00                	mov    (%rax),%eax
  80042165f2:	89 c2                	mov    %eax,%edx
  80042165f4:	48 b9 20 b0 37 04 80 	movabs $0x800437b020,%rcx
  80042165fb:	00 00 00 
  80042165fe:	48 63 c6             	movslq %esi,%rax
  8004216601:	48 c1 e0 03          	shl    $0x3,%rax
  8004216605:	48 89 c6             	mov    %rax,%rsi
  8004216608:	48 c1 e6 04          	shl    $0x4,%rsi
  800421660c:	48 01 f0             	add    %rsi,%rax
  800421660f:	48 01 c8             	add    %rcx,%rax
  8004216612:	88 10                	mov    %dl,(%rax)
					ncpu++;
  8004216614:	48 b8 48 b2 37 04 80 	movabs $0x800437b248,%rax
  800421661b:	00 00 00 
  800421661e:	8b 00                	mov    (%rax),%eax
  8004216620:	8d 50 01             	lea    0x1(%rax),%edx
  8004216623:	48 b8 48 b2 37 04 80 	movabs $0x800437b248,%rax
  800421662a:	00 00 00 
  800421662d:	89 10                	mov    %edx,(%rax)
  800421662f:	eb 45                	jmp    8004216676 <mp_init+0x241>
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
  8004216631:	48 bf 50 a6 21 04 80 	movabs $0x800421a650,%rdi
  8004216638:	00 00 00 
  800421663b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216640:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004216647:	00 00 00 
  800421664a:	ff d2                	callq  *%rdx
  800421664c:	eb 28                	jmp    8004216676 <mp_init+0x241>
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
					proc->apicid);
  800421664e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004216652:	0f b6 40 01          	movzbl 0x1(%rax),%eax
					ncpu++;
				} else {
					cprintf("Found unusable CPU. Not intiializing it..\n");
				}
			} else {
				cprintf("SMP: too many CPUs, CPU %d disabled\n",
  8004216656:	0f b6 c0             	movzbl %al,%eax
  8004216659:	89 c6                	mov    %eax,%esi
  800421665b:	48 bf 80 a6 21 04 80 	movabs $0x800421a680,%rdi
  8004216662:	00 00 00 
  8004216665:	b8 00 00 00 00       	mov    $0x0,%eax
  800421666a:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004216671:	00 00 00 
  8004216674:	ff d2                	callq  *%rdx
					proc->apicid);
			}
			p += sizeof(struct mpproc);
  8004216676:	48 83 45 e8 14       	addq   $0x14,-0x18(%rbp)
			continue;
  800421667b:	eb 4c                	jmp    80042166c9 <mp_init+0x294>
		case MPBUS:
		case MPIOAPIC:
		case MPIOINTR:
		case MPLINTR:
		p += 8;
  800421667d:	48 83 45 e8 08       	addq   $0x8,-0x18(%rbp)
		continue;
  8004216682:	eb 45                	jmp    80042166c9 <mp_init+0x294>
		default:
			cprintf("mpinit: unknown config type %x\n", *p);
  8004216684:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216688:	0f b6 00             	movzbl (%rax),%eax
  800421668b:	0f b6 c0             	movzbl %al,%eax
  800421668e:	89 c6                	mov    %eax,%esi
  8004216690:	48 bf a8 a6 21 04 80 	movabs $0x800421a6a8,%rdi
  8004216697:	00 00 00 
  800421669a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421669f:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042166a6:	00 00 00 
  80042166a9:	ff d2                	callq  *%rdx
			ismp = 0;
  80042166ab:	48 b8 00 b0 37 04 80 	movabs $0x800437b000,%rax
  80042166b2:	00 00 00 
  80042166b5:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
			i = conf->entry;
  80042166bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042166bf:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  80042166c3:	0f b7 c0             	movzwl %ax,%eax
  80042166c6:	89 45 e4             	mov    %eax,-0x1c(%rbp)
	if ((conf = mpconfig(&mp)) == 0)
		return;
	ismp = 1;
	lapicaddr = conf->lapicaddr;

	for (p = conf->entries, i = 0; i < conf->entry; i++) {
  80042166c9:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  80042166cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042166d1:	0f b7 40 22          	movzwl 0x22(%rax),%eax
  80042166d5:	0f b7 c0             	movzwl %ax,%eax
  80042166d8:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
  80042166db:	0f 87 d5 fd ff ff    	ja     80042164b6 <mp_init+0x81>
			ismp = 0;
			i = conf->entry;
		}
	}

	for (i=0; i< NCPU; ++i) {
  80042166e1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
  80042166e8:	eb 53                	jmp    800421673d <mp_init+0x308>
		cpus[i].is_vmx_root = false;
  80042166ea:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  80042166f1:	00 00 00 
  80042166f4:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  80042166f7:	48 c1 e0 03          	shl    $0x3,%rax
  80042166fb:	48 89 c1             	mov    %rax,%rcx
  80042166fe:	48 c1 e1 04          	shl    $0x4,%rcx
  8004216702:	48 01 c8             	add    %rcx,%rax
  8004216705:	48 01 d0             	add    %rdx,%rax
  8004216708:	48 83 c0 70          	add    $0x70,%rax
  800421670c:	c6 40 08 00          	movb   $0x0,0x8(%rax)
		cpus[i].vmxon_region = 0;
  8004216710:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004216717:	00 00 00 
  800421671a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421671d:	48 c1 e0 03          	shl    $0x3,%rax
  8004216721:	48 89 c1             	mov    %rax,%rcx
  8004216724:	48 c1 e1 04          	shl    $0x4,%rcx
  8004216728:	48 01 c8             	add    %rcx,%rax
  800421672b:	48 01 d0             	add    %rdx,%rax
  800421672e:	48 83 e8 80          	sub    $0xffffffffffffff80,%rax
  8004216732:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			ismp = 0;
			i = conf->entry;
		}
	}

	for (i=0; i< NCPU; ++i) {
  8004216739:	83 45 e4 01          	addl   $0x1,-0x1c(%rbp)
  800421673d:	83 7d e4 03          	cmpl   $0x3,-0x1c(%rbp)
  8004216741:	76 a7                	jbe    80042166ea <mp_init+0x2b5>
		cpus[i].is_vmx_root = false;
		cpus[i].vmxon_region = 0;
	}

	bootcpu->cpu_status = CPU_STARTED;
  8004216743:	48 b8 40 b2 37 04 80 	movabs $0x800437b240,%rax
  800421674a:	00 00 00 
  800421674d:	48 8b 00             	mov    (%rax),%rax
  8004216750:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%rax)
	if (!ismp) {
  8004216757:	48 b8 00 b0 37 04 80 	movabs $0x800437b000,%rax
  800421675e:	00 00 00 
  8004216761:	8b 00                	mov    (%rax),%eax
  8004216763:	85 c0                	test   %eax,%eax
  8004216765:	75 41                	jne    80042167a8 <mp_init+0x373>
		// Didn't like what we found; fall back to no MP.
		ncpu = 1;
  8004216767:	48 b8 48 b2 37 04 80 	movabs $0x800437b248,%rax
  800421676e:	00 00 00 
  8004216771:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
		lapicaddr = 0;
  8004216777:	48 b8 00 c0 3b 04 80 	movabs $0x80043bc000,%rax
  800421677e:	00 00 00 
  8004216781:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		cprintf("SMP: configuration not found, SMP disabled\n");
  8004216788:	48 bf c8 a6 21 04 80 	movabs $0x800421a6c8,%rdi
  800421678f:	00 00 00 
  8004216792:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216797:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  800421679e:	00 00 00 
  80042167a1:	ff d2                	callq  *%rdx
		return;
  80042167a3:	e9 a2 00 00 00       	jmpq   800421684a <mp_init+0x415>
	}
	cprintf("SMP: CPU %d found %d CPU(s)\n", bootcpu->cpu_id,  ncpu);
  80042167a8:	48 b8 48 b2 37 04 80 	movabs $0x800437b248,%rax
  80042167af:	00 00 00 
  80042167b2:	8b 10                	mov    (%rax),%edx
  80042167b4:	48 b8 40 b2 37 04 80 	movabs $0x800437b240,%rax
  80042167bb:	00 00 00 
  80042167be:	48 8b 00             	mov    (%rax),%rax
  80042167c1:	0f b6 00             	movzbl (%rax),%eax
  80042167c4:	0f b6 c0             	movzbl %al,%eax
  80042167c7:	89 c6                	mov    %eax,%esi
  80042167c9:	48 bf f4 a6 21 04 80 	movabs $0x800421a6f4,%rdi
  80042167d0:	00 00 00 
  80042167d3:	b8 00 00 00 00       	mov    $0x0,%eax
  80042167d8:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  80042167df:	00 00 00 
  80042167e2:	ff d1                	callq  *%rcx

	if (mp->imcrp) {
  80042167e4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  80042167e8:	0f b6 40 0c          	movzbl 0xc(%rax),%eax
  80042167ec:	84 c0                	test   %al,%al
  80042167ee:	74 5a                	je     800421684a <mp_init+0x415>
		// [MP 3.2.6.1] If the hardware implements PIC mode,
		// switch to getting interrupts from the LAPIC.
		cprintf("SMP: Setting IMCR to switch from PIC mode to symmetric I/O mode\n");
  80042167f0:	48 bf 18 a7 21 04 80 	movabs $0x800421a718,%rdi
  80042167f7:	00 00 00 
  80042167fa:	b8 00 00 00 00       	mov    $0x0,%eax
  80042167ff:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  8004216806:	00 00 00 
  8004216809:	ff d2                	callq  *%rdx
  800421680b:	c7 45 cc 22 00 00 00 	movl   $0x22,-0x34(%rbp)
  8004216812:	c6 45 cb 70          	movb   $0x70,-0x35(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004216816:	0f b6 45 cb          	movzbl -0x35(%rbp),%eax
  800421681a:	8b 55 cc             	mov    -0x34(%rbp),%edx
  800421681d:	ee                   	out    %al,(%dx)
  800421681e:	c7 45 c4 23 00 00 00 	movl   $0x23,-0x3c(%rbp)

    static __inline uint8_t
inb(int port)
{
    uint8_t data;
    __asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
  8004216825:	8b 45 c4             	mov    -0x3c(%rbp),%eax
  8004216828:	89 c2                	mov    %eax,%edx
  800421682a:	ec                   	in     (%dx),%al
  800421682b:	88 45 c3             	mov    %al,-0x3d(%rbp)
    return data;
  800421682e:	0f b6 45 c3          	movzbl -0x3d(%rbp),%eax
		outb(0x22, 0x70);   // Select IMCR
		outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
  8004216832:	83 c8 01             	or     $0x1,%eax
  8004216835:	0f b6 c0             	movzbl %al,%eax
  8004216838:	c7 45 bc 23 00 00 00 	movl   $0x23,-0x44(%rbp)
  800421683f:	88 45 bb             	mov    %al,-0x45(%rbp)
}

    static __inline void
outb(int port, uint8_t data)
{
    __asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
  8004216842:	0f b6 45 bb          	movzbl -0x45(%rbp),%eax
  8004216846:	8b 55 bc             	mov    -0x44(%rbp),%edx
  8004216849:	ee                   	out    %al,(%dx)
	}
}
  800421684a:	48 83 c4 58          	add    $0x58,%rsp
  800421684e:	5b                   	pop    %rbx
  800421684f:	5d                   	pop    %rbp
  8004216850:	c3                   	retq   

0000008004216851 <lapicw>:
physaddr_t lapicaddr;        // Initialized in mpconfig.c
volatile uint32_t *lapic;

static void
lapicw(int index, int value)
{
  8004216851:	55                   	push   %rbp
  8004216852:	48 89 e5             	mov    %rsp,%rbp
  8004216855:	48 83 ec 08          	sub    $0x8,%rsp
  8004216859:	89 7d fc             	mov    %edi,-0x4(%rbp)
  800421685c:	89 75 f8             	mov    %esi,-0x8(%rbp)
	lapic[index] = value;
  800421685f:	48 b8 08 c0 3b 04 80 	movabs $0x80043bc008,%rax
  8004216866:	00 00 00 
  8004216869:	48 8b 00             	mov    (%rax),%rax
  800421686c:	8b 55 fc             	mov    -0x4(%rbp),%edx
  800421686f:	48 63 d2             	movslq %edx,%rdx
  8004216872:	48 c1 e2 02          	shl    $0x2,%rdx
  8004216876:	48 01 c2             	add    %rax,%rdx
  8004216879:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421687c:	89 02                	mov    %eax,(%rdx)
	lapic[ID];  // wait for write to finish, by reading
  800421687e:	48 b8 08 c0 3b 04 80 	movabs $0x80043bc008,%rax
  8004216885:	00 00 00 
  8004216888:	48 8b 00             	mov    (%rax),%rax
  800421688b:	48 83 c0 20          	add    $0x20,%rax
  800421688f:	8b 00                	mov    (%rax),%eax
}
  8004216891:	c9                   	leaveq 
  8004216892:	c3                   	retq   

0000008004216893 <lapic_init>:

void
lapic_init(void)
{
  8004216893:	55                   	push   %rbp
  8004216894:	48 89 e5             	mov    %rsp,%rbp
	if (!lapicaddr)
  8004216897:	48 b8 00 c0 3b 04 80 	movabs $0x80043bc000,%rax
  800421689e:	00 00 00 
  80042168a1:	48 8b 00             	mov    (%rax),%rax
  80042168a4:	48 85 c0             	test   %rax,%rax
  80042168a7:	75 05                	jne    80042168ae <lapic_init+0x1b>
		return;
  80042168a9:	e9 da 01 00 00       	jmpq   8004216a88 <lapic_init+0x1f5>

	// lapicaddr is the physical address of the LAPIC's 4K MMIO
	// region.  Map it in to virtual memory so we can access it.
	lapic = mmio_map_region(lapicaddr, 4096);
  80042168ae:	48 b8 00 c0 3b 04 80 	movabs $0x80043bc000,%rax
  80042168b5:	00 00 00 
  80042168b8:	48 8b 00             	mov    (%rax),%rax
  80042168bb:	be 00 10 00 00       	mov    $0x1000,%esi
  80042168c0:	48 89 c7             	mov    %rax,%rdi
  80042168c3:	48 b8 75 3c 20 04 80 	movabs $0x8004203c75,%rax
  80042168ca:	00 00 00 
  80042168cd:	ff d0                	callq  *%rax
  80042168cf:	48 ba 08 c0 3b 04 80 	movabs $0x80043bc008,%rdx
  80042168d6:	00 00 00 
  80042168d9:	48 89 02             	mov    %rax,(%rdx)

	// Enable local APIC; set spurious interrupt vector.
	lapicw(SVR, ENABLE | (IRQ_OFFSET + IRQ_SPURIOUS));
  80042168dc:	be 27 01 00 00       	mov    $0x127,%esi
  80042168e1:	bf 3c 00 00 00       	mov    $0x3c,%edi
  80042168e6:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  80042168ed:	00 00 00 
  80042168f0:	ff d0                	callq  *%rax

	// The timer repeatedly counts down at bus frequency
	// from lapic[TICR] and then issues an interrupt.  
	// If we cared more about precise timekeeping,
	// TICR would be calibrated using an external time source.
	lapicw(TDCR, X1);
  80042168f2:	be 0b 00 00 00       	mov    $0xb,%esi
  80042168f7:	bf f8 00 00 00       	mov    $0xf8,%edi
  80042168fc:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216903:	00 00 00 
  8004216906:	ff d0                	callq  *%rax
	lapicw(TIMER, PERIODIC | (IRQ_OFFSET + IRQ_TIMER));
  8004216908:	be 20 00 02 00       	mov    $0x20020,%esi
  800421690d:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216912:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216919:	00 00 00 
  800421691c:	ff d0                	callq  *%rax
	lapicw(TICR, 10000000); 
  800421691e:	be 80 96 98 00       	mov    $0x989680,%esi
  8004216923:	bf e0 00 00 00       	mov    $0xe0,%edi
  8004216928:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  800421692f:	00 00 00 
  8004216932:	ff d0                	callq  *%rax
	//
	// According to Intel MP Specification, the BIOS should initialize
	// BSP's local APIC in Virtual Wire Mode, in which 8259A's
	// INTR is virtually connected to BSP's LINTIN0. In this mode,
	// we do not need to program the IOAPIC.
	if (thiscpu != bootcpu)
  8004216934:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  800421693b:	00 00 00 
  800421693e:	ff d0                	callq  *%rax
  8004216940:	48 98                	cltq   
  8004216942:	48 c1 e0 03          	shl    $0x3,%rax
  8004216946:	48 89 c2             	mov    %rax,%rdx
  8004216949:	48 c1 e2 04          	shl    $0x4,%rdx
  800421694d:	48 01 d0             	add    %rdx,%rax
  8004216950:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004216957:	00 00 00 
  800421695a:	48 01 c2             	add    %rax,%rdx
  800421695d:	48 b8 40 b2 37 04 80 	movabs $0x800437b240,%rax
  8004216964:	00 00 00 
  8004216967:	48 8b 00             	mov    (%rax),%rax
  800421696a:	48 39 c2             	cmp    %rax,%rdx
  800421696d:	74 16                	je     8004216985 <lapic_init+0xf2>
		lapicw(LINT0, MASKED);
  800421696f:	be 00 00 01 00       	mov    $0x10000,%esi
  8004216974:	bf d4 00 00 00       	mov    $0xd4,%edi
  8004216979:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216980:	00 00 00 
  8004216983:	ff d0                	callq  *%rax

	// Disable NMI (LINT1) on all CPUs
	lapicw(LINT1, MASKED);
  8004216985:	be 00 00 01 00       	mov    $0x10000,%esi
  800421698a:	bf d8 00 00 00       	mov    $0xd8,%edi
  800421698f:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216996:	00 00 00 
  8004216999:	ff d0                	callq  *%rax

	// Disable performance counter overflow interrupts
	// on machines that provide that interrupt entry.
	if (((lapic[VER]>>16) & 0xFF) >= 4)
  800421699b:	48 b8 08 c0 3b 04 80 	movabs $0x80043bc008,%rax
  80042169a2:	00 00 00 
  80042169a5:	48 8b 00             	mov    (%rax),%rax
  80042169a8:	48 83 c0 30          	add    $0x30,%rax
  80042169ac:	8b 00                	mov    (%rax),%eax
  80042169ae:	c1 e8 10             	shr    $0x10,%eax
  80042169b1:	0f b6 c0             	movzbl %al,%eax
  80042169b4:	83 f8 03             	cmp    $0x3,%eax
  80042169b7:	76 16                	jbe    80042169cf <lapic_init+0x13c>
		lapicw(PCINT, MASKED);
  80042169b9:	be 00 00 01 00       	mov    $0x10000,%esi
  80042169be:	bf d0 00 00 00       	mov    $0xd0,%edi
  80042169c3:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  80042169ca:	00 00 00 
  80042169cd:	ff d0                	callq  *%rax

	// Map error interrupt to IRQ_ERROR.
	lapicw(ERROR, IRQ_OFFSET + IRQ_ERROR);
  80042169cf:	be 33 00 00 00       	mov    $0x33,%esi
  80042169d4:	bf dc 00 00 00       	mov    $0xdc,%edi
  80042169d9:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  80042169e0:	00 00 00 
  80042169e3:	ff d0                	callq  *%rax

	// Clear error status register (requires back-to-back writes).
	lapicw(ESR, 0);
  80042169e5:	be 00 00 00 00       	mov    $0x0,%esi
  80042169ea:	bf a0 00 00 00       	mov    $0xa0,%edi
  80042169ef:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  80042169f6:	00 00 00 
  80042169f9:	ff d0                	callq  *%rax
	lapicw(ESR, 0);
  80042169fb:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a00:	bf a0 00 00 00       	mov    $0xa0,%edi
  8004216a05:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216a0c:	00 00 00 
  8004216a0f:	ff d0                	callq  *%rax

	// Ack any outstanding interrupts.
	lapicw(EOI, 0);
  8004216a11:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a16:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004216a1b:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216a22:	00 00 00 
  8004216a25:	ff d0                	callq  *%rax

	// Send an Init Level De-Assert to synchronize arbitration ID's.
	lapicw(ICRHI, 0);
  8004216a27:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a2c:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216a31:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216a38:	00 00 00 
  8004216a3b:	ff d0                	callq  *%rax
	lapicw(ICRLO, BCAST | INIT | LEVEL);
  8004216a3d:	be 00 85 08 00       	mov    $0x88500,%esi
  8004216a42:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216a47:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216a4e:	00 00 00 
  8004216a51:	ff d0                	callq  *%rax
	while(lapic[ICRLO] & DELIVS)
  8004216a53:	90                   	nop
  8004216a54:	48 b8 08 c0 3b 04 80 	movabs $0x80043bc008,%rax
  8004216a5b:	00 00 00 
  8004216a5e:	48 8b 00             	mov    (%rax),%rax
  8004216a61:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216a67:	8b 00                	mov    (%rax),%eax
  8004216a69:	25 00 10 00 00       	and    $0x1000,%eax
  8004216a6e:	85 c0                	test   %eax,%eax
  8004216a70:	75 e2                	jne    8004216a54 <lapic_init+0x1c1>
		;

	// Enable interrupts on the APIC (but not on the processor).
	lapicw(TPR, 0);
  8004216a72:	be 00 00 00 00       	mov    $0x0,%esi
  8004216a77:	bf 20 00 00 00       	mov    $0x20,%edi
  8004216a7c:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216a83:	00 00 00 
  8004216a86:	ff d0                	callq  *%rax
}
  8004216a88:	5d                   	pop    %rbp
  8004216a89:	c3                   	retq   

0000008004216a8a <cpunum>:

int
cpunum(void)
{
  8004216a8a:	55                   	push   %rbp
  8004216a8b:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004216a8e:	48 b8 08 c0 3b 04 80 	movabs $0x80043bc008,%rax
  8004216a95:	00 00 00 
  8004216a98:	48 8b 00             	mov    (%rax),%rax
  8004216a9b:	48 85 c0             	test   %rax,%rax
  8004216a9e:	74 18                	je     8004216ab8 <cpunum+0x2e>
		return lapic[ID] >> 24;
  8004216aa0:	48 b8 08 c0 3b 04 80 	movabs $0x80043bc008,%rax
  8004216aa7:	00 00 00 
  8004216aaa:	48 8b 00             	mov    (%rax),%rax
  8004216aad:	48 83 c0 20          	add    $0x20,%rax
  8004216ab1:	8b 00                	mov    (%rax),%eax
  8004216ab3:	c1 e8 18             	shr    $0x18,%eax
  8004216ab6:	eb 05                	jmp    8004216abd <cpunum+0x33>
	return 0;
  8004216ab8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216abd:	5d                   	pop    %rbp
  8004216abe:	c3                   	retq   

0000008004216abf <lapic_eoi>:

// Acknowledge interrupt.
void
lapic_eoi(void)
{
  8004216abf:	55                   	push   %rbp
  8004216ac0:	48 89 e5             	mov    %rsp,%rbp
	if (lapic)
  8004216ac3:	48 b8 08 c0 3b 04 80 	movabs $0x80043bc008,%rax
  8004216aca:	00 00 00 
  8004216acd:	48 8b 00             	mov    (%rax),%rax
  8004216ad0:	48 85 c0             	test   %rax,%rax
  8004216ad3:	74 16                	je     8004216aeb <lapic_eoi+0x2c>
		lapicw(EOI, 0);
  8004216ad5:	be 00 00 00 00       	mov    $0x0,%esi
  8004216ada:	bf 2c 00 00 00       	mov    $0x2c,%edi
  8004216adf:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216ae6:	00 00 00 
  8004216ae9:	ff d0                	callq  *%rax
}
  8004216aeb:	5d                   	pop    %rbp
  8004216aec:	c3                   	retq   

0000008004216aed <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
static void
microdelay(int us)
{
  8004216aed:	55                   	push   %rbp
  8004216aee:	48 89 e5             	mov    %rsp,%rbp
  8004216af1:	48 83 ec 04          	sub    $0x4,%rsp
  8004216af5:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
  8004216af8:	c9                   	leaveq 
  8004216af9:	c3                   	retq   

0000008004216afa <lapic_startap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapic_startap(uint8_t apicid, uint32_t addr)
{
  8004216afa:	55                   	push   %rbp
  8004216afb:	48 89 e5             	mov    %rsp,%rbp
  8004216afe:	48 83 ec 40          	sub    $0x40,%rsp
  8004216b02:	89 f8                	mov    %edi,%eax
  8004216b04:	89 75 c8             	mov    %esi,-0x38(%rbp)
  8004216b07:	88 45 cc             	mov    %al,-0x34(%rbp)
  8004216b0a:	c7 45 dc 70 00 00 00 	movl   $0x70,-0x24(%rbp)
  8004216b11:	c6 45 db 0f          	movb   $0xf,-0x25(%rbp)
  8004216b15:	0f b6 45 db          	movzbl -0x25(%rbp),%eax
  8004216b19:	8b 55 dc             	mov    -0x24(%rbp),%edx
  8004216b1c:	ee                   	out    %al,(%dx)
  8004216b1d:	c7 45 d4 71 00 00 00 	movl   $0x71,-0x2c(%rbp)
  8004216b24:	c6 45 d3 0a          	movb   $0xa,-0x2d(%rbp)
  8004216b28:	0f b6 45 d3          	movzbl -0x2d(%rbp),%eax
  8004216b2c:	8b 55 d4             	mov    -0x2c(%rbp),%edx
  8004216b2f:	ee                   	out    %al,(%dx)
	// "The BSP must initialize CMOS shutdown code to 0AH
	// and the warm reset vector (DWORD based at 40:67) to point at
	// the AP startup code prior to the [universal startup algorithm]."
	outb(IO_RTC, 0xF);  // offset 0xF is shutdown code
	outb(IO_RTC+1, 0x0A);
	wrv = (uint16_t *)KADDR((0x40 << 4 | 0x67));  // Warm reset vector
  8004216b30:	48 c7 45 f0 67 04 00 	movq   $0x467,-0x10(%rbp)
  8004216b37:	00 
  8004216b38:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216b3c:	48 c1 e8 0c          	shr    $0xc,%rax
  8004216b40:	89 45 ec             	mov    %eax,-0x14(%rbp)
  8004216b43:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004216b46:	48 b8 90 97 37 04 80 	movabs $0x8004379790,%rax
  8004216b4d:	00 00 00 
  8004216b50:	48 8b 00             	mov    (%rax),%rax
  8004216b53:	48 39 c2             	cmp    %rax,%rdx
  8004216b56:	72 32                	jb     8004216b8a <lapic_startap+0x90>
  8004216b58:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216b5c:	48 89 c1             	mov    %rax,%rcx
  8004216b5f:	48 ba 60 a7 21 04 80 	movabs $0x800421a760,%rdx
  8004216b66:	00 00 00 
  8004216b69:	be 98 00 00 00       	mov    $0x98,%esi
  8004216b6e:	48 bf 83 a7 21 04 80 	movabs $0x800421a783,%rdi
  8004216b75:	00 00 00 
  8004216b78:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216b7d:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004216b84:	00 00 00 
  8004216b87:	41 ff d0             	callq  *%r8
  8004216b8a:	48 ba 00 00 00 04 80 	movabs $0x8004000000,%rdx
  8004216b91:	00 00 00 
  8004216b94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  8004216b98:	48 01 d0             	add    %rdx,%rax
  8004216b9b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	wrv[0] = 0;
  8004216b9f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216ba3:	66 c7 00 00 00       	movw   $0x0,(%rax)
	wrv[1] = addr >> 4;
  8004216ba8:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004216bac:	48 8d 50 02          	lea    0x2(%rax),%rdx
  8004216bb0:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216bb3:	c1 e8 04             	shr    $0x4,%eax
  8004216bb6:	66 89 02             	mov    %ax,(%rdx)

	// "Universal startup algorithm."
	// Send INIT (level-triggered) interrupt to reset other CPU.
	lapicw(ICRHI, apicid << 24);
  8004216bb9:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004216bbd:	c1 e0 18             	shl    $0x18,%eax
  8004216bc0:	89 c6                	mov    %eax,%esi
  8004216bc2:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216bc7:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216bce:	00 00 00 
  8004216bd1:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL | ASSERT);
  8004216bd3:	be 00 c5 00 00       	mov    $0xc500,%esi
  8004216bd8:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216bdd:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216be4:	00 00 00 
  8004216be7:	ff d0                	callq  *%rax
	microdelay(200);
  8004216be9:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216bee:	48 b8 ed 6a 21 04 80 	movabs $0x8004216aed,%rax
  8004216bf5:	00 00 00 
  8004216bf8:	ff d0                	callq  *%rax
	lapicw(ICRLO, INIT | LEVEL);
  8004216bfa:	be 00 85 00 00       	mov    $0x8500,%esi
  8004216bff:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216c04:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216c0b:	00 00 00 
  8004216c0e:	ff d0                	callq  *%rax
	microdelay(100);    // should be 10ms, but too slow in Bochs!
  8004216c10:	bf 64 00 00 00       	mov    $0x64,%edi
  8004216c15:	48 b8 ed 6a 21 04 80 	movabs $0x8004216aed,%rax
  8004216c1c:	00 00 00 
  8004216c1f:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004216c21:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004216c28:	eb 4b                	jmp    8004216c75 <lapic_startap+0x17b>
		lapicw(ICRHI, apicid << 24);
  8004216c2a:	0f b6 45 cc          	movzbl -0x34(%rbp),%eax
  8004216c2e:	c1 e0 18             	shl    $0x18,%eax
  8004216c31:	89 c6                	mov    %eax,%esi
  8004216c33:	bf c4 00 00 00       	mov    $0xc4,%edi
  8004216c38:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216c3f:	00 00 00 
  8004216c42:	ff d0                	callq  *%rax
		lapicw(ICRLO, STARTUP | (addr >> 12));
  8004216c44:	8b 45 c8             	mov    -0x38(%rbp),%eax
  8004216c47:	c1 e8 0c             	shr    $0xc,%eax
  8004216c4a:	80 cc 06             	or     $0x6,%ah
  8004216c4d:	89 c6                	mov    %eax,%esi
  8004216c4f:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216c54:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216c5b:	00 00 00 
  8004216c5e:	ff d0                	callq  *%rax
		microdelay(200);
  8004216c60:	bf c8 00 00 00       	mov    $0xc8,%edi
  8004216c65:	48 b8 ed 6a 21 04 80 	movabs $0x8004216aed,%rax
  8004216c6c:	00 00 00 
  8004216c6f:	ff d0                	callq  *%rax
	// Send startup IPI (twice!) to enter code.
	// Regular hardware is supposed to only accept a STARTUP
	// when it is in the halted state due to an INIT.  So the second
	// should be ignored, but it is part of the official Intel algorithm.
	// Bochs complains about the second one.  Too bad for Bochs.
	for (i = 0; i < 2; i++) {
  8004216c71:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004216c75:	83 7d fc 01          	cmpl   $0x1,-0x4(%rbp)
  8004216c79:	7e af                	jle    8004216c2a <lapic_startap+0x130>
		lapicw(ICRHI, apicid << 24);
		lapicw(ICRLO, STARTUP | (addr >> 12));
		microdelay(200);
	}
}
  8004216c7b:	c9                   	leaveq 
  8004216c7c:	c3                   	retq   

0000008004216c7d <lapic_ipi>:

void
lapic_ipi(int vector)
{
  8004216c7d:	55                   	push   %rbp
  8004216c7e:	48 89 e5             	mov    %rsp,%rbp
  8004216c81:	48 83 ec 08          	sub    $0x8,%rsp
  8004216c85:	89 7d fc             	mov    %edi,-0x4(%rbp)
	lapicw(ICRLO, OTHERS | FIXED | vector);
  8004216c88:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004216c8b:	0d 00 00 0c 00       	or     $0xc0000,%eax
  8004216c90:	89 c6                	mov    %eax,%esi
  8004216c92:	bf c0 00 00 00       	mov    $0xc0,%edi
  8004216c97:	48 b8 51 68 21 04 80 	movabs $0x8004216851,%rax
  8004216c9e:	00 00 00 
  8004216ca1:	ff d0                	callq  *%rax
	while (lapic[ICRLO] & DELIVS)
  8004216ca3:	90                   	nop
  8004216ca4:	48 b8 08 c0 3b 04 80 	movabs $0x80043bc008,%rax
  8004216cab:	00 00 00 
  8004216cae:	48 8b 00             	mov    (%rax),%rax
  8004216cb1:	48 05 00 03 00 00    	add    $0x300,%rax
  8004216cb7:	8b 00                	mov    (%rax),%eax
  8004216cb9:	25 00 10 00 00       	and    $0x1000,%eax
  8004216cbe:	85 c0                	test   %eax,%eax
  8004216cc0:	75 e2                	jne    8004216ca4 <lapic_ipi+0x27>
		;
}
  8004216cc2:	c9                   	leaveq 
  8004216cc3:	c3                   	retq   

0000008004216cc4 <xchg>:
	if (edxp)
		*edxp = edx;
}

static inline uint32_t
xchg(volatile uint32_t *addr,uint32_t newval){
  8004216cc4:	55                   	push   %rbp
  8004216cc5:	48 89 e5             	mov    %rsp,%rbp
  8004216cc8:	48 83 ec 1c          	sub    $0x1c,%rsp
  8004216ccc:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  8004216cd0:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	uint32_t result;
	__asm __volatile("lock; xchgl %0, %1":
  8004216cd3:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  8004216cd7:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004216cda:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
  8004216cde:	f0 87 02             	lock xchg %eax,(%rdx)
  8004216ce1:	89 45 fc             	mov    %eax,-0x4(%rbp)
			 "+m" (*addr), "=a" (result):
			 "1"(newval):
			 "cc");
	return result;
  8004216ce4:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004216ce7:	c9                   	leaveq 
  8004216ce8:	c3                   	retq   

0000008004216ce9 <get_caller_pcs>:

#ifdef DEBUG_SPINLOCK
// Record the current call stack in pcs[] by following the %ebp chain.
static void
get_caller_pcs(uint64_t pcs[])
{
  8004216ce9:	55                   	push   %rbp
  8004216cea:	48 89 e5             	mov    %rsp,%rbp
  8004216ced:	48 83 ec 28          	sub    $0x28,%rsp
  8004216cf1:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)

    static __inline uint64_t
read_rbp(void)
{
    uint64_t rbp;
    __asm __volatile("movq %%rbp,%0" : "=r" (rbp)::"cc","memory");
  8004216cf5:	48 89 e8             	mov    %rbp,%rax
  8004216cf8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    return rbp;
  8004216cfc:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
  8004216d00:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	for (i = 0; i < 10; i++){
  8004216d04:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
  8004216d0b:	eb 45                	jmp    8004216d52 <get_caller_pcs+0x69>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
  8004216d0d:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
  8004216d12:	74 44                	je     8004216d58 <get_caller_pcs+0x6f>
  8004216d14:	48 b8 ff ff bf 03 80 	movabs $0x8003bfffff,%rax
  8004216d1b:	00 00 00 
  8004216d1e:	48 39 45 f8          	cmp    %rax,-0x8(%rbp)
  8004216d22:	76 34                	jbe    8004216d58 <get_caller_pcs+0x6f>
			break;
		pcs[i] = rbp[1];          // saved %rip
  8004216d24:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216d27:	48 98                	cltq   
  8004216d29:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216d30:	00 
  8004216d31:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d35:	48 01 c2             	add    %rax,%rdx
  8004216d38:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216d3c:	48 8b 40 08          	mov    0x8(%rax),%rax
  8004216d40:	48 89 02             	mov    %rax,(%rdx)
		rbp = (uint64_t *)rbp[0]; // saved %rbp
  8004216d43:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216d47:	48 8b 00             	mov    (%rax),%rax
  8004216d4a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
{
	uint64_t *rbp;
	int i;

	rbp = (uint64_t *)read_rbp();
	for (i = 0; i < 10; i++){
  8004216d4e:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216d52:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216d56:	7e b5                	jle    8004216d0d <get_caller_pcs+0x24>
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216d58:	eb 1f                	jmp    8004216d79 <get_caller_pcs+0x90>
		pcs[i] = 0;
  8004216d5a:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004216d5d:	48 98                	cltq   
  8004216d5f:	48 8d 14 c5 00 00 00 	lea    0x0(,%rax,8),%rdx
  8004216d66:	00 
  8004216d67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004216d6b:	48 01 d0             	add    %rdx,%rax
  8004216d6e:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
		if (rbp == 0 || rbp < (uint64_t *)ULIM)
			break;
		pcs[i] = rbp[1];          // saved %rip
		rbp = (uint64_t *)rbp[0]; // saved %rbp
	}
	for (; i < 10; i++)
  8004216d75:	83 45 f4 01          	addl   $0x1,-0xc(%rbp)
  8004216d79:	83 7d f4 09          	cmpl   $0x9,-0xc(%rbp)
  8004216d7d:	7e db                	jle    8004216d5a <get_caller_pcs+0x71>
		pcs[i] = 0;
}
  8004216d7f:	c9                   	leaveq 
  8004216d80:	c3                   	retq   

0000008004216d81 <holding>:

// Check whether this CPU is holding the lock.
static int
holding(struct spinlock *lock)
{
  8004216d81:	55                   	push   %rbp
  8004216d82:	48 89 e5             	mov    %rsp,%rbp
  8004216d85:	53                   	push   %rbx
  8004216d86:	48 83 ec 18          	sub    $0x18,%rsp
  8004216d8a:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	return lock->locked && lock->cpu == thiscpu;
  8004216d8e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216d92:	8b 00                	mov    (%rax),%eax
  8004216d94:	85 c0                	test   %eax,%eax
  8004216d96:	74 3d                	je     8004216dd5 <holding+0x54>
  8004216d98:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216d9c:	48 8b 58 10          	mov    0x10(%rax),%rbx
  8004216da0:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004216da7:	00 00 00 
  8004216daa:	ff d0                	callq  *%rax
  8004216dac:	48 98                	cltq   
  8004216dae:	48 c1 e0 03          	shl    $0x3,%rax
  8004216db2:	48 89 c2             	mov    %rax,%rdx
  8004216db5:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216db9:	48 01 d0             	add    %rdx,%rax
  8004216dbc:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004216dc3:	00 00 00 
  8004216dc6:	48 01 d0             	add    %rdx,%rax
  8004216dc9:	48 39 c3             	cmp    %rax,%rbx
  8004216dcc:	75 07                	jne    8004216dd5 <holding+0x54>
  8004216dce:	b8 01 00 00 00       	mov    $0x1,%eax
  8004216dd3:	eb 05                	jmp    8004216dda <holding+0x59>
  8004216dd5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004216dda:	48 83 c4 18          	add    $0x18,%rsp
  8004216dde:	5b                   	pop    %rbx
  8004216ddf:	5d                   	pop    %rbp
  8004216de0:	c3                   	retq   

0000008004216de1 <__spin_initlock>:
#endif

void
__spin_initlock(struct spinlock *lk, char *name)
{
  8004216de1:	55                   	push   %rbp
  8004216de2:	48 89 e5             	mov    %rsp,%rbp
  8004216de5:	48 83 ec 10          	sub    $0x10,%rsp
  8004216de9:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  8004216ded:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
	lk->locked = 0;
  8004216df1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216df5:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
#ifdef DEBUG_SPINLOCK
	lk->name = name;
  8004216dfb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216dff:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
  8004216e03:	48 89 50 08          	mov    %rdx,0x8(%rax)
	lk->cpu = 0;
  8004216e07:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  8004216e0b:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  8004216e12:	00 
#endif
}
  8004216e13:	c9                   	leaveq 
  8004216e14:	c3                   	retq   

0000008004216e15 <spin_lock>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
spin_lock(struct spinlock *lk)
{
  8004216e15:	55                   	push   %rbp
  8004216e16:	48 89 e5             	mov    %rsp,%rbp
  8004216e19:	53                   	push   %rbx
  8004216e1a:	48 83 ec 18          	sub    $0x18,%rsp
  8004216e1e:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
  8004216e22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e26:	48 89 c7             	mov    %rax,%rdi
  8004216e29:	48 b8 81 6d 21 04 80 	movabs $0x8004216d81,%rax
  8004216e30:	00 00 00 
  8004216e33:	ff d0                	callq  *%rax
  8004216e35:	85 c0                	test   %eax,%eax
  8004216e37:	74 44                	je     8004216e7d <spin_lock+0x68>
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
  8004216e39:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e3d:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216e41:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004216e48:	00 00 00 
  8004216e4b:	ff d0                	callq  *%rax
  8004216e4d:	49 89 d8             	mov    %rbx,%r8
  8004216e50:	89 c1                	mov    %eax,%ecx
  8004216e52:	48 ba a0 a7 21 04 80 	movabs $0x800421a7a0,%rdx
  8004216e59:	00 00 00 
  8004216e5c:	be 41 00 00 00       	mov    $0x41,%esi
  8004216e61:	48 bf ca a7 21 04 80 	movabs $0x800421a7ca,%rdi
  8004216e68:	00 00 00 
  8004216e6b:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216e70:	49 b9 59 06 20 04 80 	movabs $0x8004200659,%r9
  8004216e77:	00 00 00 
  8004216e7a:	41 ff d1             	callq  *%r9
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216e7d:	eb 02                	jmp    8004216e81 <spin_lock+0x6c>
		asm volatile ("pause");
  8004216e7f:	f3 90                	pause  
#endif

	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not
	// reordered before it. 
	while (xchg(&lk->locked, 1) != 0)
  8004216e81:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216e85:	be 01 00 00 00       	mov    $0x1,%esi
  8004216e8a:	48 89 c7             	mov    %rax,%rdi
  8004216e8d:	48 b8 c4 6c 21 04 80 	movabs $0x8004216cc4,%rax
  8004216e94:	00 00 00 
  8004216e97:	ff d0                	callq  *%rax
  8004216e99:	85 c0                	test   %eax,%eax
  8004216e9b:	75 e2                	jne    8004216e7f <spin_lock+0x6a>
		asm volatile ("pause");

	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
  8004216e9d:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004216ea4:	00 00 00 
  8004216ea7:	ff d0                	callq  *%rax
  8004216ea9:	48 98                	cltq   
  8004216eab:	48 c1 e0 03          	shl    $0x3,%rax
  8004216eaf:	48 89 c2             	mov    %rax,%rdx
  8004216eb2:	48 c1 e2 04          	shl    $0x4,%rdx
  8004216eb6:	48 01 d0             	add    %rdx,%rax
  8004216eb9:	48 ba 20 b0 37 04 80 	movabs $0x800437b020,%rdx
  8004216ec0:	00 00 00 
  8004216ec3:	48 01 c2             	add    %rax,%rdx
  8004216ec6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216eca:	48 89 50 10          	mov    %rdx,0x10(%rax)
	get_caller_pcs(lk->pcs);
  8004216ece:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004216ed2:	48 83 c0 18          	add    $0x18,%rax
  8004216ed6:	48 89 c7             	mov    %rax,%rdi
  8004216ed9:	48 b8 e9 6c 21 04 80 	movabs $0x8004216ce9,%rax
  8004216ee0:	00 00 00 
  8004216ee3:	ff d0                	callq  *%rax
#endif
}
  8004216ee5:	48 83 c4 18          	add    $0x18,%rsp
  8004216ee9:	5b                   	pop    %rbx
  8004216eea:	5d                   	pop    %rbp
  8004216eeb:	c3                   	retq   

0000008004216eec <spin_unlock>:

// Release the lock.
void
spin_unlock(struct spinlock *lk)
{
  8004216eec:	55                   	push   %rbp
  8004216eed:	48 89 e5             	mov    %rsp,%rbp
  8004216ef0:	41 54                	push   %r12
  8004216ef2:	53                   	push   %rbx
  8004216ef3:	48 81 ec 20 05 00 00 	sub    $0x520,%rsp
  8004216efa:	48 89 bd d8 fa ff ff 	mov    %rdi,-0x528(%rbp)
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
  8004216f01:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216f08:	48 89 c7             	mov    %rax,%rdi
  8004216f0b:	48 b8 81 6d 21 04 80 	movabs $0x8004216d81,%rax
  8004216f12:	00 00 00 
  8004216f15:	ff d0                	callq  *%rax
  8004216f17:	85 c0                	test   %eax,%eax
  8004216f19:	0f 85 d2 01 00 00    	jne    80042170f1 <spin_unlock+0x205>
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
  8004216f1f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216f26:	48 8d 48 18          	lea    0x18(%rax),%rcx
  8004216f2a:	48 8d 85 e0 fa ff ff 	lea    -0x520(%rbp),%rax
  8004216f31:	ba 28 00 00 00       	mov    $0x28,%edx
  8004216f36:	48 89 ce             	mov    %rcx,%rsi
  8004216f39:	48 89 c7             	mov    %rax,%rdi
  8004216f3c:	48 b8 08 fb 20 04 80 	movabs $0x800420fb08,%rax
  8004216f43:	00 00 00 
  8004216f46:	ff d0                	callq  *%rax
		if (!lk->cpu) 
  8004216f48:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216f4f:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216f53:	48 85 c0             	test   %rax,%rax
  8004216f56:	75 39                	jne    8004216f91 <spin_unlock+0xa5>
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
  8004216f58:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216f5f:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216f63:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004216f6a:	00 00 00 
  8004216f6d:	ff d0                	callq  *%rax
  8004216f6f:	48 89 da             	mov    %rbx,%rdx
  8004216f72:	89 c6                	mov    %eax,%esi
  8004216f74:	48 bf e0 a7 21 04 80 	movabs $0x800421a7e0,%rdi
  8004216f7b:	00 00 00 
  8004216f7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216f83:	48 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%rcx
  8004216f8a:	00 00 00 
  8004216f8d:	ff d1                	callq  *%rcx
  8004216f8f:	eb 4d                	jmp    8004216fde <spin_unlock+0xf2>
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
  8004216f91:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216f98:	48 8b 40 10          	mov    0x10(%rax),%rax
  8004216f9c:	0f b6 00             	movzbl (%rax),%eax
		memmove(pcs, lk->pcs, sizeof pcs);
		if (!lk->cpu) 
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
  8004216f9f:	44 0f b6 e0          	movzbl %al,%r12d
  8004216fa3:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004216faa:	48 8b 58 08          	mov    0x8(%rax),%rbx
  8004216fae:	48 b8 8a 6a 21 04 80 	movabs $0x8004216a8a,%rax
  8004216fb5:	00 00 00 
  8004216fb8:	ff d0                	callq  *%rax
  8004216fba:	44 89 e1             	mov    %r12d,%ecx
  8004216fbd:	48 89 da             	mov    %rbx,%rdx
  8004216fc0:	89 c6                	mov    %eax,%esi
  8004216fc2:	48 bf 20 a8 21 04 80 	movabs $0x800421a820,%rdi
  8004216fc9:	00 00 00 
  8004216fcc:	b8 00 00 00 00       	mov    $0x0,%eax
  8004216fd1:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  8004216fd8:	00 00 00 
  8004216fdb:	41 ff d0             	callq  *%r8
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  8004216fde:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  8004216fe5:	e9 c3 00 00 00       	jmpq   80042170ad <spin_unlock+0x1c1>
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
  8004216fea:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004216fed:	48 98                	cltq   
  8004216fef:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004216ff6:	89 c0                	mov    %eax,%eax
  8004216ff8:	48 8d 95 10 fb ff ff 	lea    -0x4f0(%rbp),%rdx
  8004216fff:	48 89 d6             	mov    %rdx,%rsi
  8004217002:	48 89 c7             	mov    %rax,%rdi
  8004217005:	48 b8 e9 e6 20 04 80 	movabs $0x800420e6e9,%rax
  800421700c:	00 00 00 
  800421700f:	ff d0                	callq  *%rax
  8004217011:	85 c0                	test   %eax,%eax
  8004217013:	78 6b                	js     8004217080 <spin_unlock+0x194>
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004217015:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217018:	48 98                	cltq   
  800421701a:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  8004217021:	89 c2                	mov    %eax,%edx
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
  8004217023:	48 8b 85 30 fb ff ff 	mov    -0x4d0(%rbp),%rax
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Ripdebuginfo info;
			if (debuginfo_rip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
  800421702a:	48 29 c2             	sub    %rax,%rdx
  800421702d:	49 89 d0             	mov    %rdx,%r8
  8004217030:	48 8b bd 20 fb ff ff 	mov    -0x4e0(%rbp),%rdi
  8004217037:	8b b5 28 fb ff ff    	mov    -0x4d8(%rbp),%esi
  800421703d:	8b 8d 18 fb ff ff    	mov    -0x4e8(%rbp),%ecx
  8004217043:	48 8b 95 10 fb ff ff 	mov    -0x4f0(%rbp),%rdx
  800421704a:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421704d:	48 98                	cltq   
  800421704f:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  8004217056:	4c 89 04 24          	mov    %r8,(%rsp)
  800421705a:	49 89 f9             	mov    %rdi,%r9
  800421705d:	41 89 f0             	mov    %esi,%r8d
  8004217060:	89 c6                	mov    %eax,%esi
  8004217062:	48 bf 56 a8 21 04 80 	movabs $0x800421a856,%rdi
  8004217069:	00 00 00 
  800421706c:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217071:	49 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%r10
  8004217078:	00 00 00 
  800421707b:	41 ff d2             	callq  *%r10
  800421707e:	eb 29                	jmp    80042170a9 <spin_unlock+0x1bd>
					info.rip_file, info.rip_line,
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
  8004217080:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217083:	48 98                	cltq   
  8004217085:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  800421708c:	89 c6                	mov    %eax,%esi
  800421708e:	48 bf 6d a8 21 04 80 	movabs $0x800421a86d,%rdi
  8004217095:	00 00 00 
  8004217098:	b8 00 00 00 00       	mov    $0x0,%eax
  800421709d:	48 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%rdx
  80042170a4:	00 00 00 
  80042170a7:	ff d2                	callq  *%rdx
                        cprintf("CPU %d cannot release %s: not held by any CPU\nAcquired at:", 
                                cpunum(), lk->name);
                else 
			cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
				cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
  80042170a9:	83 45 ec 01          	addl   $0x1,-0x14(%rbp)
  80042170ad:	83 7d ec 09          	cmpl   $0x9,-0x14(%rbp)
  80042170b1:	7f 14                	jg     80042170c7 <spin_unlock+0x1db>
  80042170b3:	8b 45 ec             	mov    -0x14(%rbp),%eax
  80042170b6:	48 98                	cltq   
  80042170b8:	8b 84 85 e0 fa ff ff 	mov    -0x520(%rbp,%rax,4),%eax
  80042170bf:	85 c0                	test   %eax,%eax
  80042170c1:	0f 85 23 ff ff ff    	jne    8004216fea <spin_unlock+0xfe>
					info.rip_fn_namelen, info.rip_fn_name,
					pcs[i] - info.rip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
  80042170c7:	48 ba 75 a8 21 04 80 	movabs $0x800421a875,%rdx
  80042170ce:	00 00 00 
  80042170d1:	be 6b 00 00 00       	mov    $0x6b,%esi
  80042170d6:	48 bf ca a7 21 04 80 	movabs $0x800421a7ca,%rdi
  80042170dd:	00 00 00 
  80042170e0:	b8 00 00 00 00       	mov    $0x0,%eax
  80042170e5:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  80042170ec:	00 00 00 
  80042170ef:	ff d1                	callq  *%rcx
	}

	lk->pcs[0] = 0;
  80042170f1:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  80042170f8:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  80042170ff:	00 
	lk->cpu = 0;
  8004217100:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004217107:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  800421710e:	00 
	// But the 2007 Intel 64 Architecture Memory Ordering White
	// Paper says that Intel 64 and IA-32 will not move a load
	// after a store. So lock->locked = 0 would work here.
	// The xchg being asm volatile ensures gcc emits it after
	// the above assignments (and after the critical section).
	xchg(&lk->locked, 0);
  800421710f:	48 8b 85 d8 fa ff ff 	mov    -0x528(%rbp),%rax
  8004217116:	be 00 00 00 00       	mov    $0x0,%esi
  800421711b:	48 89 c7             	mov    %rax,%rdi
  800421711e:	48 b8 c4 6c 21 04 80 	movabs $0x8004216cc4,%rax
  8004217125:	00 00 00 
  8004217128:	ff d0                	callq  *%rax
}
  800421712a:	48 81 c4 20 05 00 00 	add    $0x520,%rsp
  8004217131:	5b                   	pop    %rbx
  8004217132:	41 5c                	pop    %r12
  8004217134:	5d                   	pop    %rbp
  8004217135:	c3                   	retq   

0000008004217136 <pci_conf1_set_addr>:
static void
pci_conf1_set_addr(uint32_t bus,
		   uint32_t dev,
		   uint32_t func,
		   uint32_t offset)
{
  8004217136:	55                   	push   %rbp
  8004217137:	48 89 e5             	mov    %rsp,%rbp
  800421713a:	48 83 ec 20          	sub    $0x20,%rsp
  800421713e:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004217141:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004217144:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  8004217147:	89 4d e0             	mov    %ecx,-0x20(%rbp)
	assert(bus < 256);
  800421714a:	81 7d ec ff 00 00 00 	cmpl   $0xff,-0x14(%rbp)
  8004217151:	76 35                	jbe    8004217188 <pci_conf1_set_addr+0x52>
  8004217153:	48 b9 88 a8 21 04 80 	movabs $0x800421a888,%rcx
  800421715a:	00 00 00 
  800421715d:	48 ba 92 a8 21 04 80 	movabs $0x800421a892,%rdx
  8004217164:	00 00 00 
  8004217167:	be 29 00 00 00       	mov    $0x29,%esi
  800421716c:	48 bf a7 a8 21 04 80 	movabs $0x800421a8a7,%rdi
  8004217173:	00 00 00 
  8004217176:	b8 00 00 00 00       	mov    $0x0,%eax
  800421717b:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004217182:	00 00 00 
  8004217185:	41 ff d0             	callq  *%r8
	assert(dev < 32);
  8004217188:	83 7d e8 1f          	cmpl   $0x1f,-0x18(%rbp)
  800421718c:	76 35                	jbe    80042171c3 <pci_conf1_set_addr+0x8d>
  800421718e:	48 b9 b2 a8 21 04 80 	movabs $0x800421a8b2,%rcx
  8004217195:	00 00 00 
  8004217198:	48 ba 92 a8 21 04 80 	movabs $0x800421a892,%rdx
  800421719f:	00 00 00 
  80042171a2:	be 2a 00 00 00       	mov    $0x2a,%esi
  80042171a7:	48 bf a7 a8 21 04 80 	movabs $0x800421a8a7,%rdi
  80042171ae:	00 00 00 
  80042171b1:	b8 00 00 00 00       	mov    $0x0,%eax
  80042171b6:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042171bd:	00 00 00 
  80042171c0:	41 ff d0             	callq  *%r8
	assert(func < 8);
  80042171c3:	83 7d e4 07          	cmpl   $0x7,-0x1c(%rbp)
  80042171c7:	76 35                	jbe    80042171fe <pci_conf1_set_addr+0xc8>
  80042171c9:	48 b9 bb a8 21 04 80 	movabs $0x800421a8bb,%rcx
  80042171d0:	00 00 00 
  80042171d3:	48 ba 92 a8 21 04 80 	movabs $0x800421a892,%rdx
  80042171da:	00 00 00 
  80042171dd:	be 2b 00 00 00       	mov    $0x2b,%esi
  80042171e2:	48 bf a7 a8 21 04 80 	movabs $0x800421a8a7,%rdi
  80042171e9:	00 00 00 
  80042171ec:	b8 00 00 00 00       	mov    $0x0,%eax
  80042171f1:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  80042171f8:	00 00 00 
  80042171fb:	41 ff d0             	callq  *%r8
	assert(offset < 256);
  80042171fe:	81 7d e0 ff 00 00 00 	cmpl   $0xff,-0x20(%rbp)
  8004217205:	76 35                	jbe    800421723c <pci_conf1_set_addr+0x106>
  8004217207:	48 b9 c4 a8 21 04 80 	movabs $0x800421a8c4,%rcx
  800421720e:	00 00 00 
  8004217211:	48 ba 92 a8 21 04 80 	movabs $0x800421a892,%rdx
  8004217218:	00 00 00 
  800421721b:	be 2c 00 00 00       	mov    $0x2c,%esi
  8004217220:	48 bf a7 a8 21 04 80 	movabs $0x800421a8a7,%rdi
  8004217227:	00 00 00 
  800421722a:	b8 00 00 00 00       	mov    $0x0,%eax
  800421722f:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004217236:	00 00 00 
  8004217239:	41 ff d0             	callq  *%r8
	assert((offset & 0x3) == 0);
  800421723c:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421723f:	83 e0 03             	and    $0x3,%eax
  8004217242:	85 c0                	test   %eax,%eax
  8004217244:	74 35                	je     800421727b <pci_conf1_set_addr+0x145>
  8004217246:	48 b9 d1 a8 21 04 80 	movabs $0x800421a8d1,%rcx
  800421724d:	00 00 00 
  8004217250:	48 ba 92 a8 21 04 80 	movabs $0x800421a892,%rdx
  8004217257:	00 00 00 
  800421725a:	be 2d 00 00 00       	mov    $0x2d,%esi
  800421725f:	48 bf a7 a8 21 04 80 	movabs $0x800421a8a7,%rdi
  8004217266:	00 00 00 
  8004217269:	b8 00 00 00 00       	mov    $0x0,%eax
  800421726e:	49 b8 59 06 20 04 80 	movabs $0x8004200659,%r8
  8004217275:	00 00 00 
  8004217278:	41 ff d0             	callq  *%r8

	uint32_t v = (1 << 31) |		// config-space
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
  800421727b:	8b 45 ec             	mov    -0x14(%rbp),%eax
  800421727e:	c1 e0 10             	shl    $0x10,%eax
  8004217281:	89 c2                	mov    %eax,%edx
  8004217283:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217286:	c1 e0 0b             	shl    $0xb,%eax
  8004217289:	09 c2                	or     %eax,%edx
  800421728b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  800421728e:	c1 e0 08             	shl    $0x8,%eax
  8004217291:	09 d0                	or     %edx,%eax
  8004217293:	0b 45 e0             	or     -0x20(%rbp),%eax
	assert(dev < 32);
	assert(func < 8);
	assert(offset < 256);
	assert((offset & 0x3) == 0);

	uint32_t v = (1 << 31) |		// config-space
  8004217296:	0d 00 00 00 80       	or     $0x80000000,%eax
  800421729b:	89 45 fc             	mov    %eax,-0x4(%rbp)
		(bus << 16) | (dev << 11) | (func << 8) | (offset);
	outl(pci_conf1_addr_ioport, v);
  800421729e:	48 b8 c4 b7 22 04 80 	movabs $0x800422b7c4,%rax
  80042172a5:	00 00 00 
  80042172a8:	8b 00                	mov    (%rax),%eax
  80042172aa:	89 45 f8             	mov    %eax,-0x8(%rbp)
  80042172ad:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042172b0:	89 45 f4             	mov    %eax,-0xc(%rbp)
}

    static __inline void
outl(int port, uint32_t data)
{
    __asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  80042172b3:	8b 45 f4             	mov    -0xc(%rbp),%eax
  80042172b6:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042172b9:	ef                   	out    %eax,(%dx)
}
  80042172ba:	c9                   	leaveq 
  80042172bb:	c3                   	retq   

00000080042172bc <pci_conf_read>:

static uint32_t
pci_conf_read(struct pci_func *f, uint32_t off)
{
  80042172bc:	55                   	push   %rbp
  80042172bd:	48 89 e5             	mov    %rsp,%rbp
  80042172c0:	48 83 ec 20          	sub    $0x20,%rsp
  80042172c4:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  80042172c8:	89 75 e4             	mov    %esi,-0x1c(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  80042172cb:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042172cf:	8b 50 0c             	mov    0xc(%rax),%edx
  80042172d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042172d6:	8b 70 08             	mov    0x8(%rax),%esi
  80042172d9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042172dd:	48 8b 00             	mov    (%rax),%rax
  80042172e0:	8b 40 08             	mov    0x8(%rax),%eax
  80042172e3:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  80042172e6:	89 c7                	mov    %eax,%edi
  80042172e8:	48 b8 36 71 21 04 80 	movabs $0x8004217136,%rax
  80042172ef:	00 00 00 
  80042172f2:	ff d0                	callq  *%rax
	return inl(pci_conf1_data_ioport);
  80042172f4:	48 b8 c8 b7 22 04 80 	movabs $0x800422b7c8,%rax
  80042172fb:	00 00 00 
  80042172fe:	8b 00                	mov    (%rax),%eax
  8004217300:	89 45 fc             	mov    %eax,-0x4(%rbp)

    static __inline uint32_t
inl(int port)
{
    uint32_t data;
    __asm __volatile("inl %w1,%0" : "=a" (data) : "d" (port));
  8004217303:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217306:	89 c2                	mov    %eax,%edx
  8004217308:	ed                   	in     (%dx),%eax
  8004217309:	89 45 f8             	mov    %eax,-0x8(%rbp)
    return data;
  800421730c:	8b 45 f8             	mov    -0x8(%rbp),%eax
}
  800421730f:	c9                   	leaveq 
  8004217310:	c3                   	retq   

0000008004217311 <pci_conf_write>:

static void
pci_conf_write(struct pci_func *f, uint32_t off, uint32_t v)
{
  8004217311:	55                   	push   %rbp
  8004217312:	48 89 e5             	mov    %rsp,%rbp
  8004217315:	48 83 ec 20          	sub    $0x20,%rsp
  8004217319:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
  800421731d:	89 75 e4             	mov    %esi,-0x1c(%rbp)
  8004217320:	89 55 e0             	mov    %edx,-0x20(%rbp)
	pci_conf1_set_addr(f->bus->busno, f->dev, f->func, off);
  8004217323:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217327:	8b 50 0c             	mov    0xc(%rax),%edx
  800421732a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421732e:	8b 70 08             	mov    0x8(%rax),%esi
  8004217331:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217335:	48 8b 00             	mov    (%rax),%rax
  8004217338:	8b 40 08             	mov    0x8(%rax),%eax
  800421733b:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
  800421733e:	89 c7                	mov    %eax,%edi
  8004217340:	48 b8 36 71 21 04 80 	movabs $0x8004217136,%rax
  8004217347:	00 00 00 
  800421734a:	ff d0                	callq  *%rax
	outl(pci_conf1_data_ioport, v);
  800421734c:	48 b8 c8 b7 22 04 80 	movabs $0x800422b7c8,%rax
  8004217353:	00 00 00 
  8004217356:	8b 00                	mov    (%rax),%eax
  8004217358:	89 45 fc             	mov    %eax,-0x4(%rbp)
  800421735b:	8b 45 e0             	mov    -0x20(%rbp),%eax
  800421735e:	89 45 f8             	mov    %eax,-0x8(%rbp)
}

    static __inline void
outl(int port, uint32_t data)
{
    __asm __volatile("outl %0,%w1" : : "a" (data), "d" (port));
  8004217361:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217364:	8b 55 fc             	mov    -0x4(%rbp),%edx
  8004217367:	ef                   	out    %eax,(%dx)
}
  8004217368:	c9                   	leaveq 
  8004217369:	c3                   	retq   

000000800421736a <pci_attach_match>:

static int __attribute__((warn_unused_result))
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
  800421736a:	55                   	push   %rbp
  800421736b:	48 89 e5             	mov    %rsp,%rbp
  800421736e:	48 83 ec 30          	sub    $0x30,%rsp
  8004217372:	89 7d ec             	mov    %edi,-0x14(%rbp)
  8004217375:	89 75 e8             	mov    %esi,-0x18(%rbp)
  8004217378:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  800421737c:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004217380:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
  8004217387:	e9 aa 00 00 00       	jmpq   8004217436 <pci_attach_match+0xcc>
		if (list[i].key1 == key1 && list[i].key2 == key2) {
  800421738c:	8b 45 fc             	mov    -0x4(%rbp),%eax
  800421738f:	48 c1 e0 04          	shl    $0x4,%rax
  8004217393:	48 89 c2             	mov    %rax,%rdx
  8004217396:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421739a:	48 01 d0             	add    %rdx,%rax
  800421739d:	8b 00                	mov    (%rax),%eax
  800421739f:	3b 45 ec             	cmp    -0x14(%rbp),%eax
  80042173a2:	0f 85 8a 00 00 00    	jne    8004217432 <pci_attach_match+0xc8>
  80042173a8:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042173ab:	48 c1 e0 04          	shl    $0x4,%rax
  80042173af:	48 89 c2             	mov    %rax,%rdx
  80042173b2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042173b6:	48 01 d0             	add    %rdx,%rax
  80042173b9:	8b 40 04             	mov    0x4(%rax),%eax
  80042173bc:	3b 45 e8             	cmp    -0x18(%rbp),%eax
  80042173bf:	75 71                	jne    8004217432 <pci_attach_match+0xc8>
			int r = list[i].attachfn(pcif);
  80042173c1:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042173c4:	48 c1 e0 04          	shl    $0x4,%rax
  80042173c8:	48 89 c2             	mov    %rax,%rdx
  80042173cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  80042173cf:	48 01 d0             	add    %rdx,%rax
  80042173d2:	48 8b 40 08          	mov    0x8(%rax),%rax
  80042173d6:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
  80042173da:	48 89 d7             	mov    %rdx,%rdi
  80042173dd:	ff d0                	callq  *%rax
  80042173df:	89 45 f8             	mov    %eax,-0x8(%rbp)
			if (r > 0)
  80042173e2:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042173e6:	7e 05                	jle    80042173ed <pci_attach_match+0x83>
				return r;
  80042173e8:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042173eb:	eb 6c                	jmp    8004217459 <pci_attach_match+0xef>
			if (r < 0)
  80042173ed:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
  80042173f1:	79 3f                	jns    8004217432 <pci_attach_match+0xc8>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
  80042173f3:	8b 45 fc             	mov    -0x4(%rbp),%eax
  80042173f6:	48 c1 e0 04          	shl    $0x4,%rax
  80042173fa:	48 89 c2             	mov    %rax,%rdx
  80042173fd:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217401:	48 01 d0             	add    %rdx,%rax
		if (list[i].key1 == key1 && list[i].key2 == key2) {
			int r = list[i].attachfn(pcif);
			if (r > 0)
				return r;
			if (r < 0)
				cprintf("pci_attach_match: attaching "
  8004217404:	48 8b 48 08          	mov    0x8(%rax),%rcx
  8004217408:	8b 75 f8             	mov    -0x8(%rbp),%esi
  800421740b:	8b 55 e8             	mov    -0x18(%rbp),%edx
  800421740e:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217411:	41 89 f0             	mov    %esi,%r8d
  8004217414:	89 c6                	mov    %eax,%esi
  8004217416:	48 bf e8 a8 21 04 80 	movabs $0x800421a8e8,%rdi
  800421741d:	00 00 00 
  8004217420:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217425:	49 b9 5f 8f 20 04 80 	movabs $0x8004208f5f,%r9
  800421742c:	00 00 00 
  800421742f:	41 ff d1             	callq  *%r9
pci_attach_match(uint32_t key1, uint32_t key2,
		 struct pci_driver *list, struct pci_func *pcif)
{
	uint32_t i;

	for (i = 0; list[i].attachfn; i++) {
  8004217432:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)
  8004217436:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217439:	48 c1 e0 04          	shl    $0x4,%rax
  800421743d:	48 89 c2             	mov    %rax,%rdx
  8004217440:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  8004217444:	48 01 d0             	add    %rdx,%rax
  8004217447:	48 8b 40 08          	mov    0x8(%rax),%rax
  800421744b:	48 85 c0             	test   %rax,%rax
  800421744e:	0f 85 38 ff ff ff    	jne    800421738c <pci_attach_match+0x22>
				cprintf("pci_attach_match: attaching "
					"%x.%x (%p): e\n",
					key1, key2, list[i].attachfn, r);
		}
	}
	return 0;
  8004217454:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8004217459:	c9                   	leaveq 
  800421745a:	c3                   	retq   

000000800421745b <pci_attach>:

static int
pci_attach(struct pci_func *f)
{
  800421745b:	55                   	push   %rbp
  800421745c:	48 89 e5             	mov    %rsp,%rbp
  800421745f:	48 83 ec 10          	sub    $0x10,%rsp
  8004217463:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
  8004217467:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  800421746b:	8b 40 14             	mov    0x14(%rax),%eax
  800421746e:	c1 e8 10             	shr    $0x10,%eax

static int
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
  8004217471:	0f b6 c0             	movzbl %al,%eax
  8004217474:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004217478:	8b 52 14             	mov    0x14(%rdx),%edx
  800421747b:	89 d7                	mov    %edx,%edi
  800421747d:	c1 ef 18             	shr    $0x18,%edi
  8004217480:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  8004217484:	48 89 d1             	mov    %rdx,%rcx
  8004217487:	48 ba e0 b7 22 04 80 	movabs $0x800422b7e0,%rdx
  800421748e:	00 00 00 
  8004217491:	89 c6                	mov    %eax,%esi
  8004217493:	48 b8 6a 73 21 04 80 	movabs $0x800421736a,%rax
  800421749a:	00 00 00 
  800421749d:	ff d0                	callq  *%rax
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  800421749f:	85 c0                	test   %eax,%eax
  80042174a1:	75 39                	jne    80042174dc <pci_attach+0x81>
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
  80042174a3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042174a7:	8b 40 10             	mov    0x10(%rax),%eax
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
		pci_attach_match(PCI_VENDOR(f->dev_id),
  80042174aa:	c1 e8 10             	shr    $0x10,%eax
  80042174ad:	89 c6                	mov    %eax,%esi
  80042174af:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  80042174b3:	8b 40 10             	mov    0x10(%rax),%eax
  80042174b6:	0f b7 c0             	movzwl %ax,%eax
  80042174b9:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
  80042174bd:	48 89 d1             	mov    %rdx,%rcx
  80042174c0:	48 ba 30 97 37 04 80 	movabs $0x8004379730,%rdx
  80042174c7:	00 00 00 
  80042174ca:	89 c7                	mov    %eax,%edi
  80042174cc:	48 b8 6a 73 21 04 80 	movabs $0x800421736a,%rax
  80042174d3:	00 00 00 
  80042174d6:	ff d0                	callq  *%rax
pci_attach(struct pci_func *f)
{
	return
		pci_attach_match(PCI_CLASS(f->dev_class),
				 PCI_SUBCLASS(f->dev_class),
				 &pci_attach_class[0], f) ||
  80042174d8:	85 c0                	test   %eax,%eax
  80042174da:	74 07                	je     80042174e3 <pci_attach+0x88>
  80042174dc:	b8 01 00 00 00       	mov    $0x1,%eax
  80042174e1:	eb 05                	jmp    80042174e8 <pci_attach+0x8d>
  80042174e3:	b8 00 00 00 00       	mov    $0x0,%eax
		pci_attach_match(PCI_VENDOR(f->dev_id),
				 PCI_PRODUCT(f->dev_id),
				 &pci_attach_vendor[0], f);
}
  80042174e8:	c9                   	leaveq 
  80042174e9:	c3                   	retq   

00000080042174ea <pci_print_func>:
	[0x6] = "Bridge device",
};

static void
pci_print_func(struct pci_func *f)
{
  80042174ea:	55                   	push   %rbp
  80042174eb:	48 89 e5             	mov    %rsp,%rbp
  80042174ee:	48 83 ec 40          	sub    $0x40,%rsp
  80042174f2:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
	const char *class = pci_class[0];
  80042174f6:	48 b8 00 b8 22 04 80 	movabs $0x800422b800,%rax
  80042174fd:	00 00 00 
  8004217500:	48 8b 00             	mov    (%rax),%rax
  8004217503:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
  8004217507:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421750b:	8b 40 14             	mov    0x14(%rax),%eax
  800421750e:	c1 e8 18             	shr    $0x18,%eax
  8004217511:	83 f8 06             	cmp    $0x6,%eax
  8004217514:	77 20                	ja     8004217536 <pci_print_func+0x4c>
		class = pci_class[PCI_CLASS(f->dev_class)];
  8004217516:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421751a:	8b 40 14             	mov    0x14(%rax),%eax
  800421751d:	c1 e8 18             	shr    $0x18,%eax
  8004217520:	89 c2                	mov    %eax,%edx
  8004217522:	48 b8 00 b8 22 04 80 	movabs $0x800422b800,%rax
  8004217529:	00 00 00 
  800421752c:	89 d2                	mov    %edx,%edx
  800421752e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
  8004217532:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
  8004217536:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421753a:	0f b6 40 48          	movzbl 0x48(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421753e:	0f b6 f8             	movzbl %al,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  8004217541:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217545:	8b 40 14             	mov    0x14(%rax),%eax
  8004217548:	c1 e8 10             	shr    $0x10,%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421754b:	0f b6 f0             	movzbl %al,%esi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
  800421754e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217552:	8b 40 14             	mov    0x14(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217555:	c1 e8 18             	shr    $0x18,%eax
  8004217558:	41 89 c1             	mov    %eax,%r9d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  800421755b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421755f:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217562:	c1 e8 10             	shr    $0x10,%eax
  8004217565:	41 89 c2             	mov    %eax,%r10d
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217568:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421756c:	8b 40 10             	mov    0x10(%rax),%eax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  800421756f:	44 0f b7 c0          	movzwl %ax,%r8d
  8004217573:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217577:	8b 48 0c             	mov    0xc(%rax),%ecx
  800421757a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  800421757e:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004217581:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8004217585:	48 8b 00             	mov    (%rax),%rax
{
	const char *class = pci_class[0];
	if (PCI_CLASS(f->dev_class) < sizeof(pci_class) / sizeof(pci_class[0]))
		class = pci_class[PCI_CLASS(f->dev_class)];

	cprintf("PCI: %02x:%02x.%d: %04x:%04x: class: %x.%x (%s) irq: %d\n",
  8004217588:	8b 40 08             	mov    0x8(%rax),%eax
  800421758b:	89 7c 24 18          	mov    %edi,0x18(%rsp)
  800421758f:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
  8004217593:	48 89 7c 24 10       	mov    %rdi,0x10(%rsp)
  8004217598:	89 74 24 08          	mov    %esi,0x8(%rsp)
  800421759c:	44 89 0c 24          	mov    %r9d,(%rsp)
  80042175a0:	45 89 d1             	mov    %r10d,%r9d
  80042175a3:	89 c6                	mov    %eax,%esi
  80042175a5:	48 bf 88 a9 21 04 80 	movabs $0x800421a988,%rdi
  80042175ac:	00 00 00 
  80042175af:	b8 00 00 00 00       	mov    $0x0,%eax
  80042175b4:	49 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%r10
  80042175bb:	00 00 00 
  80042175be:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
		PCI_CLASS(f->dev_class), PCI_SUBCLASS(f->dev_class), class,
		f->irq_line);
}
  80042175c1:	c9                   	leaveq 
  80042175c2:	c3                   	retq   

00000080042175c3 <pci_scan_bus>:

static int
pci_scan_bus(struct pci_bus *bus)
{
  80042175c3:	55                   	push   %rbp
  80042175c4:	48 89 e5             	mov    %rsp,%rbp
  80042175c7:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
  80042175ce:	48 89 bd f8 fe ff ff 	mov    %rdi,-0x108(%rbp)
	int totaldev = 0;
  80042175d5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
	struct pci_func df;
	memset(&df, 0, sizeof(df));
  80042175dc:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  80042175e0:	ba 50 00 00 00       	mov    $0x50,%edx
  80042175e5:	be 00 00 00 00       	mov    $0x0,%esi
  80042175ea:	48 89 c7             	mov    %rax,%rdi
  80042175ed:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  80042175f4:	00 00 00 
  80042175f7:	ff d0                	callq  *%rax
	df.bus = bus;
  80042175f9:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
  8004217600:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004217604:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
  800421760b:	e9 22 02 00 00       	jmpq   8004217832 <pci_scan_bus+0x26f>
		uint32_t bhlc = pci_conf_read(&df, PCI_BHLC_REG);
  8004217610:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
  8004217614:	be 0c 00 00 00       	mov    $0xc,%esi
  8004217619:	48 89 c7             	mov    %rax,%rdi
  800421761c:	48 b8 bc 72 21 04 80 	movabs $0x80042172bc,%rax
  8004217623:	00 00 00 
  8004217626:	ff d0                	callq  *%rax
  8004217628:	89 45 f8             	mov    %eax,-0x8(%rbp)
		if (PCI_HDRTYPE_TYPE(bhlc) > 1)	    // Unsupported or no device
  800421762b:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421762e:	c1 e8 10             	shr    $0x10,%eax
  8004217631:	83 e0 7f             	and    $0x7f,%eax
  8004217634:	83 f8 01             	cmp    $0x1,%eax
  8004217637:	0f 87 ec 01 00 00    	ja     8004217829 <pci_scan_bus+0x266>
			continue;

		totaldev++;
  800421763d:	83 45 fc 01          	addl   $0x1,-0x4(%rbp)

		struct pci_func f = df;
  8004217641:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
  8004217645:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
  800421764c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
  8004217650:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  8004217657:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
  800421765b:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
  8004217662:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
  8004217666:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
  800421766d:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
  8004217671:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
  8004217678:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  800421767c:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
  8004217683:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
  8004217687:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
  800421768e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217692:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
  8004217699:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
  800421769d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  80042176a4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  80042176a8:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  80042176af:	c7 85 0c ff ff ff 00 	movl   $0x0,-0xf4(%rbp)
  80042176b6:	00 00 00 
  80042176b9:	e9 45 01 00 00       	jmpq   8004217803 <pci_scan_bus+0x240>
		     f.func++) {
			struct pci_func af = f;
  80042176be:	48 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%rax
  80042176c5:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
  80042176cc:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
  80042176d3:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
  80042176da:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
  80042176e1:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
  80042176e8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
  80042176ef:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
  80042176f6:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
  80042176fd:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
  8004217704:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
  800421770b:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
  8004217712:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
  8004217719:	48 89 45 80          	mov    %rax,-0x80(%rbp)
  800421771d:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
  8004217724:	48 89 45 88          	mov    %rax,-0x78(%rbp)
  8004217728:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
  800421772f:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  8004217733:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
  800421773a:	48 89 45 98          	mov    %rax,-0x68(%rbp)

			af.dev_id = pci_conf_read(&f, PCI_ID_REG);
  800421773e:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
  8004217745:	be 00 00 00 00       	mov    $0x0,%esi
  800421774a:	48 89 c7             	mov    %rax,%rdi
  800421774d:	48 b8 bc 72 21 04 80 	movabs $0x80042172bc,%rax
  8004217754:	00 00 00 
  8004217757:	ff d0                	callq  *%rax
  8004217759:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%rbp)
			if (PCI_VENDOR(af.dev_id) == 0xffff)
  800421775f:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
  8004217765:	0f b7 c0             	movzwl %ax,%eax
  8004217768:	3d ff ff 00 00       	cmp    $0xffff,%eax
  800421776d:	0f 84 81 00 00 00    	je     80042177f4 <pci_scan_bus+0x231>
				continue;

			uint32_t intr = pci_conf_read(&af, PCI_INTERRUPT_REG);
  8004217773:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800421777a:	be 3c 00 00 00       	mov    $0x3c,%esi
  800421777f:	48 89 c7             	mov    %rax,%rdi
  8004217782:	48 b8 bc 72 21 04 80 	movabs $0x80042172bc,%rax
  8004217789:	00 00 00 
  800421778c:	ff d0                	callq  *%rax
  800421778e:	89 45 f4             	mov    %eax,-0xc(%rbp)
			af.irq_line = PCI_INTERRUPT_LINE(intr);
  8004217791:	8b 45 f4             	mov    -0xc(%rbp),%eax
  8004217794:	88 45 98             	mov    %al,-0x68(%rbp)

			af.dev_class = pci_conf_read(&af, PCI_CLASS_REG);
  8004217797:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  800421779e:	be 08 00 00 00       	mov    $0x8,%esi
  80042177a3:	48 89 c7             	mov    %rax,%rdi
  80042177a6:	48 b8 bc 72 21 04 80 	movabs $0x80042172bc,%rax
  80042177ad:	00 00 00 
  80042177b0:	ff d0                	callq  *%rax
  80042177b2:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
			if (pci_show_devs)
  80042177b8:	48 b8 c0 b7 22 04 80 	movabs $0x800422b7c0,%rax
  80042177bf:	00 00 00 
  80042177c2:	8b 00                	mov    (%rax),%eax
  80042177c4:	85 c0                	test   %eax,%eax
  80042177c6:	74 16                	je     80042177de <pci_scan_bus+0x21b>
				pci_print_func(&af);
  80042177c8:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042177cf:	48 89 c7             	mov    %rax,%rdi
  80042177d2:	48 b8 ea 74 21 04 80 	movabs $0x80042174ea,%rax
  80042177d9:	00 00 00 
  80042177dc:	ff d0                	callq  *%rax
			pci_attach(&af);
  80042177de:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
  80042177e5:	48 89 c7             	mov    %rax,%rdi
  80042177e8:	48 b8 5b 74 21 04 80 	movabs $0x800421745b,%rax
  80042177ef:	00 00 00 
  80042177f2:	ff d0                	callq  *%rax

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
		     f.func++) {
  80042177f4:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
  80042177fa:	83 c0 01             	add    $0x1,%eax
  80042177fd:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
			continue;

		totaldev++;

		struct pci_func f = df;
		for (f.func = 0; f.func < (PCI_HDRTYPE_MULTIFN(bhlc) ? 8 : 1);
  8004217803:	8b 95 0c ff ff ff    	mov    -0xf4(%rbp),%edx
  8004217809:	8b 45 f8             	mov    -0x8(%rbp),%eax
  800421780c:	25 00 00 80 00       	and    $0x800000,%eax
  8004217811:	85 c0                	test   %eax,%eax
  8004217813:	74 07                	je     800421781c <pci_scan_bus+0x259>
  8004217815:	b8 08 00 00 00       	mov    $0x8,%eax
  800421781a:	eb 05                	jmp    8004217821 <pci_scan_bus+0x25e>
  800421781c:	b8 01 00 00 00       	mov    $0x1,%eax
  8004217821:	39 c2                	cmp    %eax,%edx
  8004217823:	0f 82 95 fe ff ff    	jb     80042176be <pci_scan_bus+0xfb>
	int totaldev = 0;
	struct pci_func df;
	memset(&df, 0, sizeof(df));
	df.bus = bus;

	for (df.dev = 0; df.dev < 32; df.dev++) {
  8004217829:	8b 45 a8             	mov    -0x58(%rbp),%eax
  800421782c:	83 c0 01             	add    $0x1,%eax
  800421782f:	89 45 a8             	mov    %eax,-0x58(%rbp)
  8004217832:	8b 45 a8             	mov    -0x58(%rbp),%eax
  8004217835:	83 f8 1f             	cmp    $0x1f,%eax
  8004217838:	0f 86 d2 fd ff ff    	jbe    8004217610 <pci_scan_bus+0x4d>
				pci_print_func(&af);
			pci_attach(&af);
		}
	}

	return totaldev;
  800421783e:	8b 45 fc             	mov    -0x4(%rbp),%eax
}
  8004217841:	c9                   	leaveq 
  8004217842:	c3                   	retq   

0000008004217843 <pci_bridge_attach>:

static int
pci_bridge_attach(struct pci_func *pcif)
{
  8004217843:	55                   	push   %rbp
  8004217844:	48 89 e5             	mov    %rsp,%rbp
  8004217847:	48 83 ec 30          	sub    $0x30,%rsp
  800421784b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
  800421784f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217853:	be 1c 00 00 00       	mov    $0x1c,%esi
  8004217858:	48 89 c7             	mov    %rax,%rdi
  800421785b:	48 b8 bc 72 21 04 80 	movabs $0x80042172bc,%rax
  8004217862:	00 00 00 
  8004217865:	ff d0                	callq  *%rax
  8004217867:	89 45 fc             	mov    %eax,-0x4(%rbp)
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);
  800421786a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421786e:	be 18 00 00 00       	mov    $0x18,%esi
  8004217873:	48 89 c7             	mov    %rax,%rdi
  8004217876:	48 b8 bc 72 21 04 80 	movabs $0x80042172bc,%rax
  800421787d:	00 00 00 
  8004217880:	ff d0                	callq  *%rax
  8004217882:	89 45 f8             	mov    %eax,-0x8(%rbp)

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
  8004217885:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217888:	83 e0 0f             	and    $0xf,%eax
  800421788b:	83 f8 01             	cmp    $0x1,%eax
  800421788e:	75 40                	jne    80042178d0 <pci_bridge_attach+0x8d>
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  8004217890:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217894:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217897:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421789b:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func);
  800421789e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042178a2:	48 8b 00             	mov    (%rax),%rax
{
	uint32_t ioreg  = pci_conf_read(pcif, PCI_BRIDGE_STATIO_REG);
	uint32_t busreg = pci_conf_read(pcif, PCI_BRIDGE_BUS_REG);

	if (PCI_BRIDGE_IO_32BITS(ioreg)) {
		cprintf("PCI: %02x:%02x.%d: 32-bit bridge IO not supported.\n",
  80042178a5:	8b 40 08             	mov    0x8(%rax),%eax
  80042178a8:	89 c6                	mov    %eax,%esi
  80042178aa:	48 bf c8 a9 21 04 80 	movabs $0x800421a9c8,%rdi
  80042178b1:	00 00 00 
  80042178b4:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178b9:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  80042178c0:	00 00 00 
  80042178c3:	41 ff d0             	callq  *%r8
			pcif->bus->busno, pcif->dev, pcif->func);
		return 0;
  80042178c6:	b8 00 00 00 00       	mov    $0x0,%eax
  80042178cb:	e9 a1 00 00 00       	jmpq   8004217971 <pci_bridge_attach+0x12e>
	}

	struct pci_bus nbus;
	memset(&nbus, 0, sizeof(nbus));
  80042178d0:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  80042178d4:	ba 10 00 00 00       	mov    $0x10,%edx
  80042178d9:	be 00 00 00 00       	mov    $0x0,%esi
  80042178de:	48 89 c7             	mov    %rax,%rdi
  80042178e1:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  80042178e8:	00 00 00 
  80042178eb:	ff d0                	callq  *%rax
	nbus.parent_bridge = pcif;
  80042178ed:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042178f1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;
  80042178f5:	8b 45 f8             	mov    -0x8(%rbp),%eax
  80042178f8:	c1 e8 08             	shr    $0x8,%eax
  80042178fb:	0f b6 c0             	movzbl %al,%eax
  80042178fe:	89 45 e8             	mov    %eax,-0x18(%rbp)

	if (pci_show_devs)
  8004217901:	48 b8 c0 b7 22 04 80 	movabs $0x800422b7c0,%rax
  8004217908:	00 00 00 
  800421790b:	8b 00                	mov    (%rax),%eax
  800421790d:	85 c0                	test   %eax,%eax
  800421790f:	74 48                	je     8004217959 <pci_bridge_attach+0x116>
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);
  8004217911:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217914:	c1 e8 10             	shr    $0x10,%eax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004217917:	0f b6 f8             	movzbl %al,%edi
  800421791a:	8b 75 e8             	mov    -0x18(%rbp),%esi
  800421791d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217921:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217924:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217928:	8b 50 08             	mov    0x8(%rax),%edx
			pcif->bus->busno, pcif->dev, pcif->func,
  800421792b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  800421792f:	48 8b 00             	mov    (%rax),%rax
	memset(&nbus, 0, sizeof(nbus));
	nbus.parent_bridge = pcif;
	nbus.busno = (busreg >> PCI_BRIDGE_BUS_SECONDARY_SHIFT) & 0xff;

	if (pci_show_devs)
		cprintf("PCI: %02x:%02x.%d: bridge to PCI bus %d--%d\n",
  8004217932:	8b 40 08             	mov    0x8(%rax),%eax
  8004217935:	41 89 f9             	mov    %edi,%r9d
  8004217938:	41 89 f0             	mov    %esi,%r8d
  800421793b:	89 c6                	mov    %eax,%esi
  800421793d:	48 bf 00 aa 21 04 80 	movabs $0x800421aa00,%rdi
  8004217944:	00 00 00 
  8004217947:	b8 00 00 00 00       	mov    $0x0,%eax
  800421794c:	49 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%r10
  8004217953:	00 00 00 
  8004217956:	41 ff d2             	callq  *%r10
			pcif->bus->busno, pcif->dev, pcif->func,
			nbus.busno,
			(busreg >> PCI_BRIDGE_BUS_SUBORDINATE_SHIFT) & 0xff);

	pci_scan_bus(&nbus);
  8004217959:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  800421795d:	48 89 c7             	mov    %rax,%rdi
  8004217960:	48 b8 c3 75 21 04 80 	movabs $0x80042175c3,%rax
  8004217967:	00 00 00 
  800421796a:	ff d0                	callq  *%rax
	return 1;
  800421796c:	b8 01 00 00 00       	mov    $0x1,%eax
}
  8004217971:	c9                   	leaveq 
  8004217972:	c3                   	retq   

0000008004217973 <pci_func_enable>:

// External PCI subsystem interface

void
pci_func_enable(struct pci_func *f)
{
  8004217973:	55                   	push   %rbp
  8004217974:	48 89 e5             	mov    %rsp,%rbp
  8004217977:	48 83 ec 40          	sub    $0x40,%rsp
  800421797b:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
	pci_conf_write(f, PCI_COMMAND_STATUS_REG,
  800421797f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217983:	ba 07 00 00 00       	mov    $0x7,%edx
  8004217988:	be 04 00 00 00       	mov    $0x4,%esi
  800421798d:	48 89 c7             	mov    %rax,%rdi
  8004217990:	48 b8 11 73 21 04 80 	movabs $0x8004217311,%rax
  8004217997:	00 00 00 
  800421799a:	ff d0                	callq  *%rax
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  800421799c:	c7 45 f8 10 00 00 00 	movl   $0x10,-0x8(%rbp)
  80042179a3:	e9 ee 01 00 00       	jmpq   8004217b96 <pci_func_enable+0x223>
	     bar += bar_width)
	{
		uint32_t oldv = pci_conf_read(f, bar);
  80042179a8:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042179ab:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042179af:	89 d6                	mov    %edx,%esi
  80042179b1:	48 89 c7             	mov    %rax,%rdi
  80042179b4:	48 b8 bc 72 21 04 80 	movabs $0x80042172bc,%rax
  80042179bb:	00 00 00 
  80042179be:	ff d0                	callq  *%rax
  80042179c0:	89 45 ec             	mov    %eax,-0x14(%rbp)

		bar_width = 4;
  80042179c3:	c7 45 fc 04 00 00 00 	movl   $0x4,-0x4(%rbp)
		pci_conf_write(f, bar, 0xffffffff);
  80042179ca:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  80042179cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042179d1:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80042179d6:	89 ce                	mov    %ecx,%esi
  80042179d8:	48 89 c7             	mov    %rax,%rdi
  80042179db:	48 b8 11 73 21 04 80 	movabs $0x8004217311,%rax
  80042179e2:	00 00 00 
  80042179e5:	ff d0                	callq  *%rax
		uint32_t rv = pci_conf_read(f, bar);
  80042179e7:	8b 55 f8             	mov    -0x8(%rbp),%edx
  80042179ea:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  80042179ee:	89 d6                	mov    %edx,%esi
  80042179f0:	48 89 c7             	mov    %rax,%rdi
  80042179f3:	48 b8 bc 72 21 04 80 	movabs $0x80042172bc,%rax
  80042179fa:	00 00 00 
  80042179fd:	ff d0                	callq  *%rax
  80042179ff:	89 45 e8             	mov    %eax,-0x18(%rbp)

		if (rv == 0)
  8004217a02:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
  8004217a06:	75 05                	jne    8004217a0d <pci_func_enable+0x9a>
			continue;
  8004217a08:	e9 83 01 00 00       	jmpq   8004217b90 <pci_func_enable+0x21d>

		int regnum = PCI_MAPREG_NUM(bar);
  8004217a0d:	8b 45 f8             	mov    -0x8(%rbp),%eax
  8004217a10:	83 e8 10             	sub    $0x10,%eax
  8004217a13:	c1 e8 02             	shr    $0x2,%eax
  8004217a16:	89 45 e4             	mov    %eax,-0x1c(%rbp)
		uint32_t base, size;
		if (PCI_MAPREG_TYPE(rv) == PCI_MAPREG_TYPE_MEM) {
  8004217a19:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217a1c:	83 e0 01             	and    $0x1,%eax
  8004217a1f:	85 c0                	test   %eax,%eax
  8004217a21:	75 65                	jne    8004217a88 <pci_func_enable+0x115>
			if (PCI_MAPREG_MEM_TYPE(rv) == PCI_MAPREG_MEM_TYPE_64BIT)
  8004217a23:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217a26:	83 e0 06             	and    $0x6,%eax
  8004217a29:	83 f8 04             	cmp    $0x4,%eax
  8004217a2c:	75 07                	jne    8004217a35 <pci_func_enable+0xc2>
				bar_width = 8;
  8004217a2e:	c7 45 fc 08 00 00 00 	movl   $0x8,-0x4(%rbp)

			size = PCI_MAPREG_MEM_SIZE(rv);
  8004217a35:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217a38:	83 e0 f0             	and    $0xfffffff0,%eax
  8004217a3b:	f7 d8                	neg    %eax
  8004217a3d:	23 45 e8             	and    -0x18(%rbp),%eax
  8004217a40:	83 e0 f0             	and    $0xfffffff0,%eax
  8004217a43:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_MEM_ADDR(oldv);
  8004217a46:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217a49:	83 e0 f0             	and    $0xfffffff0,%eax
  8004217a4c:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004217a4f:	48 b8 40 97 37 04 80 	movabs $0x8004379740,%rax
  8004217a56:	00 00 00 
  8004217a59:	8b 00                	mov    (%rax),%eax
  8004217a5b:	85 c0                	test   %eax,%eax
  8004217a5d:	74 7a                	je     8004217ad9 <pci_func_enable+0x166>
				cprintf("  mem region %d: %d bytes at 0x%x\n",
  8004217a5f:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004217a62:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004217a65:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217a68:	89 c6                	mov    %eax,%esi
  8004217a6a:	48 bf 30 aa 21 04 80 	movabs $0x800421aa30,%rdi
  8004217a71:	00 00 00 
  8004217a74:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217a79:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  8004217a80:	00 00 00 
  8004217a83:	41 ff d0             	callq  *%r8
  8004217a86:	eb 51                	jmp    8004217ad9 <pci_func_enable+0x166>
					regnum, size, base);
		} else {
			size = PCI_MAPREG_IO_SIZE(rv);
  8004217a88:	8b 45 e8             	mov    -0x18(%rbp),%eax
  8004217a8b:	83 e0 fc             	and    $0xfffffffc,%eax
  8004217a8e:	f7 d8                	neg    %eax
  8004217a90:	23 45 e8             	and    -0x18(%rbp),%eax
  8004217a93:	83 e0 fc             	and    $0xfffffffc,%eax
  8004217a96:	89 45 f0             	mov    %eax,-0x10(%rbp)
			base = PCI_MAPREG_IO_ADDR(oldv);
  8004217a99:	8b 45 ec             	mov    -0x14(%rbp),%eax
  8004217a9c:	83 e0 fc             	and    $0xfffffffc,%eax
  8004217a9f:	89 45 f4             	mov    %eax,-0xc(%rbp)
			if (pci_show_addrs)
  8004217aa2:	48 b8 40 97 37 04 80 	movabs $0x8004379740,%rax
  8004217aa9:	00 00 00 
  8004217aac:	8b 00                	mov    (%rax),%eax
  8004217aae:	85 c0                	test   %eax,%eax
  8004217ab0:	74 27                	je     8004217ad9 <pci_func_enable+0x166>
				cprintf("  io region %d: %d bytes at 0x%x\n",
  8004217ab2:	8b 4d f4             	mov    -0xc(%rbp),%ecx
  8004217ab5:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004217ab8:	8b 45 e4             	mov    -0x1c(%rbp),%eax
  8004217abb:	89 c6                	mov    %eax,%esi
  8004217abd:	48 bf 58 aa 21 04 80 	movabs $0x800421aa58,%rdi
  8004217ac4:	00 00 00 
  8004217ac7:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217acc:	49 b8 5f 8f 20 04 80 	movabs $0x8004208f5f,%r8
  8004217ad3:	00 00 00 
  8004217ad6:	41 ff d0             	callq  *%r8
					regnum, size, base);
		}

		pci_conf_write(f, bar, oldv);
  8004217ad9:	8b 55 ec             	mov    -0x14(%rbp),%edx
  8004217adc:	8b 4d f8             	mov    -0x8(%rbp),%ecx
  8004217adf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217ae3:	89 ce                	mov    %ecx,%esi
  8004217ae5:	48 89 c7             	mov    %rax,%rdi
  8004217ae8:	48 b8 11 73 21 04 80 	movabs $0x8004217311,%rax
  8004217aef:	00 00 00 
  8004217af2:	ff d0                	callq  *%rax
		f->reg_base[regnum] = base;
  8004217af4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217af8:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004217afb:	48 63 d2             	movslq %edx,%rdx
  8004217afe:	48 8d 4a 04          	lea    0x4(%rdx),%rcx
  8004217b02:	8b 55 f4             	mov    -0xc(%rbp),%edx
  8004217b05:	89 54 88 08          	mov    %edx,0x8(%rax,%rcx,4)
		f->reg_size[regnum] = size;
  8004217b09:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217b0d:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  8004217b10:	48 63 d2             	movslq %edx,%rdx
  8004217b13:	48 8d 4a 0c          	lea    0xc(%rdx),%rcx
  8004217b17:	8b 55 f0             	mov    -0x10(%rbp),%edx
  8004217b1a:	89 14 88             	mov    %edx,(%rax,%rcx,4)

		if (size && !base)
  8004217b1d:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
  8004217b21:	74 6d                	je     8004217b90 <pci_func_enable+0x21d>
  8004217b23:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
  8004217b27:	75 67                	jne    8004217b90 <pci_func_enable+0x21d>
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217b29:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217b2d:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004217b30:	c1 e8 10             	shr    $0x10,%eax
  8004217b33:	41 89 c0             	mov    %eax,%r8d
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
  8004217b36:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217b3a:	8b 40 10             	mov    0x10(%rax),%eax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004217b3d:	0f b7 f8             	movzwl %ax,%edi
  8004217b40:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217b44:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217b47:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217b4b:	8b 50 08             	mov    0x8(%rax),%edx
				"may be misconfigured: "
				"region %d: base 0x%x, size %d\n",
				f->bus->busno, f->dev, f->func,
  8004217b4e:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217b52:	48 8b 00             	mov    (%rax),%rax
		pci_conf_write(f, bar, oldv);
		f->reg_base[regnum] = base;
		f->reg_size[regnum] = size;

		if (size && !base)
			cprintf("PCI device %02x:%02x.%d (%04x:%04x) "
  8004217b55:	8b 40 08             	mov    0x8(%rax),%eax
  8004217b58:	8b 75 f0             	mov    -0x10(%rbp),%esi
  8004217b5b:	89 74 24 10          	mov    %esi,0x10(%rsp)
  8004217b5f:	8b 75 f4             	mov    -0xc(%rbp),%esi
  8004217b62:	89 74 24 08          	mov    %esi,0x8(%rsp)
  8004217b66:	8b 75 e4             	mov    -0x1c(%rbp),%esi
  8004217b69:	89 34 24             	mov    %esi,(%rsp)
  8004217b6c:	45 89 c1             	mov    %r8d,%r9d
  8004217b6f:	41 89 f8             	mov    %edi,%r8d
  8004217b72:	89 c6                	mov    %eax,%esi
  8004217b74:	48 bf 80 aa 21 04 80 	movabs $0x800421aa80,%rdi
  8004217b7b:	00 00 00 
  8004217b7e:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217b83:	49 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%r10
  8004217b8a:	00 00 00 
  8004217b8d:	41 ff d2             	callq  *%r10
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
	     bar += bar_width)
  8004217b90:	8b 45 fc             	mov    -0x4(%rbp),%eax
  8004217b93:	01 45 f8             	add    %eax,-0x8(%rbp)
		       PCI_COMMAND_MEM_ENABLE |
		       PCI_COMMAND_MASTER_ENABLE);

	uint32_t bar_width;
	uint32_t bar;
	for (bar = PCI_MAPREG_START; bar < PCI_MAPREG_END;
  8004217b96:	83 7d f8 27          	cmpl   $0x27,-0x8(%rbp)
  8004217b9a:	0f 86 08 fe ff ff    	jbe    80042179a8 <pci_func_enable+0x35>
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004217ba0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217ba4:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004217ba7:	c1 e8 10             	shr    $0x10,%eax
  8004217baa:	89 c7                	mov    %eax,%edi
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
  8004217bac:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217bb0:	8b 40 10             	mov    0x10(%rax),%eax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004217bb3:	0f b7 f0             	movzwl %ax,%esi
  8004217bb6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217bba:	8b 48 0c             	mov    0xc(%rax),%ecx
  8004217bbd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217bc1:	8b 50 08             	mov    0x8(%rax),%edx
		f->bus->busno, f->dev, f->func,
  8004217bc4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
  8004217bc8:	48 8b 00             	mov    (%rax),%rax
				f->bus->busno, f->dev, f->func,
				PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id),
				regnum, base, size);
	}

	cprintf("PCI function %02x:%02x.%d (%04x:%04x) enabled\n",
  8004217bcb:	8b 40 08             	mov    0x8(%rax),%eax
  8004217bce:	41 89 f9             	mov    %edi,%r9d
  8004217bd1:	41 89 f0             	mov    %esi,%r8d
  8004217bd4:	89 c6                	mov    %eax,%esi
  8004217bd6:	48 bf e0 aa 21 04 80 	movabs $0x800421aae0,%rdi
  8004217bdd:	00 00 00 
  8004217be0:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217be5:	49 ba 5f 8f 20 04 80 	movabs $0x8004208f5f,%r10
  8004217bec:	00 00 00 
  8004217bef:	41 ff d2             	callq  *%r10
		f->bus->busno, f->dev, f->func,
		PCI_VENDOR(f->dev_id), PCI_PRODUCT(f->dev_id));
}
  8004217bf2:	c9                   	leaveq 
  8004217bf3:	c3                   	retq   

0000008004217bf4 <pci_init>:

int
pci_init(void)
{
  8004217bf4:	55                   	push   %rbp
  8004217bf5:	48 89 e5             	mov    %rsp,%rbp
	static struct pci_bus root_bus;
	memset(&root_bus, 0, sizeof(root_bus));
  8004217bf8:	ba 10 00 00 00       	mov    $0x10,%edx
  8004217bfd:	be 00 00 00 00       	mov    $0x0,%esi
  8004217c02:	48 bf 50 97 37 04 80 	movabs $0x8004379750,%rdi
  8004217c09:	00 00 00 
  8004217c0c:	48 b8 7d fa 20 04 80 	movabs $0x800420fa7d,%rax
  8004217c13:	00 00 00 
  8004217c16:	ff d0                	callq  *%rax

	return pci_scan_bus(&root_bus);
  8004217c18:	48 bf 50 97 37 04 80 	movabs $0x8004379750,%rdi
  8004217c1f:	00 00 00 
  8004217c22:	48 b8 c3 75 21 04 80 	movabs $0x80042175c3,%rax
  8004217c29:	00 00 00 
  8004217c2c:	ff d0                	callq  *%rax
}
  8004217c2e:	5d                   	pop    %rbp
  8004217c2f:	c3                   	retq   

0000008004217c30 <time_init>:

static unsigned int ticks;

void
time_init(void)
{
  8004217c30:	55                   	push   %rbp
  8004217c31:	48 89 e5             	mov    %rsp,%rbp
	ticks = 0;
  8004217c34:	48 b8 60 97 37 04 80 	movabs $0x8004379760,%rax
  8004217c3b:	00 00 00 
  8004217c3e:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
}
  8004217c44:	5d                   	pop    %rbp
  8004217c45:	c3                   	retq   

0000008004217c46 <time_tick>:

// This should be called once per timer interrupt.  A timer interrupt
// fires every 10 ms.
void
time_tick(void)
{
  8004217c46:	55                   	push   %rbp
  8004217c47:	48 89 e5             	mov    %rsp,%rbp
	ticks++;
  8004217c4a:	48 b8 60 97 37 04 80 	movabs $0x8004379760,%rax
  8004217c51:	00 00 00 
  8004217c54:	8b 00                	mov    (%rax),%eax
  8004217c56:	8d 50 01             	lea    0x1(%rax),%edx
  8004217c59:	48 b8 60 97 37 04 80 	movabs $0x8004379760,%rax
  8004217c60:	00 00 00 
  8004217c63:	89 10                	mov    %edx,(%rax)
	if (ticks * 10 < ticks)
  8004217c65:	48 b8 60 97 37 04 80 	movabs $0x8004379760,%rax
  8004217c6c:	00 00 00 
  8004217c6f:	8b 10                	mov    (%rax),%edx
  8004217c71:	89 d0                	mov    %edx,%eax
  8004217c73:	c1 e0 02             	shl    $0x2,%eax
  8004217c76:	01 d0                	add    %edx,%eax
  8004217c78:	01 c0                	add    %eax,%eax
  8004217c7a:	89 c2                	mov    %eax,%edx
  8004217c7c:	48 b8 60 97 37 04 80 	movabs $0x8004379760,%rax
  8004217c83:	00 00 00 
  8004217c86:	8b 00                	mov    (%rax),%eax
  8004217c88:	39 c2                	cmp    %eax,%edx
  8004217c8a:	73 2a                	jae    8004217cb6 <time_tick+0x70>
		panic("time_tick: time overflowed");
  8004217c8c:	48 ba 0f ab 21 04 80 	movabs $0x800421ab0f,%rdx
  8004217c93:	00 00 00 
  8004217c96:	be 13 00 00 00       	mov    $0x13,%esi
  8004217c9b:	48 bf 2a ab 21 04 80 	movabs $0x800421ab2a,%rdi
  8004217ca2:	00 00 00 
  8004217ca5:	b8 00 00 00 00       	mov    $0x0,%eax
  8004217caa:	48 b9 59 06 20 04 80 	movabs $0x8004200659,%rcx
  8004217cb1:	00 00 00 
  8004217cb4:	ff d1                	callq  *%rcx
}
  8004217cb6:	5d                   	pop    %rbp
  8004217cb7:	c3                   	retq   

0000008004217cb8 <time_msec>:

unsigned int
time_msec(void)
{
  8004217cb8:	55                   	push   %rbp
  8004217cb9:	48 89 e5             	mov    %rsp,%rbp
	return ticks * 10;
  8004217cbc:	48 b8 60 97 37 04 80 	movabs $0x8004379760,%rax
  8004217cc3:	00 00 00 
  8004217cc6:	8b 10                	mov    (%rax),%edx
  8004217cc8:	89 d0                	mov    %edx,%eax
  8004217cca:	c1 e0 02             	shl    $0x2,%eax
  8004217ccd:	01 d0                	add    %edx,%eax
  8004217ccf:	01 c0                	add    %eax,%eax
}
  8004217cd1:	5d                   	pop    %rbp
  8004217cd2:	c3                   	retq   
